# 1 "src/transform_reduce/std_vector.cpp"
# 1 "<built-in>" 1
# 1 "<built-in>" 3
# 892 "<built-in>" 3
# 1 "<command line>" 1
# 1 "<built-in>" 2
# 1 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/openmp_wrappers/__clang_openmp_device_functions.h" 1 3
# 18 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/openmp_wrappers/__clang_openmp_device_functions.h" 3
extern "C" {


#pragma omp begin declare variant match( device = {arch(nvptx, nvptx64)}, implementation = {extension(match_any)})






# 1 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/__clang_cuda_libdevice_declares.h" 1 3
# 14 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/__clang_cuda_libdevice_declares.h" 3
extern "C" {




#pragma omp begin assumes ext_spmd_amenable no_openmp




           int __nv_abs(int __a);
           double __nv_acos(double __a);
           float __nv_acosf(float __a);
           double __nv_acosh(double __a);
           float __nv_acoshf(float __a);
           double __nv_asin(double __a);
           float __nv_asinf(float __a);
           double __nv_asinh(double __a);
           float __nv_asinhf(float __a);
           double __nv_atan2(double __a, double __b);
           float __nv_atan2f(float __a, float __b);
           double __nv_atan(double __a);
           float __nv_atanf(float __a);
           double __nv_atanh(double __a);
           float __nv_atanhf(float __a);
           int __nv_brev(int __a);
           long long __nv_brevll(long long __a);
           int __nv_byte_perm(int __a, int __b, int __c);
           double __nv_cbrt(double __a);
           float __nv_cbrtf(float __a);
           double __nv_ceil(double __a);
           float __nv_ceilf(float __a);
           int __nv_clz(int __a);
           int __nv_clzll(long long __a);
           double __nv_copysign(double __a, double __b);
           float __nv_copysignf(float __a, float __b);
           double __nv_cos(double __a);
           float __nv_cosf(float __a);
           double __nv_cosh(double __a);
           float __nv_coshf(float __a);
           double __nv_cospi(double __a);
           float __nv_cospif(float __a);
           double __nv_cyl_bessel_i0(double __a);
           float __nv_cyl_bessel_i0f(float __a);
           double __nv_cyl_bessel_i1(double __a);
           float __nv_cyl_bessel_i1f(float __a);
           double __nv_dadd_rd(double __a, double __b);
           double __nv_dadd_rn(double __a, double __b);
           double __nv_dadd_ru(double __a, double __b);
           double __nv_dadd_rz(double __a, double __b);
           double __nv_ddiv_rd(double __a, double __b);
           double __nv_ddiv_rn(double __a, double __b);
           double __nv_ddiv_ru(double __a, double __b);
           double __nv_ddiv_rz(double __a, double __b);
           double __nv_dmul_rd(double __a, double __b);
           double __nv_dmul_rn(double __a, double __b);
           double __nv_dmul_ru(double __a, double __b);
           double __nv_dmul_rz(double __a, double __b);
           float __nv_double2float_rd(double __a);
           float __nv_double2float_rn(double __a);
           float __nv_double2float_ru(double __a);
           float __nv_double2float_rz(double __a);
           int __nv_double2hiint(double __a);
           int __nv_double2int_rd(double __a);
           int __nv_double2int_rn(double __a);
           int __nv_double2int_ru(double __a);
           int __nv_double2int_rz(double __a);
           long long __nv_double2ll_rd(double __a);
           long long __nv_double2ll_rn(double __a);
           long long __nv_double2ll_ru(double __a);
           long long __nv_double2ll_rz(double __a);
           int __nv_double2loint(double __a);
           unsigned int __nv_double2uint_rd(double __a);
           unsigned int __nv_double2uint_rn(double __a);
           unsigned int __nv_double2uint_ru(double __a);
           unsigned int __nv_double2uint_rz(double __a);
           unsigned long long __nv_double2ull_rd(double __a);
           unsigned long long __nv_double2ull_rn(double __a);
           unsigned long long __nv_double2ull_ru(double __a);
           unsigned long long __nv_double2ull_rz(double __a);
           unsigned long long __nv_double_as_longlong(double __a);
           double __nv_drcp_rd(double __a);
           double __nv_drcp_rn(double __a);
           double __nv_drcp_ru(double __a);
           double __nv_drcp_rz(double __a);
           double __nv_dsqrt_rd(double __a);
           double __nv_dsqrt_rn(double __a);
           double __nv_dsqrt_ru(double __a);
           double __nv_dsqrt_rz(double __a);
           double __nv_dsub_rd(double __a, double __b);
           double __nv_dsub_rn(double __a, double __b);
           double __nv_dsub_ru(double __a, double __b);
           double __nv_dsub_rz(double __a, double __b);
           double __nv_erfc(double __a);
           float __nv_erfcf(float __a);
           double __nv_erfcinv(double __a);
           float __nv_erfcinvf(float __a);
           double __nv_erfcx(double __a);
           float __nv_erfcxf(float __a);
           double __nv_erf(double __a);
           float __nv_erff(float __a);
           double __nv_erfinv(double __a);
           float __nv_erfinvf(float __a);
           double __nv_exp10(double __a);
           float __nv_exp10f(float __a);
           double __nv_exp2(double __a);
           float __nv_exp2f(float __a);
           double __nv_exp(double __a);
           float __nv_expf(float __a);
           double __nv_expm1(double __a);
           float __nv_expm1f(float __a);
           double __nv_fabs(double __a);
           float __nv_fabsf(float __a);
           float __nv_fadd_rd(float __a, float __b);
           float __nv_fadd_rn(float __a, float __b);
           float __nv_fadd_ru(float __a, float __b);
           float __nv_fadd_rz(float __a, float __b);
           float __nv_fast_cosf(float __a);
           float __nv_fast_exp10f(float __a);
           float __nv_fast_expf(float __a);
           float __nv_fast_fdividef(float __a, float __b);
           float __nv_fast_log10f(float __a);
           float __nv_fast_log2f(float __a);
           float __nv_fast_logf(float __a);
           float __nv_fast_powf(float __a, float __b);
           void __nv_fast_sincosf(float __a, float *__s, float *__c);
           float __nv_fast_sinf(float __a);
           float __nv_fast_tanf(float __a);
           double __nv_fdim(double __a, double __b);
           float __nv_fdimf(float __a, float __b);
           float __nv_fdiv_rd(float __a, float __b);
           float __nv_fdiv_rn(float __a, float __b);
           float __nv_fdiv_ru(float __a, float __b);
           float __nv_fdiv_rz(float __a, float __b);
           int __nv_ffs(int __a);
           int __nv_ffsll(long long __a);
           int __nv_finitef(float __a);
           unsigned short __nv_float2half_rn(float __a);
           int __nv_float2int_rd(float __a);
           int __nv_float2int_rn(float __a);
           int __nv_float2int_ru(float __a);
           int __nv_float2int_rz(float __a);
           long long __nv_float2ll_rd(float __a);
           long long __nv_float2ll_rn(float __a);
           long long __nv_float2ll_ru(float __a);
           long long __nv_float2ll_rz(float __a);
           unsigned int __nv_float2uint_rd(float __a);
           unsigned int __nv_float2uint_rn(float __a);
           unsigned int __nv_float2uint_ru(float __a);
           unsigned int __nv_float2uint_rz(float __a);
           unsigned long long __nv_float2ull_rd(float __a);
           unsigned long long __nv_float2ull_rn(float __a);
           unsigned long long __nv_float2ull_ru(float __a);
           unsigned long long __nv_float2ull_rz(float __a);
           int __nv_float_as_int(float __a);
           unsigned int __nv_float_as_uint(float __a);
           double __nv_floor(double __a);
           float __nv_floorf(float __a);
           double __nv_fma(double __a, double __b, double __c);
           float __nv_fmaf(float __a, float __b, float __c);
           float __nv_fmaf_ieee_rd(float __a, float __b, float __c);
           float __nv_fmaf_ieee_rn(float __a, float __b, float __c);
           float __nv_fmaf_ieee_ru(float __a, float __b, float __c);
           float __nv_fmaf_ieee_rz(float __a, float __b, float __c);
           float __nv_fmaf_rd(float __a, float __b, float __c);
           float __nv_fmaf_rn(float __a, float __b, float __c);
           float __nv_fmaf_ru(float __a, float __b, float __c);
           float __nv_fmaf_rz(float __a, float __b, float __c);
           double __nv_fma_rd(double __a, double __b, double __c);
           double __nv_fma_rn(double __a, double __b, double __c);
           double __nv_fma_ru(double __a, double __b, double __c);
           double __nv_fma_rz(double __a, double __b, double __c);
           double __nv_fmax(double __a, double __b);
           float __nv_fmaxf(float __a, float __b);
           double __nv_fmin(double __a, double __b);
           float __nv_fminf(float __a, float __b);
           double __nv_fmod(double __a, double __b);
           float __nv_fmodf(float __a, float __b);
           float __nv_fmul_rd(float __a, float __b);
           float __nv_fmul_rn(float __a, float __b);
           float __nv_fmul_ru(float __a, float __b);
           float __nv_fmul_rz(float __a, float __b);
           float __nv_frcp_rd(float __a);
           float __nv_frcp_rn(float __a);
           float __nv_frcp_ru(float __a);
           float __nv_frcp_rz(float __a);
           double __nv_frexp(double __a, int *__b);
           float __nv_frexpf(float __a, int *__b);
           float __nv_frsqrt_rn(float __a);
           float __nv_fsqrt_rd(float __a);
           float __nv_fsqrt_rn(float __a);
           float __nv_fsqrt_ru(float __a);
           float __nv_fsqrt_rz(float __a);
           float __nv_fsub_rd(float __a, float __b);
           float __nv_fsub_rn(float __a, float __b);
           float __nv_fsub_ru(float __a, float __b);
           float __nv_fsub_rz(float __a, float __b);
           int __nv_hadd(int __a, int __b);
           float __nv_half2float(unsigned short __h);
           double __nv_hiloint2double(int __a, int __b);
           double __nv_hypot(double __a, double __b);
           float __nv_hypotf(float __a, float __b);
           int __nv_ilogb(double __a);
           int __nv_ilogbf(float __a);
           double __nv_int2double_rn(int __a);
           float __nv_int2float_rd(int __a);
           float __nv_int2float_rn(int __a);
           float __nv_int2float_ru(int __a);
           float __nv_int2float_rz(int __a);
           float __nv_int_as_float(int __a);
           int __nv_isfinited(double __a);
           int __nv_isinfd(double __a);
           int __nv_isinff(float __a);
           int __nv_isnand(double __a);
           int __nv_isnanf(float __a);
           double __nv_j0(double __a);
           float __nv_j0f(float __a);
           double __nv_j1(double __a);
           float __nv_j1f(float __a);
           float __nv_jnf(int __a, float __b);
           double __nv_jn(int __a, double __b);
           double __nv_ldexp(double __a, int __b);
           float __nv_ldexpf(float __a, int __b);
           double __nv_lgamma(double __a);
           float __nv_lgammaf(float __a);
           double __nv_ll2double_rd(long long __a);
           double __nv_ll2double_rn(long long __a);
           double __nv_ll2double_ru(long long __a);
           double __nv_ll2double_rz(long long __a);
           float __nv_ll2float_rd(long long __a);
           float __nv_ll2float_rn(long long __a);
           float __nv_ll2float_ru(long long __a);
           float __nv_ll2float_rz(long long __a);
           long long __nv_llabs(long long __a);
           long long __nv_llmax(long long __a, long long __b);
           long long __nv_llmin(long long __a, long long __b);
           long long __nv_llrint(double __a);
           long long __nv_llrintf(float __a);
           long long __nv_llround(double __a);
           long long __nv_llroundf(float __a);
           double __nv_log10(double __a);
           float __nv_log10f(float __a);
           double __nv_log1p(double __a);
           float __nv_log1pf(float __a);
           double __nv_log2(double __a);
           float __nv_log2f(float __a);
           double __nv_logb(double __a);
           float __nv_logbf(float __a);
           double __nv_log(double __a);
           float __nv_logf(float __a);
           double __nv_longlong_as_double(long long __a);
           int __nv_max(int __a, int __b);
           int __nv_min(int __a, int __b);
           double __nv_modf(double __a, double *__b);
           float __nv_modff(float __a, float *__b);
           int __nv_mul24(int __a, int __b);
           long long __nv_mul64hi(long long __a, long long __b);
           int __nv_mulhi(int __a, int __b);
           double __nv_nan(const signed char *__a);
           float __nv_nanf(const signed char *__a);
           double __nv_nearbyint(double __a);
           float __nv_nearbyintf(float __a);
           double __nv_nextafter(double __a, double __b);
           float __nv_nextafterf(float __a, float __b);
           double __nv_norm3d(double __a, double __b, double __c);
           float __nv_norm3df(float __a, float __b, float __c);
           double __nv_norm4d(double __a, double __b, double __c, double __d);
           float __nv_norm4df(float __a, float __b, float __c, float __d);
           double __nv_normcdf(double __a);
           float __nv_normcdff(float __a);
           double __nv_normcdfinv(double __a);
           float __nv_normcdfinvf(float __a);
           float __nv_normf(int __a, const float *__b);
           double __nv_norm(int __a, const double *__b);
           int __nv_popc(unsigned int __a);
           int __nv_popcll(unsigned long long __a);
           double __nv_pow(double __a, double __b);
           float __nv_powf(float __a, float __b);
           double __nv_powi(double __a, int __b);
           float __nv_powif(float __a, int __b);
           double __nv_rcbrt(double __a);
           float __nv_rcbrtf(float __a);
           double __nv_rcp64h(double __a);
           double __nv_remainder(double __a, double __b);
           float __nv_remainderf(float __a, float __b);
           double __nv_remquo(double __a, double __b, int *__c);
           float __nv_remquof(float __a, float __b, int *__c);
           int __nv_rhadd(int __a, int __b);
           double __nv_rhypot(double __a, double __b);
           float __nv_rhypotf(float __a, float __b);
           double __nv_rint(double __a);
           float __nv_rintf(float __a);
           double __nv_rnorm3d(double __a, double __b, double __c);
           float __nv_rnorm3df(float __a, float __b, float __c);
           double __nv_rnorm4d(double __a, double __b, double __c, double __d);
           float __nv_rnorm4df(float __a, float __b, float __c, float __d);
           float __nv_rnormf(int __a, const float *__b);
           double __nv_rnorm(int __a, const double *__b);
           double __nv_round(double __a);
           float __nv_roundf(float __a);
           double __nv_rsqrt(double __a);
           float __nv_rsqrtf(float __a);
           int __nv_sad(int __a, int __b, int __c);
           float __nv_saturatef(float __a);
           double __nv_scalbn(double __a, int __b);
           float __nv_scalbnf(float __a, int __b);
           int __nv_signbitd(double __a);
           int __nv_signbitf(float __a);
           void __nv_sincos(double __a, double *__b, double *__c);
           void __nv_sincosf(float __a, float *__b, float *__c);
           void __nv_sincospi(double __a, double *__b, double *__c);
           void __nv_sincospif(float __a, float *__b, float *__c);
           double __nv_sin(double __a);
           float __nv_sinf(float __a);
           double __nv_sinh(double __a);
           float __nv_sinhf(float __a);
           double __nv_sinpi(double __a);
           float __nv_sinpif(float __a);
           double __nv_sqrt(double __a);
           float __nv_sqrtf(float __a);
           double __nv_tan(double __a);
           float __nv_tanf(float __a);
           double __nv_tanh(double __a);
           float __nv_tanhf(float __a);
           double __nv_tgamma(double __a);
           float __nv_tgammaf(float __a);
           double __nv_trunc(double __a);
           float __nv_truncf(float __a);
           int __nv_uhadd(unsigned int __a, unsigned int __b);
           double __nv_uint2double_rn(unsigned int __i);
           float __nv_uint2float_rd(unsigned int __a);
           float __nv_uint2float_rn(unsigned int __a);
           float __nv_uint2float_ru(unsigned int __a);
           float __nv_uint2float_rz(unsigned int __a);
           float __nv_uint_as_float(unsigned int __a);
           double __nv_ull2double_rd(unsigned long long __a);
           double __nv_ull2double_rn(unsigned long long __a);
           double __nv_ull2double_ru(unsigned long long __a);
           double __nv_ull2double_rz(unsigned long long __a);
           float __nv_ull2float_rd(unsigned long long __a);
           float __nv_ull2float_rn(unsigned long long __a);
           float __nv_ull2float_ru(unsigned long long __a);
           float __nv_ull2float_rz(unsigned long long __a);
           unsigned long long __nv_ullmax(unsigned long long __a,
                                          unsigned long long __b);
           unsigned long long __nv_ullmin(unsigned long long __a,
                                          unsigned long long __b);
           unsigned int __nv_umax(unsigned int __a, unsigned int __b);
           unsigned int __nv_umin(unsigned int __a, unsigned int __b);
           unsigned int __nv_umul24(unsigned int __a, unsigned int __b);
           unsigned long long __nv_umul64hi(unsigned long long __a,
                                            unsigned long long __b);
           unsigned int __nv_umulhi(unsigned int __a, unsigned int __b);
           unsigned int __nv_urhadd(unsigned int __a, unsigned int __b);
           unsigned int __nv_usad(unsigned int __a, unsigned int __b,
                                  unsigned int __c);
# 454 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/__clang_cuda_libdevice_declares.h" 3
           double __nv_y0(double __a);
           float __nv_y0f(float __a);
           double __nv_y1(double __a);
           float __nv_y1f(float __a);
           float __nv_ynf(int __a, float __b);
           double __nv_yn(int __a, double __b);


#pragma omp end assumes ext_spmd_amenable no_openmp



}
# 29 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/openmp_wrappers/__clang_openmp_device_functions.h" 2 3


# 1 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/__clang_cuda_device_functions.h" 1 3
# 29 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/__clang_cuda_device_functions.h" 3
static __attribute__((always_inline, nothrow)) int __all(int __a) { return __nvvm_vote_all(__a); }
static __attribute__((always_inline, nothrow)) int __any(int __a) { return __nvvm_vote_any(__a); }
static __attribute__((always_inline, nothrow)) unsigned int __ballot(int __a) { return __nvvm_vote_ballot(__a); }
static __attribute__((always_inline, nothrow)) unsigned int __brev(unsigned int __a) { return __nv_brev(__a); }
static __attribute__((always_inline, nothrow)) unsigned long long __brevll(unsigned long long __a) {
  return __nv_brevll(__a);
}

static __attribute__((always_inline, nothrow)) void __brkpt() { __asm__ __volatile__("brkpt;"); }
static __attribute__((always_inline, nothrow)) void __brkpt(int __a) { __brkpt(); }






static __attribute__((always_inline, nothrow)) unsigned int __byte_perm(unsigned int __a, unsigned int __b,
                                    unsigned int __c) {
  return __nv_byte_perm(__a, __b, __c);
}
static __attribute__((always_inline, nothrow)) int __clz(int __a) { return __nv_clz(__a); }
static __attribute__((always_inline, nothrow)) int __clzll(long long __a) { return __nv_clzll(__a); }
static __attribute__((always_inline, nothrow)) float __cosf(float __a) { return __nv_fast_cosf(__a); }
static __attribute__((always_inline, nothrow)) double __dAtomicAdd(double *__p, double __v) {
  return __nvvm_atom_add_gen_d(__p, __v);
}
static __attribute__((always_inline, nothrow)) double __dAtomicAdd_block(double *__p, double __v) {
  return __nvvm_atom_cta_add_gen_d(__p, __v);
}
static __attribute__((always_inline, nothrow)) double __dAtomicAdd_system(double *__p, double __v) {
  return __nvvm_atom_sys_add_gen_d(__p, __v);
}
static __attribute__((always_inline, nothrow)) double __dadd_rd(double __a, double __b) {
  return __nv_dadd_rd(__a, __b);
}
static __attribute__((always_inline, nothrow)) double __dadd_rn(double __a, double __b) {
  return __nv_dadd_rn(__a, __b);
}
static __attribute__((always_inline, nothrow)) double __dadd_ru(double __a, double __b) {
  return __nv_dadd_ru(__a, __b);
}
static __attribute__((always_inline, nothrow)) double __dadd_rz(double __a, double __b) {
  return __nv_dadd_rz(__a, __b);
}
static __attribute__((always_inline, nothrow)) double __ddiv_rd(double __a, double __b) {
  return __nv_ddiv_rd(__a, __b);
}
static __attribute__((always_inline, nothrow)) double __ddiv_rn(double __a, double __b) {
  return __nv_ddiv_rn(__a, __b);
}
static __attribute__((always_inline, nothrow)) double __ddiv_ru(double __a, double __b) {
  return __nv_ddiv_ru(__a, __b);
}
static __attribute__((always_inline, nothrow)) double __ddiv_rz(double __a, double __b) {
  return __nv_ddiv_rz(__a, __b);
}
static __attribute__((always_inline, nothrow)) double __dmul_rd(double __a, double __b) {
  return __nv_dmul_rd(__a, __b);
}
static __attribute__((always_inline, nothrow)) double __dmul_rn(double __a, double __b) {
  return __nv_dmul_rn(__a, __b);
}
static __attribute__((always_inline, nothrow)) double __dmul_ru(double __a, double __b) {
  return __nv_dmul_ru(__a, __b);
}
static __attribute__((always_inline, nothrow)) double __dmul_rz(double __a, double __b) {
  return __nv_dmul_rz(__a, __b);
}
static __attribute__((always_inline, nothrow)) float __double2float_rd(double __a) {
  return __nv_double2float_rd(__a);
}
static __attribute__((always_inline, nothrow)) float __double2float_rn(double __a) {
  return __nv_double2float_rn(__a);
}
static __attribute__((always_inline, nothrow)) float __double2float_ru(double __a) {
  return __nv_double2float_ru(__a);
}
static __attribute__((always_inline, nothrow)) float __double2float_rz(double __a) {
  return __nv_double2float_rz(__a);
}
static __attribute__((always_inline, nothrow)) int __double2hiint(double __a) { return __nv_double2hiint(__a); }
static __attribute__((always_inline, nothrow)) int __double2int_rd(double __a) { return __nv_double2int_rd(__a); }
static __attribute__((always_inline, nothrow)) int __double2int_rn(double __a) { return __nv_double2int_rn(__a); }
static __attribute__((always_inline, nothrow)) int __double2int_ru(double __a) { return __nv_double2int_ru(__a); }
static __attribute__((always_inline, nothrow)) int __double2int_rz(double __a) { return __nv_double2int_rz(__a); }
static __attribute__((always_inline, nothrow)) long long __double2ll_rd(double __a) {
  return __nv_double2ll_rd(__a);
}
static __attribute__((always_inline, nothrow)) long long __double2ll_rn(double __a) {
  return __nv_double2ll_rn(__a);
}
static __attribute__((always_inline, nothrow)) long long __double2ll_ru(double __a) {
  return __nv_double2ll_ru(__a);
}
static __attribute__((always_inline, nothrow)) long long __double2ll_rz(double __a) {
  return __nv_double2ll_rz(__a);
}
static __attribute__((always_inline, nothrow)) int __double2loint(double __a) { return __nv_double2loint(__a); }
static __attribute__((always_inline, nothrow)) unsigned int __double2uint_rd(double __a) {
  return __nv_double2uint_rd(__a);
}
static __attribute__((always_inline, nothrow)) unsigned int __double2uint_rn(double __a) {
  return __nv_double2uint_rn(__a);
}
static __attribute__((always_inline, nothrow)) unsigned int __double2uint_ru(double __a) {
  return __nv_double2uint_ru(__a);
}
static __attribute__((always_inline, nothrow)) unsigned int __double2uint_rz(double __a) {
  return __nv_double2uint_rz(__a);
}
static __attribute__((always_inline, nothrow)) unsigned long long __double2ull_rd(double __a) {
  return __nv_double2ull_rd(__a);
}
static __attribute__((always_inline, nothrow)) unsigned long long __double2ull_rn(double __a) {
  return __nv_double2ull_rn(__a);
}
static __attribute__((always_inline, nothrow)) unsigned long long __double2ull_ru(double __a) {
  return __nv_double2ull_ru(__a);
}
static __attribute__((always_inline, nothrow)) unsigned long long __double2ull_rz(double __a) {
  return __nv_double2ull_rz(__a);
}
static __attribute__((always_inline, nothrow)) long long __double_as_longlong(double __a) {
  return __nv_double_as_longlong(__a);
}
static __attribute__((always_inline, nothrow)) double __drcp_rd(double __a) { return __nv_drcp_rd(__a); }
static __attribute__((always_inline, nothrow)) double __drcp_rn(double __a) { return __nv_drcp_rn(__a); }
static __attribute__((always_inline, nothrow)) double __drcp_ru(double __a) { return __nv_drcp_ru(__a); }
static __attribute__((always_inline, nothrow)) double __drcp_rz(double __a) { return __nv_drcp_rz(__a); }
static __attribute__((always_inline, nothrow)) double __dsqrt_rd(double __a) { return __nv_dsqrt_rd(__a); }
static __attribute__((always_inline, nothrow)) double __dsqrt_rn(double __a) { return __nv_dsqrt_rn(__a); }
static __attribute__((always_inline, nothrow)) double __dsqrt_ru(double __a) { return __nv_dsqrt_ru(__a); }
static __attribute__((always_inline, nothrow)) double __dsqrt_rz(double __a) { return __nv_dsqrt_rz(__a); }
static __attribute__((always_inline, nothrow)) double __dsub_rd(double __a, double __b) {
  return __nv_dsub_rd(__a, __b);
}
static __attribute__((always_inline, nothrow)) double __dsub_rn(double __a, double __b) {
  return __nv_dsub_rn(__a, __b);
}
static __attribute__((always_inline, nothrow)) double __dsub_ru(double __a, double __b) {
  return __nv_dsub_ru(__a, __b);
}
static __attribute__((always_inline, nothrow)) double __dsub_rz(double __a, double __b) {
  return __nv_dsub_rz(__a, __b);
}
static __attribute__((always_inline, nothrow)) float __exp10f(float __a) { return __nv_fast_exp10f(__a); }
static __attribute__((always_inline, nothrow)) float __expf(float __a) { return __nv_fast_expf(__a); }
static __attribute__((always_inline, nothrow)) float __fAtomicAdd(float *__p, float __v) {
  return __nvvm_atom_add_gen_f(__p, __v);
}
static __attribute__((always_inline, nothrow)) float __fAtomicAdd_block(float *__p, float __v) {
  return __nvvm_atom_cta_add_gen_f(__p, __v);
}
static __attribute__((always_inline, nothrow)) float __fAtomicAdd_system(float *__p, float __v) {
  return __nvvm_atom_sys_add_gen_f(__p, __v);
}
static __attribute__((always_inline, nothrow)) float __fAtomicExch(float *__p, float __v) {
  return __nv_int_as_float(
      __nvvm_atom_xchg_gen_i((int *)__p, __nv_float_as_int(__v)));
}
static __attribute__((always_inline, nothrow)) float __fAtomicExch_block(float *__p, float __v) {
  return __nv_int_as_float(
      __nvvm_atom_cta_xchg_gen_i((int *)__p, __nv_float_as_int(__v)));
}
static __attribute__((always_inline, nothrow)) float __fAtomicExch_system(float *__p, float __v) {
  return __nv_int_as_float(
      __nvvm_atom_sys_xchg_gen_i((int *)__p, __nv_float_as_int(__v)));
}
static __attribute__((always_inline, nothrow)) float __fadd_rd(float __a, float __b) {
  return __nv_fadd_rd(__a, __b);
}
static __attribute__((always_inline, nothrow)) float __fadd_rn(float __a, float __b) {
  return __nv_fadd_rn(__a, __b);
}
static __attribute__((always_inline, nothrow)) float __fadd_ru(float __a, float __b) {
  return __nv_fadd_ru(__a, __b);
}
static __attribute__((always_inline, nothrow)) float __fadd_rz(float __a, float __b) {
  return __nv_fadd_rz(__a, __b);
}
static __attribute__((always_inline, nothrow)) float __fdiv_rd(float __a, float __b) {
  return __nv_fdiv_rd(__a, __b);
}
static __attribute__((always_inline, nothrow)) float __fdiv_rn(float __a, float __b) {
  return __nv_fdiv_rn(__a, __b);
}
static __attribute__((always_inline, nothrow)) float __fdiv_ru(float __a, float __b) {
  return __nv_fdiv_ru(__a, __b);
}
static __attribute__((always_inline, nothrow)) float __fdiv_rz(float __a, float __b) {
  return __nv_fdiv_rz(__a, __b);
}
static __attribute__((always_inline, nothrow)) float __fdividef(float __a, float __b) {
  return __nv_fast_fdividef(__a, __b);
}
static __attribute__((always_inline, nothrow)) int __ffs(int __a) { return __nv_ffs(__a); }
static __attribute__((always_inline, nothrow)) int __ffsll(long long __a) { return __nv_ffsll(__a); }
static __attribute__((always_inline, nothrow)) int __finite(double __a) { return __nv_isfinited(__a); }
static __attribute__((always_inline, nothrow)) int __finitef(float __a) { return __nv_finitef(__a); }



static __attribute__((always_inline, nothrow)) int __float2int_rd(float __a) { return __nv_float2int_rd(__a); }
static __attribute__((always_inline, nothrow)) int __float2int_rn(float __a) { return __nv_float2int_rn(__a); }
static __attribute__((always_inline, nothrow)) int __float2int_ru(float __a) { return __nv_float2int_ru(__a); }
static __attribute__((always_inline, nothrow)) int __float2int_rz(float __a) { return __nv_float2int_rz(__a); }
static __attribute__((always_inline, nothrow)) long long __float2ll_rd(float __a) { return __nv_float2ll_rd(__a); }
static __attribute__((always_inline, nothrow)) long long __float2ll_rn(float __a) { return __nv_float2ll_rn(__a); }
static __attribute__((always_inline, nothrow)) long long __float2ll_ru(float __a) { return __nv_float2ll_ru(__a); }
static __attribute__((always_inline, nothrow)) long long __float2ll_rz(float __a) { return __nv_float2ll_rz(__a); }
static __attribute__((always_inline, nothrow)) unsigned int __float2uint_rd(float __a) {
  return __nv_float2uint_rd(__a);
}
static __attribute__((always_inline, nothrow)) unsigned int __float2uint_rn(float __a) {
  return __nv_float2uint_rn(__a);
}
static __attribute__((always_inline, nothrow)) unsigned int __float2uint_ru(float __a) {
  return __nv_float2uint_ru(__a);
}
static __attribute__((always_inline, nothrow)) unsigned int __float2uint_rz(float __a) {
  return __nv_float2uint_rz(__a);
}
static __attribute__((always_inline, nothrow)) unsigned long long __float2ull_rd(float __a) {
  return __nv_float2ull_rd(__a);
}
static __attribute__((always_inline, nothrow)) unsigned long long __float2ull_rn(float __a) {
  return __nv_float2ull_rn(__a);
}
static __attribute__((always_inline, nothrow)) unsigned long long __float2ull_ru(float __a) {
  return __nv_float2ull_ru(__a);
}
static __attribute__((always_inline, nothrow)) unsigned long long __float2ull_rz(float __a) {
  return __nv_float2ull_rz(__a);
}
static __attribute__((always_inline, nothrow)) int __float_as_int(float __a) { return __nv_float_as_int(__a); }
static __attribute__((always_inline, nothrow)) unsigned int __float_as_uint(float __a) {
  return __nv_float_as_uint(__a);
}
static __attribute__((always_inline, nothrow)) double __fma_rd(double __a, double __b, double __c) {
  return __nv_fma_rd(__a, __b, __c);
}
static __attribute__((always_inline, nothrow)) double __fma_rn(double __a, double __b, double __c) {
  return __nv_fma_rn(__a, __b, __c);
}
static __attribute__((always_inline, nothrow)) double __fma_ru(double __a, double __b, double __c) {
  return __nv_fma_ru(__a, __b, __c);
}
static __attribute__((always_inline, nothrow)) double __fma_rz(double __a, double __b, double __c) {
  return __nv_fma_rz(__a, __b, __c);
}
static __attribute__((always_inline, nothrow)) float __fmaf_ieee_rd(float __a, float __b, float __c) {
  return __nv_fmaf_ieee_rd(__a, __b, __c);
}
static __attribute__((always_inline, nothrow)) float __fmaf_ieee_rn(float __a, float __b, float __c) {
  return __nv_fmaf_ieee_rn(__a, __b, __c);
}
static __attribute__((always_inline, nothrow)) float __fmaf_ieee_ru(float __a, float __b, float __c) {
  return __nv_fmaf_ieee_ru(__a, __b, __c);
}
static __attribute__((always_inline, nothrow)) float __fmaf_ieee_rz(float __a, float __b, float __c) {
  return __nv_fmaf_ieee_rz(__a, __b, __c);
}
static __attribute__((always_inline, nothrow)) float __fmaf_rd(float __a, float __b, float __c) {
  return __nv_fmaf_rd(__a, __b, __c);
}
static __attribute__((always_inline, nothrow)) float __fmaf_rn(float __a, float __b, float __c) {
  return __nv_fmaf_rn(__a, __b, __c);
}
static __attribute__((always_inline, nothrow)) float __fmaf_ru(float __a, float __b, float __c) {
  return __nv_fmaf_ru(__a, __b, __c);
}
static __attribute__((always_inline, nothrow)) float __fmaf_rz(float __a, float __b, float __c) {
  return __nv_fmaf_rz(__a, __b, __c);
}
static __attribute__((always_inline, nothrow)) float __fmul_rd(float __a, float __b) {
  return __nv_fmul_rd(__a, __b);
}
static __attribute__((always_inline, nothrow)) float __fmul_rn(float __a, float __b) {
  return __nv_fmul_rn(__a, __b);
}
static __attribute__((always_inline, nothrow)) float __fmul_ru(float __a, float __b) {
  return __nv_fmul_ru(__a, __b);
}
static __attribute__((always_inline, nothrow)) float __fmul_rz(float __a, float __b) {
  return __nv_fmul_rz(__a, __b);
}
static __attribute__((always_inline, nothrow)) float __frcp_rd(float __a) { return __nv_frcp_rd(__a); }
static __attribute__((always_inline, nothrow)) float __frcp_rn(float __a) { return __nv_frcp_rn(__a); }
static __attribute__((always_inline, nothrow)) float __frcp_ru(float __a) { return __nv_frcp_ru(__a); }
static __attribute__((always_inline, nothrow)) float __frcp_rz(float __a) { return __nv_frcp_rz(__a); }
static __attribute__((always_inline, nothrow)) float __frsqrt_rn(float __a) { return __nv_frsqrt_rn(__a); }
static __attribute__((always_inline, nothrow)) float __fsqrt_rd(float __a) { return __nv_fsqrt_rd(__a); }
static __attribute__((always_inline, nothrow)) float __fsqrt_rn(float __a) { return __nv_fsqrt_rn(__a); }
static __attribute__((always_inline, nothrow)) float __fsqrt_ru(float __a) { return __nv_fsqrt_ru(__a); }
static __attribute__((always_inline, nothrow)) float __fsqrt_rz(float __a) { return __nv_fsqrt_rz(__a); }
static __attribute__((always_inline, nothrow)) float __fsub_rd(float __a, float __b) {
  return __nv_fsub_rd(__a, __b);
}
static __attribute__((always_inline, nothrow)) float __fsub_rn(float __a, float __b) {
  return __nv_fsub_rn(__a, __b);
}
static __attribute__((always_inline, nothrow)) float __fsub_ru(float __a, float __b) {
  return __nv_fsub_ru(__a, __b);
}
static __attribute__((always_inline, nothrow)) float __fsub_rz(float __a, float __b) {
  return __nv_fsub_rz(__a, __b);
}
static __attribute__((always_inline, nothrow)) int __hadd(int __a, int __b) { return __nv_hadd(__a, __b); }
static __attribute__((always_inline, nothrow)) double __hiloint2double(int __a, int __b) {
  return __nv_hiloint2double(__a, __b);
}
static __attribute__((always_inline, nothrow)) int __iAtomicAdd(int *__p, int __v) {
  return __nvvm_atom_add_gen_i(__p, __v);
}
static __attribute__((always_inline, nothrow)) int __iAtomicAdd_block(int *__p, int __v) {
  return __nvvm_atom_cta_add_gen_i(__p, __v);
}
static __attribute__((always_inline, nothrow)) int __iAtomicAdd_system(int *__p, int __v) {
  return __nvvm_atom_sys_add_gen_i(__p, __v);
}
static __attribute__((always_inline, nothrow)) int __iAtomicAnd(int *__p, int __v) {
  return __nvvm_atom_and_gen_i(__p, __v);
}
static __attribute__((always_inline, nothrow)) int __iAtomicAnd_block(int *__p, int __v) {
  return __nvvm_atom_cta_and_gen_i(__p, __v);
}
static __attribute__((always_inline, nothrow)) int __iAtomicAnd_system(int *__p, int __v) {
  return __nvvm_atom_sys_and_gen_i(__p, __v);
}
static __attribute__((always_inline, nothrow)) int __iAtomicCAS(int *__p, int __cmp, int __v) {
  return __nvvm_atom_cas_gen_i(__p, __cmp, __v);
}
static __attribute__((always_inline, nothrow)) int __iAtomicCAS_block(int *__p, int __cmp, int __v) {
  return __nvvm_atom_cta_cas_gen_i(__p, __cmp, __v);
}
static __attribute__((always_inline, nothrow)) int __iAtomicCAS_system(int *__p, int __cmp, int __v) {
  return __nvvm_atom_sys_cas_gen_i(__p, __cmp, __v);
}
static __attribute__((always_inline, nothrow)) int __iAtomicExch(int *__p, int __v) {
  return __nvvm_atom_xchg_gen_i(__p, __v);
}
static __attribute__((always_inline, nothrow)) int __iAtomicExch_block(int *__p, int __v) {
  return __nvvm_atom_cta_xchg_gen_i(__p, __v);
}
static __attribute__((always_inline, nothrow)) int __iAtomicExch_system(int *__p, int __v) {
  return __nvvm_atom_sys_xchg_gen_i(__p, __v);
}
static __attribute__((always_inline, nothrow)) int __iAtomicMax(int *__p, int __v) {
  return __nvvm_atom_max_gen_i(__p, __v);
}
static __attribute__((always_inline, nothrow)) int __iAtomicMax_block(int *__p, int __v) {
  return __nvvm_atom_cta_max_gen_i(__p, __v);
}
static __attribute__((always_inline, nothrow)) int __iAtomicMax_system(int *__p, int __v) {
  return __nvvm_atom_sys_max_gen_i(__p, __v);
}
static __attribute__((always_inline, nothrow)) int __iAtomicMin(int *__p, int __v) {
  return __nvvm_atom_min_gen_i(__p, __v);
}
static __attribute__((always_inline, nothrow)) int __iAtomicMin_block(int *__p, int __v) {
  return __nvvm_atom_cta_min_gen_i(__p, __v);
}
static __attribute__((always_inline, nothrow)) int __iAtomicMin_system(int *__p, int __v) {
  return __nvvm_atom_sys_min_gen_i(__p, __v);
}
static __attribute__((always_inline, nothrow)) int __iAtomicOr(int *__p, int __v) {
  return __nvvm_atom_or_gen_i(__p, __v);
}
static __attribute__((always_inline, nothrow)) int __iAtomicOr_block(int *__p, int __v) {
  return __nvvm_atom_cta_or_gen_i(__p, __v);
}
static __attribute__((always_inline, nothrow)) int __iAtomicOr_system(int *__p, int __v) {
  return __nvvm_atom_sys_or_gen_i(__p, __v);
}
static __attribute__((always_inline, nothrow)) int __iAtomicXor(int *__p, int __v) {
  return __nvvm_atom_xor_gen_i(__p, __v);
}
static __attribute__((always_inline, nothrow)) int __iAtomicXor_block(int *__p, int __v) {
  return __nvvm_atom_cta_xor_gen_i(__p, __v);
}
static __attribute__((always_inline, nothrow)) int __iAtomicXor_system(int *__p, int __v) {
  return __nvvm_atom_sys_xor_gen_i(__p, __v);
}
static __attribute__((always_inline, nothrow)) long long __illAtomicMax(long long *__p, long long __v) {
  return __nvvm_atom_max_gen_ll(__p, __v);
}
static __attribute__((always_inline, nothrow)) long long __illAtomicMax_block(long long *__p, long long __v) {
  return __nvvm_atom_cta_max_gen_ll(__p, __v);
}
static __attribute__((always_inline, nothrow)) long long __illAtomicMax_system(long long *__p, long long __v) {
  return __nvvm_atom_sys_max_gen_ll(__p, __v);
}
static __attribute__((always_inline, nothrow)) long long __illAtomicMin(long long *__p, long long __v) {
  return __nvvm_atom_min_gen_ll(__p, __v);
}
static __attribute__((always_inline, nothrow)) long long __illAtomicMin_block(long long *__p, long long __v) {
  return __nvvm_atom_cta_min_gen_ll(__p, __v);
}
static __attribute__((always_inline, nothrow)) long long __illAtomicMin_system(long long *__p, long long __v) {
  return __nvvm_atom_sys_min_gen_ll(__p, __v);
}
static __attribute__((always_inline, nothrow)) double __int2double_rn(int __a) { return __nv_int2double_rn(__a); }
static __attribute__((always_inline, nothrow)) float __int2float_rd(int __a) { return __nv_int2float_rd(__a); }
static __attribute__((always_inline, nothrow)) float __int2float_rn(int __a) { return __nv_int2float_rn(__a); }
static __attribute__((always_inline, nothrow)) float __int2float_ru(int __a) { return __nv_int2float_ru(__a); }
static __attribute__((always_inline, nothrow)) float __int2float_rz(int __a) { return __nv_int2float_rz(__a); }
static __attribute__((always_inline, nothrow)) float __int_as_float(int __a) { return __nv_int_as_float(__a); }
static __attribute__((always_inline, nothrow)) int __isfinited(double __a) { return __nv_isfinited(__a); }
static __attribute__((always_inline, nothrow)) int __isinf(double __a) { return __nv_isinfd(__a); }
static __attribute__((always_inline, nothrow)) int __isinff(float __a) { return __nv_isinff(__a); }



static __attribute__((always_inline, nothrow)) int __isnan(double __a) { return __nv_isnand(__a); }
static __attribute__((always_inline, nothrow)) int __isnanf(float __a) { return __nv_isnanf(__a); }



static __attribute__((always_inline, nothrow)) double __ll2double_rd(long long __a) {
  return __nv_ll2double_rd(__a);
}
static __attribute__((always_inline, nothrow)) double __ll2double_rn(long long __a) {
  return __nv_ll2double_rn(__a);
}
static __attribute__((always_inline, nothrow)) double __ll2double_ru(long long __a) {
  return __nv_ll2double_ru(__a);
}
static __attribute__((always_inline, nothrow)) double __ll2double_rz(long long __a) {
  return __nv_ll2double_rz(__a);
}
static __attribute__((always_inline, nothrow)) float __ll2float_rd(long long __a) { return __nv_ll2float_rd(__a); }
static __attribute__((always_inline, nothrow)) float __ll2float_rn(long long __a) { return __nv_ll2float_rn(__a); }
static __attribute__((always_inline, nothrow)) float __ll2float_ru(long long __a) { return __nv_ll2float_ru(__a); }
static __attribute__((always_inline, nothrow)) float __ll2float_rz(long long __a) { return __nv_ll2float_rz(__a); }
static __attribute__((always_inline, nothrow)) long long __llAtomicAnd(long long *__p, long long __v) {
  return __nvvm_atom_and_gen_ll(__p, __v);
}
static __attribute__((always_inline, nothrow)) long long __llAtomicAnd_block(long long *__p, long long __v) {
  return __nvvm_atom_cta_and_gen_ll(__p, __v);
}
static __attribute__((always_inline, nothrow)) long long __llAtomicAnd_system(long long *__p, long long __v) {
  return __nvvm_atom_sys_and_gen_ll(__p, __v);
}
static __attribute__((always_inline, nothrow)) long long __llAtomicOr(long long *__p, long long __v) {
  return __nvvm_atom_or_gen_ll(__p, __v);
}
static __attribute__((always_inline, nothrow)) long long __llAtomicOr_block(long long *__p, long long __v) {
  return __nvvm_atom_cta_or_gen_ll(__p, __v);
}
static __attribute__((always_inline, nothrow)) long long __llAtomicOr_system(long long *__p, long long __v) {
  return __nvvm_atom_sys_or_gen_ll(__p, __v);
}
static __attribute__((always_inline, nothrow)) long long __llAtomicXor(long long *__p, long long __v) {
  return __nvvm_atom_xor_gen_ll(__p, __v);
}
static __attribute__((always_inline, nothrow)) long long __llAtomicXor_block(long long *__p, long long __v) {
  return __nvvm_atom_cta_xor_gen_ll(__p, __v);
}
static __attribute__((always_inline, nothrow)) long long __llAtomicXor_system(long long *__p, long long __v) {
  return __nvvm_atom_sys_xor_gen_ll(__p, __v);
}
static __attribute__((always_inline, nothrow)) float __log10f(float __a) { return __nv_fast_log10f(__a); }
static __attribute__((always_inline, nothrow)) float __log2f(float __a) { return __nv_fast_log2f(__a); }
static __attribute__((always_inline, nothrow)) float __logf(float __a) { return __nv_fast_logf(__a); }
static __attribute__((always_inline, nothrow)) double __longlong_as_double(long long __a) {
  return __nv_longlong_as_double(__a);
}
static __attribute__((always_inline, nothrow)) int __mul24(int __a, int __b) { return __nv_mul24(__a, __b); }
static __attribute__((always_inline, nothrow)) long long __mul64hi(long long __a, long long __b) {
  return __nv_mul64hi(__a, __b);
}
static __attribute__((always_inline, nothrow)) int __mulhi(int __a, int __b) { return __nv_mulhi(__a, __b); }
static __attribute__((always_inline, nothrow)) unsigned int __pm0(void) { return __nvvm_read_ptx_sreg_pm0(); }
static __attribute__((always_inline, nothrow)) unsigned int __pm1(void) { return __nvvm_read_ptx_sreg_pm1(); }
static __attribute__((always_inline, nothrow)) unsigned int __pm2(void) { return __nvvm_read_ptx_sreg_pm2(); }
static __attribute__((always_inline, nothrow)) unsigned int __pm3(void) { return __nvvm_read_ptx_sreg_pm3(); }
static __attribute__((always_inline, nothrow)) int __popc(unsigned int __a) { return __nv_popc(__a); }
static __attribute__((always_inline, nothrow)) int __popcll(unsigned long long __a) { return __nv_popcll(__a); }
static __attribute__((always_inline, nothrow)) float __powf(float __a, float __b) {
  return __nv_fast_powf(__a, __b);
}



static __attribute__((always_inline, nothrow)) int __rhadd(int __a, int __b) { return __nv_rhadd(__a, __b); }
static __attribute__((always_inline, nothrow)) unsigned int __sad(int __a, int __b, unsigned int __c) {
  return __nv_sad(__a, __b, __c);
}
static __attribute__((always_inline, nothrow)) float __saturatef(float __a) { return __nv_saturatef(__a); }
static __attribute__((always_inline, nothrow)) int __signbitd(double __a) { return __nv_signbitd(__a); }
static __attribute__((always_inline, nothrow)) int __signbitf(float __a) { return __nv_signbitf(__a); }
static __attribute__((always_inline, nothrow)) void __sincosf(float __a, float *__s, float *__c) {
  return __nv_fast_sincosf(__a, __s, __c);
}
static __attribute__((always_inline, nothrow)) float __sinf(float __a) { return __nv_fast_sinf(__a); }
static __attribute__((always_inline, nothrow)) int __syncthreads_and(int __a) { return __nvvm_bar0_and(__a); }
static __attribute__((always_inline, nothrow)) int __syncthreads_count(int __a) { return __nvvm_bar0_popc(__a); }
static __attribute__((always_inline, nothrow)) int __syncthreads_or(int __a) { return __nvvm_bar0_or(__a); }
static __attribute__((always_inline, nothrow)) float __tanf(float __a) { return __nv_fast_tanf(__a); }
static __attribute__((always_inline, nothrow)) void __threadfence(void) { __nvvm_membar_gl(); }
static __attribute__((always_inline, nothrow)) void __threadfence_block(void) { __nvvm_membar_cta(); };
static __attribute__((always_inline, nothrow)) void __threadfence_system(void) { __nvvm_membar_sys(); };
static __attribute__((always_inline, nothrow)) void __trap(void) { __asm__ __volatile__("trap;"); }
static __attribute__((always_inline, nothrow)) unsigned int __uAtomicAdd(unsigned int *__p, unsigned int __v) {
  return __nvvm_atom_add_gen_i((int *)__p, __v);
}
static __attribute__((always_inline, nothrow)) unsigned int __uAtomicAdd_block(unsigned int *__p,
                                           unsigned int __v) {
  return __nvvm_atom_cta_add_gen_i((int *)__p, __v);
}
static __attribute__((always_inline, nothrow)) unsigned int __uAtomicAdd_system(unsigned int *__p,
                                            unsigned int __v) {
  return __nvvm_atom_sys_add_gen_i((int *)__p, __v);
}
static __attribute__((always_inline, nothrow)) unsigned int __uAtomicAnd(unsigned int *__p, unsigned int __v) {
  return __nvvm_atom_and_gen_i((int *)__p, __v);
}
static __attribute__((always_inline, nothrow)) unsigned int __uAtomicAnd_block(unsigned int *__p,
                                           unsigned int __v) {
  return __nvvm_atom_cta_and_gen_i((int *)__p, __v);
}
static __attribute__((always_inline, nothrow)) unsigned int __uAtomicAnd_system(unsigned int *__p,
                                            unsigned int __v) {
  return __nvvm_atom_sys_and_gen_i((int *)__p, __v);
}
static __attribute__((always_inline, nothrow)) unsigned int __uAtomicCAS(unsigned int *__p, unsigned int __cmp,
                                     unsigned int __v) {
  return __nvvm_atom_cas_gen_i((int *)__p, __cmp, __v);
}
static __attribute__((always_inline, nothrow)) unsigned int
__uAtomicCAS_block(unsigned int *__p, unsigned int __cmp, unsigned int __v) {
  return __nvvm_atom_cta_cas_gen_i((int *)__p, __cmp, __v);
}
static __attribute__((always_inline, nothrow)) unsigned int
__uAtomicCAS_system(unsigned int *__p, unsigned int __cmp, unsigned int __v) {
  return __nvvm_atom_sys_cas_gen_i((int *)__p, __cmp, __v);
}
static __attribute__((always_inline, nothrow)) unsigned int __uAtomicDec(unsigned int *__p, unsigned int __v) {
  return __nvvm_atom_dec_gen_ui(__p, __v);
}
static __attribute__((always_inline, nothrow)) unsigned int __uAtomicDec_block(unsigned int *__p,
                                           unsigned int __v) {
  return __nvvm_atom_cta_dec_gen_ui(__p, __v);
}
static __attribute__((always_inline, nothrow)) unsigned int __uAtomicDec_system(unsigned int *__p,
                                            unsigned int __v) {
  return __nvvm_atom_sys_dec_gen_ui(__p, __v);
}
static __attribute__((always_inline, nothrow)) unsigned int __uAtomicExch(unsigned int *__p, unsigned int __v) {
  return __nvvm_atom_xchg_gen_i((int *)__p, __v);
}
static __attribute__((always_inline, nothrow)) unsigned int __uAtomicExch_block(unsigned int *__p,
                                            unsigned int __v) {
  return __nvvm_atom_cta_xchg_gen_i((int *)__p, __v);
}
static __attribute__((always_inline, nothrow)) unsigned int __uAtomicExch_system(unsigned int *__p,
                                             unsigned int __v) {
  return __nvvm_atom_sys_xchg_gen_i((int *)__p, __v);
}
static __attribute__((always_inline, nothrow)) unsigned int __uAtomicInc(unsigned int *__p, unsigned int __v) {
  return __nvvm_atom_inc_gen_ui(__p, __v);
}
static __attribute__((always_inline, nothrow)) unsigned int __uAtomicInc_block(unsigned int *__p,
                                           unsigned int __v) {
  return __nvvm_atom_cta_inc_gen_ui(__p, __v);
}
static __attribute__((always_inline, nothrow)) unsigned int __uAtomicInc_system(unsigned int *__p,
                                            unsigned int __v) {
  return __nvvm_atom_sys_inc_gen_ui(__p, __v);
}
static __attribute__((always_inline, nothrow)) unsigned int __uAtomicMax(unsigned int *__p, unsigned int __v) {
  return __nvvm_atom_max_gen_ui(__p, __v);
}
static __attribute__((always_inline, nothrow)) unsigned int __uAtomicMax_block(unsigned int *__p,
                                           unsigned int __v) {
  return __nvvm_atom_cta_max_gen_ui(__p, __v);
}
static __attribute__((always_inline, nothrow)) unsigned int __uAtomicMax_system(unsigned int *__p,
                                            unsigned int __v) {
  return __nvvm_atom_sys_max_gen_ui(__p, __v);
}
static __attribute__((always_inline, nothrow)) unsigned int __uAtomicMin(unsigned int *__p, unsigned int __v) {
  return __nvvm_atom_min_gen_ui(__p, __v);
}
static __attribute__((always_inline, nothrow)) unsigned int __uAtomicMin_block(unsigned int *__p,
                                           unsigned int __v) {
  return __nvvm_atom_cta_min_gen_ui(__p, __v);
}
static __attribute__((always_inline, nothrow)) unsigned int __uAtomicMin_system(unsigned int *__p,
                                            unsigned int __v) {
  return __nvvm_atom_sys_min_gen_ui(__p, __v);
}
static __attribute__((always_inline, nothrow)) unsigned int __uAtomicOr(unsigned int *__p, unsigned int __v) {
  return __nvvm_atom_or_gen_i((int *)__p, __v);
}
static __attribute__((always_inline, nothrow)) unsigned int __uAtomicOr_block(unsigned int *__p, unsigned int __v) {
  return __nvvm_atom_cta_or_gen_i((int *)__p, __v);
}
static __attribute__((always_inline, nothrow)) unsigned int __uAtomicOr_system(unsigned int *__p,
                                           unsigned int __v) {
  return __nvvm_atom_sys_or_gen_i((int *)__p, __v);
}
static __attribute__((always_inline, nothrow)) unsigned int __uAtomicXor(unsigned int *__p, unsigned int __v) {
  return __nvvm_atom_xor_gen_i((int *)__p, __v);
}
static __attribute__((always_inline, nothrow)) unsigned int __uAtomicXor_block(unsigned int *__p,
                                           unsigned int __v) {
  return __nvvm_atom_cta_xor_gen_i((int *)__p, __v);
}
static __attribute__((always_inline, nothrow)) unsigned int __uAtomicXor_system(unsigned int *__p,
                                            unsigned int __v) {
  return __nvvm_atom_sys_xor_gen_i((int *)__p, __v);
}
static __attribute__((always_inline, nothrow)) unsigned int __uhadd(unsigned int __a, unsigned int __b) {
  return __nv_uhadd(__a, __b);
}
static __attribute__((always_inline, nothrow)) double __uint2double_rn(unsigned int __a) {
  return __nv_uint2double_rn(__a);
}
static __attribute__((always_inline, nothrow)) float __uint2float_rd(unsigned int __a) {
  return __nv_uint2float_rd(__a);
}
static __attribute__((always_inline, nothrow)) float __uint2float_rn(unsigned int __a) {
  return __nv_uint2float_rn(__a);
}
static __attribute__((always_inline, nothrow)) float __uint2float_ru(unsigned int __a) {
  return __nv_uint2float_ru(__a);
}
static __attribute__((always_inline, nothrow)) float __uint2float_rz(unsigned int __a) {
  return __nv_uint2float_rz(__a);
}
static __attribute__((always_inline, nothrow)) float __uint_as_float(unsigned int __a) {
  return __nv_uint_as_float(__a);
}
static __attribute__((always_inline, nothrow)) double __ull2double_rd(unsigned long long __a) {
  return __nv_ull2double_rd(__a);
}
static __attribute__((always_inline, nothrow)) double __ull2double_rn(unsigned long long __a) {
  return __nv_ull2double_rn(__a);
}
static __attribute__((always_inline, nothrow)) double __ull2double_ru(unsigned long long __a) {
  return __nv_ull2double_ru(__a);
}
static __attribute__((always_inline, nothrow)) double __ull2double_rz(unsigned long long __a) {
  return __nv_ull2double_rz(__a);
}
static __attribute__((always_inline, nothrow)) float __ull2float_rd(unsigned long long __a) {
  return __nv_ull2float_rd(__a);
}
static __attribute__((always_inline, nothrow)) float __ull2float_rn(unsigned long long __a) {
  return __nv_ull2float_rn(__a);
}
static __attribute__((always_inline, nothrow)) float __ull2float_ru(unsigned long long __a) {
  return __nv_ull2float_ru(__a);
}
static __attribute__((always_inline, nothrow)) float __ull2float_rz(unsigned long long __a) {
  return __nv_ull2float_rz(__a);
}
static __attribute__((always_inline, nothrow)) unsigned long long __ullAtomicAdd(unsigned long long *__p,
                                             unsigned long long __v) {
  return __nvvm_atom_add_gen_ll((long long *)__p, __v);
}
static __attribute__((always_inline, nothrow)) unsigned long long __ullAtomicAdd_block(unsigned long long *__p,
                                                   unsigned long long __v) {
  return __nvvm_atom_cta_add_gen_ll((long long *)__p, __v);
}
static __attribute__((always_inline, nothrow)) unsigned long long __ullAtomicAdd_system(unsigned long long *__p,
                                                    unsigned long long __v) {
  return __nvvm_atom_sys_add_gen_ll((long long *)__p, __v);
}
static __attribute__((always_inline, nothrow)) unsigned long long __ullAtomicAnd(unsigned long long *__p,
                                             unsigned long long __v) {
  return __nvvm_atom_and_gen_ll((long long *)__p, __v);
}
static __attribute__((always_inline, nothrow)) unsigned long long __ullAtomicAnd_block(unsigned long long *__p,
                                                   unsigned long long __v) {
  return __nvvm_atom_cta_and_gen_ll((long long *)__p, __v);
}
static __attribute__((always_inline, nothrow)) unsigned long long __ullAtomicAnd_system(unsigned long long *__p,
                                                    unsigned long long __v) {
  return __nvvm_atom_sys_and_gen_ll((long long *)__p, __v);
}
static __attribute__((always_inline, nothrow)) unsigned long long __ullAtomicCAS(unsigned long long *__p,
                                             unsigned long long __cmp,
                                             unsigned long long __v) {
  return __nvvm_atom_cas_gen_ll((long long *)__p, __cmp, __v);
}
static __attribute__((always_inline, nothrow)) unsigned long long __ullAtomicCAS_block(unsigned long long *__p,
                                                   unsigned long long __cmp,
                                                   unsigned long long __v) {
  return __nvvm_atom_cta_cas_gen_ll((long long *)__p, __cmp, __v);
}
static __attribute__((always_inline, nothrow)) unsigned long long __ullAtomicCAS_system(unsigned long long *__p,
                                                    unsigned long long __cmp,
                                                    unsigned long long __v) {
  return __nvvm_atom_sys_cas_gen_ll((long long *)__p, __cmp, __v);
}
static __attribute__((always_inline, nothrow)) unsigned long long __ullAtomicExch(unsigned long long *__p,
                                              unsigned long long __v) {
  return __nvvm_atom_xchg_gen_ll((long long *)__p, __v);
}
static __attribute__((always_inline, nothrow)) unsigned long long __ullAtomicExch_block(unsigned long long *__p,
                                                    unsigned long long __v) {
  return __nvvm_atom_cta_xchg_gen_ll((long long *)__p, __v);
}
static __attribute__((always_inline, nothrow)) unsigned long long __ullAtomicExch_system(unsigned long long *__p,
                                                     unsigned long long __v) {
  return __nvvm_atom_sys_xchg_gen_ll((long long *)__p, __v);
}
static __attribute__((always_inline, nothrow)) unsigned long long __ullAtomicMax(unsigned long long *__p,
                                             unsigned long long __v) {
  return __nvvm_atom_max_gen_ull(__p, __v);
}
static __attribute__((always_inline, nothrow)) unsigned long long __ullAtomicMax_block(unsigned long long *__p,
                                                   unsigned long long __v) {
  return __nvvm_atom_cta_max_gen_ull(__p, __v);
}
static __attribute__((always_inline, nothrow)) unsigned long long __ullAtomicMax_system(unsigned long long *__p,
                                                    unsigned long long __v) {
  return __nvvm_atom_sys_max_gen_ull(__p, __v);
}
static __attribute__((always_inline, nothrow)) unsigned long long __ullAtomicMin(unsigned long long *__p,
                                             unsigned long long __v) {
  return __nvvm_atom_min_gen_ull(__p, __v);
}
static __attribute__((always_inline, nothrow)) unsigned long long __ullAtomicMin_block(unsigned long long *__p,
                                                   unsigned long long __v) {
  return __nvvm_atom_cta_min_gen_ull(__p, __v);
}
static __attribute__((always_inline, nothrow)) unsigned long long __ullAtomicMin_system(unsigned long long *__p,
                                                    unsigned long long __v) {
  return __nvvm_atom_sys_min_gen_ull(__p, __v);
}
static __attribute__((always_inline, nothrow)) unsigned long long __ullAtomicOr(unsigned long long *__p,
                                            unsigned long long __v) {
  return __nvvm_atom_or_gen_ll((long long *)__p, __v);
}
static __attribute__((always_inline, nothrow)) unsigned long long __ullAtomicOr_block(unsigned long long *__p,
                                                  unsigned long long __v) {
  return __nvvm_atom_cta_or_gen_ll((long long *)__p, __v);
}
static __attribute__((always_inline, nothrow)) unsigned long long __ullAtomicOr_system(unsigned long long *__p,
                                                   unsigned long long __v) {
  return __nvvm_atom_sys_or_gen_ll((long long *)__p, __v);
}
static __attribute__((always_inline, nothrow)) unsigned long long __ullAtomicXor(unsigned long long *__p,
                                             unsigned long long __v) {
  return __nvvm_atom_xor_gen_ll((long long *)__p, __v);
}
static __attribute__((always_inline, nothrow)) unsigned long long __ullAtomicXor_block(unsigned long long *__p,
                                                   unsigned long long __v) {
  return __nvvm_atom_cta_xor_gen_ll((long long *)__p, __v);
}
static __attribute__((always_inline, nothrow)) unsigned long long __ullAtomicXor_system(unsigned long long *__p,
                                                    unsigned long long __v) {
  return __nvvm_atom_sys_xor_gen_ll((long long *)__p, __v);
}
static __attribute__((always_inline, nothrow)) unsigned int __umul24(unsigned int __a, unsigned int __b) {
  return __nv_umul24(__a, __b);
}
static __attribute__((always_inline, nothrow)) unsigned long long __umul64hi(unsigned long long __a,
                                         unsigned long long __b) {
  return __nv_umul64hi(__a, __b);
}
static __attribute__((always_inline, nothrow)) unsigned int __umulhi(unsigned int __a, unsigned int __b) {
  return __nv_umulhi(__a, __b);
}
static __attribute__((always_inline, nothrow)) unsigned int __urhadd(unsigned int __a, unsigned int __b) {
  return __nv_urhadd(__a, __b);
}
static __attribute__((always_inline, nothrow)) unsigned int __usad(unsigned int __a, unsigned int __b,
                               unsigned int __c) {
  return __nv_usad(__a, __b, __c);
}
# 1051 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/__clang_cuda_device_functions.h" 3
static __attribute__((always_inline, nothrow)) unsigned int __bool2mask(unsigned int __a, int shift) {
  return (__a << shift) - __a;
}
static __attribute__((always_inline, nothrow)) unsigned int __vabs2(unsigned int __a) {
  unsigned int r;
  __asm__("vabsdiff2.s32.s32.s32 %0,%1,%2,%3;"
          : "=r"(r)
          : "r"(__a), "r"(0), "r"(0));
  return r;
}
static __attribute__((always_inline, nothrow)) unsigned int __vabs4(unsigned int __a) {
  unsigned int r;
  __asm__("vabsdiff4.s32.s32.s32 %0,%1,%2,%3;"
          : "=r"(r)
          : "r"(__a), "r"(0), "r"(0));
  return r;
}
static __attribute__((always_inline, nothrow)) unsigned int __vabsdiffs2(unsigned int __a, unsigned int __b) {
  unsigned int r;
  __asm__("vabsdiff2.s32.s32.s32 %0,%1,%2,%3;"
          : "=r"(r)
          : "r"(__a), "r"(__b), "r"(0));
  return r;
}

static __attribute__((always_inline, nothrow)) unsigned int __vabsdiffs4(unsigned int __a, unsigned int __b) {
  unsigned int r;
  __asm__("vabsdiff4.s32.s32.s32 %0,%1,%2,%3;"
          : "=r"(r)
          : "r"(__a), "r"(__b), "r"(0));
  return r;
}
static __attribute__((always_inline, nothrow)) unsigned int __vabsdiffu2(unsigned int __a, unsigned int __b) {
  unsigned int r;
  __asm__("vabsdiff2.u32.u32.u32 %0,%1,%2,%3;"
          : "=r"(r)
          : "r"(__a), "r"(__b), "r"(0));
  return r;
}
static __attribute__((always_inline, nothrow)) unsigned int __vabsdiffu4(unsigned int __a, unsigned int __b) {
  unsigned int r;
  __asm__("vabsdiff4.u32.u32.u32 %0,%1,%2,%3;"
          : "=r"(r)
          : "r"(__a), "r"(__b), "r"(0));
  return r;
}
static __attribute__((always_inline, nothrow)) unsigned int __vabsss2(unsigned int __a) {
  unsigned int r;
  __asm__("vabsdiff2.s32.s32.s32.sat %0,%1,%2,%3;"
          : "=r"(r)
          : "r"(__a), "r"(0), "r"(0));
  return r;
}
static __attribute__((always_inline, nothrow)) unsigned int __vabsss4(unsigned int __a) {
  unsigned int r;
  __asm__("vabsdiff4.s32.s32.s32.sat %0,%1,%2,%3;"
          : "=r"(r)
          : "r"(__a), "r"(0), "r"(0));
  return r;
}
static __attribute__((always_inline, nothrow)) unsigned int __vadd2(unsigned int __a, unsigned int __b) {
  unsigned int r;
  __asm__("vadd2.u32.u32.u32 %0,%1,%2,%3;"
          : "=r"(r)
          : "r"(__a), "r"(__b), "r"(0));
  return r;
}
static __attribute__((always_inline, nothrow)) unsigned int __vadd4(unsigned int __a, unsigned int __b) {
  unsigned int r;
  __asm__("vadd4.u32.u32.u32 %0,%1,%2,%3;"
          : "=r"(r)
          : "r"(__a), "r"(__b), "r"(0));
  return r;
}
static __attribute__((always_inline, nothrow)) unsigned int __vaddss2(unsigned int __a, unsigned int __b) {
  unsigned int r;
  __asm__("vadd2.s32.s32.s32.sat %0,%1,%2,%3;"
          : "=r"(r)
          : "r"(__a), "r"(__b), "r"(0));
  return r;
}
static __attribute__((always_inline, nothrow)) unsigned int __vaddss4(unsigned int __a, unsigned int __b) {
  unsigned int r;
  __asm__("vadd4.s32.s32.s32.sat %0,%1,%2,%3;"
          : "=r"(r)
          : "r"(__a), "r"(__b), "r"(0));
  return r;
}
static __attribute__((always_inline, nothrow)) unsigned int __vaddus2(unsigned int __a, unsigned int __b) {
  unsigned int r;
  __asm__("vadd2.u32.u32.u32.sat %0,%1,%2,%3;"
          : "=r"(r)
          : "r"(__a), "r"(__b), "r"(0));
  return r;
}
static __attribute__((always_inline, nothrow)) unsigned int __vaddus4(unsigned int __a, unsigned int __b) {
  unsigned int r;
  __asm__("vadd4.u32.u32.u32.sat %0,%1,%2,%3;"
          : "=r"(r)
          : "r"(__a), "r"(__b), "r"(0));
  return r;
}
static __attribute__((always_inline, nothrow)) unsigned int __vavgs2(unsigned int __a, unsigned int __b) {
  unsigned int r;
  __asm__("vavrg2.s32.s32.s32 %0,%1,%2,%3;"
          : "=r"(r)
          : "r"(__a), "r"(__b), "r"(0));
  return r;
}
static __attribute__((always_inline, nothrow)) unsigned int __vavgs4(unsigned int __a, unsigned int __b) {
  unsigned int r;
  __asm__("vavrg4.s32.s32.s32 %0,%1,%2,%3;"
          : "=r"(r)
          : "r"(__a), "r"(__b), "r"(0));
  return r;
}
static __attribute__((always_inline, nothrow)) unsigned int __vavgu2(unsigned int __a, unsigned int __b) {
  unsigned int r;
  __asm__("vavrg2.u32.u32.u32 %0,%1,%2,%3;"
          : "=r"(r)
          : "r"(__a), "r"(__b), "r"(0));
  return r;
}
static __attribute__((always_inline, nothrow)) unsigned int __vavgu4(unsigned int __a, unsigned int __b) {
  unsigned int r;
  __asm__("vavrg4.u32.u32.u32 %0,%1,%2,%3;"
          : "=r"(r)
          : "r"(__a), "r"(__b), "r"(0));
  return r;
}
static __attribute__((always_inline, nothrow)) unsigned int __vseteq2(unsigned int __a, unsigned int __b) {
  unsigned int r;
  __asm__("vset2.u32.u32.eq %0,%1,%2,%3;"
          : "=r"(r)
          : "r"(__a), "r"(__b), "r"(0));
  return r;
}
static __attribute__((always_inline, nothrow)) unsigned int __vcmpeq2(unsigned int __a, unsigned int __b) {
  return __bool2mask(__vseteq2(__a, __b), 16);
}
static __attribute__((always_inline, nothrow)) unsigned int __vseteq4(unsigned int __a, unsigned int __b) {
  unsigned int r;
  __asm__("vset4.u32.u32.eq %0,%1,%2,%3;"
          : "=r"(r)
          : "r"(__a), "r"(__b), "r"(0));
  return r;
}
static __attribute__((always_inline, nothrow)) unsigned int __vcmpeq4(unsigned int __a, unsigned int __b) {
  return __bool2mask(__vseteq4(__a, __b), 8);
}
static __attribute__((always_inline, nothrow)) unsigned int __vsetges2(unsigned int __a, unsigned int __b) {
  unsigned int r;
  __asm__("vset2.s32.s32.ge %0,%1,%2,%3;"
          : "=r"(r)
          : "r"(__a), "r"(__b), "r"(0));
  return r;
}
static __attribute__((always_inline, nothrow)) unsigned int __vcmpges2(unsigned int __a, unsigned int __b) {
  return __bool2mask(__vsetges2(__a, __b), 16);
}
static __attribute__((always_inline, nothrow)) unsigned int __vsetges4(unsigned int __a, unsigned int __b) {
  unsigned int r;
  __asm__("vset4.s32.s32.ge %0,%1,%2,%3;"
          : "=r"(r)
          : "r"(__a), "r"(__b), "r"(0));
  return r;
}
static __attribute__((always_inline, nothrow)) unsigned int __vcmpges4(unsigned int __a, unsigned int __b) {
  return __bool2mask(__vsetges4(__a, __b), 8);
}
static __attribute__((always_inline, nothrow)) unsigned int __vsetgeu2(unsigned int __a, unsigned int __b) {
  unsigned int r;
  __asm__("vset2.u32.u32.ge %0,%1,%2,%3;"
          : "=r"(r)
          : "r"(__a), "r"(__b), "r"(0));
  return r;
}
static __attribute__((always_inline, nothrow)) unsigned int __vcmpgeu2(unsigned int __a, unsigned int __b) {
  return __bool2mask(__vsetgeu2(__a, __b), 16);
}
static __attribute__((always_inline, nothrow)) unsigned int __vsetgeu4(unsigned int __a, unsigned int __b) {
  unsigned int r;
  __asm__("vset4.u32.u32.ge %0,%1,%2,%3;"
          : "=r"(r)
          : "r"(__a), "r"(__b), "r"(0));
  return r;
}
static __attribute__((always_inline, nothrow)) unsigned int __vcmpgeu4(unsigned int __a, unsigned int __b) {
  return __bool2mask(__vsetgeu4(__a, __b), 8);
}
static __attribute__((always_inline, nothrow)) unsigned int __vsetgts2(unsigned int __a, unsigned int __b) {
  unsigned int r;
  __asm__("vset2.s32.s32.gt %0,%1,%2,%3;"
          : "=r"(r)
          : "r"(__a), "r"(__b), "r"(0));
  return r;
}
static __attribute__((always_inline, nothrow)) unsigned int __vcmpgts2(unsigned int __a, unsigned int __b) {
  return __bool2mask(__vsetgts2(__a, __b), 16);
}
static __attribute__((always_inline, nothrow)) unsigned int __vsetgts4(unsigned int __a, unsigned int __b) {
  unsigned int r;
  __asm__("vset4.s32.s32.gt %0,%1,%2,%3;"
          : "=r"(r)
          : "r"(__a), "r"(__b), "r"(0));
  return r;
}
static __attribute__((always_inline, nothrow)) unsigned int __vcmpgts4(unsigned int __a, unsigned int __b) {
  return __bool2mask(__vsetgts4(__a, __b), 8);
}
static __attribute__((always_inline, nothrow)) unsigned int __vsetgtu2(unsigned int __a, unsigned int __b) {
  unsigned int r;
  __asm__("vset2.u32.u32.gt %0,%1,%2,%3;"
          : "=r"(r)
          : "r"(__a), "r"(__b), "r"(0));
  return r;
}
static __attribute__((always_inline, nothrow)) unsigned int __vcmpgtu2(unsigned int __a, unsigned int __b) {
  return __bool2mask(__vsetgtu2(__a, __b), 16);
}
static __attribute__((always_inline, nothrow)) unsigned int __vsetgtu4(unsigned int __a, unsigned int __b) {
  unsigned int r;
  __asm__("vset4.u32.u32.gt %0,%1,%2,%3;"
          : "=r"(r)
          : "r"(__a), "r"(__b), "r"(0));
  return r;
}
static __attribute__((always_inline, nothrow)) unsigned int __vcmpgtu4(unsigned int __a, unsigned int __b) {
  return __bool2mask(__vsetgtu4(__a, __b), 8);
}
static __attribute__((always_inline, nothrow)) unsigned int __vsetles2(unsigned int __a, unsigned int __b) {
  unsigned int r;
  __asm__("vset2.s32.s32.le %0,%1,%2,%3;"
          : "=r"(r)
          : "r"(__a), "r"(__b), "r"(0));
  return r;
}
static __attribute__((always_inline, nothrow)) unsigned int __vcmples2(unsigned int __a, unsigned int __b) {
  return __bool2mask(__vsetles2(__a, __b), 16);
}
static __attribute__((always_inline, nothrow)) unsigned int __vsetles4(unsigned int __a, unsigned int __b) {
  unsigned int r;
  __asm__("vset4.s32.s32.le %0,%1,%2,%3;"
          : "=r"(r)
          : "r"(__a), "r"(__b), "r"(0));
  return r;
}
static __attribute__((always_inline, nothrow)) unsigned int __vcmples4(unsigned int __a, unsigned int __b) {
  return __bool2mask(__vsetles4(__a, __b), 8);
}
static __attribute__((always_inline, nothrow)) unsigned int __vsetleu2(unsigned int __a, unsigned int __b) {
  unsigned int r;
  __asm__("vset2.u32.u32.le %0,%1,%2,%3;"
          : "=r"(r)
          : "r"(__a), "r"(__b), "r"(0));
  return r;
}
static __attribute__((always_inline, nothrow)) unsigned int __vcmpleu2(unsigned int __a, unsigned int __b) {
  return __bool2mask(__vsetleu2(__a, __b), 16);
}
static __attribute__((always_inline, nothrow)) unsigned int __vsetleu4(unsigned int __a, unsigned int __b) {
  unsigned int r;
  __asm__("vset4.u32.u32.le %0,%1,%2,%3;"
          : "=r"(r)
          : "r"(__a), "r"(__b), "r"(0));
  return r;
}
static __attribute__((always_inline, nothrow)) unsigned int __vcmpleu4(unsigned int __a, unsigned int __b) {
  return __bool2mask(__vsetleu4(__a, __b), 8);
}
static __attribute__((always_inline, nothrow)) unsigned int __vsetlts2(unsigned int __a, unsigned int __b) {
  unsigned int r;
  __asm__("vset2.s32.s32.lt %0,%1,%2,%3;"
          : "=r"(r)
          : "r"(__a), "r"(__b), "r"(0));
  return r;
}
static __attribute__((always_inline, nothrow)) unsigned int __vcmplts2(unsigned int __a, unsigned int __b) {
  return __bool2mask(__vsetlts2(__a, __b), 16);
}
static __attribute__((always_inline, nothrow)) unsigned int __vsetlts4(unsigned int __a, unsigned int __b) {
  unsigned int r;
  __asm__("vset4.s32.s32.lt %0,%1,%2,%3;"
          : "=r"(r)
          : "r"(__a), "r"(__b), "r"(0));
  return r;
}
static __attribute__((always_inline, nothrow)) unsigned int __vcmplts4(unsigned int __a, unsigned int __b) {
  return __bool2mask(__vsetlts4(__a, __b), 8);
}
static __attribute__((always_inline, nothrow)) unsigned int __vsetltu2(unsigned int __a, unsigned int __b) {
  unsigned int r;
  __asm__("vset2.u32.u32.lt %0,%1,%2,%3;"
          : "=r"(r)
          : "r"(__a), "r"(__b), "r"(0));
  return r;
}
static __attribute__((always_inline, nothrow)) unsigned int __vcmpltu2(unsigned int __a, unsigned int __b) {
  return __bool2mask(__vsetltu2(__a, __b), 16);
}
static __attribute__((always_inline, nothrow)) unsigned int __vsetltu4(unsigned int __a, unsigned int __b) {
  unsigned int r;
  __asm__("vset4.u32.u32.lt %0,%1,%2,%3;"
          : "=r"(r)
          : "r"(__a), "r"(__b), "r"(0));
  return r;
}
static __attribute__((always_inline, nothrow)) unsigned int __vcmpltu4(unsigned int __a, unsigned int __b) {
  return __bool2mask(__vsetltu4(__a, __b), 8);
}
static __attribute__((always_inline, nothrow)) unsigned int __vsetne2(unsigned int __a, unsigned int __b) {
  unsigned int r;
  __asm__("vset2.u32.u32.ne %0,%1,%2,%3;"
          : "=r"(r)
          : "r"(__a), "r"(__b), "r"(0));
  return r;
}
static __attribute__((always_inline, nothrow)) unsigned int __vcmpne2(unsigned int __a, unsigned int __b) {
  return __bool2mask(__vsetne2(__a, __b), 16);
}
static __attribute__((always_inline, nothrow)) unsigned int __vsetne4(unsigned int __a, unsigned int __b) {
  unsigned int r;
  __asm__("vset4.u32.u32.ne %0,%1,%2,%3;"
          : "=r"(r)
          : "r"(__a), "r"(__b), "r"(0));
  return r;
}
static __attribute__((always_inline, nothrow)) unsigned int __vcmpne4(unsigned int __a, unsigned int __b) {
  return __bool2mask(__vsetne4(__a, __b), 8);
}






static __attribute__((always_inline, nothrow)) unsigned int __vhaddu2(unsigned int __a, unsigned int __b) {
  return (((__a ^ __b) >> 1) & ~0x80008000u) + (__a & __b);
}
static __attribute__((always_inline, nothrow)) unsigned int __vhaddu4(unsigned int __a, unsigned int __b) {
  return (((__a ^ __b) >> 1) & ~0x80808080u) + (__a & __b);
}

static __attribute__((always_inline, nothrow)) unsigned int __vmaxs2(unsigned int __a, unsigned int __b) {
  unsigned int r;
  if ((__a & 0x8000) && (__b & 0x8000)) {


    unsigned mask = __vcmpgts2(__a, __b);
    r = (__a & mask) | (__b & ~mask);
  } else {
    __asm__("vmax2.s32.s32.s32 %0,%1,%2,%3;"
            : "=r"(r)
            : "r"(__a), "r"(__b), "r"(0));
  }
  return r;
}
static __attribute__((always_inline, nothrow)) unsigned int __vmaxs4(unsigned int __a, unsigned int __b) {
  unsigned int r;
  __asm__("vmax4.s32.s32.s32 %0,%1,%2,%3;"
          : "=r"(r)
          : "r"(__a), "r"(__b), "r"(0));
  return r;
}
static __attribute__((always_inline, nothrow)) unsigned int __vmaxu2(unsigned int __a, unsigned int __b) {
  unsigned int r;
  __asm__("vmax2.u32.u32.u32 %0,%1,%2,%3;"
          : "=r"(r)
          : "r"(__a), "r"(__b), "r"(0));
  return r;
}
static __attribute__((always_inline, nothrow)) unsigned int __vmaxu4(unsigned int __a, unsigned int __b) {
  unsigned int r;
  __asm__("vmax4.u32.u32.u32 %0,%1,%2,%3;"
          : "=r"(r)
          : "r"(__a), "r"(__b), "r"(0));
  return r;
}
static __attribute__((always_inline, nothrow)) unsigned int __vmins2(unsigned int __a, unsigned int __b) {
  unsigned int r;
  __asm__("vmin2.s32.s32.s32 %0,%1,%2,%3;"
          : "=r"(r)
          : "r"(__a), "r"(__b), "r"(0));
  return r;
}
static __attribute__((always_inline, nothrow)) unsigned int __vmins4(unsigned int __a, unsigned int __b) {
  unsigned int r;
  __asm__("vmin4.s32.s32.s32 %0,%1,%2,%3;"
          : "=r"(r)
          : "r"(__a), "r"(__b), "r"(0));
  return r;
}
static __attribute__((always_inline, nothrow)) unsigned int __vminu2(unsigned int __a, unsigned int __b) {
  unsigned int r;
  __asm__("vmin2.u32.u32.u32 %0,%1,%2,%3;"
          : "=r"(r)
          : "r"(__a), "r"(__b), "r"(0));
  return r;
}
static __attribute__((always_inline, nothrow)) unsigned int __vminu4(unsigned int __a, unsigned int __b) {
  unsigned int r;
  __asm__("vmin4.u32.u32.u32 %0,%1,%2,%3;"
          : "=r"(r)
          : "r"(__a), "r"(__b), "r"(0));
  return r;
}
static __attribute__((always_inline, nothrow)) unsigned int __vsads2(unsigned int __a, unsigned int __b) {
  unsigned int r;
  __asm__("vabsdiff2.s32.s32.s32.add %0,%1,%2,%3;"
          : "=r"(r)
          : "r"(__a), "r"(__b), "r"(0));
  return r;
}
static __attribute__((always_inline, nothrow)) unsigned int __vsads4(unsigned int __a, unsigned int __b) {
  unsigned int r;
  __asm__("vabsdiff4.s32.s32.s32.add %0,%1,%2,%3;"
          : "=r"(r)
          : "r"(__a), "r"(__b), "r"(0));
  return r;
}
static __attribute__((always_inline, nothrow)) unsigned int __vsadu2(unsigned int __a, unsigned int __b) {
  unsigned int r;
  __asm__("vabsdiff2.u32.u32.u32.add %0,%1,%2,%3;"
          : "=r"(r)
          : "r"(__a), "r"(__b), "r"(0));
  return r;
}
static __attribute__((always_inline, nothrow)) unsigned int __vsadu4(unsigned int __a, unsigned int __b) {
  unsigned int r;
  __asm__("vabsdiff4.u32.u32.u32.add %0,%1,%2,%3;"
          : "=r"(r)
          : "r"(__a), "r"(__b), "r"(0));
  return r;
}

static __attribute__((always_inline, nothrow)) unsigned int __vsub2(unsigned int __a, unsigned int __b) {
  unsigned int r;
  __asm__("vsub2.u32.u32.u32 %0,%1,%2,%3;"
          : "=r"(r)
          : "r"(__a), "r"(__b), "r"(0));
  return r;
}
static __attribute__((always_inline, nothrow)) unsigned int __vneg2(unsigned int __a) { return __vsub2(0, __a); }

static __attribute__((always_inline, nothrow)) unsigned int __vsub4(unsigned int __a, unsigned int __b) {
  unsigned int r;
  __asm__("vsub4.u32.u32.u32 %0,%1,%2,%3;"
          : "=r"(r)
          : "r"(__a), "r"(__b), "r"(0));
  return r;
}
static __attribute__((always_inline, nothrow)) unsigned int __vneg4(unsigned int __a) { return __vsub4(0, __a); }
static __attribute__((always_inline, nothrow)) unsigned int __vsubss2(unsigned int __a, unsigned int __b) {
  unsigned int r;
  __asm__("vsub2.s32.s32.s32.sat %0,%1,%2,%3;"
          : "=r"(r)
          : "r"(__a), "r"(__b), "r"(0));
  return r;
}
static __attribute__((always_inline, nothrow)) unsigned int __vnegss2(unsigned int __a) {
  return __vsubss2(0, __a);
}
static __attribute__((always_inline, nothrow)) unsigned int __vsubss4(unsigned int __a, unsigned int __b) {
  unsigned int r;
  __asm__("vsub4.s32.s32.s32.sat %0,%1,%2,%3;"
          : "=r"(r)
          : "r"(__a), "r"(__b), "r"(0));
  return r;
}
static __attribute__((always_inline, nothrow)) unsigned int __vnegss4(unsigned int __a) {
  return __vsubss4(0, __a);
}
static __attribute__((always_inline, nothrow)) unsigned int __vsubus2(unsigned int __a, unsigned int __b) {
  unsigned int r;
  __asm__("vsub2.u32.u32.u32.sat %0,%1,%2,%3;"
          : "=r"(r)
          : "r"(__a), "r"(__b), "r"(0));
  return r;
}
static __attribute__((always_inline, nothrow)) unsigned int __vsubus4(unsigned int __a, unsigned int __b) {
  unsigned int r;
  __asm__("vsub4.u32.u32.u32.sat %0,%1,%2,%3;"
          : "=r"(r)
          : "r"(__a), "r"(__b), "r"(0));
  return r;
}







static __attribute__((always_inline, nothrow)) long long clock64() { return __nvvm_read_ptx_sreg_clock64(); }
# 32 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/openmp_wrappers/__clang_openmp_device_functions.h" 2 3




#pragma omp end declare variant


#pragma omp begin declare variant match(device = {arch(amdgcn)})
# 51 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/openmp_wrappers/__clang_openmp_device_functions.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/__clang_hip_libdevice_declares.h" 1 3
# 18 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/__clang_hip_libdevice_declares.h" 3
extern "C" {



           __attribute__((const)) float __ocml_acos_f32(float);
           __attribute__((pure)) float __ocml_acosh_f32(float);
           __attribute__((const)) float __ocml_asin_f32(float);
           __attribute__((pure)) float __ocml_asinh_f32(float);
           __attribute__((const)) float __ocml_atan2_f32(float, float);
           __attribute__((const)) float __ocml_atan_f32(float);
           __attribute__((pure)) float __ocml_atanh_f32(float);
           __attribute__((pure)) float __ocml_cbrt_f32(float);
           __attribute__((const)) float __ocml_ceil_f32(float);
           __attribute__((const)) float __ocml_copysign_f32(float,
                                                                       float);
           float __ocml_cos_f32(float);
           float __ocml_native_cos_f32(float);
           __attribute__((pure)) float __ocml_cosh_f32(float);
           float __ocml_cospi_f32(float);
           float __ocml_i0_f32(float);
           float __ocml_i1_f32(float);
           __attribute__((pure)) float __ocml_erfc_f32(float);
           __attribute__((pure)) float __ocml_erfcinv_f32(float);
           __attribute__((pure)) float __ocml_erfcx_f32(float);
           __attribute__((pure)) float __ocml_erf_f32(float);
           __attribute__((pure)) float __ocml_erfinv_f32(float);
           __attribute__((pure)) float __ocml_exp10_f32(float);
           __attribute__((pure)) float __ocml_native_exp10_f32(float);
           __attribute__((pure)) float __ocml_exp2_f32(float);
           __attribute__((pure)) float __ocml_exp_f32(float);
           __attribute__((pure)) float __ocml_native_exp_f32(float);
           __attribute__((pure)) float __ocml_expm1_f32(float);
           __attribute__((const)) float __ocml_fabs_f32(float);
           __attribute__((const)) float __ocml_fdim_f32(float, float);
           __attribute__((const)) float __ocml_floor_f32(float);
           __attribute__((const)) float __ocml_fma_f32(float, float, float);
           __attribute__((const)) float __ocml_fmax_f32(float, float);
           __attribute__((const)) float __ocml_fmin_f32(float, float);
           __attribute__((const)) float __ocml_fmod_f32(float,
                                                                   float);
           float __ocml_frexp_f32(float,
                                  __attribute__((address_space(5))) int *);
           __attribute__((const)) float __ocml_hypot_f32(float, float);
           __attribute__((const)) int __ocml_ilogb_f32(float);
           __attribute__((const)) int __ocml_isfinite_f32(float);
           __attribute__((const)) int __ocml_isinf_f32(float);
           __attribute__((const)) int __ocml_isnan_f32(float);
           float __ocml_j0_f32(float);
           float __ocml_j1_f32(float);
           __attribute__((const)) float __ocml_ldexp_f32(float, int);
           float __ocml_lgamma_f32(float);
           __attribute__((pure)) float __ocml_log10_f32(float);
           __attribute__((pure)) float __ocml_native_log10_f32(float);
           __attribute__((pure)) float __ocml_log1p_f32(float);
           __attribute__((pure)) float __ocml_log2_f32(float);
           __attribute__((pure)) float __ocml_native_log2_f32(float);
           __attribute__((const)) float __ocml_logb_f32(float);
           __attribute__((pure)) float __ocml_log_f32(float);
           __attribute__((pure)) float __ocml_native_log_f32(float);
           float __ocml_modf_f32(float,
                                 __attribute__((address_space(5))) float *);
           __attribute__((const)) float __ocml_nearbyint_f32(float);
           __attribute__((const)) float __ocml_nextafter_f32(float, float);
           __attribute__((const)) float __ocml_len3_f32(float, float, float);
           __attribute__((const)) float __ocml_len4_f32(float, float, float,
                                                        float);
           __attribute__((pure)) float __ocml_ncdf_f32(float);
           __attribute__((pure)) float __ocml_ncdfinv_f32(float);
           __attribute__((pure)) float __ocml_pow_f32(float, float);
           __attribute__((pure)) float __ocml_pown_f32(float, int);
           __attribute__((pure)) float __ocml_rcbrt_f32(float);
           __attribute__((const)) float __ocml_remainder_f32(float, float);
           float __ocml_remquo_f32(float, float,
                                   __attribute__((address_space(5))) int *);
           __attribute__((const)) float __ocml_rhypot_f32(float, float);
           __attribute__((const)) float __ocml_rint_f32(float);
           __attribute__((const)) float __ocml_rlen3_f32(float, float, float);
           __attribute__((const)) float __ocml_rlen4_f32(float, float, float,
                                                         float);
           __attribute__((const)) float __ocml_round_f32(float);
           __attribute__((pure)) float __ocml_rsqrt_f32(float);
           __attribute__((const)) float __ocml_scalb_f32(float, float);
           __attribute__((const)) float __ocml_scalbn_f32(float, int);
           __attribute__((const)) int __ocml_signbit_f32(float);
           float __ocml_sincos_f32(float,
                                   __attribute__((address_space(5))) float *);
           float __ocml_sincospi_f32(float,
                                     __attribute__((address_space(5))) float *);
           float __ocml_sin_f32(float);
           float __ocml_native_sin_f32(float);
           __attribute__((pure)) float __ocml_sinh_f32(float);
           float __ocml_sinpi_f32(float);
           __attribute__((const)) float __ocml_sqrt_f32(float);
           __attribute__((const)) float __ocml_native_sqrt_f32(float);
           float __ocml_tan_f32(float);
           __attribute__((pure)) float __ocml_tanh_f32(float);
           float __ocml_tgamma_f32(float);
           __attribute__((const)) float __ocml_trunc_f32(float);
           float __ocml_y0_f32(float);
           float __ocml_y1_f32(float);


           __attribute__((const)) float __ocml_add_rte_f32(float, float);
           __attribute__((const)) float __ocml_add_rtn_f32(float, float);
           __attribute__((const)) float __ocml_add_rtp_f32(float, float);
           __attribute__((const)) float __ocml_add_rtz_f32(float, float);
           __attribute__((const)) float __ocml_sub_rte_f32(float, float);
           __attribute__((const)) float __ocml_sub_rtn_f32(float, float);
           __attribute__((const)) float __ocml_sub_rtp_f32(float, float);
           __attribute__((const)) float __ocml_sub_rtz_f32(float, float);
           __attribute__((const)) float __ocml_mul_rte_f32(float, float);
           __attribute__((const)) float __ocml_mul_rtn_f32(float, float);
           __attribute__((const)) float __ocml_mul_rtp_f32(float, float);
           __attribute__((const)) float __ocml_mul_rtz_f32(float, float);
           __attribute__((const)) float __ocml_div_rte_f32(float, float);
           __attribute__((const)) float __ocml_div_rtn_f32(float, float);
           __attribute__((const)) float __ocml_div_rtp_f32(float, float);
           __attribute__((const)) float __ocml_div_rtz_f32(float, float);
           __attribute__((const)) float __ocml_sqrt_rte_f32(float);
           __attribute__((const)) float __ocml_sqrt_rtn_f32(float);
           __attribute__((const)) float __ocml_sqrt_rtp_f32(float);
           __attribute__((const)) float __ocml_sqrt_rtz_f32(float);
           __attribute__((const)) float __ocml_fma_rte_f32(float, float, float);
           __attribute__((const)) float __ocml_fma_rtn_f32(float, float, float);
           __attribute__((const)) float __ocml_fma_rtp_f32(float, float, float);
           __attribute__((const)) float __ocml_fma_rtz_f32(float, float, float);




           __attribute__((const)) double __ocml_acos_f64(double);
           __attribute__((pure)) double __ocml_acosh_f64(double);
           __attribute__((const)) double __ocml_asin_f64(double);
           __attribute__((pure)) double __ocml_asinh_f64(double);
           __attribute__((const)) double __ocml_atan2_f64(double, double);
           __attribute__((const)) double __ocml_atan_f64(double);
           __attribute__((pure)) double __ocml_atanh_f64(double);
           __attribute__((pure)) double __ocml_cbrt_f64(double);
           __attribute__((const)) double __ocml_ceil_f64(double);
           __attribute__((const)) double __ocml_copysign_f64(double, double);
           double __ocml_cos_f64(double);
           __attribute__((pure)) double __ocml_cosh_f64(double);
           double __ocml_cospi_f64(double);
           double __ocml_i0_f64(double);
           double __ocml_i1_f64(double);
           __attribute__((pure)) double __ocml_erfc_f64(double);
           __attribute__((pure)) double __ocml_erfcinv_f64(double);
           __attribute__((pure)) double __ocml_erfcx_f64(double);
           __attribute__((pure)) double __ocml_erf_f64(double);
           __attribute__((pure)) double __ocml_erfinv_f64(double);
           __attribute__((pure)) double __ocml_exp10_f64(double);
           __attribute__((pure)) double __ocml_exp2_f64(double);
           __attribute__((pure)) double __ocml_exp_f64(double);
           __attribute__((pure)) double __ocml_expm1_f64(double);
           __attribute__((const)) double __ocml_fabs_f64(double);
           __attribute__((const)) double __ocml_fdim_f64(double, double);
           __attribute__((const)) double __ocml_floor_f64(double);
           __attribute__((const)) double __ocml_fma_f64(double, double, double);
           __attribute__((const)) double __ocml_fmax_f64(double, double);
           __attribute__((const)) double __ocml_fmin_f64(double, double);
           __attribute__((const)) double __ocml_fmod_f64(double, double);
           double __ocml_frexp_f64(double,
                                   __attribute__((address_space(5))) int *);
           __attribute__((const)) double __ocml_hypot_f64(double, double);
           __attribute__((const)) int __ocml_ilogb_f64(double);
           __attribute__((const)) int __ocml_isfinite_f64(double);
           __attribute__((const)) int __ocml_isinf_f64(double);
           __attribute__((const)) int __ocml_isnan_f64(double);
           double __ocml_j0_f64(double);
           double __ocml_j1_f64(double);
           __attribute__((const)) double __ocml_ldexp_f64(double, int);
           double __ocml_lgamma_f64(double);
           __attribute__((pure)) double __ocml_log10_f64(double);
           __attribute__((pure)) double __ocml_log1p_f64(double);
           __attribute__((pure)) double __ocml_log2_f64(double);
           __attribute__((const)) double __ocml_logb_f64(double);
           __attribute__((pure)) double __ocml_log_f64(double);
           double __ocml_modf_f64(double,
                                  __attribute__((address_space(5))) double *);
           __attribute__((const)) double __ocml_nearbyint_f64(double);
           __attribute__((const)) double __ocml_nextafter_f64(double, double);
           __attribute__((const)) double __ocml_len3_f64(double, double,
                                                         double);
           __attribute__((const)) double __ocml_len4_f64(double, double, double,
                                                         double);
           __attribute__((pure)) double __ocml_ncdf_f64(double);
           __attribute__((pure)) double __ocml_ncdfinv_f64(double);
           __attribute__((pure)) double __ocml_pow_f64(double, double);
           __attribute__((pure)) double __ocml_pown_f64(double, int);
           __attribute__((pure)) double __ocml_rcbrt_f64(double);
           __attribute__((const)) double __ocml_remainder_f64(double, double);
           double __ocml_remquo_f64(double, double,
                                    __attribute__((address_space(5))) int *);
           __attribute__((const)) double __ocml_rhypot_f64(double, double);
           __attribute__((const)) double __ocml_rint_f64(double);
           __attribute__((const)) double __ocml_rlen3_f64(double, double,
                                                          double);
           __attribute__((const)) double __ocml_rlen4_f64(double, double,
                                                          double, double);
           __attribute__((const)) double __ocml_round_f64(double);
           __attribute__((pure)) double __ocml_rsqrt_f64(double);
           __attribute__((const)) double __ocml_scalb_f64(double, double);
           __attribute__((const)) double __ocml_scalbn_f64(double, int);
           __attribute__((const)) int __ocml_signbit_f64(double);
           double __ocml_sincos_f64(double,
                                    __attribute__((address_space(5))) double *);
           double
__ocml_sincospi_f64(double, __attribute__((address_space(5))) double *);
           double __ocml_sin_f64(double);
           __attribute__((pure)) double __ocml_sinh_f64(double);
           double __ocml_sinpi_f64(double);
           __attribute__((const)) double __ocml_sqrt_f64(double);
           double __ocml_tan_f64(double);
           __attribute__((pure)) double __ocml_tanh_f64(double);
           double __ocml_tgamma_f64(double);
           __attribute__((const)) double __ocml_trunc_f64(double);
           double __ocml_y0_f64(double);
           double __ocml_y1_f64(double);


           __attribute__((const)) double __ocml_add_rte_f64(double, double);
           __attribute__((const)) double __ocml_add_rtn_f64(double, double);
           __attribute__((const)) double __ocml_add_rtp_f64(double, double);
           __attribute__((const)) double __ocml_add_rtz_f64(double, double);
           __attribute__((const)) double __ocml_sub_rte_f64(double, double);
           __attribute__((const)) double __ocml_sub_rtn_f64(double, double);
           __attribute__((const)) double __ocml_sub_rtp_f64(double, double);
           __attribute__((const)) double __ocml_sub_rtz_f64(double, double);
           __attribute__((const)) double __ocml_mul_rte_f64(double, double);
           __attribute__((const)) double __ocml_mul_rtn_f64(double, double);
           __attribute__((const)) double __ocml_mul_rtp_f64(double, double);
           __attribute__((const)) double __ocml_mul_rtz_f64(double, double);
           __attribute__((const)) double __ocml_div_rte_f64(double, double);
           __attribute__((const)) double __ocml_div_rtn_f64(double, double);
           __attribute__((const)) double __ocml_div_rtp_f64(double, double);
           __attribute__((const)) double __ocml_div_rtz_f64(double, double);
           __attribute__((const)) double __ocml_sqrt_rte_f64(double);
           __attribute__((const)) double __ocml_sqrt_rtn_f64(double);
           __attribute__((const)) double __ocml_sqrt_rtp_f64(double);
           __attribute__((const)) double __ocml_sqrt_rtz_f64(double);
           __attribute__((const)) double __ocml_fma_rte_f64(double, double,
                                                            double);
           __attribute__((const)) double __ocml_fma_rtn_f64(double, double,
                                                            double);
           __attribute__((const)) double __ocml_fma_rtp_f64(double, double,
                                                            double);
           __attribute__((const)) double __ocml_fma_rtz_f64(double, double,
                                                            double);

           __attribute__((const)) _Float16 __ocml_ceil_f16(_Float16);
           _Float16 __ocml_cos_f16(_Float16);
           __attribute__((const)) _Float16 __ocml_cvtrtn_f16_f32(float);
           __attribute__((const)) _Float16 __ocml_cvtrtp_f16_f32(float);
           __attribute__((const)) _Float16 __ocml_cvtrtz_f16_f32(float);
           __attribute__((pure)) _Float16 __ocml_exp_f16(_Float16);
           __attribute__((pure)) _Float16 __ocml_exp10_f16(_Float16);
           __attribute__((pure)) _Float16 __ocml_exp2_f16(_Float16);
           __attribute__((const)) _Float16 __ocml_floor_f16(_Float16);
           __attribute__((const)) _Float16 __ocml_fma_f16(_Float16, _Float16,
                                                          _Float16);
           __attribute__((const)) _Float16 __ocml_fmax_f16(_Float16, _Float16);
           __attribute__((const)) _Float16 __ocml_fmin_f16(_Float16, _Float16);
           __attribute__((const)) _Float16 __ocml_fabs_f16(_Float16);
           __attribute__((const)) int __ocml_isinf_f16(_Float16);
           __attribute__((const)) int __ocml_isnan_f16(_Float16);
           __attribute__((pure)) _Float16 __ocml_log_f16(_Float16);
           __attribute__((pure)) _Float16 __ocml_log10_f16(_Float16);
           __attribute__((pure)) _Float16 __ocml_log2_f16(_Float16);
           __attribute__((const)) _Float16 __ocml_rint_f16(_Float16);
           __attribute__((const)) _Float16 __ocml_rsqrt_f16(_Float16);
           _Float16 __ocml_sin_f16(_Float16);
           __attribute__((const)) _Float16 __ocml_sqrt_f16(_Float16);
           __attribute__((const)) _Float16 __ocml_trunc_f16(_Float16);
           __attribute__((pure)) _Float16 __ocml_pown_f16(_Float16, int);

typedef _Float16 __2f16 __attribute__((ext_vector_type(2)));
typedef short __2i16 __attribute__((ext_vector_type(2)));



typedef bool __ockl_bool;




           __attribute__((const)) float __ockl_fdot2(__2f16 a, __2f16 b,
                                                     float c, __ockl_bool s);
           __attribute__((const)) __2f16 __ocml_ceil_2f16(__2f16);
           __attribute__((const)) __2f16 __ocml_fabs_2f16(__2f16);
           __2f16 __ocml_cos_2f16(__2f16);
           __attribute__((pure)) __2f16 __ocml_exp_2f16(__2f16);
           __attribute__((pure)) __2f16 __ocml_exp10_2f16(__2f16);
           __attribute__((pure)) __2f16 __ocml_exp2_2f16(__2f16);
           __attribute__((const)) __2f16 __ocml_floor_2f16(__2f16);
           __attribute__((const))
__2f16 __ocml_fma_2f16(__2f16, __2f16, __2f16);
           __attribute__((const)) __2i16 __ocml_isinf_2f16(__2f16);
           __attribute__((const)) __2i16 __ocml_isnan_2f16(__2f16);
           __attribute__((pure)) __2f16 __ocml_log_2f16(__2f16);
           __attribute__((pure)) __2f16 __ocml_log10_2f16(__2f16);
           __attribute__((pure)) __2f16 __ocml_log2_2f16(__2f16);
# 329 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/__clang_hip_libdevice_declares.h" 3
           inline _Float16 __llvm_amdgcn_rcp_f16(_Float16 x) {
  return ((_Float16)1.0f) / x;
}


           inline __2f16
__llvm_amdgcn_rcp_2f16(__2f16 __x)
{
  return ((__2f16)1.0f) / __x;
}



           __attribute__((const)) __2f16 __ocml_rint_2f16(__2f16);
           __attribute__((const)) __2f16 __ocml_rsqrt_2f16(__2f16);
           __2f16 __ocml_sin_2f16(__2f16);
           __attribute__((const)) __2f16 __ocml_sqrt_2f16(__2f16);
           __attribute__((const)) __2f16 __ocml_trunc_2f16(__2f16);
           __attribute__((const)) __2f16 __ocml_pown_2f16(__2f16, __2i16);


}
# 52 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/openmp_wrappers/__clang_openmp_device_functions.h" 2 3




#pragma omp end declare variant



}







# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/cstdlib" 1 3
# 84 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/cstdlib" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__assert" 1 3
# 13 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__assert" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__config" 1 3
# 13 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__config" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/x86_64-unknown-linux-gnu/c++/v1/__config_site" 1 3
# 47 "/dev/shm/rydahl1/LLVM/install/bin/../include/x86_64-unknown-linux-gnu/c++/v1/__config_site" 3
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wmacro-redefined"






#pragma clang diagnostic pop
# 14 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__config" 2 3
# 17 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__config" 3
# 454 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__config" 3
# 1 "/usr/include/features.h" 1 3 4
# 416 "/usr/include/features.h" 3 4
# 1 "/usr/include/stdc-predef.h" 1 3 4
# 417 "/usr/include/features.h" 2 3 4
# 438 "/usr/include/features.h" 3 4
# 1 "/usr/include/sys/cdefs.h" 1 3 4
# 499 "/usr/include/sys/cdefs.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 500 "/usr/include/sys/cdefs.h" 2 3 4
# 1 "/usr/include/bits/long-double.h" 1 3 4
# 501 "/usr/include/sys/cdefs.h" 2 3 4
# 439 "/usr/include/features.h" 2 3 4
# 462 "/usr/include/features.h" 3 4
# 1 "/usr/include/gnu/stubs.h" 1 3 4
# 10 "/usr/include/gnu/stubs.h" 3 4
# 1 "/usr/include/gnu/stubs-64.h" 1 3 4
# 11 "/usr/include/gnu/stubs.h" 2 3 4
# 463 "/usr/include/features.h" 2 3 4
# 455 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__config" 2 3
# 803 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__config" 3
namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 { }}
# 14 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__assert" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__verbose_abort" 1 3
# 13 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__verbose_abort" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__availability" 1 3
# 17 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__availability" 3
# 14 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__verbose_abort" 2 3
# 18 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__verbose_abort" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {



[[noreturn]] __attribute__((__visibility__("default"))) __attribute__((__format__(__printf__, 1, 2)))
void __libcpp_verbose_abort(const char *__format, ...);
# 58 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__verbose_abort" 3
}}
# 15 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__assert" 2 3
# 18 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__assert" 3
# 85 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/cstdlib" 2 3


# 1 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/llvm_libc_wrappers/stdlib.h" 1 3
# 16 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/llvm_libc_wrappers/stdlib.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/stdlib.h" 1 3
# 91 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/stdlib.h" 3



# 1 "/usr/include/stdlib.h" 1 3 4
# 25 "/usr/include/stdlib.h" 3 4
# 1 "/usr/include/bits/libc-header-start.h" 1 3 4
# 26 "/usr/include/stdlib.h" 2 3 4





# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/stddef.h" 1 3 4
# 15 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/stddef.h" 3


# 1 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/stddef.h" 1 3
# 59 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/stddef.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/__stddef_size_t.h" 1 3
# 15 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/__stddef_size_t.h" 3
typedef long unsigned int size_t;
# 60 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/stddef.h" 2 3
# 69 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/stddef.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/__stddef_wchar_t.h" 1 3
# 70 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/stddef.h" 2 3




# 1 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/__stddef_null.h" 1 3
# 75 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/stddef.h" 2 3
# 18 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/stddef.h" 2 3
# 32 "/usr/include/stdlib.h" 2 3 4

extern "C" {





# 1 "/usr/include/bits/waitflags.h" 1 3 4
# 40 "/usr/include/stdlib.h" 2 3 4
# 1 "/usr/include/bits/waitstatus.h" 1 3 4
# 41 "/usr/include/stdlib.h" 2 3 4
# 55 "/usr/include/stdlib.h" 3 4
# 1 "/usr/include/bits/floatn.h" 1 3 4
# 119 "/usr/include/bits/floatn.h" 3 4
# 1 "/usr/include/bits/floatn-common.h" 1 3 4
# 24 "/usr/include/bits/floatn-common.h" 3 4
# 1 "/usr/include/bits/long-double.h" 1 3 4
# 25 "/usr/include/bits/floatn-common.h" 2 3 4
# 214 "/usr/include/bits/floatn-common.h" 3 4
typedef float _Float32;
# 251 "/usr/include/bits/floatn-common.h" 3 4
typedef double _Float64;
# 268 "/usr/include/bits/floatn-common.h" 3 4
typedef double _Float32x;
# 285 "/usr/include/bits/floatn-common.h" 3 4
typedef long double _Float64x;
# 120 "/usr/include/bits/floatn.h" 2 3 4
# 56 "/usr/include/stdlib.h" 2 3 4


typedef struct
  {
    int quot;
    int rem;
  } div_t;



typedef struct
  {
    long int quot;
    long int rem;
  } ldiv_t;





__extension__ typedef struct
  {
    long long int quot;
    long long int rem;
  } lldiv_t;
# 97 "/usr/include/stdlib.h" 3 4
extern size_t __ctype_get_mb_cur_max (void) throw () ;



extern double atof (const char *__nptr)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;

extern int atoi (const char *__nptr)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;

extern long int atol (const char *__nptr)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;



__extension__ extern long long int atoll (const char *__nptr)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;



extern double strtod (const char *__restrict __nptr,
        char **__restrict __endptr)
     throw () __attribute__ ((__nonnull__ (1)));



extern float strtof (const char *__restrict __nptr,
       char **__restrict __endptr) throw () __attribute__ ((__nonnull__ (1)));

extern long double strtold (const char *__restrict __nptr,
       char **__restrict __endptr)
     throw () __attribute__ ((__nonnull__ (1)));
# 140 "/usr/include/stdlib.h" 3 4
extern _Float32 strtof32 (const char *__restrict __nptr,
     char **__restrict __endptr)
     throw () __attribute__ ((__nonnull__ (1)));



extern _Float64 strtof64 (const char *__restrict __nptr,
     char **__restrict __endptr)
     throw () __attribute__ ((__nonnull__ (1)));
# 158 "/usr/include/stdlib.h" 3 4
extern _Float32x strtof32x (const char *__restrict __nptr,
       char **__restrict __endptr)
     throw () __attribute__ ((__nonnull__ (1)));



extern _Float64x strtof64x (const char *__restrict __nptr,
       char **__restrict __endptr)
     throw () __attribute__ ((__nonnull__ (1)));
# 176 "/usr/include/stdlib.h" 3 4
extern long int strtol (const char *__restrict __nptr,
   char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1)));

extern unsigned long int strtoul (const char *__restrict __nptr,
      char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1)));



__extension__
extern long long int strtoq (const char *__restrict __nptr,
        char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1)));

__extension__
extern unsigned long long int strtouq (const char *__restrict __nptr,
           char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1)));




__extension__
extern long long int strtoll (const char *__restrict __nptr,
         char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1)));

__extension__
extern unsigned long long int strtoull (const char *__restrict __nptr,
     char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1)));




extern int strfromd (char *__dest, size_t __size, const char *__format,
       double __f)
     throw () __attribute__ ((__nonnull__ (3)));

extern int strfromf (char *__dest, size_t __size, const char *__format,
       float __f)
     throw () __attribute__ ((__nonnull__ (3)));

extern int strfroml (char *__dest, size_t __size, const char *__format,
       long double __f)
     throw () __attribute__ ((__nonnull__ (3)));
# 232 "/usr/include/stdlib.h" 3 4
extern int strfromf32 (char *__dest, size_t __size, const char * __format,
         _Float32 __f)
     throw () __attribute__ ((__nonnull__ (3)));



extern int strfromf64 (char *__dest, size_t __size, const char * __format,
         _Float64 __f)
     throw () __attribute__ ((__nonnull__ (3)));
# 250 "/usr/include/stdlib.h" 3 4
extern int strfromf32x (char *__dest, size_t __size, const char * __format,
   _Float32x __f)
     throw () __attribute__ ((__nonnull__ (3)));



extern int strfromf64x (char *__dest, size_t __size, const char * __format,
   _Float64x __f)
     throw () __attribute__ ((__nonnull__ (3)));
# 272 "/usr/include/stdlib.h" 3 4
# 1 "/usr/include/bits/types/locale_t.h" 1 3 4
# 22 "/usr/include/bits/types/locale_t.h" 3 4
# 1 "/usr/include/bits/types/__locale_t.h" 1 3 4
# 28 "/usr/include/bits/types/__locale_t.h" 3 4
struct __locale_struct
{

  struct __locale_data *__locales[13];


  const unsigned short int *__ctype_b;
  const int *__ctype_tolower;
  const int *__ctype_toupper;


  const char *__names[13];
};

typedef struct __locale_struct *__locale_t;
# 23 "/usr/include/bits/types/locale_t.h" 2 3 4

typedef __locale_t locale_t;
# 273 "/usr/include/stdlib.h" 2 3 4

extern long int strtol_l (const char *__restrict __nptr,
     char **__restrict __endptr, int __base,
     locale_t __loc) throw () __attribute__ ((__nonnull__ (1, 4)));

extern unsigned long int strtoul_l (const char *__restrict __nptr,
        char **__restrict __endptr,
        int __base, locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 4)));

__extension__
extern long long int strtoll_l (const char *__restrict __nptr,
    char **__restrict __endptr, int __base,
    locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 4)));

__extension__
extern unsigned long long int strtoull_l (const char *__restrict __nptr,
       char **__restrict __endptr,
       int __base, locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 4)));

extern double strtod_l (const char *__restrict __nptr,
   char **__restrict __endptr, locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 3)));

extern float strtof_l (const char *__restrict __nptr,
         char **__restrict __endptr, locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 3)));

extern long double strtold_l (const char *__restrict __nptr,
         char **__restrict __endptr,
         locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 3)));
# 316 "/usr/include/stdlib.h" 3 4
extern _Float32 strtof32_l (const char *__restrict __nptr,
       char **__restrict __endptr,
       locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 3)));



extern _Float64 strtof64_l (const char *__restrict __nptr,
       char **__restrict __endptr,
       locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 3)));
# 337 "/usr/include/stdlib.h" 3 4
extern _Float32x strtof32x_l (const char *__restrict __nptr,
         char **__restrict __endptr,
         locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 3)));



extern _Float64x strtof64x_l (const char *__restrict __nptr,
         char **__restrict __endptr,
         locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 3)));
# 360 "/usr/include/stdlib.h" 3 4
extern __inline __attribute__ ((__gnu_inline__)) int
 atoi (const char *__nptr) throw ()
{
  return (int) strtol (__nptr, (char **) __null, 10);
}
extern __inline __attribute__ ((__gnu_inline__)) long int
 atol (const char *__nptr) throw ()
{
  return strtol (__nptr, (char **) __null, 10);
}


__extension__ extern __inline __attribute__ ((__gnu_inline__)) long long int
 atoll (const char *__nptr) throw ()
{
  return strtoll (__nptr, (char **) __null, 10);
}
# 385 "/usr/include/stdlib.h" 3 4
extern char *l64a (long int __n) throw () ;


extern long int a64l (const char *__s)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;




# 1 "/usr/include/sys/types.h" 1 3 4
# 27 "/usr/include/sys/types.h" 3 4
extern "C" {

# 1 "/usr/include/bits/types.h" 1 3 4
# 27 "/usr/include/bits/types.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 28 "/usr/include/bits/types.h" 2 3 4


typedef unsigned char __u_char;
typedef unsigned short int __u_short;
typedef unsigned int __u_int;
typedef unsigned long int __u_long;


typedef signed char __int8_t;
typedef unsigned char __uint8_t;
typedef signed short int __int16_t;
typedef unsigned short int __uint16_t;
typedef signed int __int32_t;
typedef unsigned int __uint32_t;

typedef signed long int __int64_t;
typedef unsigned long int __uint64_t;






typedef __int8_t __int_least8_t;
typedef __uint8_t __uint_least8_t;
typedef __int16_t __int_least16_t;
typedef __uint16_t __uint_least16_t;
typedef __int32_t __int_least32_t;
typedef __uint32_t __uint_least32_t;
typedef __int64_t __int_least64_t;
typedef __uint64_t __uint_least64_t;



typedef long int __quad_t;
typedef unsigned long int __u_quad_t;







typedef long int __intmax_t;
typedef unsigned long int __uintmax_t;
# 140 "/usr/include/bits/types.h" 3 4
# 1 "/usr/include/bits/typesizes.h" 1 3 4
# 141 "/usr/include/bits/types.h" 2 3 4


typedef unsigned long int __dev_t;
typedef unsigned int __uid_t;
typedef unsigned int __gid_t;
typedef unsigned long int __ino_t;
typedef unsigned long int __ino64_t;
typedef unsigned int __mode_t;
typedef unsigned long int __nlink_t;
typedef long int __off_t;
typedef long int __off64_t;
typedef int __pid_t;
typedef struct { int __val[2]; } __fsid_t;
typedef long int __clock_t;
typedef unsigned long int __rlim_t;
typedef unsigned long int __rlim64_t;
typedef unsigned int __id_t;
typedef long int __time_t;
typedef unsigned int __useconds_t;
typedef long int __suseconds_t;

typedef int __daddr_t;
typedef int __key_t;


typedef int __clockid_t;


typedef void * __timer_t;


typedef long int __blksize_t;




typedef long int __blkcnt_t;
typedef long int __blkcnt64_t;


typedef unsigned long int __fsblkcnt_t;
typedef unsigned long int __fsblkcnt64_t;


typedef unsigned long int __fsfilcnt_t;
typedef unsigned long int __fsfilcnt64_t;


typedef long int __fsword_t;

typedef long int __ssize_t;


typedef long int __syscall_slong_t;

typedef unsigned long int __syscall_ulong_t;



typedef __off64_t __loff_t;
typedef char *__caddr_t;


typedef long int __intptr_t;


typedef unsigned int __socklen_t;




typedef int __sig_atomic_t;
# 30 "/usr/include/sys/types.h" 2 3 4



typedef __u_char u_char;
typedef __u_short u_short;
typedef __u_int u_int;
typedef __u_long u_long;
typedef __quad_t quad_t;
typedef __u_quad_t u_quad_t;
typedef __fsid_t fsid_t;


typedef __loff_t loff_t;




typedef __ino_t ino_t;






typedef __ino64_t ino64_t;




typedef __dev_t dev_t;




typedef __gid_t gid_t;




typedef __mode_t mode_t;




typedef __nlink_t nlink_t;




typedef __uid_t uid_t;





typedef __off_t off_t;






typedef __off64_t off64_t;




typedef __pid_t pid_t;





typedef __id_t id_t;




typedef __ssize_t ssize_t;





typedef __daddr_t daddr_t;
typedef __caddr_t caddr_t;





typedef __key_t key_t;




# 1 "/usr/include/bits/types/clock_t.h" 1 3 4






typedef __clock_t clock_t;
# 127 "/usr/include/sys/types.h" 2 3 4

# 1 "/usr/include/bits/types/clockid_t.h" 1 3 4






typedef __clockid_t clockid_t;
# 129 "/usr/include/sys/types.h" 2 3 4
# 1 "/usr/include/bits/types/time_t.h" 1 3 4






typedef __time_t time_t;
# 130 "/usr/include/sys/types.h" 2 3 4
# 1 "/usr/include/bits/types/timer_t.h" 1 3 4






typedef __timer_t timer_t;
# 131 "/usr/include/sys/types.h" 2 3 4



typedef __useconds_t useconds_t;



typedef __suseconds_t suseconds_t;





# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/stddef.h" 1 3 4
# 15 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/stddef.h" 3


# 1 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/stddef.h" 1 3
# 59 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/stddef.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/__stddef_size_t.h" 1 3
# 15 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/__stddef_size_t.h" 3
typedef long unsigned int size_t;
# 60 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/stddef.h" 2 3
# 18 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/stddef.h" 2 3
# 145 "/usr/include/sys/types.h" 2 3 4



typedef unsigned long int ulong;
typedef unsigned short int ushort;
typedef unsigned int uint;




# 1 "/usr/include/bits/stdint-intn.h" 1 3 4
# 24 "/usr/include/bits/stdint-intn.h" 3 4
typedef __int8_t int8_t;
typedef __int16_t int16_t;
typedef __int32_t int32_t;
typedef __int64_t int64_t;
# 156 "/usr/include/sys/types.h" 2 3 4


typedef __uint8_t u_int8_t;
typedef __uint16_t u_int16_t;
typedef __uint32_t u_int32_t;
typedef __uint64_t u_int64_t;


typedef int register_t __attribute__ ((__mode__ (__word__)));
# 176 "/usr/include/sys/types.h" 3 4
# 1 "/usr/include/endian.h" 1 3 4
# 36 "/usr/include/endian.h" 3 4
# 1 "/usr/include/bits/endian.h" 1 3 4
# 37 "/usr/include/endian.h" 2 3 4
# 60 "/usr/include/endian.h" 3 4
# 1 "/usr/include/bits/byteswap.h" 1 3 4
# 33 "/usr/include/bits/byteswap.h" 3 4
static __inline __uint16_t
__bswap_16 (__uint16_t __bsx)
{



  return ((__uint16_t) ((((__bsx) >> 8) & 0xff) | (((__bsx) & 0xff) << 8)));

}






static __inline __uint32_t
__bswap_32 (__uint32_t __bsx)
{



  return ((((__bsx) & 0xff000000u) >> 24) | (((__bsx) & 0x00ff0000u) >> 8) | (((__bsx) & 0x0000ff00u) << 8) | (((__bsx) & 0x000000ffu) << 24));

}
# 69 "/usr/include/bits/byteswap.h" 3 4
__extension__ static __inline __uint64_t
__bswap_64 (__uint64_t __bsx)
{



  return ((((__bsx) & 0xff00000000000000ull) >> 56) | (((__bsx) & 0x00ff000000000000ull) >> 40) | (((__bsx) & 0x0000ff0000000000ull) >> 24) | (((__bsx) & 0x000000ff00000000ull) >> 8) | (((__bsx) & 0x00000000ff000000ull) << 8) | (((__bsx) & 0x0000000000ff0000ull) << 24) | (((__bsx) & 0x000000000000ff00ull) << 40) | (((__bsx) & 0x00000000000000ffull) << 56));

}
# 61 "/usr/include/endian.h" 2 3 4
# 1 "/usr/include/bits/uintn-identity.h" 1 3 4
# 32 "/usr/include/bits/uintn-identity.h" 3 4
static __inline __uint16_t
__uint16_identity (__uint16_t __x)
{
  return __x;
}

static __inline __uint32_t
__uint32_identity (__uint32_t __x)
{
  return __x;
}

static __inline __uint64_t
__uint64_identity (__uint64_t __x)
{
  return __x;
}
# 62 "/usr/include/endian.h" 2 3 4
# 177 "/usr/include/sys/types.h" 2 3 4


# 1 "/usr/include/sys/select.h" 1 3 4
# 30 "/usr/include/sys/select.h" 3 4
# 1 "/usr/include/bits/select.h" 1 3 4
# 22 "/usr/include/bits/select.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 23 "/usr/include/bits/select.h" 2 3 4
# 31 "/usr/include/sys/select.h" 2 3 4


# 1 "/usr/include/bits/types/sigset_t.h" 1 3 4



# 1 "/usr/include/bits/types/__sigset_t.h" 1 3 4




typedef struct
{
  unsigned long int __val[(1024 / (8 * sizeof (unsigned long int)))];
} __sigset_t;
# 5 "/usr/include/bits/types/sigset_t.h" 2 3 4


typedef __sigset_t sigset_t;
# 34 "/usr/include/sys/select.h" 2 3 4



# 1 "/usr/include/bits/types/struct_timeval.h" 1 3 4







struct timeval
{
  __time_t tv_sec;
  __suseconds_t tv_usec;
};
# 38 "/usr/include/sys/select.h" 2 3 4

# 1 "/usr/include/bits/types/struct_timespec.h" 1 3 4








struct timespec
{
  __time_t tv_sec;
  __syscall_slong_t tv_nsec;
};
# 40 "/usr/include/sys/select.h" 2 3 4
# 49 "/usr/include/sys/select.h" 3 4
typedef long int __fd_mask;
# 59 "/usr/include/sys/select.h" 3 4
typedef struct
  {



    __fd_mask fds_bits[1024 / (8 * (int) sizeof (__fd_mask))];





  } fd_set;






typedef __fd_mask fd_mask;
# 91 "/usr/include/sys/select.h" 3 4
extern "C" {
# 101 "/usr/include/sys/select.h" 3 4
extern int select (int __nfds, fd_set *__restrict __readfds,
     fd_set *__restrict __writefds,
     fd_set *__restrict __exceptfds,
     struct timeval *__restrict __timeout);
# 113 "/usr/include/sys/select.h" 3 4
extern int pselect (int __nfds, fd_set *__restrict __readfds,
      fd_set *__restrict __writefds,
      fd_set *__restrict __exceptfds,
      const struct timespec *__restrict __timeout,
      const __sigset_t *__restrict __sigmask);
# 126 "/usr/include/sys/select.h" 3 4
}
# 180 "/usr/include/sys/types.h" 2 3 4





typedef __blksize_t blksize_t;






typedef __blkcnt_t blkcnt_t;



typedef __fsblkcnt_t fsblkcnt_t;



typedef __fsfilcnt_t fsfilcnt_t;
# 219 "/usr/include/sys/types.h" 3 4
typedef __blkcnt64_t blkcnt64_t;
typedef __fsblkcnt64_t fsblkcnt64_t;
typedef __fsfilcnt64_t fsfilcnt64_t;





# 1 "/usr/include/bits/pthreadtypes.h" 1 3 4
# 23 "/usr/include/bits/pthreadtypes.h" 3 4
# 1 "/usr/include/bits/thread-shared-types.h" 1 3 4
# 77 "/usr/include/bits/thread-shared-types.h" 3 4
# 1 "/usr/include/bits/pthreadtypes-arch.h" 1 3 4
# 21 "/usr/include/bits/pthreadtypes-arch.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 22 "/usr/include/bits/pthreadtypes-arch.h" 2 3 4
# 65 "/usr/include/bits/pthreadtypes-arch.h" 3 4
struct __pthread_rwlock_arch_t
{
  unsigned int __readers;
  unsigned int __writers;
  unsigned int __wrphase_futex;
  unsigned int __writers_futex;
  unsigned int __pad3;
  unsigned int __pad4;

  int __cur_writer;
  int __shared;
  signed char __rwelision;




  unsigned char __pad1[7];


  unsigned long int __pad2;


  unsigned int __flags;
# 99 "/usr/include/bits/pthreadtypes-arch.h" 3 4
};
# 78 "/usr/include/bits/thread-shared-types.h" 2 3 4




typedef struct __pthread_internal_list
{
  struct __pthread_internal_list *__prev;
  struct __pthread_internal_list *__next;
} __pthread_list_t;
# 118 "/usr/include/bits/thread-shared-types.h" 3 4
struct __pthread_mutex_s
{
  int __lock ;
  unsigned int __count;
  int __owner;

  unsigned int __nusers;
# 148 "/usr/include/bits/thread-shared-types.h" 3 4
  int __kind;





  short __spins; short __elision;
  __pthread_list_t __list;
# 166 "/usr/include/bits/thread-shared-types.h" 3 4
};




struct __pthread_cond_s
{
  __extension__ union
  {
    __extension__ unsigned long long int __wseq;
    struct
    {
      unsigned int __low;
      unsigned int __high;
    } __wseq32;
  };
  __extension__ union
  {
    __extension__ unsigned long long int __g1_start;
    struct
    {
      unsigned int __low;
      unsigned int __high;
    } __g1_start32;
  };
  unsigned int __g_refs[2] ;
  unsigned int __g_size[2];
  unsigned int __g1_orig_size;
  unsigned int __wrefs;
  unsigned int __g_signals[2];
};
# 24 "/usr/include/bits/pthreadtypes.h" 2 3 4



typedef unsigned long int pthread_t;




typedef union
{
  char __size[4];
  int __align;
} pthread_mutexattr_t;




typedef union
{
  char __size[4];
  int __align;
} pthread_condattr_t;



typedef unsigned int pthread_key_t;



typedef int pthread_once_t;


union pthread_attr_t
{
  char __size[56];
  long int __align;
};

typedef union pthread_attr_t pthread_attr_t;




typedef union
{
  struct __pthread_mutex_s __data;
  char __size[40];
  long int __align;
} pthread_mutex_t;


typedef union
{
  struct __pthread_cond_s __data;
  char __size[48];
  __extension__ long long int __align;
} pthread_cond_t;





typedef union
{
  struct __pthread_rwlock_arch_t __data;
  char __size[56];
  long int __align;
} pthread_rwlock_t;

typedef union
{
  char __size[8];
  long int __align;
} pthread_rwlockattr_t;





typedef volatile int pthread_spinlock_t;




typedef union
{
  char __size[32];
  long int __align;
} pthread_barrier_t;

typedef union
{
  char __size[4];
  int __align;
} pthread_barrierattr_t;
# 228 "/usr/include/sys/types.h" 2 3 4


}
# 395 "/usr/include/stdlib.h" 2 3 4






extern long int random (void) throw ();


extern void srandom (unsigned int __seed) throw ();





extern char *initstate (unsigned int __seed, char *__statebuf,
   size_t __statelen) throw () __attribute__ ((__nonnull__ (2)));



extern char *setstate (char *__statebuf) throw () __attribute__ ((__nonnull__ (1)));







struct random_data
  {
    int32_t *fptr;
    int32_t *rptr;
    int32_t *state;
    int rand_type;
    int rand_deg;
    int rand_sep;
    int32_t *end_ptr;
  };

extern int random_r (struct random_data *__restrict __buf,
       int32_t *__restrict __result) throw () __attribute__ ((__nonnull__ (1, 2)));

extern int srandom_r (unsigned int __seed, struct random_data *__buf)
     throw () __attribute__ ((__nonnull__ (2)));

extern int initstate_r (unsigned int __seed, char *__restrict __statebuf,
   size_t __statelen,
   struct random_data *__restrict __buf)
     throw () __attribute__ ((__nonnull__ (2, 4)));

extern int setstate_r (char *__restrict __statebuf,
         struct random_data *__restrict __buf)
     throw () __attribute__ ((__nonnull__ (1, 2)));





extern int rand (void) throw ();

extern void srand (unsigned int __seed) throw ();



extern int rand_r (unsigned int *__seed) throw ();







extern double drand48 (void) throw ();
extern double erand48 (unsigned short int __xsubi[3]) throw () __attribute__ ((__nonnull__ (1)));


extern long int lrand48 (void) throw ();
extern long int nrand48 (unsigned short int __xsubi[3])
     throw () __attribute__ ((__nonnull__ (1)));


extern long int mrand48 (void) throw ();
extern long int jrand48 (unsigned short int __xsubi[3])
     throw () __attribute__ ((__nonnull__ (1)));


extern void srand48 (long int __seedval) throw ();
extern unsigned short int *seed48 (unsigned short int __seed16v[3])
     throw () __attribute__ ((__nonnull__ (1)));
extern void lcong48 (unsigned short int __param[7]) throw () __attribute__ ((__nonnull__ (1)));





struct drand48_data
  {
    unsigned short int __x[3];
    unsigned short int __old_x[3];
    unsigned short int __c;
    unsigned short int __init;
    __extension__ unsigned long long int __a;

  };


extern int drand48_r (struct drand48_data *__restrict __buffer,
        double *__restrict __result) throw () __attribute__ ((__nonnull__ (1, 2)));
extern int erand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        double *__restrict __result) throw () __attribute__ ((__nonnull__ (1, 2)));


extern int lrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern int nrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int mrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern int jrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int srand48_r (long int __seedval, struct drand48_data *__buffer)
     throw () __attribute__ ((__nonnull__ (2)));

extern int seed48_r (unsigned short int __seed16v[3],
       struct drand48_data *__buffer) throw () __attribute__ ((__nonnull__ (1, 2)));

extern int lcong48_r (unsigned short int __param[7],
        struct drand48_data *__buffer)
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern void *malloc (size_t __size) throw () __attribute__ ((__malloc__)) ;

extern void *calloc (size_t __nmemb, size_t __size)
     throw () __attribute__ ((__malloc__)) ;






extern void *realloc (void *__ptr, size_t __size)
     throw () __attribute__ ((__warn_unused_result__));







extern void *reallocarray (void *__ptr, size_t __nmemb, size_t __size)
     throw () __attribute__ ((__warn_unused_result__));



extern void free (void *__ptr) throw ();


# 1 "/usr/include/alloca.h" 1 3 4
# 24 "/usr/include/alloca.h" 3 4
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/stddef.h" 1 3 4
# 15 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/stddef.h" 3


# 1 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/stddef.h" 1 3
# 59 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/stddef.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/__stddef_size_t.h" 1 3
# 15 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/__stddef_size_t.h" 3
typedef long unsigned int size_t;
# 60 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/stddef.h" 2 3
# 18 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/stddef.h" 2 3
# 25 "/usr/include/alloca.h" 2 3 4

extern "C" {





extern void *alloca (size_t __size) throw ();





}
# 567 "/usr/include/stdlib.h" 2 3 4





extern void *valloc (size_t __size) throw () __attribute__ ((__malloc__)) ;




extern int posix_memalign (void **__memptr, size_t __alignment, size_t __size)
     throw () __attribute__ ((__nonnull__ (1))) ;




extern void *aligned_alloc (size_t __alignment, size_t __size)
     throw () __attribute__ ((__malloc__)) ;



extern void abort (void) throw () __attribute__ ((__noreturn__));



extern int atexit (void (*__func) (void)) throw () __attribute__ ((__nonnull__ (1)));




extern "C++" int at_quick_exit (void (*__func) (void))
     throw () __asm ("at_quick_exit") __attribute__ ((__nonnull__ (1)));
# 607 "/usr/include/stdlib.h" 3 4
extern int on_exit (void (*__func) (int __status, void *__arg), void *__arg)
     throw () __attribute__ ((__nonnull__ (1)));





extern void exit (int __status) throw () __attribute__ ((__noreturn__));





extern void quick_exit (int __status) throw () __attribute__ ((__noreturn__));





extern void _Exit (int __status) throw () __attribute__ ((__noreturn__));




extern char *getenv (const char *__name) throw () __attribute__ ((__nonnull__ (1))) ;




extern char *secure_getenv (const char *__name)
     throw () __attribute__ ((__nonnull__ (1))) ;






extern int putenv (char *__string) throw () __attribute__ ((__nonnull__ (1)));





extern int setenv (const char *__name, const char *__value, int __replace)
     throw () __attribute__ ((__nonnull__ (2)));


extern int unsetenv (const char *__name) throw () __attribute__ ((__nonnull__ (1)));






extern int clearenv (void) throw ();
# 672 "/usr/include/stdlib.h" 3 4
extern char *mktemp (char *__template) throw () __attribute__ ((__nonnull__ (1)));
# 685 "/usr/include/stdlib.h" 3 4
extern int mkstemp (char *__template) __attribute__ ((__nonnull__ (1))) ;
# 695 "/usr/include/stdlib.h" 3 4
extern int mkstemp64 (char *__template) __attribute__ ((__nonnull__ (1))) ;
# 707 "/usr/include/stdlib.h" 3 4
extern int mkstemps (char *__template, int __suffixlen) __attribute__ ((__nonnull__ (1))) ;
# 717 "/usr/include/stdlib.h" 3 4
extern int mkstemps64 (char *__template, int __suffixlen)
     __attribute__ ((__nonnull__ (1))) ;
# 728 "/usr/include/stdlib.h" 3 4
extern char *mkdtemp (char *__template) throw () __attribute__ ((__nonnull__ (1))) ;
# 739 "/usr/include/stdlib.h" 3 4
extern int mkostemp (char *__template, int __flags) __attribute__ ((__nonnull__ (1))) ;
# 749 "/usr/include/stdlib.h" 3 4
extern int mkostemp64 (char *__template, int __flags) __attribute__ ((__nonnull__ (1))) ;
# 759 "/usr/include/stdlib.h" 3 4
extern int mkostemps (char *__template, int __suffixlen, int __flags)
     __attribute__ ((__nonnull__ (1))) ;
# 771 "/usr/include/stdlib.h" 3 4
extern int mkostemps64 (char *__template, int __suffixlen, int __flags)
     __attribute__ ((__nonnull__ (1))) ;
# 781 "/usr/include/stdlib.h" 3 4
extern int system (const char *__command) ;





extern char *canonicalize_file_name (const char *__name)
     throw () __attribute__ ((__nonnull__ (1))) ;
# 797 "/usr/include/stdlib.h" 3 4
extern char *realpath (const char *__restrict __name,
         char *__restrict __resolved) throw () ;






typedef int (*__compar_fn_t) (const void *, const void *);


typedef __compar_fn_t comparison_fn_t;



typedef int (*__compar_d_fn_t) (const void *, const void *, void *);




extern void *bsearch (const void *__key, const void *__base,
        size_t __nmemb, size_t __size, __compar_fn_t __compar)
     __attribute__ ((__nonnull__ (1, 2, 5))) ;


# 1 "/usr/include/bits/stdlib-bsearch.h" 1 3 4
# 19 "/usr/include/bits/stdlib-bsearch.h" 3 4
extern __inline __attribute__ ((__gnu_inline__)) void *
bsearch (const void *__key, const void *__base, size_t __nmemb, size_t __size,
  __compar_fn_t __compar)
{
  size_t __l, __u, __idx;
  const void *__p;
  int __comparison;

  __l = 0;
  __u = __nmemb;
  while (__l < __u)
    {
      __idx = (__l + __u) / 2;
      __p = (void *) (((const char *) __base) + (__idx * __size));
      __comparison = (*__compar) (__key, __p);
      if (__comparison < 0)
 __u = __idx;
      else if (__comparison > 0)
 __l = __idx + 1;
      else
 return (void *) __p;
    }

  return __null;
}
# 823 "/usr/include/stdlib.h" 2 3 4




extern void qsort (void *__base, size_t __nmemb, size_t __size,
     __compar_fn_t __compar) __attribute__ ((__nonnull__ (1, 4)));

extern void qsort_r (void *__base, size_t __nmemb, size_t __size,
       __compar_d_fn_t __compar, void *__arg)
  __attribute__ ((__nonnull__ (1, 4)));




extern int abs (int __x) throw () __attribute__ ((__const__)) ;
extern long int labs (long int __x) throw () __attribute__ ((__const__)) ;


__extension__ extern long long int llabs (long long int __x)
     throw () __attribute__ ((__const__)) ;






extern div_t div (int __numer, int __denom)
     throw () __attribute__ ((__const__)) ;
extern ldiv_t ldiv (long int __numer, long int __denom)
     throw () __attribute__ ((__const__)) ;


__extension__ extern lldiv_t lldiv (long long int __numer,
        long long int __denom)
     throw () __attribute__ ((__const__)) ;
# 869 "/usr/include/stdlib.h" 3 4
extern char *ecvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) throw () __attribute__ ((__nonnull__ (3, 4))) ;




extern char *fcvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) throw () __attribute__ ((__nonnull__ (3, 4))) ;




extern char *gcvt (double __value, int __ndigit, char *__buf)
     throw () __attribute__ ((__nonnull__ (3))) ;




extern char *qecvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     throw () __attribute__ ((__nonnull__ (3, 4))) ;
extern char *qfcvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     throw () __attribute__ ((__nonnull__ (3, 4))) ;
extern char *qgcvt (long double __value, int __ndigit, char *__buf)
     throw () __attribute__ ((__nonnull__ (3))) ;




extern int ecvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) throw () __attribute__ ((__nonnull__ (3, 4, 5)));
extern int fcvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) throw () __attribute__ ((__nonnull__ (3, 4, 5)));

extern int qecvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     throw () __attribute__ ((__nonnull__ (3, 4, 5)));
extern int qfcvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     throw () __attribute__ ((__nonnull__ (3, 4, 5)));





extern int mblen (const char *__s, size_t __n) throw ();


extern int mbtowc (wchar_t *__restrict __pwc,
     const char *__restrict __s, size_t __n) throw ();


extern int wctomb (char *__s, wchar_t __wchar) throw ();



extern size_t mbstowcs (wchar_t *__restrict __pwcs,
   const char *__restrict __s, size_t __n) throw ();

extern size_t wcstombs (char *__restrict __s,
   const wchar_t *__restrict __pwcs, size_t __n)
     throw ();







extern int rpmatch (const char *__response) throw () __attribute__ ((__nonnull__ (1))) ;
# 954 "/usr/include/stdlib.h" 3 4
extern int getsubopt (char **__restrict __optionp,
        char *const *__restrict __tokens,
        char **__restrict __valuep)
     throw () __attribute__ ((__nonnull__ (1, 2, 3))) ;







extern int posix_openpt (int __oflag) ;







extern int grantpt (int __fd) throw ();



extern int unlockpt (int __fd) throw ();




extern char *ptsname (int __fd) throw () ;






extern int ptsname_r (int __fd, char *__buf, size_t __buflen)
     throw () __attribute__ ((__nonnull__ (2)));


extern int getpt (void);






extern int getloadavg (double __loadavg[], int __nelem)
     throw () __attribute__ ((__nonnull__ (1)));
# 1010 "/usr/include/stdlib.h" 3 4
# 1 "/usr/include/bits/stdlib-float.h" 1 3 4
# 24 "/usr/include/bits/stdlib-float.h" 3 4
extern __inline __attribute__ ((__gnu_inline__)) double
 atof (const char *__nptr) throw ()
{
  return strtod (__nptr, (char **) __null);
}
# 1011 "/usr/include/stdlib.h" 2 3 4
# 1020 "/usr/include/stdlib.h" 3 4
}
# 95 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/stdlib.h" 2 3



extern "C++" {
# 113 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/stdlib.h" 3
[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) long abs(long __x) noexcept {
  return __builtin_labs(__x);
}
[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) long long abs(long long __x) noexcept {
  return __builtin_llabs(__x);
}


[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) float abs(float __lcpp_x) noexcept {
  return __builtin_fabsf(__lcpp_x);
}

[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) double abs(double __lcpp_x) noexcept {
  return __builtin_fabs(__lcpp_x);
}

[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) long double
abs(long double __lcpp_x) noexcept {
  return __builtin_fabsl(__lcpp_x);
}
# 148 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/stdlib.h" 3
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) ldiv_t div(long __x, long __y) noexcept {
  return ::ldiv(__x, __y);
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) lldiv_t div(long long __x,
                                             long long __y) noexcept {
  return ::lldiv(__x, __y);
}


}
# 17 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/llvm_libc_wrappers/stdlib.h" 2 3
# 88 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/cstdlib" 2 3
# 99 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/cstdlib" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

using ::size_t __attribute__((__using_if_exists__));
using ::div_t __attribute__((__using_if_exists__));
using ::ldiv_t __attribute__((__using_if_exists__));
using ::lldiv_t __attribute__((__using_if_exists__));
using ::atof __attribute__((__using_if_exists__));
using ::atoi __attribute__((__using_if_exists__));
using ::atol __attribute__((__using_if_exists__));
using ::atoll __attribute__((__using_if_exists__));
using ::strtod __attribute__((__using_if_exists__));
using ::strtof __attribute__((__using_if_exists__));
using ::strtold __attribute__((__using_if_exists__));
using ::strtol __attribute__((__using_if_exists__));
using ::strtoll __attribute__((__using_if_exists__));
using ::strtoul __attribute__((__using_if_exists__));
using ::strtoull __attribute__((__using_if_exists__));
using ::rand __attribute__((__using_if_exists__));
using ::srand __attribute__((__using_if_exists__));
using ::calloc __attribute__((__using_if_exists__));
using ::free __attribute__((__using_if_exists__));
using ::malloc __attribute__((__using_if_exists__));
using ::realloc __attribute__((__using_if_exists__));
using ::abort __attribute__((__using_if_exists__));
using ::atexit __attribute__((__using_if_exists__));
using ::exit __attribute__((__using_if_exists__));
using ::_Exit __attribute__((__using_if_exists__));
using ::getenv __attribute__((__using_if_exists__));
using ::system __attribute__((__using_if_exists__));
using ::bsearch __attribute__((__using_if_exists__));
using ::qsort __attribute__((__using_if_exists__));
using ::abs __attribute__((__using_if_exists__));
using ::labs __attribute__((__using_if_exists__));
using ::llabs __attribute__((__using_if_exists__));
using ::div __attribute__((__using_if_exists__));
using ::ldiv __attribute__((__using_if_exists__));
using ::lldiv __attribute__((__using_if_exists__));
using ::mblen __attribute__((__using_if_exists__));

using ::mbtowc __attribute__((__using_if_exists__));
using ::wctomb __attribute__((__using_if_exists__));
using ::mbstowcs __attribute__((__using_if_exists__));
using ::wcstombs __attribute__((__using_if_exists__));


using ::at_quick_exit __attribute__((__using_if_exists__));
using ::quick_exit __attribute__((__using_if_exists__));


using ::aligned_alloc __attribute__((__using_if_exists__));


}}
# 69 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/openmp_wrappers/__clang_openmp_device_functions.h" 2 3
# 78 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/openmp_wrappers/__clang_openmp_device_functions.h" 3
inline void *operator new(long unsigned int size) {
  if (size == 0)
    size = 1;
  return ::malloc(size);
}

inline void *operator new[](long unsigned int size) { return ::operator new(size); }

inline void operator delete(void *ptr)noexcept { ::free(ptr); }

inline void operator delete[](void *ptr) noexcept {
  ::operator delete(ptr);
}



inline void operator delete(void *ptr, long unsigned int size)noexcept {
  ::operator delete(ptr);
}
inline void operator delete[](void *ptr, long unsigned int size) noexcept {
  ::operator delete(ptr);
}
# 2 "<built-in>" 2
# 1 "src/transform_reduce/std_vector.cpp" 2
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/algorithm" 1 3
# 1757 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/algorithm" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/cstddef" 1 3
# 38 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/cstddef" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/enable_if.h" 1 3
# 16 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/enable_if.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <bool, class _Tp = void>
struct enable_if {};
template <class _Tp>
struct enable_if<true, _Tp> {
  typedef _Tp type;
};

template <bool _Bp, class _Tp = void>
using __enable_if_t __attribute__((__nodebug__)) = typename enable_if<_Bp, _Tp>::type;


template <bool _Bp, class _Tp = void>
using enable_if_t = typename enable_if<_Bp, _Tp>::type;


}}
# 39 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/cstddef" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/integral_constant.h" 1 3
# 16 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/integral_constant.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Tp, _Tp __v>
struct integral_constant {
  static constexpr const _Tp value = __v;
  typedef _Tp value_type;
  typedef integral_constant type;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr operator value_type() const noexcept { return value; }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr value_type operator()() const noexcept { return value; }

};

template <class _Tp, _Tp __v>
constexpr const _Tp integral_constant<_Tp, __v>::value;

typedef integral_constant<bool, true> true_type;
typedef integral_constant<bool, false> false_type;

template <bool _Val>
using _BoolConstant __attribute__((__nodebug__)) = integral_constant<bool, _Val>;


template <bool __b>
using bool_constant = integral_constant<bool, __b>;


}}
# 40 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/cstddef" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_integral.h" 1 3
# 14 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_integral.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/remove_cv.h" 1 3
# 13 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/remove_cv.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/remove_const.h" 1 3
# 16 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/remove_const.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {


template <class _Tp>
struct remove_const {
  using type __attribute__((__nodebug__)) = __remove_const(_Tp);
};

template <class _Tp>
using __remove_const_t = __remove_const(_Tp);
# 43 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/remove_const.h" 3
template <class _Tp>
using remove_const_t = __remove_const_t<_Tp>;


}}
# 14 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/remove_cv.h" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/remove_volatile.h" 1 3
# 16 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/remove_volatile.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {


template <class _Tp>
struct remove_volatile {
  using type __attribute__((__nodebug__)) = __remove_volatile(_Tp);
};

template <class _Tp>
using __remove_volatile_t = __remove_volatile(_Tp);
# 43 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/remove_volatile.h" 3
template <class _Tp>
using remove_volatile_t = __remove_volatile_t<_Tp>;


}}
# 15 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/remove_cv.h" 2 3
# 18 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/remove_cv.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {


template <class _Tp>
struct remove_cv {
  using type __attribute__((__nodebug__)) = __remove_cv(_Tp);
};

template <class _Tp>
using __remove_cv_t = __remove_cv(_Tp);
# 41 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/remove_cv.h" 3
template <class _Tp>
using remove_cv_t = __remove_cv_t<_Tp>;


}}
# 15 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_integral.h" 2 3
# 18 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_integral.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {


template <class _Tp> struct __libcpp_is_integral { enum { value = 0 }; };
template <> struct __libcpp_is_integral<bool> { enum { value = 1 }; };
template <> struct __libcpp_is_integral<char> { enum { value = 1 }; };
template <> struct __libcpp_is_integral<signed char> { enum { value = 1 }; };
template <> struct __libcpp_is_integral<unsigned char> { enum { value = 1 }; };

template <> struct __libcpp_is_integral<wchar_t> { enum { value = 1 }; };


template <> struct __libcpp_is_integral<char8_t> { enum { value = 1 }; };

template <> struct __libcpp_is_integral<char16_t> { enum { value = 1 }; };
template <> struct __libcpp_is_integral<char32_t> { enum { value = 1 }; };
template <> struct __libcpp_is_integral<short> { enum { value = 1 }; };
template <> struct __libcpp_is_integral<unsigned short> { enum { value = 1 }; };
template <> struct __libcpp_is_integral<int> { enum { value = 1 }; };
template <> struct __libcpp_is_integral<unsigned int> { enum { value = 1 }; };
template <> struct __libcpp_is_integral<long> { enum { value = 1 }; };
template <> struct __libcpp_is_integral<unsigned long> { enum { value = 1 }; };
template <> struct __libcpp_is_integral<long long> { enum { value = 1 }; };
template <> struct __libcpp_is_integral<unsigned long long> { enum { value = 1 }; };

template <> struct __libcpp_is_integral<__int128_t> { enum { value = 1 }; };
template <> struct __libcpp_is_integral<__uint128_t> { enum { value = 1 }; };





template <class _Tp>
struct is_integral : _BoolConstant<__is_integral(_Tp)> {};


template <class _Tp>
inline constexpr bool is_integral_v = __is_integral(_Tp);
# 72 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_integral.h" 3
}}
# 41 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/cstddef" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/version" 1 3
# 232 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/version" 3
# 42 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/cstddef" 2 3

# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/stddef.h" 1 3
# 43 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/stddef.h" 3



# 1 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/stddef.h" 1 3
# 54 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/stddef.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/__stddef_ptrdiff_t.h" 1 3
# 15 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/__stddef_ptrdiff_t.h" 3
typedef long int ptrdiff_t;
# 55 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/stddef.h" 2 3




# 1 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/__stddef_size_t.h" 1 3
# 15 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/__stddef_size_t.h" 3
typedef long unsigned int size_t;
# 60 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/stddef.h" 2 3
# 69 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/stddef.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/__stddef_wchar_t.h" 1 3
# 70 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/stddef.h" 2 3




# 1 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/__stddef_null.h" 1 3
# 75 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/stddef.h" 2 3




# 1 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/__stddef_nullptr_t.h" 1 3
# 80 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/stddef.h" 2 3
# 89 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/stddef.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/__stddef_max_align_t.h" 1 3
# 19 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/__stddef_max_align_t.h" 3
typedef struct {
  long long __clang_max_align_nonce1
      __attribute__((__aligned__(__alignof__(long long))));
  long double __clang_max_align_nonce2
      __attribute__((__aligned__(__alignof__(long double))));
} max_align_t;
# 90 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/stddef.h" 2 3




# 1 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/__stddef_offsetof.h" 1 3
# 95 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/stddef.h" 2 3
# 47 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/stddef.h" 2 3



    typedef decltype(nullptr) nullptr_t;
# 44 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/cstddef" 2 3
# 55 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/cstddef" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

using ::nullptr_t;
using ::ptrdiff_t __attribute__((__using_if_exists__));
using ::size_t __attribute__((__using_if_exists__));


using ::max_align_t __attribute__((__using_if_exists__));


}}


namespace std
{
enum class byte : unsigned char {};

__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr byte operator| (byte __lhs, byte __rhs) noexcept
{
    return static_cast<byte>(
      static_cast<unsigned char>(
         static_cast<unsigned int>(__lhs) | static_cast<unsigned int>(__rhs)
    ));
}

__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr byte& operator|=(byte& __lhs, byte __rhs) noexcept
{ return __lhs = __lhs | __rhs; }

__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr byte operator& (byte __lhs, byte __rhs) noexcept
{
    return static_cast<byte>(
      static_cast<unsigned char>(
         static_cast<unsigned int>(__lhs) & static_cast<unsigned int>(__rhs)
    ));
}

__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr byte& operator&=(byte& __lhs, byte __rhs) noexcept
{ return __lhs = __lhs & __rhs; }

__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr byte operator^ (byte __lhs, byte __rhs) noexcept
{
    return static_cast<byte>(
      static_cast<unsigned char>(
         static_cast<unsigned int>(__lhs) ^ static_cast<unsigned int>(__rhs)
    ));
}

__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr byte& operator^=(byte& __lhs, byte __rhs) noexcept
{ return __lhs = __lhs ^ __rhs; }

__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr byte operator~ (byte __b) noexcept
{
    return static_cast<byte>(
      static_cast<unsigned char>(
        ~static_cast<unsigned int>(__b)
    ));
}

template <class _Tp>
using _EnableByteOverload = __enable_if_t<is_integral<_Tp>::value, byte>;

template <class _Integer>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr _EnableByteOverload<_Integer> &
  operator<<=(byte& __lhs, _Integer __shift) noexcept
  { return __lhs = __lhs << __shift; }

template <class _Integer>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr _EnableByteOverload<_Integer>
  operator<< (byte __lhs, _Integer __shift) noexcept
  { return static_cast<byte>(static_cast<unsigned char>(static_cast<unsigned int>(__lhs) << __shift)); }

template <class _Integer>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr _EnableByteOverload<_Integer> &
  operator>>=(byte& __lhs, _Integer __shift) noexcept
  { return __lhs = __lhs >> __shift; }

template <class _Integer>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr _EnableByteOverload<_Integer>
  operator>> (byte __lhs, _Integer __shift) noexcept
  { return static_cast<byte>(static_cast<unsigned char>(static_cast<unsigned int>(__lhs) >> __shift)); }

template <class _Integer, class = _EnableByteOverload<_Integer> >
[[__nodiscard__]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr _Integer
  to_integer(byte __b) noexcept { return static_cast<_Integer>(__b); }

}
# 1758 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/algorithm" 2 3


# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/adjacent_find.h" 1 3
# 13 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/adjacent_find.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/comp.h" 1 3
# 14 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/comp.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/predicate_traits.h" 1 3
# 17 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/predicate_traits.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Pred, class _Lhs, class _Rhs>
struct __is_trivial_equality_predicate : false_type {};

}}
# 15 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/comp.h" 2 3
# 18 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/comp.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

struct __equal_to {
  template <class _T1, class _T2>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr bool operator()(const _T1& __x, const _T2& __y) const {
    return __x == __y;
  }
};

template <class _Lhs, class _Rhs>
struct __is_trivial_equality_predicate<__equal_to, _Lhs, _Rhs> : true_type {};



template <class _T1 = void, class _T2 = _T1>
struct __less {};

template <>
struct __less<void, void> {
  template <class _Tp, class _Up>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr bool operator()(const _Tp& __lhs, const _Up& __rhs) const {
    return __lhs < __rhs;
  }
};

}}
# 14 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/adjacent_find.h" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/iterator_operations.h" 1 3
# 12 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/iterator_operations.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/iter_swap.h" 1 3
# 13 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/iter_swap.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__utility/declval.h" 1 3
# 16 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__utility/declval.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {



#pragma GCC diagnostic push
# 22 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__utility/declval.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
# 22 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__utility/declval.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
template <class _Tp>
_Tp&& __declval(int);
template <class _Tp>
_Tp __declval(long);
#pragma GCC diagnostic pop

template <class _Tp>
decltype(std::__declval<_Tp>(0)) declval() noexcept;

}}
# 14 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/iter_swap.h" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__utility/swap.h" 1 3
# 13 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__utility/swap.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_move_assignable.h" 1 3
# 13 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_move_assignable.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/add_lvalue_reference.h" 1 3
# 13 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/add_lvalue_reference.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_referenceable.h" 1 3
# 14 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_referenceable.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_same.h" 1 3
# 17 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_same.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Tp, class _Up>
struct is_same : _BoolConstant<__is_same(_Tp, _Up)> {};


template <class _Tp, class _Up>
inline constexpr bool is_same_v = __is_same(_Tp, _Up);
# 36 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_same.h" 3
template <class _Tp, class _Up>
using _IsSame = _BoolConstant<__is_same(_Tp, _Up)>;

template <class _Tp, class _Up>
using _IsNotSame = _BoolConstant<!__is_same(_Tp, _Up)>;

}}
# 15 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_referenceable.h" 2 3
# 18 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_referenceable.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {


template <class _Tp>
struct __libcpp_is_referenceable : integral_constant<bool, __is_referenceable(_Tp)> {};
# 39 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_referenceable.h" 3
}}
# 14 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/add_lvalue_reference.h" 2 3
# 17 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/add_lvalue_reference.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {



template <class _Tp>
using __add_lvalue_reference_t = __add_lvalue_reference(_Tp);
# 42 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/add_lvalue_reference.h" 3
template <class _Tp>
struct add_lvalue_reference {
  using type __attribute__((__nodebug__)) = __add_lvalue_reference_t<_Tp>;
};


template <class _Tp>
using add_lvalue_reference_t = __add_lvalue_reference_t<_Tp>;


}}
# 14 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_move_assignable.h" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/add_rvalue_reference.h" 1 3
# 17 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/add_rvalue_reference.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {



template <class _Tp>
using __add_rvalue_reference_t = __add_rvalue_reference(_Tp);
# 42 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/add_rvalue_reference.h" 3
template <class _Tp>
struct add_rvalue_reference {
  using type = __add_rvalue_reference_t<_Tp>;
};


template <class _Tp>
using add_rvalue_reference_t = __add_rvalue_reference_t<_Tp>;


}}
# 15 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_move_assignable.h" 2 3
# 19 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_move_assignable.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Tp>
struct is_move_assignable
    : public integral_constant<bool, __is_assignable(__add_lvalue_reference_t<_Tp>, __add_rvalue_reference_t<_Tp>)> {};


template <class _Tp>
inline constexpr bool is_move_assignable_v = is_move_assignable<_Tp>::value;


}}
# 14 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__utility/swap.h" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_move_constructible.h" 1 3
# 18 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_move_constructible.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Tp>
struct is_move_constructible
    : public integral_constant<bool, __is_constructible(_Tp, __add_rvalue_reference_t<_Tp>)> {};


template <class _Tp>
inline constexpr bool is_move_constructible_v = is_move_constructible<_Tp>::value;


}}
# 15 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__utility/swap.h" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_nothrow_move_assignable.h" 1 3
# 19 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_nothrow_move_assignable.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Tp>
struct is_nothrow_move_assignable
    : public integral_constant<bool,
                               __is_nothrow_assignable(__add_lvalue_reference_t<_Tp>, __add_rvalue_reference_t<_Tp>)> {
};


template <class _Tp>
inline constexpr bool is_nothrow_move_assignable_v = is_nothrow_move_assignable<_Tp>::value;


}}
# 16 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__utility/swap.h" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_nothrow_move_constructible.h" 1 3
# 15 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_nothrow_move_constructible.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_nothrow_constructible.h" 1 3
# 14 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_nothrow_constructible.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_constructible.h" 1 3
# 17 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_constructible.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Tp, class... _Args>
struct is_constructible : public integral_constant<bool, __is_constructible(_Tp, _Args...)> {};


template <class _Tp, class... _Args>
inline constexpr bool is_constructible_v = __is_constructible(_Tp, _Args...);


}}
# 15 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_nothrow_constructible.h" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_reference.h" 1 3
# 17 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_reference.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {



template <class _Tp>
struct is_lvalue_reference : _BoolConstant<__is_lvalue_reference(_Tp)> {};

template <class _Tp>
struct is_rvalue_reference : _BoolConstant<__is_rvalue_reference(_Tp)> {};

template <class _Tp>
struct is_reference : _BoolConstant<__is_reference(_Tp)> {};


template <class _Tp>
inline constexpr bool is_reference_v = __is_reference(_Tp);
template <class _Tp>
inline constexpr bool is_lvalue_reference_v = __is_lvalue_reference(_Tp);
template <class _Tp>
inline constexpr bool is_rvalue_reference_v = __is_rvalue_reference(_Tp);
# 73 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_reference.h" 3
}}
# 16 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_nothrow_constructible.h" 2 3
# 21 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_nothrow_constructible.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {




template < class _Tp, class... _Args>
struct is_nothrow_constructible
    : public integral_constant<bool, __is_nothrow_constructible(_Tp, _Args...)> {};
# 65 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_nothrow_constructible.h" 3
template <class _Tp, class... _Args>
inline constexpr bool is_nothrow_constructible_v = is_nothrow_constructible<_Tp, _Args...>::value;


}}
# 16 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_nothrow_move_constructible.h" 2 3
# 19 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_nothrow_move_constructible.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {




template <class _Tp>
struct is_nothrow_move_constructible
    : public integral_constant<bool, __is_nothrow_constructible(_Tp, __add_rvalue_reference_t<_Tp>)> {};
# 39 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_nothrow_move_constructible.h" 3
template <class _Tp>
inline constexpr bool is_nothrow_move_constructible_v = is_nothrow_move_constructible<_Tp>::value;


}}
# 17 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__utility/swap.h" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_swappable.h" 1 3
# 14 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_swappable.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/conditional.h" 1 3
# 16 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/conditional.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <bool>
struct _IfImpl;

template <>
struct _IfImpl<true> {
  template <class _IfRes, class _ElseRes>
  using _Select __attribute__((__nodebug__)) = _IfRes;
};

template <>
struct _IfImpl<false> {
  template <class _IfRes, class _ElseRes>
  using _Select __attribute__((__nodebug__)) = _ElseRes;
};

template <bool _Cond, class _IfRes, class _ElseRes>
using _If __attribute__((__nodebug__)) = typename _IfImpl<_Cond>::template _Select<_IfRes, _ElseRes>;

template <bool _Bp, class _If, class _Then>
struct conditional {
  using type __attribute__((__nodebug__)) = _If;
};
template <class _If, class _Then>
struct conditional<false, _If, _Then> {
  using type __attribute__((__nodebug__)) = _Then;
};


template <bool _Bp, class _IfRes, class _ElseRes>
using conditional_t __attribute__((__nodebug__)) = typename conditional<_Bp, _IfRes, _ElseRes>::type;



template <bool _Bp, class _If, class _Then>
using __conditional_t __attribute__((__nodebug__)) = typename conditional<_Bp, _If, _Then>::type;

}}
# 15 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_swappable.h" 2 3







# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_void.h" 1 3
# 19 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_void.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {



template <class _Tp>
struct is_void : _BoolConstant<__is_void(_Tp)> {};


template <class _Tp>
inline constexpr bool is_void_v = __is_void(_Tp);
# 45 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_void.h" 3
}}
# 23 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_swappable.h" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/nat.h" 1 3
# 16 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/nat.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

struct __nat {

  __nat() = delete;
  __nat(const __nat&) = delete;
  __nat& operator=(const __nat&) = delete;
  ~__nat() = delete;

};

}}
# 24 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_swappable.h" 2 3
# 29 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_swappable.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Tp>
struct __is_swappable;
template <class _Tp>
struct __is_nothrow_swappable;


template <class _Tp>
using __swap_result_t = __enable_if_t<is_move_constructible<_Tp>::value && is_move_assignable<_Tp>::value>;





template <class _Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr __swap_result_t<_Tp> swap(_Tp& __x, _Tp& __y)
    noexcept(is_nothrow_move_constructible<_Tp>::value&& is_nothrow_move_assignable<_Tp>::value);

template <class _Tp, size_t _Np, __enable_if_t<__is_swappable<_Tp>::value, int> = 0>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr void swap(_Tp (&__a)[_Np], _Tp (&__b)[_Np])
    noexcept(__is_nothrow_swappable<_Tp>::value);

namespace __detail {


template <class _Tp, class _Up = _Tp, bool _NotVoid = !is_void<_Tp>::value && !is_void<_Up>::value>
struct __swappable_with {
  template <class _LHS, class _RHS>
  static decltype(swap(std::declval<_LHS>(), std::declval<_RHS>())) __test_swap(int);
  template <class, class>
  static __nat __test_swap(long);


  typedef decltype((__test_swap<_Tp, _Up>(0))) __swap1;
  typedef decltype((__test_swap<_Up, _Tp>(0))) __swap2;

  static const bool value = _IsNotSame<__swap1, __nat>::value && _IsNotSame<__swap2, __nat>::value;
};

template <class _Tp, class _Up>
struct __swappable_with<_Tp, _Up, false> : false_type {};

template <class _Tp, class _Up = _Tp, bool _Swappable = __swappable_with<_Tp, _Up>::value>
struct __nothrow_swappable_with {
  static const bool value =

      noexcept(swap(std::declval<_Tp>(), std::declval<_Up>()))&& noexcept(
          swap(std::declval<_Up>(), std::declval<_Tp>()));



};

template <class _Tp, class _Up>
struct __nothrow_swappable_with<_Tp, _Up, false> : false_type {};

}

template <class _Tp>
struct __is_swappable : public integral_constant<bool, __detail::__swappable_with<_Tp&>::value> {};

template <class _Tp>
struct __is_nothrow_swappable : public integral_constant<bool, __detail::__nothrow_swappable_with<_Tp&>::value> {};



template <class _Tp, class _Up>
struct is_swappable_with
    : public integral_constant<bool, __detail::__swappable_with<_Tp, _Up>::value> {};

template <class _Tp>
struct is_swappable
    : public __conditional_t<__libcpp_is_referenceable<_Tp>::value,
                             is_swappable_with<__add_lvalue_reference_t<_Tp>, __add_lvalue_reference_t<_Tp> >,
                             false_type> {};

template <class _Tp, class _Up>
struct is_nothrow_swappable_with
    : public integral_constant<bool, __detail::__nothrow_swappable_with<_Tp, _Up>::value> {};

template <class _Tp>
struct is_nothrow_swappable
    : public __conditional_t<__libcpp_is_referenceable<_Tp>::value,
                             is_nothrow_swappable_with<__add_lvalue_reference_t<_Tp>, __add_lvalue_reference_t<_Tp> >,
                             false_type> {};

template <class _Tp, class _Up>
inline constexpr bool is_swappable_with_v = is_swappable_with<_Tp, _Up>::value;

template <class _Tp>
inline constexpr bool is_swappable_v = is_swappable<_Tp>::value;

template <class _Tp, class _Up>
inline constexpr bool is_nothrow_swappable_with_v = is_nothrow_swappable_with<_Tp, _Up>::value;

template <class _Tp>
inline constexpr bool is_nothrow_swappable_v = is_nothrow_swappable<_Tp>::value;



}}
# 18 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__utility/swap.h" 2 3

# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__utility/move.h" 1 3
# 15 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__utility/move.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_copy_constructible.h" 1 3
# 13 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_copy_constructible.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/add_const.h" 1 3
# 16 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/add_const.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Tp>
struct add_const {
  typedef __attribute__((__nodebug__)) const _Tp type;
};


template <class _Tp>
using add_const_t = typename add_const<_Tp>::type;


}}
# 14 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_copy_constructible.h" 2 3
# 19 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_copy_constructible.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Tp>
struct is_copy_constructible
    : public integral_constant<bool, __is_constructible(_Tp, __add_lvalue_reference_t<typename add_const<_Tp>::type>)> {
};


template <class _Tp>
inline constexpr bool is_copy_constructible_v = is_copy_constructible<_Tp>::value;


}}
# 16 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__utility/move.h" 2 3

# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/remove_reference.h" 1 3
# 17 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/remove_reference.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {


template <class _Tp>
struct remove_reference {
  using type __attribute__((__nodebug__)) = __remove_reference_t(_Tp);
};

template <class _Tp>
using __libcpp_remove_reference_t = __remove_reference_t(_Tp);
# 41 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/remove_reference.h" 3
template <class _Tp>
using remove_reference_t = __libcpp_remove_reference_t<_Tp>;


}}
# 18 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__utility/move.h" 2 3
# 21 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__utility/move.h" 3



# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__undef_macros" 1 3
# 25 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__utility/move.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Tp>
[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr __libcpp_remove_reference_t<_Tp>&&
move([[_Clang::__lifetimebound__]] _Tp&& __t) noexcept {
  typedef __attribute__((__nodebug__)) __libcpp_remove_reference_t<_Tp> _Up;
  return static_cast<_Up&&>(__t);
}

template <class _Tp>
using __move_if_noexcept_result_t =
    __conditional_t<!is_nothrow_move_constructible<_Tp>::value && is_copy_constructible<_Tp>::value, const _Tp&, _Tp&&>;

template <class _Tp>
[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr __move_if_noexcept_result_t<_Tp>
move_if_noexcept([[_Clang::__lifetimebound__]] _Tp& __x) noexcept {
  return std::move(__x);
}

}}
# 20 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__utility/swap.h" 2 3
# 24 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__utility/swap.h" 3



# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__undef_macros" 1 3
# 28 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__utility/swap.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {


template <class _Tp>
using __swap_result_t = __enable_if_t<is_move_constructible<_Tp>::value && is_move_assignable<_Tp>::value>;





template <class _Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) __swap_result_t<_Tp> constexpr swap(_Tp& __x, _Tp& __y)
    noexcept(is_nothrow_move_constructible<_Tp>::value&& is_nothrow_move_assignable<_Tp>::value) {
  _Tp __t(std::move(__x));
  __x = std::move(__y);
  __y = std::move(__t);
}

template <class _Tp, size_t _Np, __enable_if_t<__is_swappable<_Tp>::value, int> >
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr void swap(_Tp (&__a)[_Np], _Tp (&__b)[_Np])
    noexcept(__is_nothrow_swappable<_Tp>::value) {
  for (size_t __i = 0; __i != _Np; ++__i) {
    swap(__a[__i], __b[__i]);
  }
}

}}
# 15 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/iter_swap.h" 2 3
# 18 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/iter_swap.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _ForwardIterator1, class _ForwardIterator2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr void iter_swap(_ForwardIterator1 __a,
                                                                              _ForwardIterator2 __b)

    noexcept(noexcept(swap(*std::declval<_ForwardIterator1>(), *std::declval<_ForwardIterator2>()))) {
  swap(*__a, *__b);
}

}}
# 13 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/iterator_operations.h" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_iterator_concept.h" 1 3
# 13 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_iterator_concept.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__iterator/concepts.h" 1 3
# 13 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__iterator/concepts.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__concepts/arithmetic.h" 1 3
# 13 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__concepts/arithmetic.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_floating_point.h" 1 3
# 18 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_floating_point.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {


template <class _Tp> struct __libcpp_is_floating_point : public false_type {};
template <> struct __libcpp_is_floating_point<float> : public true_type {};
template <> struct __libcpp_is_floating_point<double> : public true_type {};
template <> struct __libcpp_is_floating_point<long double> : public true_type {};


template <class _Tp>
struct is_floating_point : public __libcpp_is_floating_point<__remove_cv_t<_Tp> > {};


template <class _Tp>
inline constexpr bool is_floating_point_v = is_floating_point<_Tp>::value;


}}
# 14 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__concepts/arithmetic.h" 2 3

# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_signed.h" 1 3
# 14 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_signed.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_arithmetic.h" 1 3
# 19 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_arithmetic.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Tp>
struct is_arithmetic
    : public integral_constant<bool, is_integral<_Tp>::value || is_floating_point<_Tp>::value> {};


template <class _Tp>
inline constexpr bool is_arithmetic_v = is_arithmetic<_Tp>::value;


}}
# 15 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_signed.h" 2 3
# 19 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_signed.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {



template <class _Tp>
struct is_signed : _BoolConstant<__is_signed(_Tp)> {};


template <class _Tp>
inline constexpr bool is_signed_v = __is_signed(_Tp);
# 57 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_signed.h" 3
}}
# 16 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__concepts/arithmetic.h" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_signed_integer.h" 1 3
# 17 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_signed_integer.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {


template <class _Tp> struct __libcpp_is_signed_integer : public false_type {};
template <> struct __libcpp_is_signed_integer<signed char> : public true_type {};
template <> struct __libcpp_is_signed_integer<signed short> : public true_type {};
template <> struct __libcpp_is_signed_integer<signed int> : public true_type {};
template <> struct __libcpp_is_signed_integer<signed long> : public true_type {};
template <> struct __libcpp_is_signed_integer<signed long long> : public true_type {};

template <> struct __libcpp_is_signed_integer<__int128_t> : public true_type {};



}}
# 17 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__concepts/arithmetic.h" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_unsigned_integer.h" 1 3
# 17 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_unsigned_integer.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {


template <class _Tp> struct __libcpp_is_unsigned_integer : public false_type {};
template <> struct __libcpp_is_unsigned_integer<unsigned char> : public true_type {};
template <> struct __libcpp_is_unsigned_integer<unsigned short> : public true_type {};
template <> struct __libcpp_is_unsigned_integer<unsigned int> : public true_type {};
template <> struct __libcpp_is_unsigned_integer<unsigned long> : public true_type {};
template <> struct __libcpp_is_unsigned_integer<unsigned long long> : public true_type {};

template <> struct __libcpp_is_unsigned_integer<__uint128_t> : public true_type {};



}}
# 18 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__concepts/arithmetic.h" 2 3
# 21 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__concepts/arithmetic.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {





template <class _Tp>
concept integral = is_integral_v<_Tp>;

template <class _Tp>
concept signed_integral = integral<_Tp> && is_signed_v<_Tp>;

template <class _Tp>
concept unsigned_integral = integral<_Tp> && !signed_integral<_Tp>;

template <class _Tp>
concept floating_point = is_floating_point_v<_Tp>;



template <class _Tp>
concept __libcpp_unsigned_integer = __libcpp_is_unsigned_integer<_Tp>::value;
template <class _Tp>
concept __libcpp_signed_integer = __libcpp_is_signed_integer<_Tp>::value;



}}
# 14 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__iterator/concepts.h" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__concepts/assignable.h" 1 3
# 12 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__concepts/assignable.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__concepts/common_reference_with.h" 1 3
# 12 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__concepts/common_reference_with.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__concepts/convertible_to.h" 1 3
# 13 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__concepts/convertible_to.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_convertible.h" 1 3
# 14 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_convertible.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_array.h" 1 3
# 18 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_array.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 36 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_array.h" 3
template <class _Tp>
struct is_array : public false_type {};
template <class _Tp>
struct is_array<_Tp[]> : public true_type {};
template <class _Tp, size_t _Np>
struct is_array<_Tp[_Np]> : public true_type {};


template <class _Tp>
inline constexpr bool is_array_v = is_array<_Tp>::value;




}}
# 15 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_convertible.h" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_function.h" 1 3
# 14 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_function.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_const.h" 1 3
# 17 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_const.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {



template <class _Tp>
struct is_const : _BoolConstant<__is_const(_Tp)> {};


template <class _Tp>
inline constexpr bool is_const_v = __is_const(_Tp);
# 45 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_const.h" 3
}}
# 15 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_function.h" 2 3
# 19 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_function.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {



template <class _Tp>
struct is_function : integral_constant<bool, __is_function(_Tp)> {};
# 37 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_function.h" 3
template <class _Tp>
inline constexpr bool is_function_v = is_function<_Tp>::value;


}}
# 16 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_convertible.h" 2 3
# 23 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_convertible.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _T1, class _T2>
struct is_convertible : public integral_constant<bool, __is_convertible(_T1, _T2)> {};


template <class _From, class _To>
inline constexpr bool is_convertible_v = __is_convertible(_From, _To);


}}
# 14 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__concepts/convertible_to.h" 2 3
# 18 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__concepts/convertible_to.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {





template <class _From, class _To>
concept convertible_to = is_convertible_v<_From, _To> && requires { static_cast<_To>(std::declval<_From>()); };



}}
# 13 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__concepts/common_reference_with.h" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__concepts/same_as.h" 1 3
# 17 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__concepts/same_as.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {





template <class _Tp, class _Up>
concept __same_as_impl = _IsSame<_Tp, _Up>::value;

template <class _Tp, class _Up>
concept same_as = __same_as_impl<_Tp, _Up> && __same_as_impl<_Up, _Tp>;



}}
# 14 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__concepts/common_reference_with.h" 2 3

# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/common_reference.h" 1 3
# 13 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/common_reference.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/common_type.h" 1 3
# 14 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/common_type.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/decay.h" 1 3
# 13 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/decay.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/add_pointer.h" 1 3
# 21 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/add_pointer.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {



template <class _Tp>
using __add_pointer_t = __add_pointer(_Tp);
# 45 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/add_pointer.h" 3
template <class _Tp>
struct add_pointer {
  using type __attribute__((__nodebug__)) = __add_pointer_t<_Tp>;
};


template <class _Tp>
using add_pointer_t = __add_pointer_t<_Tp>;


}}
# 14 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/decay.h" 2 3





# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/remove_extent.h" 1 3
# 17 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/remove_extent.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {


template <class _Tp>
struct remove_extent {
  using type __attribute__((__nodebug__)) = __remove_extent(_Tp);
};

template <class _Tp>
using __remove_extent_t = __remove_extent(_Tp);
# 48 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/remove_extent.h" 3
template <class _Tp>
using remove_extent_t = __remove_extent_t<_Tp>;


}}
# 20 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/decay.h" 2 3
# 24 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/decay.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {


template <class _Tp>
using __decay_t __attribute__((__nodebug__)) = __decay(_Tp);

template <class _Tp>
struct decay {
  using type __attribute__((__nodebug__)) = __decay_t<_Tp>;
};
# 67 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/decay.h" 3
template <class _Tp>
using decay_t = __decay_t<_Tp>;


}}
# 15 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/common_type.h" 2 3

# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/remove_cvref.h" 1 3
# 19 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/remove_cvref.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {


template <class _Tp>
using __remove_cvref_t __attribute__((__nodebug__)) = __remove_cvref(_Tp);





template <class _Tp, class _Up>
struct __is_same_uncvref : _IsSame<__remove_cvref_t<_Tp>, __remove_cvref_t<_Up> > {};


template <class _Tp>
struct remove_cvref {
  using type __attribute__((__nodebug__)) = __remove_cvref_t<_Tp>;
};

template <class _Tp>
using remove_cvref_t = __remove_cvref_t<_Tp>;


}}
# 17 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/common_type.h" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/void_t.h" 1 3
# 16 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/void_t.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {


template <class...>
using void_t = void;


template <class...>
using __void_t = void;

}}
# 18 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/common_type.h" 2 3
# 22 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/common_type.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {



template <class _Tp, class _Up>
using __cond_type = decltype(false ? std::declval<_Tp>() : std::declval<_Up>());

template <class _Tp, class _Up, class = void>
struct __common_type3 {};


template <class _Tp, class _Up>
struct __common_type3<_Tp, _Up, void_t<__cond_type<const _Tp&, const _Up&>>> {
  using type = remove_cvref_t<__cond_type<const _Tp&, const _Up&>>;
};

template <class _Tp, class _Up, class = void>
struct __common_type2_imp : __common_type3<_Tp, _Up> {};






template <class _Tp, class _Up>
struct __common_type2_imp<_Tp, _Up, __void_t<decltype(true ? std::declval<_Tp>() : std::declval<_Up>())> > {
  typedef __attribute__((__nodebug__)) __decay_t<decltype(true ? std::declval<_Tp>() : std::declval<_Up>())> type;
};

template <class, class = void>
struct __common_type_impl {};

template <class... _Tp>
struct __common_types;
template <class... _Tp>
struct common_type;

template <class _Tp, class _Up>
struct __common_type_impl< __common_types<_Tp, _Up>, __void_t<typename common_type<_Tp, _Up>::type> > {
  typedef typename common_type<_Tp, _Up>::type type;
};

template <class _Tp, class _Up, class _Vp, class... _Rest>
struct __common_type_impl<__common_types<_Tp, _Up, _Vp, _Rest...>, __void_t<typename common_type<_Tp, _Up>::type> >
    : __common_type_impl<__common_types<typename common_type<_Tp, _Up>::type, _Vp, _Rest...> > {};



template <>
struct common_type<> {};



template <class _Tp>
struct common_type<_Tp> : public common_type<_Tp, _Tp> {};




template <class _Tp, class _Up>
struct common_type<_Tp, _Up>
    : conditional<_IsSame<_Tp, __decay_t<_Tp> >::value && _IsSame<_Up, __decay_t<_Up> >::value,
                  __common_type2_imp<_Tp, _Up>,
                  common_type<__decay_t<_Tp>, __decay_t<_Up> > >::type {};



template <class _Tp, class _Up, class _Vp, class... _Rest>
struct common_type<_Tp, _Up, _Vp, _Rest...>
    : __common_type_impl<__common_types<_Tp, _Up, _Vp, _Rest...> > {};


template <class... _Tp>
using common_type_t = typename common_type<_Tp...>::type;


}}
# 14 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/common_reference.h" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/copy_cv.h" 1 3
# 14 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/copy_cv.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/add_cv.h" 1 3
# 16 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/add_cv.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Tp>
struct add_cv {
  typedef __attribute__((__nodebug__)) const volatile _Tp type;
};


template <class _Tp>
using add_cv_t = typename add_cv<_Tp>::type;


}}
# 15 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/copy_cv.h" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/add_volatile.h" 1 3
# 16 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/add_volatile.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Tp>
struct add_volatile {
  typedef __attribute__((__nodebug__)) volatile _Tp type;
};


template <class _Tp>
using add_volatile_t = typename add_volatile<_Tp>::type;


}}
# 16 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/copy_cv.h" 2 3
# 19 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/copy_cv.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {



template <class _From, class _To>
struct __copy_cv {
  using type = _To;
};

template <class _From, class _To>
struct __copy_cv<const _From, _To> {
  using type = typename add_const<_To>::type;
};

template <class _From, class _To>
struct __copy_cv<volatile _From, _To> {
  using type = typename add_volatile<_To>::type;
};

template <class _From, class _To>
struct __copy_cv<const volatile _From, _To> {
  using type = typename add_cv<_To>::type;
};

template <class _From, class _To>
using __copy_cv_t = typename __copy_cv<_From, _To>::type;

}}
# 15 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/common_reference.h" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/copy_cvref.h" 1 3
# 19 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/copy_cvref.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _From, class _To>
struct __copy_cvref {
  using type = __copy_cv_t<_From, _To>;
};

template <class _From, class _To>
struct __copy_cvref<_From&, _To> {
  using type = __add_lvalue_reference_t<__copy_cv_t<_From, _To> >;
};

template <class _From, class _To>
struct __copy_cvref<_From&&, _To> {
  using type = __add_rvalue_reference_t<__copy_cv_t<_From, _To> >;
};

template <class _From, class _To>
using __copy_cvref_t = typename __copy_cvref<_From, _To>::type;

}}
# 16 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/common_reference.h" 2 3
# 25 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/common_reference.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {




template <class _Xp, class _Yp>
using __cond_res = decltype(false ? std::declval<_Xp (&)()>()() : std::declval<_Yp (&)()>()());





template <class _Tp>
struct __xref {
  template <class _Up>
  using __apply = __copy_cvref_t<_Tp, _Up>;
};



template <class _Ap, class _Bp, class _Xp = remove_reference_t<_Ap>, class _Yp = remove_reference_t<_Bp>>
struct __common_ref;

template <class _Xp, class _Yp>
using __common_ref_t = typename __common_ref<_Xp, _Yp>::__type;

template <class _Xp, class _Yp>
using __cv_cond_res = __cond_res<__copy_cv_t<_Xp, _Yp>&, __copy_cv_t<_Yp, _Xp>&>;




template <class _Ap, class _Bp, class _Xp, class _Yp>
  requires
    requires { typename __cv_cond_res<_Xp, _Yp>; } &&
    is_reference_v<__cv_cond_res<_Xp, _Yp>>
struct __common_ref<_Ap&, _Bp&, _Xp, _Yp> {
  using __type = __cv_cond_res<_Xp, _Yp>;
};



template <class _Xp, class _Yp>
using __common_ref_C = remove_reference_t<__common_ref_t<_Xp&, _Yp&>>&&;




template <class _Ap, class _Bp, class _Xp, class _Yp>
  requires
    requires { typename __common_ref_C<_Xp, _Yp>; } &&
    is_convertible_v<_Ap&&, __common_ref_C<_Xp, _Yp>> &&
    is_convertible_v<_Bp&&, __common_ref_C<_Xp, _Yp>>
struct __common_ref<_Ap&&, _Bp&&, _Xp, _Yp> {
  using __type = __common_ref_C<_Xp, _Yp>;
};



template <class _Tp, class _Up>
using __common_ref_D = __common_ref_t<const _Tp&, _Up&>;




template <class _Ap, class _Bp, class _Xp, class _Yp>
  requires
    requires { typename __common_ref_D<_Xp, _Yp>; } &&
    is_convertible_v<_Ap&&, __common_ref_D<_Xp, _Yp>>
struct __common_ref<_Ap&&, _Bp&, _Xp, _Yp> {
  using __type = __common_ref_D<_Xp, _Yp>;
};




template <class _Ap, class _Bp, class _Xp, class _Yp>
struct __common_ref<_Ap&, _Bp&&, _Xp, _Yp> : __common_ref<_Bp&&, _Ap&> {};


template <class _Ap, class _Bp, class _Xp, class _Yp>
struct __common_ref {};



template <class...>
struct common_reference;

template <class... _Types>
using common_reference_t = typename common_reference<_Types...>::type;


template <>
struct common_reference<> {};


template <class _Tp>
struct common_reference<_Tp> {
  using type = _Tp;
};


template <class _Tp, class _Up>
struct __common_reference_sub_bullet3;
template <class _Tp, class _Up>
struct __common_reference_sub_bullet2 : __common_reference_sub_bullet3<_Tp, _Up> {};
template <class _Tp, class _Up>
struct __common_reference_sub_bullet1 : __common_reference_sub_bullet2<_Tp, _Up> {};



template <class _Tp, class _Up>
struct common_reference<_Tp, _Up> : __common_reference_sub_bullet1<_Tp, _Up> {};

template <class _Tp, class _Up>
  requires is_reference_v<_Tp> && is_reference_v<_Up> && requires { typename __common_ref_t<_Tp, _Up>; }
struct __common_reference_sub_bullet1<_Tp, _Up> {
  using type = __common_ref_t<_Tp, _Up>;
};



template <class, class, template <class> class, template <class> class>
struct basic_common_reference {};

template <class _Tp, class _Up>
using __basic_common_reference_t =
    typename basic_common_reference<remove_cvref_t<_Tp>,
                                    remove_cvref_t<_Up>,
                                    __xref<_Tp>::template __apply,
                                    __xref<_Up>::template __apply>::type;

template <class _Tp, class _Up>
  requires requires { typename __basic_common_reference_t<_Tp, _Up>; }
struct __common_reference_sub_bullet2<_Tp, _Up> {
  using type = __basic_common_reference_t<_Tp, _Up>;
};



template <class _Tp, class _Up>
  requires requires { typename __cond_res<_Tp, _Up>; }
struct __common_reference_sub_bullet3<_Tp, _Up> {
  using type = __cond_res<_Tp, _Up>;
};




template <class _Tp, class _Up>
struct __common_reference_sub_bullet3 : common_type<_Tp, _Up> {};



template <class _Tp, class _Up, class _Vp, class... _Rest>
  requires requires { typename common_reference_t<_Tp, _Up>; }
struct common_reference<_Tp, _Up, _Vp, _Rest...> : common_reference<common_reference_t<_Tp, _Up>, _Vp, _Rest...> {};


template <class...>
struct common_reference {};



}}
# 16 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__concepts/common_reference_with.h" 2 3
# 19 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__concepts/common_reference_with.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {





template <class _Tp, class _Up>
concept common_reference_with =
    same_as<common_reference_t<_Tp, _Up>, common_reference_t<_Up, _Tp>> &&
    convertible_to<_Tp, common_reference_t<_Tp, _Up>> && convertible_to<_Up, common_reference_t<_Tp, _Up>>;



}}
# 13 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__concepts/assignable.h" 2 3



# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/make_const_lvalue_ref.h" 1 3
# 17 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/make_const_lvalue_ref.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Tp>
using __make_const_lvalue_ref = const __libcpp_remove_reference_t<_Tp>&;

}}
# 17 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__concepts/assignable.h" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__utility/forward.h" 1 3
# 19 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__utility/forward.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Tp>
[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr _Tp&&
forward([[_Clang::__lifetimebound__]] __libcpp_remove_reference_t<_Tp>& __t) noexcept {
  return static_cast<_Tp&&>(__t);
}

template <class _Tp>
[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr _Tp&&
forward([[_Clang::__lifetimebound__]] __libcpp_remove_reference_t<_Tp>&& __t) noexcept {
  static_assert(!is_lvalue_reference<_Tp>::value, "cannot forward an rvalue as an lvalue");
  return static_cast<_Tp&&>(__t);
}

}}
# 18 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__concepts/assignable.h" 2 3
# 21 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__concepts/assignable.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {





template <class _Lhs, class _Rhs>
concept assignable_from =
    is_lvalue_reference_v<_Lhs> &&
    common_reference_with<__make_const_lvalue_ref<_Lhs>, __make_const_lvalue_ref<_Rhs>> &&
    requires(_Lhs __lhs, _Rhs&& __rhs) {
      { __lhs = std::forward<_Rhs>(__rhs) } -> same_as<_Lhs>;
    };



}}
# 15 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__iterator/concepts.h" 2 3

# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__concepts/constructible.h" 1 3
# 13 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__concepts/constructible.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__concepts/destructible.h" 1 3
# 13 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__concepts/destructible.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_nothrow_destructible.h" 1 3
# 14 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_nothrow_destructible.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_destructible.h" 1 3
# 16 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_destructible.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/remove_all_extents.h" 1 3
# 17 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/remove_all_extents.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {


template <class _Tp>
struct remove_all_extents {
  using type __attribute__((__nodebug__)) = __remove_all_extents(_Tp);
};

template <class _Tp>
using __remove_all_extents_t = __remove_all_extents(_Tp);
# 48 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/remove_all_extents.h" 3
template <class _Tp>
using remove_all_extents_t = __remove_all_extents_t<_Tp>;


}}
# 17 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_destructible.h" 2 3
# 21 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_destructible.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {



template <class _Tp>
struct is_destructible : _BoolConstant<__is_destructible(_Tp)> {};


template <class _Tp>
inline constexpr bool is_destructible_v = __is_destructible(_Tp);
# 95 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_destructible.h" 3
}}
# 15 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_nothrow_destructible.h" 2 3

# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_scalar.h" 1 3
# 15 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_scalar.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_enum.h" 1 3
# 17 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_enum.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Tp>
struct is_enum : public integral_constant<bool, __is_enum(_Tp)> {};


template <class _Tp>
inline constexpr bool is_enum_v = __is_enum(_Tp);


}}
# 16 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_scalar.h" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_member_pointer.h" 1 3
# 14 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_member_pointer.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_member_function_pointer.h" 1 3
# 20 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_member_function_pointer.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Tp>
struct __libcpp_is_member_pointer {
  enum { __is_member = false, __is_func = false, __is_obj = false };
};
template <class _Tp, class _Up>
struct __libcpp_is_member_pointer<_Tp _Up::*> {
  enum {
    __is_member = true,
    __is_func = is_function<_Tp>::value,
    __is_obj = !__is_func,
  };
};



template <class _Tp>
struct is_member_function_pointer : _BoolConstant<__is_member_function_pointer(_Tp)> {};


template <class _Tp>
inline constexpr bool is_member_function_pointer_v = __is_member_function_pointer(_Tp);
# 60 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_member_function_pointer.h" 3
}}
# 15 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_member_pointer.h" 2 3
# 18 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_member_pointer.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {



template <class _Tp>
struct is_member_pointer : _BoolConstant<__is_member_pointer(_Tp)> {};


template <class _Tp>
inline constexpr bool is_member_pointer_v = __is_member_pointer(_Tp);
# 45 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_member_pointer.h" 3
}}
# 17 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_scalar.h" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_null_pointer.h" 1 3
# 19 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_null_pointer.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Tp>
struct __is_nullptr_t_impl : public false_type {};
template <>
struct __is_nullptr_t_impl<nullptr_t> : public true_type {};

template <class _Tp>
struct __is_nullptr_t : public __is_nullptr_t_impl<__remove_cv_t<_Tp> > {};


template <class _Tp>
struct is_null_pointer : public __is_nullptr_t_impl<__remove_cv_t<_Tp> > {};


template <class _Tp>
inline constexpr bool is_null_pointer_v = is_null_pointer<_Tp>::value;



}}
# 18 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_scalar.h" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_pointer.h" 1 3
# 18 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_pointer.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {



template <class _Tp>
struct is_pointer : _BoolConstant<__is_pointer(_Tp)> {};


template <class _Tp>
inline constexpr bool is_pointer_v = __is_pointer(_Tp);
# 63 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_pointer.h" 3
}}
# 19 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_scalar.h" 2 3
# 22 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_scalar.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {



template <class _Tp>
struct is_scalar : _BoolConstant<__is_scalar(_Tp)> {};


template <class _Tp>
inline constexpr bool is_scalar_v = __is_scalar(_Tp);
# 67 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_scalar.h" 3
}}
# 17 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_nothrow_destructible.h" 2 3
# 23 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_nothrow_destructible.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {



template <bool, class _Tp>
struct __libcpp_is_nothrow_destructible;

template <class _Tp>
struct __libcpp_is_nothrow_destructible<false, _Tp> : public false_type {};

template <class _Tp>
struct __libcpp_is_nothrow_destructible<true, _Tp>
    : public integral_constant<bool, noexcept(std::declval<_Tp>().~_Tp()) > {};

template <class _Tp>
struct is_nothrow_destructible
    : public __libcpp_is_nothrow_destructible<is_destructible<_Tp>::value, _Tp> {};

template <class _Tp, size_t _Ns>
struct is_nothrow_destructible<_Tp[_Ns]> : public is_nothrow_destructible<_Tp> {};

template <class _Tp>
struct is_nothrow_destructible<_Tp&> : public true_type {};

template <class _Tp>
struct is_nothrow_destructible<_Tp&&> : public true_type {};
# 68 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_nothrow_destructible.h" 3
template <class _Tp>
inline constexpr bool is_nothrow_destructible_v = is_nothrow_destructible<_Tp>::value;


}}
# 14 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__concepts/destructible.h" 2 3
# 17 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__concepts/destructible.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {





template <class _Tp>
concept destructible = is_nothrow_destructible_v<_Tp>;



}}
# 14 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__concepts/constructible.h" 2 3
# 19 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__concepts/constructible.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {




template <class _Tp, class... _Args>
concept constructible_from = destructible<_Tp> && is_constructible_v<_Tp, _Args...>;



template <class _Tp>
concept __default_initializable = requires { ::new _Tp; };

template <class _Tp>
concept default_initializable = constructible_from<_Tp> && requires { _Tp{}; } && __default_initializable<_Tp>;


template <class _Tp>
concept move_constructible = constructible_from<_Tp, _Tp> && convertible_to<_Tp, _Tp>;



template <class _Tp>
concept copy_constructible =
    move_constructible<_Tp> &&
    constructible_from<_Tp, _Tp&> && convertible_to<_Tp&, _Tp> &&
    constructible_from<_Tp, const _Tp&> && convertible_to<const _Tp&, _Tp> &&
    constructible_from<_Tp, const _Tp> && convertible_to<const _Tp, _Tp>;




}}
# 17 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__iterator/concepts.h" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__concepts/copyable.h" 1 3
# 14 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__concepts/copyable.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__concepts/movable.h" 1 3
# 14 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__concepts/movable.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__concepts/swappable.h" 1 3
# 13 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__concepts/swappable.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__concepts/class_or_enum.h" 1 3
# 13 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__concepts/class_or_enum.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_class.h" 1 3
# 17 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_class.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Tp>
struct is_class : public integral_constant<bool, __is_class(_Tp)> {};


template <class _Tp>
inline constexpr bool is_class_v = __is_class(_Tp);


}}
# 14 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__concepts/class_or_enum.h" 2 3

# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_union.h" 1 3
# 17 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_union.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Tp>
struct is_union : public integral_constant<bool, __is_union(_Tp)> {};


template <class _Tp>
inline constexpr bool is_union_v = __is_union(_Tp);


}}
# 16 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__concepts/class_or_enum.h" 2 3
# 20 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__concepts/class_or_enum.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {





template <class _Tp>
concept __class_or_enum = is_class_v<_Tp> || is_union_v<_Tp> || is_enum_v<_Tp>;



template <class _Tp>
concept __workaround_52970 = is_class_v<__remove_cvref_t<_Tp>> || is_union_v<__remove_cvref_t<_Tp>>;



}}
# 14 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__concepts/swappable.h" 2 3



# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/extent.h" 1 3
# 18 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/extent.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {



template <class _Tp, size_t _Dim = 0>
struct extent : integral_constant<size_t, __array_extent(_Tp, _Dim)> {};


template <class _Tp, unsigned _Ip = 0>
inline constexpr size_t extent_v = __array_extent(_Tp, _Ip);
# 52 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/extent.h" 3
}}
# 18 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__concepts/swappable.h" 2 3



# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__utility/exchange.h" 1 3
# 13 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__utility/exchange.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_nothrow_assignable.h" 1 3
# 17 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_nothrow_assignable.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Tp, class _Arg>
struct is_nothrow_assignable : public integral_constant<bool, __is_nothrow_assignable(_Tp, _Arg)> {
};


template <class _Tp, class _Arg>
inline constexpr bool is_nothrow_assignable_v = __is_nothrow_assignable(_Tp, _Arg);


}}
# 14 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__utility/exchange.h" 2 3
# 20 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__utility/exchange.h" 3



# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__undef_macros" 1 3
# 24 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__utility/exchange.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {


template<class _T1, class _T2 = _T1>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
_T1 exchange(_T1& __obj, _T2&& __new_value)
    noexcept(is_nothrow_move_constructible<_T1>::value && is_nothrow_assignable<_T1&, _T2>::value)
{
    _T1 __old_value = std::move(__obj);
    __obj = std::forward<_T2>(__new_value);
    return __old_value;
}


}}
# 22 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__concepts/swappable.h" 2 3
# 29 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__concepts/swappable.h" 3



# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__undef_macros" 1 3
# 33 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__concepts/swappable.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {





namespace ranges {
namespace __swap {

template <class _Tp>
void swap(_Tp&, _Tp&) = delete;


template <class _Tp, class _Up>
concept __unqualified_swappable_with =
    (__class_or_enum<remove_cvref_t<_Tp>> || __class_or_enum<remove_cvref_t<_Up>>) &&
    requires(_Tp&& __t, _Up&& __u) {
        swap(std::forward<_Tp>(__t), std::forward<_Up>(__u));
    };


struct __fn;


template <class _Tp, class _Up, size_t _Size>
concept __swappable_arrays =
    !__unqualified_swappable_with<_Tp (&)[_Size], _Up (&)[_Size]> &&
    extent_v<_Tp> == extent_v<_Up> &&
    requires(_Tp (&__t)[_Size], _Up (&__u)[_Size], const __fn& __swap) {
        __swap(__t[0], __u[0]);
    };


template <class _Tp>
concept __exchangeable =
    !__unqualified_swappable_with<_Tp&, _Tp&> && move_constructible<_Tp> && assignable_from<_Tp&, _Tp>;

struct __fn {


  template <class _Tp, class _Up>
    requires __unqualified_swappable_with<_Tp, _Up>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr void operator()(_Tp&& __t, _Up&& __u) const
      noexcept(noexcept(swap(std::forward<_Tp>(__t), std::forward<_Up>(__u)))) {
    swap(std::forward<_Tp>(__t), std::forward<_Up>(__u));
  }


  template <class _Tp, class _Up, size_t _Size>
    requires __swappable_arrays<_Tp, _Up, _Size>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr void operator()(_Tp (&__t)[_Size], _Up (&__u)[_Size]) const
      noexcept(noexcept((*this)(*__t, *__u))) {

    for (size_t __i = 0; __i < _Size; ++__i) {
      (*this)(__t[__i], __u[__i]);
    }
  }


  template <__exchangeable _Tp>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr void operator()(_Tp& __x, _Tp& __y) const
      noexcept(is_nothrow_move_constructible_v<_Tp>&& is_nothrow_move_assignable_v<_Tp>) {
    __y = std::exchange(__x, std::move(__y));
  }
};
}

inline namespace __cpo {
inline constexpr auto swap = __swap::__fn{};
}
}

template <class _Tp>
concept swappable = requires(_Tp& __a, _Tp& __b) { ranges::swap(__a, __b); };

template <class _Tp, class _Up>
concept swappable_with = common_reference_with<_Tp, _Up> && requires(_Tp&& __t, _Up&& __u) {
  ranges::swap(std::forward<_Tp>(__t), std::forward<_Tp>(__t));
  ranges::swap(std::forward<_Up>(__u), std::forward<_Up>(__u));
  ranges::swap(std::forward<_Tp>(__t), std::forward<_Up>(__u));
  ranges::swap(std::forward<_Up>(__u), std::forward<_Tp>(__t));
};



}}
# 15 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__concepts/movable.h" 2 3

# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_object.h" 1 3
# 21 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_object.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {



template <class _Tp>
struct is_object : _BoolConstant<__is_object(_Tp)> {};


template <class _Tp>
inline constexpr bool is_object_v = __is_object(_Tp);
# 50 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_object.h" 3
}}
# 17 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__concepts/movable.h" 2 3
# 20 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__concepts/movable.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {





template <class _Tp>
concept movable = is_object_v<_Tp> && move_constructible<_Tp> && assignable_from<_Tp&, _Tp> && swappable<_Tp>;



}}
# 15 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__concepts/copyable.h" 2 3
# 19 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__concepts/copyable.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {






template <class _Tp>
concept copyable =
    copy_constructible<_Tp> &&
    movable<_Tp> &&
    assignable_from<_Tp&, _Tp&> &&
    assignable_from<_Tp&, const _Tp&> &&
    assignable_from<_Tp&, const _Tp>;




}}
# 18 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__iterator/concepts.h" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__concepts/derived_from.h" 1 3
# 13 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__concepts/derived_from.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_base_of.h" 1 3
# 17 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_base_of.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Bp, class _Dp>
struct is_base_of : public integral_constant<bool, __is_base_of(_Bp, _Dp)> {};


template <class _Bp, class _Dp>
inline constexpr bool is_base_of_v = __is_base_of(_Bp, _Dp);


}}
# 14 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__concepts/derived_from.h" 2 3
# 18 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__concepts/derived_from.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {





template <class _Dp, class _Bp>
concept derived_from = is_base_of_v<_Bp, _Dp> && is_convertible_v<const volatile _Dp*, const volatile _Bp*>;



}}
# 19 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__iterator/concepts.h" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__concepts/equality_comparable.h" 1 3
# 12 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__concepts/equality_comparable.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__concepts/boolean_testable.h" 1 3
# 18 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__concepts/boolean_testable.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {





template <class _Tp>
concept __boolean_testable_impl = convertible_to<_Tp, bool>;

template <class _Tp>
concept __boolean_testable = __boolean_testable_impl<_Tp> && requires(_Tp&& __t) {
  { !std::forward<_Tp>(__t) } -> __boolean_testable_impl;
};



}}
# 13 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__concepts/equality_comparable.h" 2 3
# 20 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__concepts/equality_comparable.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {





template <class _Tp, class _Up>
concept __weakly_equality_comparable_with =
    requires(__make_const_lvalue_ref<_Tp> __t, __make_const_lvalue_ref<_Up> __u) {
      { __t == __u } -> __boolean_testable;
      { __t != __u } -> __boolean_testable;
      { __u == __t } -> __boolean_testable;
      { __u != __t } -> __boolean_testable;
    };

template <class _Tp>
concept equality_comparable = __weakly_equality_comparable_with<_Tp, _Tp>;


template <class _Tp, class _Up>
concept equality_comparable_with =
    equality_comparable<_Tp> && equality_comparable<_Up> &&
    common_reference_with<__make_const_lvalue_ref<_Tp>, __make_const_lvalue_ref<_Up>> &&
    equality_comparable<
        common_reference_t<
            __make_const_lvalue_ref<_Tp>,
            __make_const_lvalue_ref<_Up>>> &&
    __weakly_equality_comparable_with<_Tp, _Up>;




}}
# 20 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__iterator/concepts.h" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__concepts/invocable.h" 1 3
# 13 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__concepts/invocable.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__functional/invoke.h" 1 3
# 14 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__functional/invoke.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/invoke.h" 1 3
# 15 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/invoke.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/apply_cv.h" 1 3
# 14 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/apply_cv.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_volatile.h" 1 3
# 17 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_volatile.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {



template <class _Tp>
struct is_volatile : _BoolConstant<__is_volatile(_Tp)> {};


template <class _Tp>
inline constexpr bool is_volatile_v = __is_volatile(_Tp);
# 45 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_volatile.h" 3
}}
# 15 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/apply_cv.h" 2 3
# 19 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/apply_cv.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Tp,
          bool = is_const<__libcpp_remove_reference_t<_Tp> >::value,
          bool = is_volatile<__libcpp_remove_reference_t<_Tp> >::value>
struct __apply_cv_impl {
  template <class _Up>
  using __apply __attribute__((__nodebug__)) = _Up;
};

template <class _Tp>
struct __apply_cv_impl<_Tp, true, false> {
  template <class _Up>
  using __apply __attribute__((__nodebug__)) = const _Up;
};

template <class _Tp>
struct __apply_cv_impl<_Tp, false, true> {
  template <class _Up>
  using __apply __attribute__((__nodebug__)) = volatile _Up;
};

template <class _Tp>
struct __apply_cv_impl<_Tp, true, true> {
  template <class _Up>
  using __apply __attribute__((__nodebug__)) = const volatile _Up;
};

template <class _Tp>
struct __apply_cv_impl<_Tp&, false, false> {
  template <class _Up>
  using __apply __attribute__((__nodebug__)) = _Up&;
};

template <class _Tp>
struct __apply_cv_impl<_Tp&, true, false> {
  template <class _Up>
  using __apply __attribute__((__nodebug__)) = const _Up&;
};

template <class _Tp>
struct __apply_cv_impl<_Tp&, false, true> {
  template <class _Up>
  using __apply __attribute__((__nodebug__)) = volatile _Up&;
};

template <class _Tp>
struct __apply_cv_impl<_Tp&, true, true> {
  template <class _Up>
  using __apply __attribute__((__nodebug__)) = const volatile _Up&;
};

template <class _Tp, class _Up>
using __apply_cv_t __attribute__((__nodebug__)) = typename __apply_cv_impl<_Tp>::template __apply<_Up>;

}}
# 16 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/invoke.h" 2 3





# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_core_convertible.h" 1 3
# 17 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_core_convertible.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {






template <class _Tp, class _Up, class = void>
struct __is_core_convertible : public false_type {};

template <class _Tp, class _Up>
struct __is_core_convertible<_Tp, _Up, decltype(static_cast<void (*)(_Up)>(0)(static_cast<_Tp (*)()>(0)()))>
    : public true_type {};

}}
# 22 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/invoke.h" 2 3

# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_member_object_pointer.h" 1 3
# 17 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_member_object_pointer.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {



template <class _Tp>
struct is_member_object_pointer : _BoolConstant<__is_member_object_pointer(_Tp)> {};


template <class _Tp>
inline constexpr bool is_member_object_pointer_v = __is_member_object_pointer(_Tp);
# 44 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_member_object_pointer.h" 3
}}
# 24 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/invoke.h" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_reference_wrapper.h" 1 3
# 18 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_reference_wrapper.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Tp>
class reference_wrapper;

template <class _Tp>
struct __is_reference_wrapper_impl : public false_type {};
template <class _Tp>
struct __is_reference_wrapper_impl<reference_wrapper<_Tp> > : public true_type {};
template <class _Tp>
struct __is_reference_wrapper : public __is_reference_wrapper_impl<__remove_cv_t<_Tp> > {};

}}
# 25 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/invoke.h" 2 3
# 34 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/invoke.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

struct __any {
  __any(...);
};

template <class _MP, bool _IsMemberFunctionPtr, bool _IsMemberObjectPtr>
struct __member_pointer_traits_imp {};

template <class _Rp, class _Class, class... _Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...), true, false> {
  typedef _Class _ClassType;
  typedef _Rp _ReturnType;
  typedef _Rp(_FnType)(_Param...);
};

template <class _Rp, class _Class, class... _Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...), true, false> {
  typedef _Class _ClassType;
  typedef _Rp _ReturnType;
  typedef _Rp(_FnType)(_Param..., ...);
};

template <class _Rp, class _Class, class... _Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const, true, false> {
  typedef _Class const _ClassType;
  typedef _Rp _ReturnType;
  typedef _Rp(_FnType)(_Param...);
};

template <class _Rp, class _Class, class... _Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const, true, false> {
  typedef _Class const _ClassType;
  typedef _Rp _ReturnType;
  typedef _Rp(_FnType)(_Param..., ...);
};

template <class _Rp, class _Class, class... _Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) volatile, true, false> {
  typedef _Class volatile _ClassType;
  typedef _Rp _ReturnType;
  typedef _Rp(_FnType)(_Param...);
};

template <class _Rp, class _Class, class... _Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) volatile, true, false> {
  typedef _Class volatile _ClassType;
  typedef _Rp _ReturnType;
  typedef _Rp(_FnType)(_Param..., ...);
};

template <class _Rp, class _Class, class... _Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const volatile, true, false> {
  typedef _Class const volatile _ClassType;
  typedef _Rp _ReturnType;
  typedef _Rp(_FnType)(_Param...);
};

template <class _Rp, class _Class, class... _Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const volatile, true, false> {
  typedef _Class const volatile _ClassType;
  typedef _Rp _ReturnType;
  typedef _Rp(_FnType)(_Param..., ...);
};

template <class _Rp, class _Class, class... _Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...)&, true, false> {
  typedef _Class& _ClassType;
  typedef _Rp _ReturnType;
  typedef _Rp(_FnType)(_Param...);
};

template <class _Rp, class _Class, class... _Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...)&, true, false> {
  typedef _Class& _ClassType;
  typedef _Rp _ReturnType;
  typedef _Rp(_FnType)(_Param..., ...);
};

template <class _Rp, class _Class, class... _Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const&, true, false> {
  typedef _Class const& _ClassType;
  typedef _Rp _ReturnType;
  typedef _Rp(_FnType)(_Param...);
};

template <class _Rp, class _Class, class... _Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const&, true, false> {
  typedef _Class const& _ClassType;
  typedef _Rp _ReturnType;
  typedef _Rp(_FnType)(_Param..., ...);
};

template <class _Rp, class _Class, class... _Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) volatile&, true, false> {
  typedef _Class volatile& _ClassType;
  typedef _Rp _ReturnType;
  typedef _Rp(_FnType)(_Param...);
};

template <class _Rp, class _Class, class... _Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) volatile&, true, false> {
  typedef _Class volatile& _ClassType;
  typedef _Rp _ReturnType;
  typedef _Rp(_FnType)(_Param..., ...);
};

template <class _Rp, class _Class, class... _Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const volatile&, true, false> {
  typedef _Class const volatile& _ClassType;
  typedef _Rp _ReturnType;
  typedef _Rp(_FnType)(_Param...);
};

template <class _Rp, class _Class, class... _Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const volatile&, true, false> {
  typedef _Class const volatile& _ClassType;
  typedef _Rp _ReturnType;
  typedef _Rp(_FnType)(_Param..., ...);
};

template <class _Rp, class _Class, class... _Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...)&&, true, false> {
  typedef _Class&& _ClassType;
  typedef _Rp _ReturnType;
  typedef _Rp(_FnType)(_Param...);
};

template <class _Rp, class _Class, class... _Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...)&&, true, false> {
  typedef _Class&& _ClassType;
  typedef _Rp _ReturnType;
  typedef _Rp(_FnType)(_Param..., ...);
};

template <class _Rp, class _Class, class... _Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const&&, true, false> {
  typedef _Class const&& _ClassType;
  typedef _Rp _ReturnType;
  typedef _Rp(_FnType)(_Param...);
};

template <class _Rp, class _Class, class... _Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const&&, true, false> {
  typedef _Class const&& _ClassType;
  typedef _Rp _ReturnType;
  typedef _Rp(_FnType)(_Param..., ...);
};

template <class _Rp, class _Class, class... _Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) volatile&&, true, false> {
  typedef _Class volatile&& _ClassType;
  typedef _Rp _ReturnType;
  typedef _Rp(_FnType)(_Param...);
};

template <class _Rp, class _Class, class... _Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) volatile&&, true, false> {
  typedef _Class volatile&& _ClassType;
  typedef _Rp _ReturnType;
  typedef _Rp(_FnType)(_Param..., ...);
};

template <class _Rp, class _Class, class... _Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const volatile&&, true, false> {
  typedef _Class const volatile&& _ClassType;
  typedef _Rp _ReturnType;
  typedef _Rp(_FnType)(_Param...);
};

template <class _Rp, class _Class, class... _Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const volatile&&, true, false> {
  typedef _Class const volatile&& _ClassType;
  typedef _Rp _ReturnType;
  typedef _Rp(_FnType)(_Param..., ...);
};

template <class _Rp, class _Class>
struct __member_pointer_traits_imp<_Rp _Class::*, false, true> {
  typedef _Class _ClassType;
  typedef _Rp _ReturnType;
};

template <class _MP>
struct __member_pointer_traits
    : public __member_pointer_traits_imp<__remove_cv_t<_MP>,
                                         is_member_function_pointer<_MP>::value,
                                         is_member_object_pointer<_MP>::value> {



};

template <class _DecayedFp>
struct __member_pointer_class_type {};

template <class _Ret, class _ClassType>
struct __member_pointer_class_type<_Ret _ClassType::*> {
  typedef _ClassType type;
};

template <class _Fp,
          class _A0,
          class _DecayFp = __decay_t<_Fp>,
          class _DecayA0 = __decay_t<_A0>,
          class _ClassT = typename __member_pointer_class_type<_DecayFp>::type>
using __enable_if_bullet1 =
    __enable_if_t<is_member_function_pointer<_DecayFp>::value &&
                  (is_same<_ClassT, _DecayA0>::value || is_base_of<_ClassT, _DecayA0>::value)>;

template <class _Fp, class _A0, class _DecayFp = __decay_t<_Fp>, class _DecayA0 = __decay_t<_A0> >
using __enable_if_bullet2 =
    __enable_if_t<is_member_function_pointer<_DecayFp>::value && __is_reference_wrapper<_DecayA0>::value>;

template <class _Fp,
          class _A0,
          class _DecayFp = __decay_t<_Fp>,
          class _DecayA0 = __decay_t<_A0>,
          class _ClassT = typename __member_pointer_class_type<_DecayFp>::type>
using __enable_if_bullet3 =
    __enable_if_t<is_member_function_pointer<_DecayFp>::value &&
                  !(is_same<_ClassT, _DecayA0>::value || is_base_of<_ClassT, _DecayA0>::value) &&
                  !__is_reference_wrapper<_DecayA0>::value>;

template <class _Fp,
          class _A0,
          class _DecayFp = __decay_t<_Fp>,
          class _DecayA0 = __decay_t<_A0>,
          class _ClassT = typename __member_pointer_class_type<_DecayFp>::type>
using __enable_if_bullet4 =
    __enable_if_t<is_member_object_pointer<_DecayFp>::value &&
                  (is_same<_ClassT, _DecayA0>::value || is_base_of<_ClassT, _DecayA0>::value)>;

template <class _Fp, class _A0, class _DecayFp = __decay_t<_Fp>, class _DecayA0 = __decay_t<_A0> >
using __enable_if_bullet5 =
    __enable_if_t<is_member_object_pointer<_DecayFp>::value && __is_reference_wrapper<_DecayA0>::value>;

template <class _Fp,
          class _A0,
          class _DecayFp = __decay_t<_Fp>,
          class _DecayA0 = __decay_t<_A0>,
          class _ClassT = typename __member_pointer_class_type<_DecayFp>::type>
using __enable_if_bullet6 =
    __enable_if_t<is_member_object_pointer<_DecayFp>::value &&
                  !(is_same<_ClassT, _DecayA0>::value || is_base_of<_ClassT, _DecayA0>::value) &&
                  !__is_reference_wrapper<_DecayA0>::value>;





template <class... _Args>
__nat __invoke(__any, _Args&&... __args);




template <class _Fp, class _A0, class... _Args, class = __enable_if_bullet1<_Fp, _A0> >
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
decltype((std::declval<_A0>().*std::declval<_Fp>())(std::declval<_Args>()...))
__invoke(_Fp&& __f, _A0&& __a0, _Args&&... __args)
    noexcept(noexcept((static_cast<_A0&&>(__a0).*__f)(static_cast<_Args&&>(__args)...)))
               { return (static_cast<_A0&&>(__a0).*__f)(static_cast<_Args&&>(__args)...); }

template <class _Fp, class _A0, class... _Args, class = __enable_if_bullet2<_Fp, _A0> >
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
decltype((std::declval<_A0>().get().*std::declval<_Fp>())(std::declval<_Args>()...))
__invoke(_Fp&& __f, _A0&& __a0, _Args&&... __args)
    noexcept(noexcept((__a0.get().*__f)(static_cast<_Args&&>(__args)...)))
               { return (__a0.get().*__f)(static_cast<_Args&&>(__args)...); }

template <class _Fp, class _A0, class... _Args, class = __enable_if_bullet3<_Fp, _A0> >
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
decltype(((*std::declval<_A0>()).*std::declval<_Fp>())(std::declval<_Args>()...))
__invoke(_Fp&& __f, _A0&& __a0, _Args&&... __args)
    noexcept(noexcept(((*static_cast<_A0&&>(__a0)).*__f)(static_cast<_Args&&>(__args)...)))
               { return ((*static_cast<_A0&&>(__a0)).*__f)(static_cast<_Args&&>(__args)...); }



template <class _Fp, class _A0, class = __enable_if_bullet4<_Fp, _A0> >
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
decltype(std::declval<_A0>().*std::declval<_Fp>())
__invoke(_Fp&& __f, _A0&& __a0)
    noexcept(noexcept(static_cast<_A0&&>(__a0).*__f))
               { return static_cast<_A0&&>(__a0).*__f; }

template <class _Fp, class _A0, class = __enable_if_bullet5<_Fp, _A0> >
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
decltype(std::declval<_A0>().get().*std::declval<_Fp>())
__invoke(_Fp&& __f, _A0&& __a0)
    noexcept(noexcept(__a0.get().*__f))
               { return __a0.get().*__f; }

template <class _Fp, class _A0, class = __enable_if_bullet6<_Fp, _A0> >
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
decltype((*std::declval<_A0>()).*std::declval<_Fp>())
__invoke(_Fp&& __f, _A0&& __a0)
    noexcept(noexcept((*static_cast<_A0&&>(__a0)).*__f))
               { return (*static_cast<_A0&&>(__a0)).*__f; }



template <class _Fp, class... _Args>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
decltype(std::declval<_Fp>()(std::declval<_Args>()...))
__invoke(_Fp&& __f, _Args&&... __args)
    noexcept(noexcept(static_cast<_Fp&&>(__f)(static_cast<_Args&&>(__args)...)))
               { return static_cast<_Fp&&>(__f)(static_cast<_Args&&>(__args)...); }



template <class _Ret, class _Fp, class... _Args>
struct __invokable_r {
  template <class _XFp, class... _XArgs>
  static decltype(std::__invoke(std::declval<_XFp>(), std::declval<_XArgs>()...)) __try_call(int);
  template <class _XFp, class... _XArgs>
  static __nat __try_call(...);



  using _Result = decltype(__try_call<_Fp, _Args...>(0));

  using type = __conditional_t<_IsNotSame<_Result, __nat>::value,
                               __conditional_t<is_void<_Ret>::value, true_type, __is_core_convertible<_Result, _Ret> >,
                               false_type>;
  static const bool value = type::value;
};
template <class _Fp, class... _Args>
using __invokable = __invokable_r<void, _Fp, _Args...>;

template <bool _IsInvokable, bool _IsCVVoid, class _Ret, class _Fp, class... _Args>
struct __nothrow_invokable_r_imp {
  static const bool value = false;
};

template <class _Ret, class _Fp, class... _Args>
struct __nothrow_invokable_r_imp<true, false, _Ret, _Fp, _Args...> {
  typedef __nothrow_invokable_r_imp _ThisT;

  template <class _Tp>
  static void __test_noexcept(_Tp) noexcept;




  static const bool value =
      noexcept(_ThisT::__test_noexcept<_Ret>(std::__invoke(std::declval<_Fp>(), std::declval<_Args>()...)));

};

template <class _Ret, class _Fp, class... _Args>
struct __nothrow_invokable_r_imp<true, true, _Ret, _Fp, _Args...> {



  static const bool value = noexcept(std::__invoke(std::declval<_Fp>(), std::declval<_Args>()...));

};

template <class _Ret, class _Fp, class... _Args>
using __nothrow_invokable_r =
    __nothrow_invokable_r_imp<__invokable_r<_Ret, _Fp, _Args...>::value, is_void<_Ret>::value, _Ret, _Fp, _Args...>;

template <class _Fp, class... _Args>
using __nothrow_invokable = __nothrow_invokable_r_imp<__invokable<_Fp, _Args...>::value, true, void, _Fp, _Args...>;

template <class _Fp, class... _Args>
struct __invoke_of
    : public enable_if<__invokable<_Fp, _Args...>::value, typename __invokable_r<void, _Fp, _Args...>::_Result> {};

template <class _Ret, bool = is_void<_Ret>::value>
struct __invoke_void_return_wrapper {
  template <class... _Args>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr static _Ret __call(_Args&&... __args) {
    return std::__invoke(std::forward<_Args>(__args)...);
  }
};

template <class _Ret>
struct __invoke_void_return_wrapper<_Ret, true> {
  template <class... _Args>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr static void __call(_Args&&... __args) {
    std::__invoke(std::forward<_Args>(__args)...);
  }
};





template <class _Fn, class... _Args>
struct is_invocable : integral_constant<bool, __invokable<_Fn, _Args...>::value> {};

template <class _Ret, class _Fn, class... _Args>
struct is_invocable_r : integral_constant<bool, __invokable_r<_Ret, _Fn, _Args...>::value> {};

template <class _Fn, class... _Args>
inline constexpr bool is_invocable_v = is_invocable<_Fn, _Args...>::value;

template <class _Ret, class _Fn, class... _Args>
inline constexpr bool is_invocable_r_v = is_invocable_r<_Ret, _Fn, _Args...>::value;



template <class _Fn, class... _Args>
struct is_nothrow_invocable : integral_constant<bool, __nothrow_invokable<_Fn, _Args...>::value> {
};

template <class _Ret, class _Fn, class... _Args>
struct is_nothrow_invocable_r
    : integral_constant<bool, __nothrow_invokable_r<_Ret, _Fn, _Args...>::value> {};

template <class _Fn, class... _Args>
inline constexpr bool is_nothrow_invocable_v = is_nothrow_invocable<_Fn, _Args...>::value;

template <class _Ret, class _Fn, class... _Args>
inline constexpr bool is_nothrow_invocable_r_v = is_nothrow_invocable_r<_Ret, _Fn, _Args...>::value;

template <class _Fn, class... _Args>
struct invoke_result : __invoke_of<_Fn, _Args...> {};

template <class _Fn, class... _Args>
using invoke_result_t = typename invoke_result<_Fn, _Args...>::type;



}}
# 15 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__functional/invoke.h" 2 3
# 19 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__functional/invoke.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {



template <class _Fn, class ..._Args>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr invoke_result_t<_Fn, _Args...>
invoke(_Fn&& __f, _Args&&... __args)
    noexcept(is_nothrow_invocable_v<_Fn, _Args...>)
{
    return std::__invoke(std::forward<_Fn>(__f), std::forward<_Args>(__args)...);
}




template <class _Result, class _Fn, class... _Args>
  requires is_invocable_r_v<_Result, _Fn, _Args...>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr _Result
invoke_r(_Fn&& __f, _Args&&... __args) noexcept(is_nothrow_invocable_r_v<_Result, _Fn, _Args...>) {
    if constexpr (is_void_v<_Result>) {
        static_cast<void>(std::invoke(std::forward<_Fn>(__f), std::forward<_Args>(__args)...));
    } else {



        static_assert(true,
            "Returning from invoke_r would bind a temporary object to the reference return type, "
            "which would result in a dangling reference.");
        return std::invoke(std::forward<_Fn>(__f), std::forward<_Args>(__args)...);
    }
}


}}
# 14 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__concepts/invocable.h" 2 3
# 18 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__concepts/invocable.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {





template <class _Fn, class... _Args>
concept invocable = requires(_Fn&& __fn, _Args&&... __args) {
  std::invoke(std::forward<_Fn>(__fn), std::forward<_Args>(__args)...);
};



template <class _Fn, class... _Args>
concept regular_invocable = invocable<_Fn, _Args...>;



}}
# 21 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__iterator/concepts.h" 2 3

# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__concepts/predicate.h" 1 3
# 19 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__concepts/predicate.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {





template <class _Fn, class... _Args>
concept predicate = regular_invocable<_Fn, _Args...> && __boolean_testable<invoke_result_t<_Fn, _Args...>>;



}}
# 23 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__iterator/concepts.h" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__concepts/regular.h" 1 3
# 13 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__concepts/regular.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__concepts/semiregular.h" 1 3
# 18 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__concepts/semiregular.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {





template <class _Tp>
concept semiregular = copyable<_Tp> && default_initializable<_Tp>;



}}
# 14 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__concepts/regular.h" 2 3
# 18 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__concepts/regular.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {





template <class _Tp>
concept regular = semiregular<_Tp> && equality_comparable<_Tp>;



}}
# 24 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__iterator/concepts.h" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__concepts/relation.h" 1 3
# 17 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__concepts/relation.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {





template <class _Rp, class _Tp, class _Up>
concept relation =
    predicate<_Rp, _Tp, _Tp> && predicate<_Rp, _Up, _Up> && predicate<_Rp, _Tp, _Up> && predicate<_Rp, _Up, _Tp>;



template <class _Rp, class _Tp, class _Up>
concept equivalence_relation = relation<_Rp, _Tp, _Up>;



template <class _Rp, class _Tp, class _Up>
concept strict_weak_order = relation<_Rp, _Tp, _Up>;



}}
# 25 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__iterator/concepts.h" 2 3


# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__concepts/totally_ordered.h" 1 3
# 20 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__concepts/totally_ordered.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {





template <class _Tp, class _Up>
concept __partially_ordered_with = requires(__make_const_lvalue_ref<_Tp> __t, __make_const_lvalue_ref<_Up> __u) {
  { __t < __u } -> __boolean_testable;
  { __t > __u } -> __boolean_testable;
  { __t <= __u } -> __boolean_testable;
  { __t >= __u } -> __boolean_testable;
  { __u < __t } -> __boolean_testable;
  { __u > __t } -> __boolean_testable;
  { __u <= __t } -> __boolean_testable;
  { __u >= __t } -> __boolean_testable;
};

template <class _Tp>
concept totally_ordered = equality_comparable<_Tp> && __partially_ordered_with<_Tp, _Tp>;


template <class _Tp, class _Up>
concept totally_ordered_with =
    totally_ordered<_Tp> && totally_ordered<_Up> &&
    equality_comparable_with<_Tp, _Up> &&
    totally_ordered<
        common_reference_t<
            __make_const_lvalue_ref<_Tp>,
            __make_const_lvalue_ref<_Up>>> &&
    __partially_ordered_with<_Tp, _Up>;




}}
# 28 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__iterator/concepts.h" 2 3


# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__iterator/incrementable_traits.h" 1 3
# 17 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__iterator/incrementable_traits.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_primary_template.h" 1 3
# 15 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_primary_template.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_valid_expansion.h" 1 3
# 17 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_valid_expansion.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <template <class...> class _Templ, class... _Args, class = _Templ<_Args...> >
true_type __sfinae_test_impl(int);
template <template <class...> class, class...>
false_type __sfinae_test_impl(...);

template <template <class...> class _Templ, class... _Args>
using _IsValidExpansion __attribute__((__nodebug__)) = decltype(std::__sfinae_test_impl<_Templ, _Args...>(0));

}}
# 16 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_primary_template.h" 2 3
# 19 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_primary_template.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Tp>
using __test_for_primary_template = __enable_if_t<_IsSame<_Tp, typename _Tp::__primary_template>::value>;

template <class _Tp>
using __is_primary_template = _IsValidExpansion<__test_for_primary_template, _Tp>;

}}
# 18 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__iterator/incrementable_traits.h" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/make_signed.h" 1 3
# 18 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/make_signed.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/type_list.h" 1 3
# 17 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/type_list.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Hp, class _Tp>
struct __type_list {
  typedef _Hp _Head;
  typedef _Tp _Tail;
};

template <class _TypeList, size_t _Size, bool = _Size <= sizeof(typename _TypeList::_Head)>
struct __find_first;

template <class _Hp, class _Tp, size_t _Size>
struct __find_first<__type_list<_Hp, _Tp>, _Size, true> {
  typedef __attribute__((__nodebug__)) _Hp type;
};

template <class _Hp, class _Tp, size_t _Size>
struct __find_first<__type_list<_Hp, _Tp>, _Size, false> {
  typedef __attribute__((__nodebug__)) typename __find_first<_Tp, _Size>::type type;
};

}}
# 19 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/make_signed.h" 2 3
# 22 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/make_signed.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {



template <class _Tp>
using __make_signed_t = __make_signed(_Tp);
# 77 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/make_signed.h" 3
template <class _Tp>
struct make_signed {
  using type __attribute__((__nodebug__)) = __make_signed_t<_Tp>;
};


template <class _Tp>
using make_signed_t = __make_signed_t<_Tp>;


}}
# 19 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__iterator/incrementable_traits.h" 2 3
# 25 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__iterator/incrementable_traits.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {




template<class> struct incrementable_traits {};

template<class _Tp>
requires is_object_v<_Tp>
struct incrementable_traits<_Tp*> {
  using difference_type = ptrdiff_t;
};

template<class _Ip>
struct incrementable_traits<const _Ip> : incrementable_traits<_Ip> {};

template<class _Tp>
concept __has_member_difference_type = requires { typename _Tp::difference_type; };

template<__has_member_difference_type _Tp>
struct incrementable_traits<_Tp> {
  using difference_type = typename _Tp::difference_type;
};

template<class _Tp>
concept __has_integral_minus =
  requires(const _Tp& __x, const _Tp& __y) {
    { __x - __y } -> integral;
  };

template<__has_integral_minus _Tp>
requires (!__has_member_difference_type<_Tp>)
struct incrementable_traits<_Tp> {
  using difference_type = make_signed_t<decltype(std::declval<_Tp>() - std::declval<_Tp>())>;
};

template <class>
struct iterator_traits;




template <class _Ip>
using iter_difference_t = typename conditional_t<__is_primary_template<iterator_traits<remove_cvref_t<_Ip> > >::value,
                                                 incrementable_traits<remove_cvref_t<_Ip> >,
                                                 iterator_traits<remove_cvref_t<_Ip> > >::difference_type;



}}
# 31 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__iterator/concepts.h" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__iterator/iter_move.h" 1 3
# 15 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__iterator/iter_move.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__iterator/iterator_traits.h" 1 3
# 21 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__iterator/iterator_traits.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__fwd/pair.h" 1 3
# 16 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__fwd/pair.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class, class>
struct pair;

}}
# 22 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__iterator/iterator_traits.h" 2 3

# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__iterator/readable_traits.h" 1 3
# 25 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__iterator/readable_traits.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {




template<class> struct __cond_value_type {};

template<class _Tp>
requires is_object_v<_Tp>
struct __cond_value_type<_Tp> { using value_type = remove_cv_t<_Tp>; };

template<class _Tp>
concept __has_member_value_type = requires { typename _Tp::value_type; };

template<class _Tp>
concept __has_member_element_type = requires { typename _Tp::element_type; };

template<class> struct indirectly_readable_traits {};

template<class _Ip>
requires is_array_v<_Ip>
struct indirectly_readable_traits<_Ip> {
  using value_type = remove_cv_t<remove_extent_t<_Ip>>;
};

template<class _Ip>
struct indirectly_readable_traits<const _Ip> : indirectly_readable_traits<_Ip> {};

template<class _Tp>
struct indirectly_readable_traits<_Tp*> : __cond_value_type<_Tp> {};

template<__has_member_value_type _Tp>
struct indirectly_readable_traits<_Tp>
  : __cond_value_type<typename _Tp::value_type> {};

template<__has_member_element_type _Tp>
struct indirectly_readable_traits<_Tp>
  : __cond_value_type<typename _Tp::element_type> {};

template<__has_member_value_type _Tp>
  requires __has_member_element_type<_Tp>
struct indirectly_readable_traits<_Tp> {};

template<__has_member_value_type _Tp>
  requires __has_member_element_type<_Tp> &&
           same_as<remove_cv_t<typename _Tp::element_type>,
                   remove_cv_t<typename _Tp::value_type>>
struct indirectly_readable_traits<_Tp>
  : __cond_value_type<typename _Tp::value_type> {};



}}
# 24 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__iterator/iterator_traits.h" 2 3



# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/disjunction.h" 1 3
# 17 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/disjunction.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <bool>
struct _OrImpl;

template <>
struct _OrImpl<true> {
  template <class _Res, class _First, class... _Rest>
  using _Result __attribute__((__nodebug__)) =
      typename _OrImpl<!bool(_First::value) && sizeof...(_Rest) != 0>::template _Result<_First, _Rest...>;
};

template <>
struct _OrImpl<false> {
  template <class _Res, class...>
  using _Result = _Res;
};







template <class... _Args>
using _Or __attribute__((__nodebug__)) = typename _OrImpl<sizeof...(_Args) != 0>::template _Result<false_type, _Args...>;



template <class... _Args>
struct disjunction : _Or<_Args...> {};

template <class... _Args>
inline constexpr bool disjunction_v = _Or<_Args...>::value;



}}
# 28 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__iterator/iterator_traits.h" 2 3
# 42 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__iterator/iterator_traits.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {



template <class _Tp>
using __with_reference = _Tp&;

template <class _Tp>
concept __can_reference = requires {
  typename __with_reference<_Tp>;
};

template <class _Tp>
concept __dereferenceable = requires(_Tp& __t) {
  { *__t } -> __can_reference;
};


template<__dereferenceable _Tp>
using iter_reference_t = decltype(*std::declval<_Tp&>());



template <class _Iter>
struct iterator_traits;

struct input_iterator_tag {};
struct output_iterator_tag {};
struct forward_iterator_tag : public input_iterator_tag {};
struct bidirectional_iterator_tag : public forward_iterator_tag {};
struct random_access_iterator_tag : public bidirectional_iterator_tag {};

struct contiguous_iterator_tag : public random_access_iterator_tag {};


template <class _Iter>
struct __iter_traits_cache {
  using type = _If<
    __is_primary_template<iterator_traits<_Iter> >::value,
    _Iter,
    iterator_traits<_Iter>
  >;
};
template <class _Iter>
using _ITER_TRAITS = typename __iter_traits_cache<_Iter>::type;

struct __iter_concept_concept_test {
  template <class _Iter>
  using _Apply = typename _ITER_TRAITS<_Iter>::iterator_concept;
};
struct __iter_concept_category_test {
  template <class _Iter>
  using _Apply = typename _ITER_TRAITS<_Iter>::iterator_category;
};
struct __iter_concept_random_fallback {
  template <class _Iter>
  using _Apply = __enable_if_t<
                          __is_primary_template<iterator_traits<_Iter> >::value,
                          random_access_iterator_tag
                        >;
};

template <class _Iter, class _Tester> struct __test_iter_concept
    : _IsValidExpansion<_Tester::template _Apply, _Iter>,
      _Tester
{
};

template <class _Iter>
struct __iter_concept_cache {
  using type = _Or<
    __test_iter_concept<_Iter, __iter_concept_concept_test>,
    __test_iter_concept<_Iter, __iter_concept_category_test>,
    __test_iter_concept<_Iter, __iter_concept_random_fallback>
  >;
};

template <class _Iter>
using _ITER_CONCEPT = typename __iter_concept_cache<_Iter>::type::template _Apply<_Iter>;


template <class _Tp>
struct __has_iterator_typedefs
{
private:
    template <class _Up> static false_type __test(...);
    template <class _Up> static true_type __test(__void_t<typename _Up::iterator_category>* = nullptr,
                                                 __void_t<typename _Up::difference_type>* = nullptr,
                                                 __void_t<typename _Up::value_type>* = nullptr,
                                                 __void_t<typename _Up::reference>* = nullptr,
                                                 __void_t<typename _Up::pointer>* = nullptr);
public:
    static const bool value = decltype(__test<_Tp>(0,0,0,0,0))::value;
};


template <class _Tp>
struct __has_iterator_category
{
private:
    template <class _Up> static false_type __test(...);
    template <class _Up> static true_type __test(typename _Up::iterator_category* = nullptr);
public:
    static const bool value = decltype(__test<_Tp>(nullptr))::value;
};

template <class _Tp>
struct __has_iterator_concept
{
private:
    template <class _Up> static false_type __test(...);
    template <class _Up> static true_type __test(typename _Up::iterator_concept* = nullptr);
public:
    static const bool value = decltype(__test<_Tp>(nullptr))::value;
};






namespace __iterator_traits_detail {
template<class _Ip>
concept __cpp17_iterator =
  requires(_Ip __i) {
    { *__i } -> __can_reference;
    { ++__i } -> same_as<_Ip&>;
    { *__i++ } -> __can_reference;
  } &&
  copyable<_Ip>;

template<class _Ip>
concept __cpp17_input_iterator =
  __cpp17_iterator<_Ip> &&
  equality_comparable<_Ip> &&
  requires(_Ip __i) {
    typename incrementable_traits<_Ip>::difference_type;
    typename indirectly_readable_traits<_Ip>::value_type;
    typename common_reference_t<iter_reference_t<_Ip>&&,
                                typename indirectly_readable_traits<_Ip>::value_type&>;
    typename common_reference_t<decltype(*__i++)&&,
                                typename indirectly_readable_traits<_Ip>::value_type&>;
    requires signed_integral<typename incrementable_traits<_Ip>::difference_type>;
  };

template<class _Ip>
concept __cpp17_forward_iterator =
  __cpp17_input_iterator<_Ip> &&
  constructible_from<_Ip> &&
  is_reference_v<iter_reference_t<_Ip>> &&
  same_as<remove_cvref_t<iter_reference_t<_Ip>>,
          typename indirectly_readable_traits<_Ip>::value_type> &&
  requires(_Ip __i) {
    { __i++ } -> convertible_to<_Ip const&>;
    { *__i++ } -> same_as<iter_reference_t<_Ip>>;
  };

template<class _Ip>
concept __cpp17_bidirectional_iterator =
  __cpp17_forward_iterator<_Ip> &&
  requires(_Ip __i) {
    { --__i } -> same_as<_Ip&>;
    { __i-- } -> convertible_to<_Ip const&>;
    { *__i-- } -> same_as<iter_reference_t<_Ip>>;
  };

template<class _Ip>
concept __cpp17_random_access_iterator =
  __cpp17_bidirectional_iterator<_Ip> &&
  totally_ordered<_Ip> &&
  requires(_Ip __i, typename incrementable_traits<_Ip>::difference_type __n) {
    { __i += __n } -> same_as<_Ip&>;
    { __i -= __n } -> same_as<_Ip&>;
    { __i + __n } -> same_as<_Ip>;
    { __n + __i } -> same_as<_Ip>;
    { __i - __n } -> same_as<_Ip>;
    { __i - __i } -> same_as<decltype(__n)>;
    { __i[__n] } -> convertible_to<iter_reference_t<_Ip>>;
  };
}

template<class _Ip>
concept __has_member_reference = requires { typename _Ip::reference; };

template<class _Ip>
concept __has_member_pointer = requires { typename _Ip::pointer; };

template<class _Ip>
concept __has_member_iterator_category = requires { typename _Ip::iterator_category; };

template<class _Ip>
concept __specifies_members = requires {
    typename _Ip::value_type;
    typename _Ip::difference_type;
    requires __has_member_reference<_Ip>;
    requires __has_member_iterator_category<_Ip>;
  };

template<class>
struct __iterator_traits_member_pointer_or_void {
  using type = void;
};

template<__has_member_pointer _Tp>
struct __iterator_traits_member_pointer_or_void<_Tp> {
  using type = typename _Tp::pointer;
};

template<class _Tp>
concept __cpp17_iterator_missing_members =
  !__specifies_members<_Tp> &&
  __iterator_traits_detail::__cpp17_iterator<_Tp>;

template<class _Tp>
concept __cpp17_input_iterator_missing_members =
  __cpp17_iterator_missing_members<_Tp> &&
  __iterator_traits_detail::__cpp17_input_iterator<_Tp>;


template<class>
struct __iterator_traits_member_pointer_or_arrow_or_void { using type = void; };



template<__has_member_pointer _Ip>
struct __iterator_traits_member_pointer_or_arrow_or_void<_Ip> { using type = typename _Ip::pointer; };



template<class _Ip>
  requires requires(_Ip& __i) { __i.operator->(); } && (!__has_member_pointer<_Ip>)
struct __iterator_traits_member_pointer_or_arrow_or_void<_Ip> {
  using type = decltype(std::declval<_Ip&>().operator->());
};


template<class _Ip>
struct __iterator_traits_member_reference { using type = iter_reference_t<_Ip>; };



template<__has_member_reference _Ip>
struct __iterator_traits_member_reference<_Ip> { using type = typename _Ip::reference; };



template<class _Ip>
struct __deduce_iterator_category {
  using type = input_iterator_tag;
};



template<__iterator_traits_detail::__cpp17_random_access_iterator _Ip>
struct __deduce_iterator_category<_Ip> {
  using type = random_access_iterator_tag;
};



template<__iterator_traits_detail::__cpp17_bidirectional_iterator _Ip>
struct __deduce_iterator_category<_Ip> {
  using type = bidirectional_iterator_tag;
};



template<__iterator_traits_detail::__cpp17_forward_iterator _Ip>
struct __deduce_iterator_category<_Ip> {
  using type = forward_iterator_tag;
};

template<class _Ip>
struct __iterator_traits_iterator_category : __deduce_iterator_category<_Ip> {};




template<__has_member_iterator_category _Ip>
struct __iterator_traits_iterator_category<_Ip> {
  using type = typename _Ip::iterator_category;
};


template<class>
struct __iterator_traits_difference_type { using type = void; };



template<class _Ip>
requires requires { typename incrementable_traits<_Ip>::difference_type; }
struct __iterator_traits_difference_type<_Ip> {
  using type = typename incrementable_traits<_Ip>::difference_type;
};



template<class>
struct __iterator_traits {};




template<__specifies_members _Ip>
struct __iterator_traits<_Ip> {
  using iterator_category = typename _Ip::iterator_category;
  using value_type = typename _Ip::value_type;
  using difference_type = typename _Ip::difference_type;
  using pointer = typename __iterator_traits_member_pointer_or_void<_Ip>::type;
  using reference = typename _Ip::reference;
};




template<__cpp17_input_iterator_missing_members _Ip>
struct __iterator_traits<_Ip> {
  using iterator_category = typename __iterator_traits_iterator_category<_Ip>::type;
  using value_type = typename indirectly_readable_traits<_Ip>::value_type;
  using difference_type = typename incrementable_traits<_Ip>::difference_type;
  using pointer = typename __iterator_traits_member_pointer_or_arrow_or_void<_Ip>::type;
  using reference = typename __iterator_traits_member_reference<_Ip>::type;
};



template<__cpp17_iterator_missing_members _Ip>
struct __iterator_traits<_Ip> {
  using iterator_category = output_iterator_tag;
  using value_type = void;
  using difference_type = typename __iterator_traits_difference_type<_Ip>::type;
  using pointer = void;
  using reference = void;
};

template<class _Ip>
struct iterator_traits : __iterator_traits<_Ip> {
  using __primary_template = iterator_traits;
};
# 423 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__iterator/iterator_traits.h" 3
template<class _Tp>

requires is_object_v<_Tp>

struct iterator_traits<_Tp*>
{
    typedef ptrdiff_t difference_type;
    typedef __remove_cv_t<_Tp> value_type;
    typedef _Tp* pointer;
    typedef _Tp& reference;
    typedef random_access_iterator_tag iterator_category;

    typedef contiguous_iterator_tag iterator_concept;

};

template <class _Tp, class _Up, bool = __has_iterator_category<iterator_traits<_Tp> >::value>
struct __has_iterator_category_convertible_to
    : is_convertible<typename iterator_traits<_Tp>::iterator_category, _Up>
{};

template <class _Tp, class _Up>
struct __has_iterator_category_convertible_to<_Tp, _Up, false> : false_type {};

template <class _Tp, class _Up, bool = __has_iterator_concept<_Tp>::value>
struct __has_iterator_concept_convertible_to
    : is_convertible<typename _Tp::iterator_concept, _Up>
{};

template <class _Tp, class _Up>
struct __has_iterator_concept_convertible_to<_Tp, _Up, false> : false_type {};

template <class _Tp>
using __has_input_iterator_category = __has_iterator_category_convertible_to<_Tp, input_iterator_tag>;

template <class _Tp>
using __has_forward_iterator_category = __has_iterator_category_convertible_to<_Tp, forward_iterator_tag>;

template <class _Tp>
using __has_bidirectional_iterator_category = __has_iterator_category_convertible_to<_Tp, bidirectional_iterator_tag>;

template <class _Tp>
using __has_random_access_iterator_category = __has_iterator_category_convertible_to<_Tp, random_access_iterator_tag>;
# 475 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__iterator/iterator_traits.h" 3
template <class _Tp>
struct __libcpp_is_contiguous_iterator : _Or<
    __has_iterator_category_convertible_to<_Tp, contiguous_iterator_tag>,
    __has_iterator_concept_convertible_to<_Tp, contiguous_iterator_tag>
> {};






template <class _Up>
struct __libcpp_is_contiguous_iterator<_Up*> : true_type {};


template <class _Iter>
class __wrap_iter;

template <class _Tp>
using __has_exactly_input_iterator_category
    = integral_constant<bool,
         __has_iterator_category_convertible_to<_Tp, input_iterator_tag>::value &&
        !__has_iterator_category_convertible_to<_Tp, forward_iterator_tag>::value>;

template <class _Tp>
using __has_exactly_forward_iterator_category
    = integral_constant<bool,
         __has_iterator_category_convertible_to<_Tp, forward_iterator_tag>::value &&
        !__has_iterator_category_convertible_to<_Tp, bidirectional_iterator_tag>::value>;

template <class _Tp>
using __has_exactly_bidirectional_iterator_category
    = integral_constant<bool,
         __has_iterator_category_convertible_to<_Tp, bidirectional_iterator_tag>::value &&
        !__has_iterator_category_convertible_to<_Tp, random_access_iterator_tag>::value>;

template<class _InputIterator>
using __iter_value_type = typename iterator_traits<_InputIterator>::value_type;

template<class _InputIterator>
using __iter_key_type = __remove_const_t<typename iterator_traits<_InputIterator>::value_type::first_type>;

template<class _InputIterator>
using __iter_mapped_type = typename iterator_traits<_InputIterator>::value_type::second_type;

template<class _InputIterator>
using __iter_to_alloc_type = pair<
    typename add_const<typename iterator_traits<_InputIterator>::value_type::first_type>::type,
    typename iterator_traits<_InputIterator>::value_type::second_type>;

template <class _Iter>
using __iterator_category_type = typename iterator_traits<_Iter>::iterator_category;

template <class _Iter>
using __iterator_pointer_type = typename iterator_traits<_Iter>::pointer;

template <class _Iter>
using __iter_diff_t = typename iterator_traits<_Iter>::difference_type;

template <class _Iter>
using __iter_reference = typename iterator_traits<_Iter>::reference;
# 545 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__iterator/iterator_traits.h" 3
template <class _Ip>
using iter_value_t = typename conditional_t<__is_primary_template<iterator_traits<remove_cvref_t<_Ip> > >::value,
                                            indirectly_readable_traits<remove_cvref_t<_Ip> >,
                                            iterator_traits<remove_cvref_t<_Ip> > >::value_type;



}}
# 16 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__iterator/iter_move.h" 2 3
# 24 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__iterator/iter_move.h" 3



# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__undef_macros" 1 3
# 28 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__iterator/iter_move.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {





namespace ranges {
namespace __iter_move {

void iter_move();

template <class _Tp>
concept __unqualified_iter_move =
  __class_or_enum<remove_cvref_t<_Tp>> &&
  requires (_Tp&& __t) {

    iter_move(std::forward<_Tp>(__t));
  };

template<class _Tp>
concept __move_deref =
  !__unqualified_iter_move<_Tp> &&
  requires (_Tp&& __t) {
    *__t;
    requires is_lvalue_reference_v<decltype(*__t)>;
  };

template<class _Tp>
concept __just_deref =
  !__unqualified_iter_move<_Tp> &&
  !__move_deref<_Tp> &&
  requires (_Tp&& __t) {
    *__t;
    requires (!is_lvalue_reference_v<decltype(*__t)>);
  };



struct __fn {

  template<class _Ip>
    requires __unqualified_iter_move<_Ip>
  [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr decltype(auto) operator()(_Ip&& __i) const
    noexcept(noexcept(iter_move(std::forward<_Ip>(__i))))
  {
    return iter_move(std::forward<_Ip>(__i));
  }


  template<class _Ip>
    requires __move_deref<_Ip>
  [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr auto operator()(_Ip&& __i) const
    noexcept(noexcept(std::move(*std::forward<_Ip>(__i))))
    -> decltype( std::move(*std::forward<_Ip>(__i)))
    { return std::move(*std::forward<_Ip>(__i)); }

  template<class _Ip>
    requires __just_deref<_Ip>
  [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr auto operator()(_Ip&& __i) const
    noexcept(noexcept(*std::forward<_Ip>(__i)))
    -> decltype( *std::forward<_Ip>(__i))
    { return *std::forward<_Ip>(__i); }
};
}

inline namespace __cpo {
  inline constexpr auto iter_move = __iter_move::__fn{};
}
}

template<__dereferenceable _Tp>
  requires requires(_Tp& __t) { { ranges::iter_move(__t) } -> __can_reference; }
using iter_rvalue_reference_t = decltype(ranges::iter_move(std::declval<_Tp&>()));



}}
# 32 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__iterator/concepts.h" 2 3


# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__memory/pointer_traits.h" 1 3
# 14 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__memory/pointer_traits.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__memory/addressof.h" 1 3
# 17 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__memory/addressof.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Tp>
inline constexpr
__attribute__((__no_sanitize__("cfi"))) __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
_Tp*
addressof(_Tp& __x) noexcept
{
    return __builtin_addressof(__x);
}
# 71 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__memory/addressof.h" 3
template <class _Tp> _Tp* addressof(const _Tp&&) noexcept = delete;


}}
# 15 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__memory/pointer_traits.h" 2 3

# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/conjunction.h" 1 3
# 19 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/conjunction.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class...>
using __expand_to_true = true_type;

template <class... _Pred>
__expand_to_true<__enable_if_t<_Pred::value>...> __and_helper(int);

template <class...>
false_type __and_helper(...);






template <class... _Pred>
using _And __attribute__((__nodebug__)) = decltype(std::__and_helper<_Pred...>(0));



template <class...>
struct conjunction : true_type {};

template <class _Arg>
struct conjunction<_Arg> : _Arg {};

template <class _Arg, class... _Args>
struct conjunction<_Arg, _Args...> : conditional_t<!bool(_Arg::value), _Arg, conjunction<_Args...>> {};

template <class... _Args>
inline constexpr bool conjunction_v = conjunction<_Args...>::value;



}}
# 17 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__memory/pointer_traits.h" 2 3
# 27 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__memory/pointer_traits.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Tp, class = void>
struct __has_element_type : false_type {};

template <class _Tp>
struct __has_element_type<_Tp, __void_t<typename _Tp::element_type> > : true_type {};

template <class _Ptr, bool = __has_element_type<_Ptr>::value>
struct __pointer_traits_element_type {};

template <class _Ptr>
struct __pointer_traits_element_type<_Ptr, true>
{
    typedef __attribute__((__nodebug__)) typename _Ptr::element_type type;
};

template <template <class, class...> class _Sp, class _Tp, class ..._Args>
struct __pointer_traits_element_type<_Sp<_Tp, _Args...>, true>
{
    typedef __attribute__((__nodebug__)) typename _Sp<_Tp, _Args...>::element_type type;
};

template <template <class, class...> class _Sp, class _Tp, class ..._Args>
struct __pointer_traits_element_type<_Sp<_Tp, _Args...>, false>
{
    typedef __attribute__((__nodebug__)) _Tp type;
};

template <class _Tp, class = void>
struct __has_difference_type : false_type {};

template <class _Tp>
struct __has_difference_type<_Tp, __void_t<typename _Tp::difference_type> > : true_type {};

template <class _Ptr, bool = __has_difference_type<_Ptr>::value>
struct __pointer_traits_difference_type
{
    typedef __attribute__((__nodebug__)) ptrdiff_t type;
};

template <class _Ptr>
struct __pointer_traits_difference_type<_Ptr, true>
{
    typedef __attribute__((__nodebug__)) typename _Ptr::difference_type type;
};

template <class _Tp, class _Up>
struct __has_rebind
{
private:
    template <class _Xp> static false_type __test(...);
#pragma GCC diagnostic push
# 81 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__memory/pointer_traits.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
# 81 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__memory/pointer_traits.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
    template <class _Xp> static true_type __test(typename _Xp::template rebind<_Up>* = 0);
#pragma GCC diagnostic pop
public:
    static const bool value = decltype(__test<_Tp>(0))::value;
};

template <class _Tp, class _Up, bool = __has_rebind<_Tp, _Up>::value>
struct __pointer_traits_rebind
{

    typedef __attribute__((__nodebug__)) typename _Tp::template rebind<_Up> type;



};

template <template <class, class...> class _Sp, class _Tp, class ..._Args, class _Up>
struct __pointer_traits_rebind<_Sp<_Tp, _Args...>, _Up, true>
{

    typedef __attribute__((__nodebug__)) typename _Sp<_Tp, _Args...>::template rebind<_Up> type;



};

template <template <class, class...> class _Sp, class _Tp, class ..._Args, class _Up>
struct __pointer_traits_rebind<_Sp<_Tp, _Args...>, _Up, false>
{
    typedef _Sp<_Up, _Args...> type;
};

template <class _Ptr, class = void>
struct __pointer_traits_impl {};

template <class _Ptr>
struct __pointer_traits_impl<_Ptr, __void_t<typename __pointer_traits_element_type<_Ptr>::type> > {
  typedef _Ptr pointer;
  typedef typename __pointer_traits_element_type<pointer>::type element_type;
  typedef typename __pointer_traits_difference_type<pointer>::type difference_type;


    template <class _Up> using rebind = typename __pointer_traits_rebind<pointer, _Up>::type;





private:
    struct __nat {};
public:
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    static pointer pointer_to(__conditional_t<is_void<element_type>::value, __nat, element_type>& __r)
        {return pointer::pointer_to(__r);}
};

template <class _Ptr>
struct pointer_traits : __pointer_traits_impl<_Ptr> {};

template <class _Tp>
struct pointer_traits<_Tp*>
{
    typedef _Tp* pointer;
    typedef _Tp element_type;
    typedef ptrdiff_t difference_type;


    template <class _Up> using rebind = _Up*;




private:
    struct __nat {};
public:
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    static pointer pointer_to(__conditional_t<is_void<element_type>::value, __nat, element_type>& __r) noexcept
        {return std::addressof(__r);}
};


template <class _From, class _To>
using __rebind_pointer_t = typename pointer_traits<_From>::template rebind<_To>;







template <class _Pointer, class = void>
struct __to_address_helper;

template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
_Tp* __to_address(_Tp* __p) noexcept {
    static_assert(!is_function<_Tp>::value, "_Tp is a function type");
    return __p;
}

template <class _Pointer, class = void>
struct _HasToAddress : false_type {};

template <class _Pointer>
struct _HasToAddress<_Pointer,
    decltype((void)pointer_traits<_Pointer>::to_address(std::declval<const _Pointer&>()))
> : true_type {};

template <class _Pointer, class = void>
struct _HasArrow : false_type {};

template <class _Pointer>
struct _HasArrow<_Pointer,
    decltype((void)std::declval<const _Pointer&>().operator->())
> : true_type {};

template <class _Pointer>
struct _IsFancyPointer {
  static const bool value = _HasArrow<_Pointer>::value || _HasToAddress<_Pointer>::value;
};


template <class _Pointer, class = __enable_if_t<
    _And<is_class<_Pointer>, _IsFancyPointer<_Pointer> >::value
> >
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
__decay_t<decltype(__to_address_helper<_Pointer>::__call(std::declval<const _Pointer&>()))>
__to_address(const _Pointer& __p) noexcept {
    return __to_address_helper<_Pointer>::__call(__p);
}

template <class _Pointer, class>
struct __to_address_helper {
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    static decltype(std::__to_address(std::declval<const _Pointer&>().operator->()))
    __call(const _Pointer& __p) noexcept {
        return std::__to_address(__p.operator->());
    }
};

template <class _Pointer>
struct __to_address_helper<_Pointer, decltype((void)pointer_traits<_Pointer>::to_address(std::declval<const _Pointer&>()))> {
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    static decltype(pointer_traits<_Pointer>::to_address(std::declval<const _Pointer&>()))
    __call(const _Pointer& __p) noexcept {
        return pointer_traits<_Pointer>::to_address(__p);
    }
};


template <class _Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
auto to_address(_Tp *__p) noexcept {
    return std::__to_address(__p);
}

template <class _Pointer>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
auto to_address(const _Pointer& __p) noexcept -> decltype(std::__to_address(__p)) {
    return std::__to_address(__p);
}


}}
# 35 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__iterator/concepts.h" 2 3
# 45 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__iterator/concepts.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {




template<class _In>
concept __indirectly_readable_impl =
  requires(const _In __i) {
    typename iter_value_t<_In>;
    typename iter_reference_t<_In>;
    typename iter_rvalue_reference_t<_In>;
    { *__i } -> same_as<iter_reference_t<_In>>;
    { ranges::iter_move(__i) } -> same_as<iter_rvalue_reference_t<_In>>;
  } &&
  common_reference_with<iter_reference_t<_In>&&, iter_value_t<_In>&> &&
  common_reference_with<iter_reference_t<_In>&&, iter_rvalue_reference_t<_In>&&> &&
  common_reference_with<iter_rvalue_reference_t<_In>&&, const iter_value_t<_In>&>;

template<class _In>
concept indirectly_readable = __indirectly_readable_impl<remove_cvref_t<_In>>;

template<indirectly_readable _Tp>
using iter_common_reference_t = common_reference_t<iter_reference_t<_Tp>, iter_value_t<_Tp>&>;


template<class _Out, class _Tp>
concept indirectly_writable =
  requires(_Out&& __o, _Tp&& __t) {
    *__o = std::forward<_Tp>(__t);
    *std::forward<_Out>(__o) = std::forward<_Tp>(__t);
    const_cast<const iter_reference_t<_Out>&&>(*__o) = std::forward<_Tp>(__t);
    const_cast<const iter_reference_t<_Out>&&>(*std::forward<_Out>(__o)) = std::forward<_Tp>(__t);
  };


template<class _Tp>
concept __integer_like = integral<_Tp> && !same_as<_Tp, bool>;

template<class _Tp>
concept __signed_integer_like = signed_integral<_Tp>;

template<class _Ip>
concept weakly_incrementable =

  !same_as<_Ip, bool> &&
  movable<_Ip> &&
  requires(_Ip __i) {
    typename iter_difference_t<_Ip>;
    requires __signed_integer_like<iter_difference_t<_Ip>>;
    { ++__i } -> same_as<_Ip&>;
    __i++;
  };


template<class _Ip>
concept incrementable =
  regular<_Ip> &&
  weakly_incrementable<_Ip> &&
  requires(_Ip __i) {
    { __i++ } -> same_as<_Ip>;
  };


template<class _Ip>
concept input_or_output_iterator =
  requires(_Ip __i) {
    { *__i } -> __can_reference;
  } &&
  weakly_incrementable<_Ip>;


template<class _Sp, class _Ip>
concept sentinel_for =
  semiregular<_Sp> &&
  input_or_output_iterator<_Ip> &&
  __weakly_equality_comparable_with<_Sp, _Ip>;

template<class, class>
inline constexpr bool disable_sized_sentinel_for = false;

template<class _Sp, class _Ip>
concept sized_sentinel_for =
  sentinel_for<_Sp, _Ip> &&
  !disable_sized_sentinel_for<remove_cv_t<_Sp>, remove_cv_t<_Ip>> &&
  requires(const _Ip& __i, const _Sp& __s) {
    { __s - __i } -> same_as<iter_difference_t<_Ip>>;
    { __i - __s } -> same_as<iter_difference_t<_Ip>>;
  };


template<class _Ip>
concept input_iterator =
  input_or_output_iterator<_Ip> &&
  indirectly_readable<_Ip> &&
  requires { typename _ITER_CONCEPT<_Ip>; } &&
  derived_from<_ITER_CONCEPT<_Ip>, input_iterator_tag>;


template<class _Ip, class _Tp>
concept output_iterator =
  input_or_output_iterator<_Ip> &&
  indirectly_writable<_Ip, _Tp> &&
  requires (_Ip __it, _Tp&& __t) {
    *__it++ = std::forward<_Tp>(__t);
  };


template<class _Ip>
concept forward_iterator =
  input_iterator<_Ip> &&
  derived_from<_ITER_CONCEPT<_Ip>, forward_iterator_tag> &&
  incrementable<_Ip> &&
  sentinel_for<_Ip, _Ip>;


template<class _Ip>
concept bidirectional_iterator =
  forward_iterator<_Ip> &&
  derived_from<_ITER_CONCEPT<_Ip>, bidirectional_iterator_tag> &&
  requires(_Ip __i) {
    { --__i } -> same_as<_Ip&>;
    { __i-- } -> same_as<_Ip>;
  };

template<class _Ip>
concept random_access_iterator =
  bidirectional_iterator<_Ip> &&
  derived_from<_ITER_CONCEPT<_Ip>, random_access_iterator_tag> &&
  totally_ordered<_Ip> &&
  sized_sentinel_for<_Ip, _Ip> &&
  requires(_Ip __i, const _Ip __j, const iter_difference_t<_Ip> __n) {
    { __i += __n } -> same_as<_Ip&>;
    { __j + __n } -> same_as<_Ip>;
    { __n + __j } -> same_as<_Ip>;
    { __i -= __n } -> same_as<_Ip&>;
    { __j - __n } -> same_as<_Ip>;
    { __j[__n] } -> same_as<iter_reference_t<_Ip>>;
  };

template<class _Ip>
concept contiguous_iterator =
  random_access_iterator<_Ip> &&
  derived_from<_ITER_CONCEPT<_Ip>, contiguous_iterator_tag> &&
  is_lvalue_reference_v<iter_reference_t<_Ip>> &&
  same_as<iter_value_t<_Ip>, remove_cvref_t<iter_reference_t<_Ip>>> &&
  requires(const _Ip& __i) {
    { std::to_address(__i) } -> same_as<add_pointer_t<iter_reference_t<_Ip>>>;
  };

template<class _Ip>
concept __has_arrow = input_iterator<_Ip> && (is_pointer_v<_Ip> || requires(_Ip __i) { __i.operator->(); });


template<class _Fp, class _It>
concept indirectly_unary_invocable =
  indirectly_readable<_It> &&
  copy_constructible<_Fp> &&
  invocable<_Fp&, iter_value_t<_It>&> &&
  invocable<_Fp&, iter_reference_t<_It>> &&
  invocable<_Fp&, iter_common_reference_t<_It>> &&
  common_reference_with<
    invoke_result_t<_Fp&, iter_value_t<_It>&>,
    invoke_result_t<_Fp&, iter_reference_t<_It>>>;

template<class _Fp, class _It>
concept indirectly_regular_unary_invocable =
  indirectly_readable<_It> &&
  copy_constructible<_Fp> &&
  regular_invocable<_Fp&, iter_value_t<_It>&> &&
  regular_invocable<_Fp&, iter_reference_t<_It>> &&
  regular_invocable<_Fp&, iter_common_reference_t<_It>> &&
  common_reference_with<
    invoke_result_t<_Fp&, iter_value_t<_It>&>,
    invoke_result_t<_Fp&, iter_reference_t<_It>>>;

template<class _Fp, class _It>
concept indirect_unary_predicate =
  indirectly_readable<_It> &&
  copy_constructible<_Fp> &&
  predicate<_Fp&, iter_value_t<_It>&> &&
  predicate<_Fp&, iter_reference_t<_It>> &&
  predicate<_Fp&, iter_common_reference_t<_It>>;

template<class _Fp, class _It1, class _It2>
concept indirect_binary_predicate =
  indirectly_readable<_It1> && indirectly_readable<_It2> &&
  copy_constructible<_Fp> &&
  predicate<_Fp&, iter_value_t<_It1>&, iter_value_t<_It2>&> &&
  predicate<_Fp&, iter_value_t<_It1>&, iter_reference_t<_It2>> &&
  predicate<_Fp&, iter_reference_t<_It1>, iter_value_t<_It2>&> &&
  predicate<_Fp&, iter_reference_t<_It1>, iter_reference_t<_It2>> &&
  predicate<_Fp&, iter_common_reference_t<_It1>, iter_common_reference_t<_It2>>;

template<class _Fp, class _It1, class _It2 = _It1>
concept indirect_equivalence_relation =
  indirectly_readable<_It1> && indirectly_readable<_It2> &&
  copy_constructible<_Fp> &&
  equivalence_relation<_Fp&, iter_value_t<_It1>&, iter_value_t<_It2>&> &&
  equivalence_relation<_Fp&, iter_value_t<_It1>&, iter_reference_t<_It2>> &&
  equivalence_relation<_Fp&, iter_reference_t<_It1>, iter_value_t<_It2>&> &&
  equivalence_relation<_Fp&, iter_reference_t<_It1>, iter_reference_t<_It2>> &&
  equivalence_relation<_Fp&, iter_common_reference_t<_It1>, iter_common_reference_t<_It2>>;

template<class _Fp, class _It1, class _It2 = _It1>
concept indirect_strict_weak_order =
  indirectly_readable<_It1> && indirectly_readable<_It2> &&
  copy_constructible<_Fp> &&
  strict_weak_order<_Fp&, iter_value_t<_It1>&, iter_value_t<_It2>&> &&
  strict_weak_order<_Fp&, iter_value_t<_It1>&, iter_reference_t<_It2>> &&
  strict_weak_order<_Fp&, iter_reference_t<_It1>, iter_value_t<_It2>&> &&
  strict_weak_order<_Fp&, iter_reference_t<_It1>, iter_reference_t<_It2>> &&
  strict_weak_order<_Fp&, iter_common_reference_t<_It1>, iter_common_reference_t<_It2>>;

template<class _Fp, class... _Its>
  requires (indirectly_readable<_Its> && ...) && invocable<_Fp, iter_reference_t<_Its>...>
using indirect_result_t = invoke_result_t<_Fp, iter_reference_t<_Its>...>;

template<class _In, class _Out>
concept indirectly_movable =
  indirectly_readable<_In> &&
  indirectly_writable<_Out, iter_rvalue_reference_t<_In>>;

template<class _In, class _Out>
concept indirectly_movable_storable =
  indirectly_movable<_In, _Out> &&
  indirectly_writable<_Out, iter_value_t<_In>> &&
  movable<iter_value_t<_In>> &&
  constructible_from<iter_value_t<_In>, iter_rvalue_reference_t<_In>> &&
  assignable_from<iter_value_t<_In>&, iter_rvalue_reference_t<_In>>;

template<class _In, class _Out>
concept indirectly_copyable =
  indirectly_readable<_In> &&
  indirectly_writable<_Out, iter_reference_t<_In>>;

template<class _In, class _Out>
concept indirectly_copyable_storable =
  indirectly_copyable<_In, _Out> &&
  indirectly_writable<_Out, iter_value_t<_In>&> &&
  indirectly_writable<_Out, const iter_value_t<_In>&> &&
  indirectly_writable<_Out, iter_value_t<_In>&&> &&
  indirectly_writable<_Out, const iter_value_t<_In>&&> &&
  copyable<iter_value_t<_In>> &&
  constructible_from<iter_value_t<_In>, iter_reference_t<_In>> &&
  assignable_from<iter_value_t<_In>&, iter_reference_t<_In>>;






template <class _Tp>
using __has_random_access_iterator_category_or_concept

  = integral_constant<bool, random_access_iterator<_Tp>>;




}}
# 14 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_iterator_concept.h" 2 3
# 19 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_iterator_concept.h" 3




namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

namespace ranges {

template <class _IterMaybeQualified>
consteval auto __get_iterator_concept() {
  using _Iter = __remove_cvref_t<_IterMaybeQualified>;

  if constexpr (contiguous_iterator<_Iter>)
    return contiguous_iterator_tag();
  else if constexpr (random_access_iterator<_Iter>)
    return random_access_iterator_tag();
  else if constexpr (bidirectional_iterator<_Iter>)
    return bidirectional_iterator_tag();
  else if constexpr (forward_iterator<_Iter>)
    return forward_iterator_tag();
  else if constexpr (input_iterator<_Iter>)
    return input_iterator_tag();
}

template <class _Iter>
using __iterator_concept = decltype(__get_iterator_concept<_Iter>());

}
}}
# 14 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/iterator_operations.h" 2 3

# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__iterator/advance.h" 1 3
# 22 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__iterator/advance.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__utility/convert_to_integral.h" 1 3
# 16 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__utility/convert_to_integral.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/underlying_type.h" 1 3
# 17 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/underlying_type.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Tp, bool = is_enum<_Tp>::value>
struct __underlying_type_impl;

template <class _Tp>
struct __underlying_type_impl<_Tp, false> {};

template <class _Tp>
struct __underlying_type_impl<_Tp, true> {
  typedef __underlying_type(_Tp) type;
};

template <class _Tp>
struct underlying_type : __underlying_type_impl<_Tp, is_enum<_Tp>::value> {};


template <class _Tp>
using underlying_type_t = typename underlying_type<_Tp>::type;


}}
# 17 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__utility/convert_to_integral.h" 2 3
# 20 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__utility/convert_to_integral.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
int __convert_to_integral(int __val) { return __val; }

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
unsigned __convert_to_integral(unsigned __val) { return __val; }

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
long __convert_to_integral(long __val) { return __val; }

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
unsigned long __convert_to_integral(unsigned long __val) { return __val; }

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
long long __convert_to_integral(long long __val) { return __val; }

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
unsigned long long __convert_to_integral(unsigned long long __val) {return __val; }

template<typename _Fp, __enable_if_t<is_floating_point<_Fp>::value, int> = 0>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
long long
 __convert_to_integral(_Fp __val) { return __val; }


inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
__int128_t __convert_to_integral(__int128_t __val) { return __val; }

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
__uint128_t __convert_to_integral(__uint128_t __val) { return __val; }


template <class _Tp, bool = is_enum<_Tp>::value>
struct __sfinae_underlying_type
{
    typedef typename underlying_type<_Tp>::type type;
    typedef decltype(((type)1) + 0) __promoted_type;
};

template <class _Tp>
struct __sfinae_underlying_type<_Tp, false> {};

template <class _Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
typename __sfinae_underlying_type<_Tp>::__promoted_type
__convert_to_integral(_Tp __val) { return __val; }

}}
# 23 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__iterator/advance.h" 2 3


# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__utility/unreachable.h" 1 3
# 17 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__utility/unreachable.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

[[noreturn]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) inline void __libcpp_unreachable() {
    ((void)0);
    __builtin_unreachable();
}



[[noreturn]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) inline void unreachable() { __libcpp_unreachable(); }



}}
# 26 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__iterator/advance.h" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/limits" 1 3
# 113 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/limits" 3



# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__undef_macros" 1 3
# 117 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/limits" 2 3



namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

enum float_round_style
{
    round_indeterminate = -1,
    round_toward_zero = 0,
    round_to_nearest = 1,
    round_toward_infinity = 2,
    round_toward_neg_infinity = 3
};

enum float_denorm_style
{
    denorm_indeterminate = -1,
    denorm_absent = 0,
    denorm_present = 1
};

template <class _Tp, bool = is_arithmetic<_Tp>::value>
class __libcpp_numeric_limits
{
protected:
    typedef _Tp type;

    static constexpr const bool is_specialized = false;
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) static constexpr type min() noexcept {return type();}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) static constexpr type max() noexcept {return type();}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) static constexpr type lowest() noexcept {return type();}

    static constexpr const int digits = 0;
    static constexpr const int digits10 = 0;
    static constexpr const int max_digits10 = 0;
    static constexpr const bool is_signed = false;
    static constexpr const bool is_integer = false;
    static constexpr const bool is_exact = false;
    static constexpr const int radix = 0;
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) static constexpr type epsilon() noexcept {return type();}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) static constexpr type round_error() noexcept {return type();}

    static constexpr const int min_exponent = 0;
    static constexpr const int min_exponent10 = 0;
    static constexpr const int max_exponent = 0;
    static constexpr const int max_exponent10 = 0;

    static constexpr const bool has_infinity = false;
    static constexpr const bool has_quiet_NaN = false;
    static constexpr const bool has_signaling_NaN = false;
    static constexpr const float_denorm_style has_denorm = denorm_absent;
    static constexpr const bool has_denorm_loss = false;
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) static constexpr type infinity() noexcept {return type();}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) static constexpr type quiet_NaN() noexcept {return type();}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) static constexpr type signaling_NaN() noexcept {return type();}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) static constexpr type denorm_min() noexcept {return type();}

    static constexpr const bool is_iec559 = false;
    static constexpr const bool is_bounded = false;
    static constexpr const bool is_modulo = false;

    static constexpr const bool traps = false;
    static constexpr const bool tinyness_before = false;
    static constexpr const float_round_style round_style = round_toward_zero;
};

template <class _Tp, int __digits, bool _IsSigned>
struct __libcpp_compute_min
{
    static constexpr const _Tp value = _Tp(_Tp(1) << __digits);
};

template <class _Tp, int __digits>
struct __libcpp_compute_min<_Tp, __digits, false>
{
    static constexpr const _Tp value = _Tp(0);
};

template <class _Tp>
class __libcpp_numeric_limits<_Tp, true>
{
protected:
    typedef _Tp type;

    static constexpr const bool is_specialized = true;

    static constexpr const bool is_signed = type(-1) < type(0);
    static constexpr const int digits = static_cast<int>(sizeof(type) * 8 - is_signed);
    static constexpr const int digits10 = digits * 3 / 10;
    static constexpr const int max_digits10 = 0;
    static constexpr const type __min = __libcpp_compute_min<type, digits, is_signed>::value;
    static constexpr const type __max = is_signed ? type(type(~0) ^ __min) : type(~0);
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) static constexpr type min() noexcept {return __min;}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) static constexpr type max() noexcept {return __max;}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) static constexpr type lowest() noexcept {return min();}

    static constexpr const bool is_integer = true;
    static constexpr const bool is_exact = true;
    static constexpr const int radix = 2;
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) static constexpr type epsilon() noexcept {return type(0);}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) static constexpr type round_error() noexcept {return type(0);}

    static constexpr const int min_exponent = 0;
    static constexpr const int min_exponent10 = 0;
    static constexpr const int max_exponent = 0;
    static constexpr const int max_exponent10 = 0;

    static constexpr const bool has_infinity = false;
    static constexpr const bool has_quiet_NaN = false;
    static constexpr const bool has_signaling_NaN = false;
    static constexpr const float_denorm_style has_denorm = denorm_absent;
    static constexpr const bool has_denorm_loss = false;
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) static constexpr type infinity() noexcept {return type(0);}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) static constexpr type quiet_NaN() noexcept {return type(0);}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) static constexpr type signaling_NaN() noexcept {return type(0);}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) static constexpr type denorm_min() noexcept {return type(0);}

    static constexpr const bool is_iec559 = false;
    static constexpr const bool is_bounded = true;
    static constexpr const bool is_modulo = !std::is_signed<_Tp>::value;



    static constexpr const bool traps = true;



    static constexpr const bool tinyness_before = false;
    static constexpr const float_round_style round_style = round_toward_zero;
};

template <>
class __libcpp_numeric_limits<bool, true>
{
protected:
    typedef bool type;

    static constexpr const bool is_specialized = true;

    static constexpr const bool is_signed = false;
    static constexpr const int digits = 1;
    static constexpr const int digits10 = 0;
    static constexpr const int max_digits10 = 0;
    static constexpr const type __min = false;
    static constexpr const type __max = true;
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) static constexpr type min() noexcept {return __min;}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) static constexpr type max() noexcept {return __max;}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) static constexpr type lowest() noexcept {return min();}

    static constexpr const bool is_integer = true;
    static constexpr const bool is_exact = true;
    static constexpr const int radix = 2;
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) static constexpr type epsilon() noexcept {return type(0);}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) static constexpr type round_error() noexcept {return type(0);}

    static constexpr const int min_exponent = 0;
    static constexpr const int min_exponent10 = 0;
    static constexpr const int max_exponent = 0;
    static constexpr const int max_exponent10 = 0;

    static constexpr const bool has_infinity = false;
    static constexpr const bool has_quiet_NaN = false;
    static constexpr const bool has_signaling_NaN = false;
    static constexpr const float_denorm_style has_denorm = denorm_absent;
    static constexpr const bool has_denorm_loss = false;
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) static constexpr type infinity() noexcept {return type(0);}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) static constexpr type quiet_NaN() noexcept {return type(0);}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) static constexpr type signaling_NaN() noexcept {return type(0);}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) static constexpr type denorm_min() noexcept {return type(0);}

    static constexpr const bool is_iec559 = false;
    static constexpr const bool is_bounded = true;
    static constexpr const bool is_modulo = false;

    static constexpr const bool traps = false;
    static constexpr const bool tinyness_before = false;
    static constexpr const float_round_style round_style = round_toward_zero;
};

template <>
class __libcpp_numeric_limits<float, true>
{
protected:
    typedef float type;

    static constexpr const bool is_specialized = true;

    static constexpr const bool is_signed = true;
    static constexpr const int digits = 24;
    static constexpr const int digits10 = 6;
    static constexpr const int max_digits10 = 2+(digits * 30103l)/100000l;
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) static constexpr type min() noexcept {return 1.17549435e-38F;}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) static constexpr type max() noexcept {return 3.40282347e+38F;}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) static constexpr type lowest() noexcept {return -max();}

    static constexpr const bool is_integer = false;
    static constexpr const bool is_exact = false;
    static constexpr const int radix = 2;
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) static constexpr type epsilon() noexcept {return 1.19209290e-7F;}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) static constexpr type round_error() noexcept {return 0.5F;}

    static constexpr const int min_exponent = (-125);
    static constexpr const int min_exponent10 = (-37);
    static constexpr const int max_exponent = 128;
    static constexpr const int max_exponent10 = 38;

    static constexpr const bool has_infinity = true;
    static constexpr const bool has_quiet_NaN = true;
    static constexpr const bool has_signaling_NaN = true;
    static constexpr const float_denorm_style has_denorm = denorm_present;
    static constexpr const bool has_denorm_loss = false;
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) static constexpr type infinity() noexcept {return __builtin_huge_valf();}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) static constexpr type quiet_NaN() noexcept {return __builtin_nanf("");}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) static constexpr type signaling_NaN() noexcept {return __builtin_nansf("");}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) static constexpr type denorm_min() noexcept {return 1.40129846e-45F;}

    static constexpr const bool is_iec559 = true;
    static constexpr const bool is_bounded = true;
    static constexpr const bool is_modulo = false;

    static constexpr const bool traps = false;



    static constexpr const bool tinyness_before = false;

    static constexpr const float_round_style round_style = round_to_nearest;
};

template <>
class __libcpp_numeric_limits<double, true>
{
protected:
    typedef double type;

    static constexpr const bool is_specialized = true;

    static constexpr const bool is_signed = true;
    static constexpr const int digits = 53;
    static constexpr const int digits10 = 15;
    static constexpr const int max_digits10 = 2+(digits * 30103l)/100000l;
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) static constexpr type min() noexcept {return 2.2250738585072014e-308;}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) static constexpr type max() noexcept {return 1.7976931348623157e+308;}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) static constexpr type lowest() noexcept {return -max();}

    static constexpr const bool is_integer = false;
    static constexpr const bool is_exact = false;
    static constexpr const int radix = 2;
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) static constexpr type epsilon() noexcept {return 2.2204460492503131e-16;}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) static constexpr type round_error() noexcept {return 0.5;}

    static constexpr const int min_exponent = (-1021);
    static constexpr const int min_exponent10 = (-307);
    static constexpr const int max_exponent = 1024;
    static constexpr const int max_exponent10 = 308;

    static constexpr const bool has_infinity = true;
    static constexpr const bool has_quiet_NaN = true;
    static constexpr const bool has_signaling_NaN = true;
    static constexpr const float_denorm_style has_denorm = denorm_present;
    static constexpr const bool has_denorm_loss = false;
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) static constexpr type infinity() noexcept {return __builtin_huge_val();}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) static constexpr type quiet_NaN() noexcept {return __builtin_nan("");}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) static constexpr type signaling_NaN() noexcept {return __builtin_nans("");}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) static constexpr type denorm_min() noexcept {return 4.9406564584124654e-324;}

    static constexpr const bool is_iec559 = true;
    static constexpr const bool is_bounded = true;
    static constexpr const bool is_modulo = false;

    static constexpr const bool traps = false;



    static constexpr const bool tinyness_before = false;

    static constexpr const float_round_style round_style = round_to_nearest;
};

template <>
class __libcpp_numeric_limits<long double, true>
{
protected:
    typedef long double type;

    static constexpr const bool is_specialized = true;

    static constexpr const bool is_signed = true;
    static constexpr const int digits = 53;
    static constexpr const int digits10 = 15;
    static constexpr const int max_digits10 = 2+(digits * 30103l)/100000l;
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) static constexpr type min() noexcept {return 2.2250738585072014e-308L;}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) static constexpr type max() noexcept {return 1.7976931348623157e+308L;}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) static constexpr type lowest() noexcept {return -max();}

    static constexpr const bool is_integer = false;
    static constexpr const bool is_exact = false;
    static constexpr const int radix = 2;
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) static constexpr type epsilon() noexcept {return 2.2204460492503131e-16L;}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) static constexpr type round_error() noexcept {return 0.5L;}

    static constexpr const int min_exponent = (-1021);
    static constexpr const int min_exponent10 = (-307);
    static constexpr const int max_exponent = 1024;
    static constexpr const int max_exponent10 = 308;

    static constexpr const bool has_infinity = true;
    static constexpr const bool has_quiet_NaN = true;
    static constexpr const bool has_signaling_NaN = true;
    static constexpr const float_denorm_style has_denorm = denorm_present;
    static constexpr const bool has_denorm_loss = false;
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) static constexpr type infinity() noexcept {return __builtin_huge_vall();}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) static constexpr type quiet_NaN() noexcept {return __builtin_nanl("");}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) static constexpr type signaling_NaN() noexcept {return __builtin_nansl("");}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) static constexpr type denorm_min() noexcept {return 4.9406564584124654e-324L;}




    static constexpr const bool is_iec559 = true;

    static constexpr const bool is_bounded = true;
    static constexpr const bool is_modulo = false;

    static constexpr const bool traps = false;



    static constexpr const bool tinyness_before = false;

    static constexpr const float_round_style round_style = round_to_nearest;
};

template <class _Tp>
class numeric_limits
    : private __libcpp_numeric_limits<__remove_cv_t<_Tp> >
{
    typedef __libcpp_numeric_limits<__remove_cv_t<_Tp> > __base;
    typedef typename __base::type type;
public:
    static constexpr const bool is_specialized = __base::is_specialized;
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) static constexpr type min() noexcept {return __base::min();}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) static constexpr type max() noexcept {return __base::max();}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) static constexpr type lowest() noexcept {return __base::lowest();}

    static constexpr const int digits = __base::digits;
    static constexpr const int digits10 = __base::digits10;
    static constexpr const int max_digits10 = __base::max_digits10;
    static constexpr const bool is_signed = __base::is_signed;
    static constexpr const bool is_integer = __base::is_integer;
    static constexpr const bool is_exact = __base::is_exact;
    static constexpr const int radix = __base::radix;
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) static constexpr type epsilon() noexcept {return __base::epsilon();}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) static constexpr type round_error() noexcept {return __base::round_error();}

    static constexpr const int min_exponent = __base::min_exponent;
    static constexpr const int min_exponent10 = __base::min_exponent10;
    static constexpr const int max_exponent = __base::max_exponent;
    static constexpr const int max_exponent10 = __base::max_exponent10;

    static constexpr const bool has_infinity = __base::has_infinity;
    static constexpr const bool has_quiet_NaN = __base::has_quiet_NaN;
    static constexpr const bool has_signaling_NaN = __base::has_signaling_NaN;
    static constexpr const float_denorm_style has_denorm = __base::has_denorm;
    static constexpr const bool has_denorm_loss = __base::has_denorm_loss;
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) static constexpr type infinity() noexcept {return __base::infinity();}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) static constexpr type quiet_NaN() noexcept {return __base::quiet_NaN();}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) static constexpr type signaling_NaN() noexcept {return __base::signaling_NaN();}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) static constexpr type denorm_min() noexcept {return __base::denorm_min();}

    static constexpr const bool is_iec559 = __base::is_iec559;
    static constexpr const bool is_bounded = __base::is_bounded;
    static constexpr const bool is_modulo = __base::is_modulo;

    static constexpr const bool traps = __base::traps;
    static constexpr const bool tinyness_before = __base::tinyness_before;
    static constexpr const float_round_style round_style = __base::round_style;
};

template <class _Tp>
    constexpr const bool numeric_limits<_Tp>::is_specialized;
template <class _Tp>
    constexpr const int numeric_limits<_Tp>::digits;
template <class _Tp>
    constexpr const int numeric_limits<_Tp>::digits10;
template <class _Tp>
    constexpr const int numeric_limits<_Tp>::max_digits10;
template <class _Tp>
    constexpr const bool numeric_limits<_Tp>::is_signed;
template <class _Tp>
    constexpr const bool numeric_limits<_Tp>::is_integer;
template <class _Tp>
    constexpr const bool numeric_limits<_Tp>::is_exact;
template <class _Tp>
    constexpr const int numeric_limits<_Tp>::radix;
template <class _Tp>
    constexpr const int numeric_limits<_Tp>::min_exponent;
template <class _Tp>
    constexpr const int numeric_limits<_Tp>::min_exponent10;
template <class _Tp>
    constexpr const int numeric_limits<_Tp>::max_exponent;
template <class _Tp>
    constexpr const int numeric_limits<_Tp>::max_exponent10;
template <class _Tp>
    constexpr const bool numeric_limits<_Tp>::has_infinity;
template <class _Tp>
    constexpr const bool numeric_limits<_Tp>::has_quiet_NaN;
template <class _Tp>
    constexpr const bool numeric_limits<_Tp>::has_signaling_NaN;
template <class _Tp>
    constexpr const float_denorm_style numeric_limits<_Tp>::has_denorm;
template <class _Tp>
    constexpr const bool numeric_limits<_Tp>::has_denorm_loss;
template <class _Tp>
    constexpr const bool numeric_limits<_Tp>::is_iec559;
template <class _Tp>
    constexpr const bool numeric_limits<_Tp>::is_bounded;
template <class _Tp>
    constexpr const bool numeric_limits<_Tp>::is_modulo;
template <class _Tp>
    constexpr const bool numeric_limits<_Tp>::traps;
template <class _Tp>
    constexpr const bool numeric_limits<_Tp>::tinyness_before;
template <class _Tp>
    constexpr const float_round_style numeric_limits<_Tp>::round_style;

template <class _Tp>
class numeric_limits<const _Tp>
    : private numeric_limits<_Tp>
{
    typedef numeric_limits<_Tp> __base;
    typedef _Tp type;
public:
    static constexpr const bool is_specialized = __base::is_specialized;
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) static constexpr type min() noexcept {return __base::min();}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) static constexpr type max() noexcept {return __base::max();}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) static constexpr type lowest() noexcept {return __base::lowest();}

    static constexpr const int digits = __base::digits;
    static constexpr const int digits10 = __base::digits10;
    static constexpr const int max_digits10 = __base::max_digits10;
    static constexpr const bool is_signed = __base::is_signed;
    static constexpr const bool is_integer = __base::is_integer;
    static constexpr const bool is_exact = __base::is_exact;
    static constexpr const int radix = __base::radix;
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) static constexpr type epsilon() noexcept {return __base::epsilon();}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) static constexpr type round_error() noexcept {return __base::round_error();}

    static constexpr const int min_exponent = __base::min_exponent;
    static constexpr const int min_exponent10 = __base::min_exponent10;
    static constexpr const int max_exponent = __base::max_exponent;
    static constexpr const int max_exponent10 = __base::max_exponent10;

    static constexpr const bool has_infinity = __base::has_infinity;
    static constexpr const bool has_quiet_NaN = __base::has_quiet_NaN;
    static constexpr const bool has_signaling_NaN = __base::has_signaling_NaN;
    static constexpr const float_denorm_style has_denorm = __base::has_denorm;
    static constexpr const bool has_denorm_loss = __base::has_denorm_loss;
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) static constexpr type infinity() noexcept {return __base::infinity();}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) static constexpr type quiet_NaN() noexcept {return __base::quiet_NaN();}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) static constexpr type signaling_NaN() noexcept {return __base::signaling_NaN();}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) static constexpr type denorm_min() noexcept {return __base::denorm_min();}

    static constexpr const bool is_iec559 = __base::is_iec559;
    static constexpr const bool is_bounded = __base::is_bounded;
    static constexpr const bool is_modulo = __base::is_modulo;

    static constexpr const bool traps = __base::traps;
    static constexpr const bool tinyness_before = __base::tinyness_before;
    static constexpr const float_round_style round_style = __base::round_style;
};

template <class _Tp>
    constexpr const bool numeric_limits<const _Tp>::is_specialized;
template <class _Tp>
    constexpr const int numeric_limits<const _Tp>::digits;
template <class _Tp>
    constexpr const int numeric_limits<const _Tp>::digits10;
template <class _Tp>
    constexpr const int numeric_limits<const _Tp>::max_digits10;
template <class _Tp>
    constexpr const bool numeric_limits<const _Tp>::is_signed;
template <class _Tp>
    constexpr const bool numeric_limits<const _Tp>::is_integer;
template <class _Tp>
    constexpr const bool numeric_limits<const _Tp>::is_exact;
template <class _Tp>
    constexpr const int numeric_limits<const _Tp>::radix;
template <class _Tp>
    constexpr const int numeric_limits<const _Tp>::min_exponent;
template <class _Tp>
    constexpr const int numeric_limits<const _Tp>::min_exponent10;
template <class _Tp>
    constexpr const int numeric_limits<const _Tp>::max_exponent;
template <class _Tp>
    constexpr const int numeric_limits<const _Tp>::max_exponent10;
template <class _Tp>
    constexpr const bool numeric_limits<const _Tp>::has_infinity;
template <class _Tp>
    constexpr const bool numeric_limits<const _Tp>::has_quiet_NaN;
template <class _Tp>
    constexpr const bool numeric_limits<const _Tp>::has_signaling_NaN;
template <class _Tp>
    constexpr const float_denorm_style numeric_limits<const _Tp>::has_denorm;
template <class _Tp>
    constexpr const bool numeric_limits<const _Tp>::has_denorm_loss;
template <class _Tp>
    constexpr const bool numeric_limits<const _Tp>::is_iec559;
template <class _Tp>
    constexpr const bool numeric_limits<const _Tp>::is_bounded;
template <class _Tp>
    constexpr const bool numeric_limits<const _Tp>::is_modulo;
template <class _Tp>
    constexpr const bool numeric_limits<const _Tp>::traps;
template <class _Tp>
    constexpr const bool numeric_limits<const _Tp>::tinyness_before;
template <class _Tp>
    constexpr const float_round_style numeric_limits<const _Tp>::round_style;

template <class _Tp>
class numeric_limits<volatile _Tp>
    : private numeric_limits<_Tp>
{
    typedef numeric_limits<_Tp> __base;
    typedef _Tp type;
public:
    static constexpr const bool is_specialized = __base::is_specialized;
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) static constexpr type min() noexcept {return __base::min();}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) static constexpr type max() noexcept {return __base::max();}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) static constexpr type lowest() noexcept {return __base::lowest();}

    static constexpr const int digits = __base::digits;
    static constexpr const int digits10 = __base::digits10;
    static constexpr const int max_digits10 = __base::max_digits10;
    static constexpr const bool is_signed = __base::is_signed;
    static constexpr const bool is_integer = __base::is_integer;
    static constexpr const bool is_exact = __base::is_exact;
    static constexpr const int radix = __base::radix;
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) static constexpr type epsilon() noexcept {return __base::epsilon();}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) static constexpr type round_error() noexcept {return __base::round_error();}

    static constexpr const int min_exponent = __base::min_exponent;
    static constexpr const int min_exponent10 = __base::min_exponent10;
    static constexpr const int max_exponent = __base::max_exponent;
    static constexpr const int max_exponent10 = __base::max_exponent10;

    static constexpr const bool has_infinity = __base::has_infinity;
    static constexpr const bool has_quiet_NaN = __base::has_quiet_NaN;
    static constexpr const bool has_signaling_NaN = __base::has_signaling_NaN;
    static constexpr const float_denorm_style has_denorm = __base::has_denorm;
    static constexpr const bool has_denorm_loss = __base::has_denorm_loss;
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) static constexpr type infinity() noexcept {return __base::infinity();}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) static constexpr type quiet_NaN() noexcept {return __base::quiet_NaN();}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) static constexpr type signaling_NaN() noexcept {return __base::signaling_NaN();}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) static constexpr type denorm_min() noexcept {return __base::denorm_min();}

    static constexpr const bool is_iec559 = __base::is_iec559;
    static constexpr const bool is_bounded = __base::is_bounded;
    static constexpr const bool is_modulo = __base::is_modulo;

    static constexpr const bool traps = __base::traps;
    static constexpr const bool tinyness_before = __base::tinyness_before;
    static constexpr const float_round_style round_style = __base::round_style;
};

template <class _Tp>
    constexpr const bool numeric_limits<volatile _Tp>::is_specialized;
template <class _Tp>
    constexpr const int numeric_limits<volatile _Tp>::digits;
template <class _Tp>
    constexpr const int numeric_limits<volatile _Tp>::digits10;
template <class _Tp>
    constexpr const int numeric_limits<volatile _Tp>::max_digits10;
template <class _Tp>
    constexpr const bool numeric_limits<volatile _Tp>::is_signed;
template <class _Tp>
    constexpr const bool numeric_limits<volatile _Tp>::is_integer;
template <class _Tp>
    constexpr const bool numeric_limits<volatile _Tp>::is_exact;
template <class _Tp>
    constexpr const int numeric_limits<volatile _Tp>::radix;
template <class _Tp>
    constexpr const int numeric_limits<volatile _Tp>::min_exponent;
template <class _Tp>
    constexpr const int numeric_limits<volatile _Tp>::min_exponent10;
template <class _Tp>
    constexpr const int numeric_limits<volatile _Tp>::max_exponent;
template <class _Tp>
    constexpr const int numeric_limits<volatile _Tp>::max_exponent10;
template <class _Tp>
    constexpr const bool numeric_limits<volatile _Tp>::has_infinity;
template <class _Tp>
    constexpr const bool numeric_limits<volatile _Tp>::has_quiet_NaN;
template <class _Tp>
    constexpr const bool numeric_limits<volatile _Tp>::has_signaling_NaN;
template <class _Tp>
    constexpr const float_denorm_style numeric_limits<volatile _Tp>::has_denorm;
template <class _Tp>
    constexpr const bool numeric_limits<volatile _Tp>::has_denorm_loss;
template <class _Tp>
    constexpr const bool numeric_limits<volatile _Tp>::is_iec559;
template <class _Tp>
    constexpr const bool numeric_limits<volatile _Tp>::is_bounded;
template <class _Tp>
    constexpr const bool numeric_limits<volatile _Tp>::is_modulo;
template <class _Tp>
    constexpr const bool numeric_limits<volatile _Tp>::traps;
template <class _Tp>
    constexpr const bool numeric_limits<volatile _Tp>::tinyness_before;
template <class _Tp>
    constexpr const float_round_style numeric_limits<volatile _Tp>::round_style;

template <class _Tp>
class numeric_limits<const volatile _Tp>
    : private numeric_limits<_Tp>
{
    typedef numeric_limits<_Tp> __base;
    typedef _Tp type;
public:
    static constexpr const bool is_specialized = __base::is_specialized;
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) static constexpr type min() noexcept {return __base::min();}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) static constexpr type max() noexcept {return __base::max();}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) static constexpr type lowest() noexcept {return __base::lowest();}

    static constexpr const int digits = __base::digits;
    static constexpr const int digits10 = __base::digits10;
    static constexpr const int max_digits10 = __base::max_digits10;
    static constexpr const bool is_signed = __base::is_signed;
    static constexpr const bool is_integer = __base::is_integer;
    static constexpr const bool is_exact = __base::is_exact;
    static constexpr const int radix = __base::radix;
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) static constexpr type epsilon() noexcept {return __base::epsilon();}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) static constexpr type round_error() noexcept {return __base::round_error();}

    static constexpr const int min_exponent = __base::min_exponent;
    static constexpr const int min_exponent10 = __base::min_exponent10;
    static constexpr const int max_exponent = __base::max_exponent;
    static constexpr const int max_exponent10 = __base::max_exponent10;

    static constexpr const bool has_infinity = __base::has_infinity;
    static constexpr const bool has_quiet_NaN = __base::has_quiet_NaN;
    static constexpr const bool has_signaling_NaN = __base::has_signaling_NaN;
    static constexpr const float_denorm_style has_denorm = __base::has_denorm;
    static constexpr const bool has_denorm_loss = __base::has_denorm_loss;
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) static constexpr type infinity() noexcept {return __base::infinity();}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) static constexpr type quiet_NaN() noexcept {return __base::quiet_NaN();}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) static constexpr type signaling_NaN() noexcept {return __base::signaling_NaN();}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) static constexpr type denorm_min() noexcept {return __base::denorm_min();}

    static constexpr const bool is_iec559 = __base::is_iec559;
    static constexpr const bool is_bounded = __base::is_bounded;
    static constexpr const bool is_modulo = __base::is_modulo;

    static constexpr const bool traps = __base::traps;
    static constexpr const bool tinyness_before = __base::tinyness_before;
    static constexpr const float_round_style round_style = __base::round_style;
};

template <class _Tp>
    constexpr const bool numeric_limits<const volatile _Tp>::is_specialized;
template <class _Tp>
    constexpr const int numeric_limits<const volatile _Tp>::digits;
template <class _Tp>
    constexpr const int numeric_limits<const volatile _Tp>::digits10;
template <class _Tp>
    constexpr const int numeric_limits<const volatile _Tp>::max_digits10;
template <class _Tp>
    constexpr const bool numeric_limits<const volatile _Tp>::is_signed;
template <class _Tp>
    constexpr const bool numeric_limits<const volatile _Tp>::is_integer;
template <class _Tp>
    constexpr const bool numeric_limits<const volatile _Tp>::is_exact;
template <class _Tp>
    constexpr const int numeric_limits<const volatile _Tp>::radix;
template <class _Tp>
    constexpr const int numeric_limits<const volatile _Tp>::min_exponent;
template <class _Tp>
    constexpr const int numeric_limits<const volatile _Tp>::min_exponent10;
template <class _Tp>
    constexpr const int numeric_limits<const volatile _Tp>::max_exponent;
template <class _Tp>
    constexpr const int numeric_limits<const volatile _Tp>::max_exponent10;
template <class _Tp>
    constexpr const bool numeric_limits<const volatile _Tp>::has_infinity;
template <class _Tp>
    constexpr const bool numeric_limits<const volatile _Tp>::has_quiet_NaN;
template <class _Tp>
    constexpr const bool numeric_limits<const volatile _Tp>::has_signaling_NaN;
template <class _Tp>
    constexpr const float_denorm_style numeric_limits<const volatile _Tp>::has_denorm;
template <class _Tp>
    constexpr const bool numeric_limits<const volatile _Tp>::has_denorm_loss;
template <class _Tp>
    constexpr const bool numeric_limits<const volatile _Tp>::is_iec559;
template <class _Tp>
    constexpr const bool numeric_limits<const volatile _Tp>::is_bounded;
template <class _Tp>
    constexpr const bool numeric_limits<const volatile _Tp>::is_modulo;
template <class _Tp>
    constexpr const bool numeric_limits<const volatile _Tp>::traps;
template <class _Tp>
    constexpr const bool numeric_limits<const volatile _Tp>::tinyness_before;
template <class _Tp>
    constexpr const float_round_style numeric_limits<const volatile _Tp>::round_style;

}}
# 27 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__iterator/advance.h" 2 3
# 30 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__iterator/advance.h" 3



# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__undef_macros" 1 3
# 34 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__iterator/advance.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _InputIter>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
void __advance(_InputIter& __i, typename iterator_traits<_InputIter>::difference_type __n, input_iterator_tag) {
  for (; __n > 0; --__n)
    ++__i;
}

template <class _BiDirIter>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
void __advance(_BiDirIter& __i, typename iterator_traits<_BiDirIter>::difference_type __n, bidirectional_iterator_tag) {
  if (__n >= 0)
    for (; __n > 0; --__n)
      ++__i;
  else
    for (; __n < 0; ++__n)
      --__i;
}

template <class _RandIter>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
void __advance(_RandIter& __i, typename iterator_traits<_RandIter>::difference_type __n, random_access_iterator_tag) {
  __i += __n;
}

template <
    class _InputIter, class _Distance,
    class _IntegralDistance = decltype(std::__convert_to_integral(std::declval<_Distance>())),
    class = __enable_if_t<is_integral<_IntegralDistance>::value> >
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
void advance(_InputIter& __i, _Distance __orig_n) {
  typedef typename iterator_traits<_InputIter>::difference_type _Difference;
  _Difference __n = static_cast<_Difference>(std::__convert_to_integral(__orig_n));
  ((void)0);

  std::__advance(__i, __n, typename iterator_traits<_InputIter>::iterator_category());
}





namespace ranges {
namespace __advance {

struct __fn {
private:
  template <class _Ip>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
  static constexpr void __advance_forward(_Ip& __i, iter_difference_t<_Ip> __n) {
    while (__n > 0) {
      --__n;
      ++__i;
    }
  }

  template <class _Ip>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
  static constexpr void __advance_backward(_Ip& __i, iter_difference_t<_Ip> __n) {
    while (__n < 0) {
      ++__n;
      --__i;
    }
  }

public:

  template <input_or_output_iterator _Ip>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
  constexpr void operator()(_Ip& __i, iter_difference_t<_Ip> __n) const {
    ((void)0);



    if constexpr (random_access_iterator<_Ip>) {
      __i += __n;
      return;
    } else if constexpr (bidirectional_iterator<_Ip>) {

      __advance_forward(__i, __n);

      __advance_backward(__i, __n);
      return;
    } else {

      __advance_forward(__i, __n);
      return;
    }
  }


  template <input_or_output_iterator _Ip, sentinel_for<_Ip> _Sp>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr void operator()(_Ip& __i, _Sp __bound_sentinel) const {

    if constexpr (assignable_from<_Ip&, _Sp>) {
      __i = std::move(__bound_sentinel);
    }

    else if constexpr (sized_sentinel_for<_Sp, _Ip>) {
      (*this)(__i, __bound_sentinel - __i);
    }

    else {
      while (__i != __bound_sentinel) {
        ++__i;
      }
    }
  }






  template <input_or_output_iterator _Ip, sentinel_for<_Ip> _Sp>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr iter_difference_t<_Ip> operator()(_Ip& __i, iter_difference_t<_Ip> __n,
                                                                    _Sp __bound_sentinel) const {
    ((void)0);


    if constexpr (sized_sentinel_for<_Sp, _Ip>) {


      auto __magnitude_geq = [](auto __a, auto __b) {
        return __a == 0 ? __b == 0 :
               __a > 0 ? __a >= __b :
                          __a <= __b;
      };
      if (const auto __m = __bound_sentinel - __i; __magnitude_geq(__n, __m)) {
        (*this)(__i, __bound_sentinel);
        return __n - __m;
      }


      (*this)(__i, __n);
      return 0;
    } else {


      while (__i != __bound_sentinel && __n > 0) {
        ++__i;
        --__n;
      }


      if constexpr (bidirectional_iterator<_Ip> && same_as<_Ip, _Sp>) {
        while (__i != __bound_sentinel && __n < 0) {
          --__i;
          ++__n;
        }
      }
      return __n;
    }

    __libcpp_unreachable();
  }
};

}

inline namespace __cpo {
  inline constexpr auto advance = __advance::__fn{};
}
}



}}
# 16 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/iterator_operations.h" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__iterator/distance.h" 1 3
# 17 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__iterator/distance.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__ranges/access.h" 1 3
# 17 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__ranges/access.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__ranges/enable_borrowed_range.h" 1 3
# 21 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__ranges/enable_borrowed_range.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {



namespace ranges {



template <class>
inline constexpr bool enable_borrowed_range = false;

}



}}
# 18 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__ranges/access.h" 2 3




# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__utility/auto_cast.h" 1 3
# 18 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__utility/auto_cast.h" 3
# 23 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__ranges/access.h" 2 3
# 28 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__ranges/access.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {



namespace ranges {
  template <class _Tp>
  concept __can_borrow =
    is_lvalue_reference_v<_Tp> || enable_borrowed_range<remove_cvref_t<_Tp>>;
}



namespace ranges {
namespace __begin {
  template <class _Tp>
  concept __member_begin =
    __can_borrow<_Tp> &&
    __workaround_52970<_Tp> &&
    requires(_Tp&& __t) {
      { static_cast<::std::__decay_t<decltype((__t.begin()))> >(__t.begin()) } -> input_or_output_iterator;
    };

  void begin(auto&) = delete;
  void begin(const auto&) = delete;

  template <class _Tp>
  concept __unqualified_begin =
    !__member_begin<_Tp> &&
    __can_borrow<_Tp> &&
    __class_or_enum<remove_cvref_t<_Tp>> &&
    requires(_Tp && __t) {
      { static_cast<::std::__decay_t<decltype((begin(__t)))> >(begin(__t)) } -> input_or_output_iterator;
    };

  struct __fn {
    template <class _Tp>
    [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr auto operator()(_Tp (&__t)[]) const noexcept
      requires (sizeof(_Tp) >= 0)
    {
      return __t + 0;
    }

    template <class _Tp, size_t _Np>
    [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr auto operator()(_Tp (&__t)[_Np]) const noexcept
      requires (sizeof(_Tp) >= 0)
    {
      return __t + 0;
    }

    template <class _Tp>
      requires __member_begin<_Tp>
    [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr auto operator()(_Tp&& __t) const
      noexcept(noexcept(static_cast<::std::__decay_t<decltype((__t.begin()))> >(__t.begin())))
    {
      return static_cast<::std::__decay_t<decltype((__t.begin()))> >(__t.begin());
    }

    template <class _Tp>
      requires __unqualified_begin<_Tp>
    [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr auto operator()(_Tp&& __t) const
      noexcept(noexcept(static_cast<::std::__decay_t<decltype((begin(__t)))> >(begin(__t))))
    {
      return static_cast<::std::__decay_t<decltype((begin(__t)))> >(begin(__t));
    }

    void operator()(auto&&) const = delete;
  };
}

inline namespace __cpo {
  inline constexpr auto begin = __begin::__fn{};
}
}



namespace ranges {
  template <class _Tp>
  using iterator_t = decltype(ranges::begin(std::declval<_Tp&>()));
}



namespace ranges {
namespace __end {
  template <class _Tp>
  concept __member_end =
    __can_borrow<_Tp> &&
    __workaround_52970<_Tp> &&
    requires(_Tp&& __t) {
      typename iterator_t<_Tp>;
      { static_cast<::std::__decay_t<decltype((__t.end()))> >(__t.end()) } -> sentinel_for<iterator_t<_Tp>>;
    };

  void end(auto&) = delete;
  void end(const auto&) = delete;

  template <class _Tp>
  concept __unqualified_end =
    !__member_end<_Tp> &&
    __can_borrow<_Tp> &&
    __class_or_enum<remove_cvref_t<_Tp>> &&
    requires(_Tp && __t) {
      typename iterator_t<_Tp>;
      { static_cast<::std::__decay_t<decltype((end(__t)))> >(end(__t)) } -> sentinel_for<iterator_t<_Tp>>;
    };

  struct __fn {
    template <class _Tp, size_t _Np>
    [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr auto operator()(_Tp (&__t)[_Np]) const noexcept
      requires (sizeof(_Tp) >= 0)
    {
      return __t + _Np;
    }

    template <class _Tp>
      requires __member_end<_Tp>
    [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr auto operator()(_Tp&& __t) const
      noexcept(noexcept(static_cast<::std::__decay_t<decltype((__t.end()))> >(__t.end())))
    {
      return static_cast<::std::__decay_t<decltype((__t.end()))> >(__t.end());
    }

    template <class _Tp>
      requires __unqualified_end<_Tp>
    [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr auto operator()(_Tp&& __t) const
      noexcept(noexcept(static_cast<::std::__decay_t<decltype((end(__t)))> >(end(__t))))
    {
      return static_cast<::std::__decay_t<decltype((end(__t)))> >(end(__t));
    }

    void operator()(auto&&) const = delete;
  };
}

inline namespace __cpo {
  inline constexpr auto end = __end::__fn{};
}
}



namespace ranges {
namespace __cbegin {
  struct __fn {
    template <class _Tp>
      requires is_lvalue_reference_v<_Tp&&>
    [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    constexpr auto operator()(_Tp&& __t) const
      noexcept(noexcept(ranges::begin(static_cast<const remove_reference_t<_Tp>&>(__t))))
      -> decltype( ranges::begin(static_cast<const remove_reference_t<_Tp>&>(__t)))
      { return ranges::begin(static_cast<const remove_reference_t<_Tp>&>(__t)); }

    template <class _Tp>
      requires is_rvalue_reference_v<_Tp&&>
    [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    constexpr auto operator()(_Tp&& __t) const
      noexcept(noexcept(ranges::begin(static_cast<const _Tp&&>(__t))))
      -> decltype( ranges::begin(static_cast<const _Tp&&>(__t)))
      { return ranges::begin(static_cast<const _Tp&&>(__t)); }
  };
}

inline namespace __cpo {
  inline constexpr auto cbegin = __cbegin::__fn{};
}
}



namespace ranges {
namespace __cend {
  struct __fn {
    template <class _Tp>
      requires is_lvalue_reference_v<_Tp&&>
    [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    constexpr auto operator()(_Tp&& __t) const
      noexcept(noexcept(ranges::end(static_cast<const remove_reference_t<_Tp>&>(__t))))
      -> decltype( ranges::end(static_cast<const remove_reference_t<_Tp>&>(__t)))
      { return ranges::end(static_cast<const remove_reference_t<_Tp>&>(__t)); }

    template <class _Tp>
      requires is_rvalue_reference_v<_Tp&&>
    [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    constexpr auto operator()(_Tp&& __t) const
      noexcept(noexcept(ranges::end(static_cast<const _Tp&&>(__t))))
      -> decltype( ranges::end(static_cast<const _Tp&&>(__t)))
      { return ranges::end(static_cast<const _Tp&&>(__t)); }
  };
}

inline namespace __cpo {
  inline constexpr auto cend = __cend::__fn{};
}
}



}}
# 18 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__iterator/distance.h" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__ranges/concepts.h" 1 3
# 23 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__ranges/concepts.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__ranges/data.h" 1 3
# 23 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__ranges/data.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/remove_pointer.h" 1 3
# 16 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/remove_pointer.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {


template <class _Tp>
struct remove_pointer {
  using type __attribute__((__nodebug__)) = __remove_pointer(_Tp);
};

template <class _Tp>
using __remove_pointer_t = __remove_pointer(_Tp);
# 42 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/remove_pointer.h" 3
template <class _Tp>
using remove_pointer_t = __remove_pointer_t<_Tp>;


}}
# 24 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__ranges/data.h" 2 3
# 29 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__ranges/data.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {





namespace ranges {
namespace __data {
  template <class _Tp>
  concept __ptr_to_object = is_pointer_v<_Tp> && is_object_v<remove_pointer_t<_Tp>>;

  template <class _Tp>
  concept __member_data =
    __can_borrow<_Tp> &&
    __workaround_52970<_Tp> &&
    requires(_Tp&& __t) {
      { static_cast<::std::__decay_t<decltype((__t.data()))> >(__t.data()) } -> __ptr_to_object;
    };

  template <class _Tp>
  concept __ranges_begin_invocable =
    !__member_data<_Tp> &&
    __can_borrow<_Tp> &&
    requires(_Tp&& __t) {
      { ranges::begin(__t) } -> contiguous_iterator;
    };

  struct __fn {
    template <__member_data _Tp>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    constexpr auto operator()(_Tp&& __t) const
        noexcept(noexcept(__t.data())) {
      return __t.data();
    }

    template<__ranges_begin_invocable _Tp>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    constexpr auto operator()(_Tp&& __t) const
        noexcept(noexcept(std::to_address(ranges::begin(__t)))) {
      return std::to_address(ranges::begin(__t));
    }
  };
}

inline namespace __cpo {
  inline constexpr auto data = __data::__fn{};
}
}



namespace ranges {
namespace __cdata {
  struct __fn {
    template <class _Tp>
      requires is_lvalue_reference_v<_Tp&&>
    [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    constexpr auto operator()(_Tp&& __t) const
      noexcept(noexcept(ranges::data(static_cast<const remove_reference_t<_Tp>&>(__t))))
      -> decltype( ranges::data(static_cast<const remove_reference_t<_Tp>&>(__t)))
      { return ranges::data(static_cast<const remove_reference_t<_Tp>&>(__t)); }

    template <class _Tp>
      requires is_rvalue_reference_v<_Tp&&>
    [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    constexpr auto operator()(_Tp&& __t) const
      noexcept(noexcept(ranges::data(static_cast<const _Tp&&>(__t))))
      -> decltype( ranges::data(static_cast<const _Tp&&>(__t)))
      { return ranges::data(static_cast<const _Tp&&>(__t)); }
  };
}

inline namespace __cpo {
  inline constexpr auto cdata = __cdata::__fn{};
}
}



}}
# 24 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__ranges/concepts.h" 2 3

# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__ranges/enable_view.h" 1 3
# 22 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__ranges/enable_view.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {



namespace ranges {

struct view_base { };

template<class _Derived>
  requires is_class_v<_Derived> && same_as<_Derived, remove_cv_t<_Derived>>
class view_interface;

template<class _Op, class _Yp>
  requires is_convertible_v<_Op*, view_interface<_Yp>*>
void __is_derived_from_view_interface(const _Op*, const view_interface<_Yp>*);

template <class _Tp>
inline constexpr bool enable_view = derived_from<_Tp, view_base> ||
  requires { ranges::__is_derived_from_view_interface((_Tp*)nullptr, (_Tp*)nullptr); };

}



}}
# 26 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__ranges/concepts.h" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__ranges/size.h" 1 3
# 21 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__ranges/size.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/make_unsigned.h" 1 3
# 17 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/make_unsigned.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_unsigned.h" 1 3
# 19 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_unsigned.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {



template <class _Tp>
struct is_unsigned : _BoolConstant<__is_unsigned(_Tp)> {};


template <class _Tp>
inline constexpr bool is_unsigned_v = __is_unsigned(_Tp);
# 57 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_unsigned.h" 3
}}
# 18 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/make_unsigned.h" 2 3
# 24 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/make_unsigned.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {



template <class _Tp>
using __make_unsigned_t = __make_unsigned(_Tp);
# 79 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/make_unsigned.h" 3
template <class _Tp>
struct make_unsigned {
  using type __attribute__((__nodebug__)) = __make_unsigned_t<_Tp>;
};


template <class _Tp>
using make_unsigned_t = __make_unsigned_t<_Tp>;



template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr __make_unsigned_t<_Tp> __to_unsigned_like(_Tp __x) noexcept {
  return static_cast<__make_unsigned_t<_Tp> >(__x);
}


template <class _Tp, class _Up>
using __copy_unsigned_t = __conditional_t<is_unsigned<_Tp>::value, __make_unsigned_t<_Up>, _Up>;

}}
# 22 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__ranges/size.h" 2 3
# 29 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__ranges/size.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {



namespace ranges {
  template<class>
  inline constexpr bool disable_sized_range = false;
}



namespace ranges {
namespace __size {
void size(auto&) = delete;
void size(const auto&) = delete;

template <class _Tp>
concept __size_enabled = !disable_sized_range<remove_cvref_t<_Tp>>;

template <class _Tp>
concept __member_size =
  __size_enabled<_Tp> &&
  __workaround_52970<_Tp> &&
  requires(_Tp&& __t) {
    { static_cast<::std::__decay_t<decltype((__t.size()))> >(__t.size()) } -> __integer_like;
  };

template <class _Tp>
concept __unqualified_size =
  __size_enabled<_Tp> &&
  !__member_size<_Tp> &&
  __class_or_enum<remove_cvref_t<_Tp>> &&
  requires(_Tp&& __t) {
    { static_cast<::std::__decay_t<decltype((size(__t)))> >(size(__t)) } -> __integer_like;
  };

template <class _Tp>
concept __difference =
  !__member_size<_Tp> &&
  !__unqualified_size<_Tp> &&
  __class_or_enum<remove_cvref_t<_Tp>> &&
  requires(_Tp&& __t) {
    { ranges::begin(__t) } -> forward_iterator;
    { ranges::end(__t) } -> sized_sentinel_for<decltype(ranges::begin(std::declval<_Tp>()))>;
  };

struct __fn {


  template <class _Tp, size_t _Sz>
  [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr size_t operator()(_Tp (&&)[_Sz]) const noexcept {
    return _Sz;
  }


  template <class _Tp, size_t _Sz>
  [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr size_t operator()(_Tp (&)[_Sz]) const noexcept {
    return _Sz;
  }


  template <__member_size _Tp>
  [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr __integer_like auto operator()(_Tp&& __t) const
      noexcept(noexcept(static_cast<::std::__decay_t<decltype((__t.size()))> >(__t.size()))) {
    return static_cast<::std::__decay_t<decltype((__t.size()))> >(__t.size());
  }


  template <__unqualified_size _Tp>
  [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr __integer_like auto operator()(_Tp&& __t) const
      noexcept(noexcept(static_cast<::std::__decay_t<decltype((size(__t)))> >(size(__t)))) {
    return static_cast<::std::__decay_t<decltype((size(__t)))> >(size(__t));
  }


  template <__difference _Tp>
  [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr auto operator()(_Tp&& __t) const
    noexcept(noexcept(std::__to_unsigned_like(ranges::end(__t) - ranges::begin(__t))))
    -> decltype( std::__to_unsigned_like(ranges::end(__t) - ranges::begin(__t)))
    { return std::__to_unsigned_like(ranges::end(__t) - ranges::begin(__t));
  }
};

}

inline namespace __cpo {
  inline constexpr auto size = __size::__fn{};
}
}



namespace ranges {
namespace __ssize {
struct __fn {
  template<class _Tp>
    requires requires (_Tp&& __t) { ranges::size(__t); }
  [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr integral auto operator()(_Tp&& __t) const
    noexcept(noexcept(ranges::size(__t))) {
    using _Signed = make_signed_t<decltype(ranges::size(__t))>;
    if constexpr (sizeof(ptrdiff_t) > sizeof(_Signed))
      return static_cast<ptrdiff_t>(ranges::size(__t));
    else
      return static_cast<_Signed>(ranges::size(__t));
  }
};
}

inline namespace __cpo {
  inline constexpr auto ssize = __ssize::__fn{};
}
}



}}
# 27 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__ranges/concepts.h" 2 3





# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/initializer_list" 1 3
# 51 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/initializer_list" 3


namespace std
{



template<class _Ep>
class initializer_list
{
    const _Ep* __begin_;
    size_t __size_;

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    constexpr
    initializer_list(const _Ep* __b, size_t __s) noexcept
        : __begin_(__b),
          __size_(__s)
        {}
public:
    typedef _Ep value_type;
    typedef const _Ep& reference;
    typedef const _Ep& const_reference;
    typedef size_t size_type;

    typedef const _Ep* iterator;
    typedef const _Ep* const_iterator;

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    constexpr
    initializer_list() noexcept : __begin_(nullptr), __size_(0) {}

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    constexpr
    size_t size() const noexcept {return __size_;}

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    constexpr
    const _Ep* begin() const noexcept {return __begin_;}

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    constexpr
    const _Ep* end() const noexcept {return __begin_ + __size_;}
};

template<class _Ep>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
constexpr
const _Ep*
begin(initializer_list<_Ep> __il) noexcept
{
    return __il.begin();
}

template<class _Ep>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
constexpr
const _Ep*
end(initializer_list<_Ep> __il) noexcept
{
    return __il.end();
}



}
# 33 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__ranges/concepts.h" 2 3
# 36 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__ranges/concepts.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {



namespace ranges {



  template <class _Tp>
  concept range = requires(_Tp& __t) {
    ranges::begin(__t);
    ranges::end(__t);
  };

  template <class _Tp>
  concept input_range = range<_Tp> && input_iterator<iterator_t<_Tp>>;

  template<class _Range>
  concept borrowed_range = range<_Range> &&
    (is_lvalue_reference_v<_Range> || enable_borrowed_range<remove_cvref_t<_Range>>);



  template <range _Rp>
  using sentinel_t = decltype(ranges::end(std::declval<_Rp&>()));

  template <range _Rp>
  using range_difference_t = iter_difference_t<iterator_t<_Rp>>;

  template <range _Rp>
  using range_value_t = iter_value_t<iterator_t<_Rp>>;

  template <range _Rp>
  using range_reference_t = iter_reference_t<iterator_t<_Rp>>;

  template <range _Rp>
  using range_rvalue_reference_t = iter_rvalue_reference_t<iterator_t<_Rp>>;

  template <range _Rp>
  using range_common_reference_t = iter_common_reference_t<iterator_t<_Rp>>;


  template <class _Tp>
  concept sized_range = range<_Tp> && requires(_Tp& __t) { ranges::size(__t); };

  template<sized_range _Rp>
  using range_size_t = decltype(ranges::size(std::declval<_Rp&>()));
# 93 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__ranges/concepts.h" 3
  template <class _Tp>
  concept view =
    range<_Tp> &&
    movable<_Tp> &&
    enable_view<_Tp>;

  template <class _Range>
  concept __simple_view =
    view<_Range> && range<const _Range> &&
    same_as<iterator_t<_Range>, iterator_t<const _Range>> &&
    same_as<sentinel_t<_Range>, sentinel_t<const _Range>>;


  template <class _Rp, class _Tp>
  concept output_range = range<_Rp> && output_iterator<iterator_t<_Rp>, _Tp>;

  template <class _Tp>
  concept forward_range = input_range<_Tp> && forward_iterator<iterator_t<_Tp>>;

  template <class _Tp>
  concept bidirectional_range = forward_range<_Tp> && bidirectional_iterator<iterator_t<_Tp>>;

  template <class _Tp>
  concept random_access_range =
      bidirectional_range<_Tp> && random_access_iterator<iterator_t<_Tp>>;

  template<class _Tp>
  concept contiguous_range =
    random_access_range<_Tp> &&
    contiguous_iterator<iterator_t<_Tp>> &&
    requires(_Tp& __t) {
      { ranges::data(__t) } -> same_as<add_pointer_t<range_reference_t<_Tp>>>;
    };

  template <class _Tp>
  concept common_range = range<_Tp> && same_as<iterator_t<_Tp>, sentinel_t<_Tp>>;

  template <class _Tp>
  inline constexpr bool __is_std_initializer_list = false;

  template <class _Ep>
  inline constexpr bool __is_std_initializer_list<initializer_list<_Ep>> = true;

  template <class _Tp>
  concept viewable_range =
    range<_Tp> &&
    ((view<remove_cvref_t<_Tp>> && constructible_from<remove_cvref_t<_Tp>, _Tp>) ||
     (!view<remove_cvref_t<_Tp>> &&
      (is_lvalue_reference_v<_Tp> ||
       (movable<remove_reference_t<_Tp>> && !__is_std_initializer_list<remove_cvref_t<_Tp>>))));

}



}}
# 19 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__iterator/distance.h" 2 3
# 25 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__iterator/distance.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _InputIter>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
typename iterator_traits<_InputIter>::difference_type
__distance(_InputIter __first, _InputIter __last, input_iterator_tag)
{
    typename iterator_traits<_InputIter>::difference_type __r(0);
    for (; __first != __last; ++__first)
        ++__r;
    return __r;
}

template <class _RandIter>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
typename iterator_traits<_RandIter>::difference_type
__distance(_RandIter __first, _RandIter __last, random_access_iterator_tag)
{
    return __last - __first;
}

template <class _InputIter>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
typename iterator_traits<_InputIter>::difference_type
distance(_InputIter __first, _InputIter __last)
{
    return std::__distance(__first, __last, typename iterator_traits<_InputIter>::iterator_category());
}





namespace ranges {
namespace __distance {

struct __fn {
  template<class _Ip, sentinel_for<_Ip> _Sp>
    requires (!sized_sentinel_for<_Sp, _Ip>)
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
  constexpr iter_difference_t<_Ip> operator()(_Ip __first, _Sp __last) const {
    iter_difference_t<_Ip> __n = 0;
    while (__first != __last) {
      ++__first;
      ++__n;
    }
    return __n;
  }

  template<class _Ip, sized_sentinel_for<decay_t<_Ip>> _Sp>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
  constexpr iter_difference_t<_Ip> operator()(_Ip&& __first, _Sp __last) const {
    if constexpr (sized_sentinel_for<_Sp, __remove_cvref_t<_Ip>>) {
      return __last - __first;
    } else {
      return __last - decay_t<_Ip>(__first);
    }
  }

  template<range _Rp>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
  constexpr range_difference_t<_Rp> operator()(_Rp&& __r) const {
    if constexpr (sized_range<_Rp>) {
      return static_cast<range_difference_t<_Rp>>(ranges::size(__r));
    } else {
      return operator()(ranges::begin(__r), ranges::end(__r));
    }
  }
};

}

inline namespace __cpo {
  inline constexpr auto distance = __distance::__fn{};
}
}



}}
# 17 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/iterator_operations.h" 2 3


# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__iterator/iter_swap.h" 1 3
# 27 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__iterator/iter_swap.h" 3



# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__undef_macros" 1 3
# 31 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__iterator/iter_swap.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {





namespace ranges {
namespace __iter_swap {
  template<class _I1, class _I2>
  void iter_swap(_I1, _I2) = delete;

  template<class _T1, class _T2>
  concept __unqualified_iter_swap =
    (__class_or_enum<remove_cvref_t<_T1>> || __class_or_enum<remove_cvref_t<_T2>>) &&
    requires (_T1&& __x, _T2&& __y) {

      iter_swap(std::forward<_T1>(__x), std::forward<_T2>(__y));
    };

  template<class _T1, class _T2>
  concept __readable_swappable =
    indirectly_readable<_T1> && indirectly_readable<_T2> &&
    swappable_with<iter_reference_t<_T1>, iter_reference_t<_T2>>;


  struct __fn {

    template <class _T1, class _T2>
      requires __unqualified_iter_swap<_T1, _T2>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    constexpr void operator()(_T1&& __x, _T2&& __y) const
      noexcept(noexcept(iter_swap(std::forward<_T1>(__x), std::forward<_T2>(__y))))
    {
      (void)iter_swap(std::forward<_T1>(__x), std::forward<_T2>(__y));
    }


    template <class _T1, class _T2>
      requires (!__unqualified_iter_swap<_T1, _T2>) &&
               __readable_swappable<_T1, _T2>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    constexpr void operator()(_T1&& __x, _T2&& __y) const
      noexcept(noexcept(ranges::swap(*std::forward<_T1>(__x), *std::forward<_T2>(__y))))
    {
      ranges::swap(*std::forward<_T1>(__x), *std::forward<_T2>(__y));
    }

    template <class _T1, class _T2>
      requires (!__unqualified_iter_swap<_T1, _T2> &&
                !__readable_swappable<_T1, _T2>) &&
               indirectly_movable_storable<_T1, _T2> &&
               indirectly_movable_storable<_T2, _T1>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    constexpr void operator()(_T1&& __x, _T2&& __y) const
      noexcept(noexcept(iter_value_t<_T2>(ranges::iter_move(__y))) &&
               noexcept(*__y = ranges::iter_move(__x)) &&
               noexcept(*std::forward<_T1>(__x) = std::declval<iter_value_t<_T2>>()))
    {
      iter_value_t<_T2> __old(ranges::iter_move(__y));
      *__y = ranges::iter_move(__x);
      *std::forward<_T1>(__x) = std::move(__old);
    }
  };
}

inline namespace __cpo {
  inline constexpr auto iter_swap = __iter_swap::__fn{};
}
}

template<class _I1, class _I2 = _I1>
concept indirectly_swappable =
  indirectly_readable<_I1> && indirectly_readable<_I2> &&
  requires(const _I1 __i1, const _I2 __i2) {
    ranges::iter_swap(__i1, __i1);
    ranges::iter_swap(__i2, __i2);
    ranges::iter_swap(__i1, __i2);
    ranges::iter_swap(__i2, __i1);
  };



}}
# 20 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/iterator_operations.h" 2 3

# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__iterator/next.h" 1 3
# 23 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__iterator/next.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _InputIter, __enable_if_t<__has_input_iterator_category<_InputIter>::value, int> = 0>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    _InputIter
    next(_InputIter __x, typename iterator_traits<_InputIter>::difference_type __n = 1) {
  ((void)0);


  std::advance(__x, __n);
  return __x;
}





namespace ranges {
namespace __next {

struct __fn {
  template <input_or_output_iterator _Ip>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
  constexpr _Ip operator()(_Ip __x) const {
    ++__x;
    return __x;
  }

  template <input_or_output_iterator _Ip>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
  constexpr _Ip operator()(_Ip __x, iter_difference_t<_Ip> __n) const {
    ranges::advance(__x, __n);
    return __x;
  }

  template <input_or_output_iterator _Ip, sentinel_for<_Ip> _Sp>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr _Ip operator()(_Ip __x, _Sp __bound_sentinel) const {
    ranges::advance(__x, __bound_sentinel);
    return __x;
  }

  template <input_or_output_iterator _Ip, sentinel_for<_Ip> _Sp>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr _Ip operator()(_Ip __x, iter_difference_t<_Ip> __n, _Sp __bound_sentinel) const {
    ranges::advance(__x, __n, __bound_sentinel);
    return __x;
  }
};

}

inline namespace __cpo {
  inline constexpr auto next = __next::__fn{};
}
}



}}
# 22 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/iterator_operations.h" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__iterator/prev.h" 1 3
# 23 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__iterator/prev.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _InputIter, __enable_if_t<__has_input_iterator_category<_InputIter>::value, int> = 0>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    _InputIter
    prev(_InputIter __x, typename iterator_traits<_InputIter>::difference_type __n = 1) {
  ((void)0);

  std::advance(__x, -__n);
  return __x;
}





namespace ranges {
namespace __prev {

struct __fn {
  template <bidirectional_iterator _Ip>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
  constexpr _Ip operator()(_Ip __x) const {
    --__x;
    return __x;
  }

  template <bidirectional_iterator _Ip>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
  constexpr _Ip operator()(_Ip __x, iter_difference_t<_Ip> __n) const {
    ranges::advance(__x, -__n);
    return __x;
  }

  template <bidirectional_iterator _Ip>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr _Ip operator()(_Ip __x, iter_difference_t<_Ip> __n, _Ip __bound_iter) const {
    ranges::advance(__x, -__n, __bound_iter);
    return __x;
  }
};

}

inline namespace __cpo {
  inline constexpr auto prev = __prev::__fn{};
}
}



}}
# 23 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/iterator_operations.h" 2 3
# 34 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/iterator_operations.h" 3



# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__undef_macros" 1 3
# 38 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/iterator_operations.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _AlgPolicy> struct _IterOps;


struct _RangeAlgPolicy {};

template <>
struct _IterOps<_RangeAlgPolicy> {

  template <class _Iter>
  using __value_type = iter_value_t<_Iter>;

  template <class _Iter>
  using __iterator_category = ranges::__iterator_concept<_Iter>;

  template <class _Iter>
  using __difference_type = iter_difference_t<_Iter>;

  static constexpr auto advance = ranges::advance;
  static constexpr auto distance = ranges::distance;
  static constexpr auto __iter_move = ranges::iter_move;
  static constexpr auto iter_swap = ranges::iter_swap;
  static constexpr auto next = ranges::next;
  static constexpr auto prev = ranges::prev;
  static constexpr auto __advance_to = ranges::advance;
};



struct _ClassicAlgPolicy {};

template <>
struct _IterOps<_ClassicAlgPolicy> {

  template <class _Iter>
  using __value_type = typename iterator_traits<_Iter>::value_type;

  template <class _Iter>
  using __iterator_category = typename iterator_traits<_Iter>::iterator_category;

  template <class _Iter>
  using __difference_type = typename iterator_traits<_Iter>::difference_type;


  template <class _Iter, class _Distance>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
  static void advance(_Iter& __iter, _Distance __count) {
    std::advance(__iter, __count);
  }


  template <class _Iter>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
  static typename iterator_traits<_Iter>::difference_type distance(_Iter __first, _Iter __last) {
    return std::distance(__first, __last);
  }

  template <class _Iter>
  using __deref_t = decltype(*std::declval<_Iter&>());

  template <class _Iter>
  using __move_t = decltype(std::move(*std::declval<_Iter&>()));

  template <class _Iter>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
  static void __validate_iter_reference() {
    static_assert(is_same<__deref_t<_Iter>, typename iterator_traits<__remove_cvref_t<_Iter> >::reference>::value,
        "It looks like your iterator's `iterator_traits<It>::reference` does not match the return type of "
        "dereferencing the iterator, i.e., calling `*it`. This is undefined behavior according to [input.iterators] "
        "and can lead to dangling reference issues at runtime, so we are flagging this.");
  }


  template <class _Iter, __enable_if_t<is_reference<__deref_t<_Iter> >::value, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr static


  __move_t<_Iter>
  __iter_move(_Iter&& __i) {
    __validate_iter_reference<_Iter>();

    return std::move(*std::forward<_Iter>(__i));
  }

  template <class _Iter, __enable_if_t<!is_reference<__deref_t<_Iter> >::value, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr static



  __deref_t<_Iter>
  __iter_move(_Iter&& __i) {
    __validate_iter_reference<_Iter>();

    return *std::forward<_Iter>(__i);
  }


  template <class _Iter1, class _Iter2>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
  static void iter_swap(_Iter1&& __a, _Iter2&& __b) {
    std::iter_swap(std::forward<_Iter1>(__a), std::forward<_Iter2>(__b));
  }


  template <class _Iterator>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) static constexpr
  _Iterator next(_Iterator, _Iterator __last) {
    return __last;
  }

  template <class _Iter>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) static constexpr
  __remove_cvref_t<_Iter> next(_Iter&& __it,
                          typename iterator_traits<__remove_cvref_t<_Iter> >::difference_type __n = 1) {
    return std::next(std::forward<_Iter>(__it), __n);
  }


  template <class _Iter>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) static constexpr
  __remove_cvref_t<_Iter> prev(_Iter&& __iter,
                 typename iterator_traits<__remove_cvref_t<_Iter> >::difference_type __n = 1) {
    return std::prev(std::forward<_Iter>(__iter), __n);
  }

  template <class _Iter>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) static constexpr
  void __advance_to(_Iter& __first, _Iter __last) {
    __first = __last;
  }
};

}}
# 15 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/adjacent_find.h" 2 3
# 21 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/adjacent_find.h" 3



# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__undef_macros" 1 3
# 25 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/adjacent_find.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Iter, class _Sent, class _BinaryPredicate>
[[__nodiscard__]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr _Iter
__adjacent_find(_Iter __first, _Sent __last, _BinaryPredicate&& __pred) {
  if (__first == __last)
    return __first;
  _Iter __i = __first;
  while (++__i != __last) {
    if (__pred(*__first, *__i))
      return __first;
    __first = __i;
  }
  return __i;
}

template <class _ForwardIterator, class _BinaryPredicate>
[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr _ForwardIterator
adjacent_find(_ForwardIterator __first, _ForwardIterator __last, _BinaryPredicate __pred) {
  return std::__adjacent_find(std::move(__first), std::move(__last), __pred);
}

template <class _ForwardIterator>
[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr _ForwardIterator
adjacent_find(_ForwardIterator __first, _ForwardIterator __last) {
  return std::adjacent_find(std::move(__first), std::move(__last), __equal_to());
}

}}
# 1761 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/algorithm" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/all_of.h" 1 3
# 17 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/all_of.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _InputIterator, class _Predicate>
[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr bool
all_of(_InputIterator __first, _InputIterator __last, _Predicate __pred) {
  for (; __first != __last; ++__first)
    if (!__pred(*__first))
      return false;
  return true;
}

}}
# 1762 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/algorithm" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/any_of.h" 1 3
# 17 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/any_of.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _InputIterator, class _Predicate>
[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr bool
any_of(_InputIterator __first, _InputIterator __last, _Predicate __pred) {
  for (; __first != __last; ++__first)
    if (__pred(*__first))
      return true;
  return false;
}

}}
# 1763 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/algorithm" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/binary_search.h" 1 3
# 13 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/binary_search.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/comp_ref_type.h" 1 3
# 18 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/comp_ref_type.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Compare>
struct __debug_less
{
    _Compare &__comp_;
    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) __debug_less(_Compare& __c) : __comp_(__c) {}

    template <class _Tp, class _Up>
    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    bool operator()(const _Tp& __x, const _Up& __y)
    {
        bool __r = __comp_(__x, __y);
        if (__r)
            __do_compare_assert(0, __y, __x);
        return __r;
    }

    template <class _Tp, class _Up>
    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    bool operator()(_Tp& __x, _Up& __y)
    {
        bool __r = __comp_(__x, __y);
        if (__r)
            __do_compare_assert(0, __y, __x);
        return __r;
    }

    template <class _LHS, class _RHS>
    constexpr
    inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    decltype((void)std::declval<_Compare&>()(
        std::declval<_LHS &>(), std::declval<_RHS &>()))
    __do_compare_assert(int, _LHS & __l, _RHS & __r) {
        ((void)0);

        (void)__l;
        (void)__r;
    }

    template <class _LHS, class _RHS>
    constexpr
    inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    void __do_compare_assert(long, _LHS &, _RHS &) {}
};







template <class _Comp>
using __comp_ref_type = _Comp&;


}}
# 14 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/binary_search.h" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/lower_bound.h" 1 3
# 13 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/lower_bound.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/half_positive.h" 1 3
# 19 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/half_positive.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {



template <typename _Integral, __enable_if_t<is_integral<_Integral>::value, int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
_Integral
__half_positive(_Integral __value)
{
    return static_cast<_Integral>(static_cast<__make_unsigned_t<_Integral> >(__value) / 2);
}

template <typename _Tp, __enable_if_t<!is_integral<_Tp>::value, int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
_Tp
__half_positive(_Tp __value)
{
    return __value / 2;
}

}}
# 14 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/lower_bound.h" 2 3


# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__functional/identity.h" 1 3
# 19 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__functional/identity.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Tp>
struct __is_identity : false_type {};

struct __identity {
  template <class _Tp>
  [[__nodiscard__]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr _Tp&& operator()(_Tp&& __t) const noexcept {
    return std::forward<_Tp>(__t);
  }

  using is_transparent = void;
};

template <>
struct __is_identity<__identity> : true_type {};



struct identity {
    template<class _Tp>
    [[__nodiscard__]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr _Tp&& operator()(_Tp&& __t) const noexcept
    {
        return std::forward<_Tp>(__t);
    }

    using is_transparent = void;
};

template <>
struct __is_identity<identity> : true_type {};



}}
# 17 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/lower_bound.h" 2 3




# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_callable.h" 1 3
# 18 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_callable.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Func, class... _Args, class = decltype(std::declval<_Func>()(std::declval<_Args>()...))>
true_type __is_callable_helper(int);
template <class...>
false_type __is_callable_helper(...);

template <class _Func, class... _Args>
struct __is_callable : decltype(std::__is_callable_helper<_Func, _Args...>(0)) {};

}}
# 22 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/lower_bound.h" 2 3
# 26 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/lower_bound.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _AlgPolicy, class _Iter, class _Sent, class _Type, class _Proj, class _Comp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
_Iter __lower_bound(_Iter __first, _Sent __last, const _Type& __value, _Comp& __comp, _Proj& __proj) {
  auto __len = _IterOps<_AlgPolicy>::distance(__first, __last);

  while (__len != 0) {
    auto __l2 = std::__half_positive(__len);
    _Iter __m = __first;
    _IterOps<_AlgPolicy>::advance(__m, __l2);
    if (std::__invoke(__comp, std::__invoke(__proj, *__m), __value)) {
      __first = ++__m;
      __len -= __l2 + 1;
    } else {
      __len = __l2;
    }
  }
  return __first;
}

template <class _ForwardIterator, class _Tp, class _Compare>
[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
_ForwardIterator lower_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value, _Compare __comp) {
  static_assert(__is_callable<_Compare, decltype(*__first), const _Tp&>::value,
                "The comparator has to be callable");
  auto __proj = std::__identity();
  return std::__lower_bound<_ClassicAlgPolicy>(__first, __last, __value, __comp, __proj);
}

template <class _ForwardIterator, class _Tp>
[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
_ForwardIterator lower_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value) {
  return std::lower_bound(__first, __last, __value, __less<>());
}

}}
# 15 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/binary_search.h" 2 3
# 20 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/binary_search.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _ForwardIterator, class _Tp, class _Compare>
[[__nodiscard__]] inline
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
bool
binary_search(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value, _Compare __comp)
{
    __first = std::lower_bound<_ForwardIterator, _Tp, __comp_ref_type<_Compare> >(__first, __last, __value, __comp);
    return __first != __last && !__comp(__value, *__first);
}

template <class _ForwardIterator, class _Tp>
[[__nodiscard__]] inline
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
bool
binary_search(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value)
{
    return std::binary_search(__first, __last, __value, __less<>());
}

}}
# 1764 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/algorithm" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/clamp.h" 1 3
# 18 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/clamp.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {


template <class _Tp, class _Compare>
[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr const _Tp&
clamp([[_Clang::__lifetimebound__]] const _Tp& __v,
      [[_Clang::__lifetimebound__]] const _Tp& __lo,
      [[_Clang::__lifetimebound__]] const _Tp& __hi,
      _Compare __comp) {
  ((void)0);
  return __comp(__v, __lo) ? __lo : __comp(__hi, __v) ? __hi : __v;
}

template <class _Tp>
[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr const _Tp&
clamp([[_Clang::__lifetimebound__]] const _Tp& __v,
      [[_Clang::__lifetimebound__]] const _Tp& __lo,
      [[_Clang::__lifetimebound__]] const _Tp& __hi) {
  return std::clamp(__v, __lo, __hi, __less<>());
}


}}
# 1765 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/algorithm" 2 3


# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/copy.h" 1 3
# 12 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/copy.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/copy_move_common.h" 1 3
# 13 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/copy_move_common.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/unwrap_iter.h" 1 3
# 22 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/unwrap_iter.h" 3



# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__undef_macros" 1 3
# 26 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/unwrap_iter.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 37 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/unwrap_iter.h" 3
template <class _Iter, bool = __libcpp_is_contiguous_iterator<_Iter>::value>
struct __unwrap_iter_impl {
  static __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr _Iter __rewrap(_Iter, _Iter __iter) { return __iter; }
  static __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr _Iter __unwrap(_Iter __i) noexcept { return __i; }
};





template <class _Iter>
struct __unwrap_iter_impl<_Iter, true> {
  using _ToAddressT = decltype(std::__to_address(std::declval<_Iter>()));

  static __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr _Iter __rewrap(_Iter __orig_iter, _ToAddressT __unwrapped_iter) {
    return __orig_iter + (__unwrapped_iter - std::__to_address(__orig_iter));
  }

  static __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr _ToAddressT __unwrap(_Iter __i) noexcept {
    return std::__to_address(__i);
  }
};

template<class _Iter,
         class _Impl = __unwrap_iter_impl<_Iter>,
         __enable_if_t<is_copy_constructible<_Iter>::value, int> = 0>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
decltype(_Impl::__unwrap(std::declval<_Iter>())) __unwrap_iter(_Iter __i) noexcept {
  return _Impl::__unwrap(__i);
}



template <class _Iter, __enable_if_t<!is_copy_constructible<_Iter>::value, int> = 0>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr _Iter __unwrap_iter(_Iter __i) noexcept {
  return __i;
}


template <class _OrigIter, class _Iter, class _Impl = __unwrap_iter_impl<_OrigIter> >
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr _OrigIter __rewrap_iter(_OrigIter __orig_iter, _Iter __iter) noexcept {
  return _Impl::__rewrap(std::move(__orig_iter), std::move(__iter));
}

}}
# 14 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/copy_move_common.h" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/unwrap_range.h" 1 3
# 19 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/unwrap_range.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__utility/pair.h" 1 3
# 12 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__utility/pair.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__compare/common_comparison_category.h" 1 3
# 12 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__compare/common_comparison_category.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__compare/ordering.h" 1 3
# 18 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__compare/ordering.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {




enum class _OrdResult : signed char {
  __less = -1,
  __equiv = 0,
  __greater = 1
};

enum class _NCmpResult : signed char {
  __unordered = -127
};

class partial_ordering;
class weak_ordering;
class strong_ordering;

template<class _Tp, class... _Args>
inline constexpr bool __one_of_v = (is_same_v<_Tp, _Args> || ...);

struct _CmpUnspecifiedParam {
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
  _CmpUnspecifiedParam(int _CmpUnspecifiedParam::*) noexcept {}

  template<class _Tp, class = enable_if_t<!__one_of_v<_Tp, int, partial_ordering, weak_ordering, strong_ordering>>>
  _CmpUnspecifiedParam(_Tp) = delete;
};

class partial_ordering {
  using _ValueT = signed char;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
  explicit constexpr partial_ordering(_OrdResult __v) noexcept
      : __value_(_ValueT(__v)) {}

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
  explicit constexpr partial_ordering(_NCmpResult __v) noexcept
      : __value_(_ValueT(__v)) {}

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
  constexpr bool __is_ordered() const noexcept {
    return __value_ != _ValueT(_NCmpResult::__unordered);
  }
public:

  static const partial_ordering less;
  static const partial_ordering equivalent;
  static const partial_ordering greater;
  static const partial_ordering unordered;


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
  friend constexpr bool operator==(partial_ordering, partial_ordering) noexcept = default;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
  friend constexpr bool operator==(partial_ordering __v, _CmpUnspecifiedParam) noexcept {
    return __v.__is_ordered() && __v.__value_ == 0;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
  friend constexpr bool operator< (partial_ordering __v, _CmpUnspecifiedParam) noexcept {
    return __v.__is_ordered() && __v.__value_ < 0;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
  friend constexpr bool operator<=(partial_ordering __v, _CmpUnspecifiedParam) noexcept {
    return __v.__is_ordered() && __v.__value_ <= 0;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
  friend constexpr bool operator> (partial_ordering __v, _CmpUnspecifiedParam) noexcept {
    return __v.__is_ordered() && __v.__value_ > 0;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
  friend constexpr bool operator>=(partial_ordering __v, _CmpUnspecifiedParam) noexcept {
    return __v.__is_ordered() && __v.__value_ >= 0;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
  friend constexpr bool operator< (_CmpUnspecifiedParam, partial_ordering __v) noexcept {
    return __v.__is_ordered() && 0 < __v.__value_;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
  friend constexpr bool operator<=(_CmpUnspecifiedParam, partial_ordering __v) noexcept {
    return __v.__is_ordered() && 0 <= __v.__value_;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
  friend constexpr bool operator> (_CmpUnspecifiedParam, partial_ordering __v) noexcept {
    return __v.__is_ordered() && 0 > __v.__value_;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
  friend constexpr bool operator>=(_CmpUnspecifiedParam, partial_ordering __v) noexcept {
    return __v.__is_ordered() && 0 >= __v.__value_;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
  friend constexpr partial_ordering operator<=>(partial_ordering __v, _CmpUnspecifiedParam) noexcept {
    return __v;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
  friend constexpr partial_ordering operator<=>(_CmpUnspecifiedParam, partial_ordering __v) noexcept {
    return __v < 0 ? partial_ordering::greater : (__v > 0 ? partial_ordering::less : __v);
  }
private:
  _ValueT __value_;
};

inline constexpr partial_ordering partial_ordering::less(_OrdResult::__less);
inline constexpr partial_ordering partial_ordering::equivalent(_OrdResult::__equiv);
inline constexpr partial_ordering partial_ordering::greater(_OrdResult::__greater);
inline constexpr partial_ordering partial_ordering::unordered(_NCmpResult ::__unordered);

class weak_ordering {
  using _ValueT = signed char;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
  explicit constexpr weak_ordering(_OrdResult __v) noexcept : __value_(_ValueT(__v)) {}

public:
  static const weak_ordering less;
  static const weak_ordering equivalent;
  static const weak_ordering greater;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
  constexpr operator partial_ordering() const noexcept {
    return __value_ == 0 ? partial_ordering::equivalent
        : (__value_ < 0 ? partial_ordering::less : partial_ordering::greater);
  }


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
  friend constexpr bool operator==(weak_ordering, weak_ordering) noexcept = default;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
  friend constexpr bool operator==(weak_ordering __v, _CmpUnspecifiedParam) noexcept {
    return __v.__value_ == 0;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
  friend constexpr bool operator< (weak_ordering __v, _CmpUnspecifiedParam) noexcept {
    return __v.__value_ < 0;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
  friend constexpr bool operator<=(weak_ordering __v, _CmpUnspecifiedParam) noexcept {
    return __v.__value_ <= 0;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
  friend constexpr bool operator> (weak_ordering __v, _CmpUnspecifiedParam) noexcept {
    return __v.__value_ > 0;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
  friend constexpr bool operator>=(weak_ordering __v, _CmpUnspecifiedParam) noexcept {
    return __v.__value_ >= 0;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
  friend constexpr bool operator< (_CmpUnspecifiedParam, weak_ordering __v) noexcept {
    return 0 < __v.__value_;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
  friend constexpr bool operator<=(_CmpUnspecifiedParam, weak_ordering __v) noexcept {
    return 0 <= __v.__value_;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
  friend constexpr bool operator> (_CmpUnspecifiedParam, weak_ordering __v) noexcept {
    return 0 > __v.__value_;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
  friend constexpr bool operator>=(_CmpUnspecifiedParam, weak_ordering __v) noexcept {
    return 0 >= __v.__value_;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
  friend constexpr weak_ordering operator<=>(weak_ordering __v, _CmpUnspecifiedParam) noexcept {
    return __v;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
  friend constexpr weak_ordering operator<=>(_CmpUnspecifiedParam, weak_ordering __v) noexcept {
    return __v < 0 ? weak_ordering::greater : (__v > 0 ? weak_ordering::less : __v);
  }

private:
  _ValueT __value_;
};

inline constexpr weak_ordering weak_ordering::less(_OrdResult::__less);
inline constexpr weak_ordering weak_ordering::equivalent(_OrdResult::__equiv);
inline constexpr weak_ordering weak_ordering::greater(_OrdResult::__greater);

class strong_ordering {
  using _ValueT = signed char;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
  explicit constexpr strong_ordering(_OrdResult __v) noexcept : __value_(_ValueT(__v)) {}

public:
  static const strong_ordering less;
  static const strong_ordering equal;
  static const strong_ordering equivalent;
  static const strong_ordering greater;


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
  constexpr operator partial_ordering() const noexcept {
    return __value_ == 0 ? partial_ordering::equivalent
        : (__value_ < 0 ? partial_ordering::less : partial_ordering::greater);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
  constexpr operator weak_ordering() const noexcept {
    return __value_ == 0 ? weak_ordering::equivalent
        : (__value_ < 0 ? weak_ordering::less : weak_ordering::greater);
  }


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
  friend constexpr bool operator==(strong_ordering, strong_ordering) noexcept = default;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
  friend constexpr bool operator==(strong_ordering __v, _CmpUnspecifiedParam) noexcept {
    return __v.__value_ == 0;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
  friend constexpr bool operator< (strong_ordering __v, _CmpUnspecifiedParam) noexcept {
    return __v.__value_ < 0;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
  friend constexpr bool operator<=(strong_ordering __v, _CmpUnspecifiedParam) noexcept {
    return __v.__value_ <= 0;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
  friend constexpr bool operator> (strong_ordering __v, _CmpUnspecifiedParam) noexcept {
    return __v.__value_ > 0;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
  friend constexpr bool operator>=(strong_ordering __v, _CmpUnspecifiedParam) noexcept {
    return __v.__value_ >= 0;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
  friend constexpr bool operator< (_CmpUnspecifiedParam, strong_ordering __v) noexcept {
    return 0 < __v.__value_;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
  friend constexpr bool operator<=(_CmpUnspecifiedParam, strong_ordering __v) noexcept {
    return 0 <= __v.__value_;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
  friend constexpr bool operator> (_CmpUnspecifiedParam, strong_ordering __v) noexcept {
    return 0 > __v.__value_;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
  friend constexpr bool operator>=(_CmpUnspecifiedParam, strong_ordering __v) noexcept {
    return 0 >= __v.__value_;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
  friend constexpr strong_ordering operator<=>(strong_ordering __v, _CmpUnspecifiedParam) noexcept {
    return __v;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
  friend constexpr strong_ordering operator<=>(_CmpUnspecifiedParam, strong_ordering __v) noexcept {
    return __v < 0 ? strong_ordering::greater : (__v > 0 ? strong_ordering::less : __v);
  }

private:
  _ValueT __value_;
};

inline constexpr strong_ordering strong_ordering::less(_OrdResult::__less);
inline constexpr strong_ordering strong_ordering::equal(_OrdResult::__equiv);
inline constexpr strong_ordering strong_ordering::equivalent(_OrdResult::__equiv);
inline constexpr strong_ordering strong_ordering::greater(_OrdResult::__greater);




template <class _Tp>
concept __comparison_category = __one_of_v<_Tp, partial_ordering, weak_ordering, strong_ordering>;



}}
# 13 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__compare/common_comparison_category.h" 2 3
# 19 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__compare/common_comparison_category.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {



namespace __comp_detail {

enum _ClassifyCompCategory : unsigned {
  _None,
  _PartialOrd,
  _WeakOrd,
  _StrongOrd,
  _CCC_Size
};

template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
constexpr _ClassifyCompCategory __type_to_enum() noexcept {
  if (is_same_v<_Tp, partial_ordering>)
    return _PartialOrd;
  if (is_same_v<_Tp, weak_ordering>)
    return _WeakOrd;
  if (is_same_v<_Tp, strong_ordering>)
    return _StrongOrd;
  return _None;
}

template <size_t _Size>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
constexpr _ClassifyCompCategory
__compute_comp_type(const _ClassifyCompCategory (&__types)[_Size]) {
  int __seen[_CCC_Size] = {};
  for (auto __type : __types)
    ++__seen[__type];
  if (__seen[_None])
    return _None;
  if (__seen[_PartialOrd])
    return _PartialOrd;
  if (__seen[_WeakOrd])
    return _WeakOrd;
  return _StrongOrd;
}

template <class ..._Ts, bool _False = false>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
constexpr auto __get_comp_type() {
  using _CCC = _ClassifyCompCategory;
  constexpr _CCC __type_kinds[] = {_StrongOrd, __type_to_enum<_Ts>()...};
  constexpr _CCC __cat = __comp_detail::__compute_comp_type(__type_kinds);
  if constexpr (__cat == _None)
    return void();
  else if constexpr (__cat == _PartialOrd)
    return partial_ordering::equivalent;
  else if constexpr (__cat == _WeakOrd)
    return weak_ordering::equivalent;
  else if constexpr (__cat == _StrongOrd)
    return strong_ordering::equivalent;
  else
    static_assert(_False, "unhandled case");
}
}


template<class... _Ts>
struct common_comparison_category {
  using type = decltype(__comp_detail::__get_comp_type<_Ts...>());
};

template<class... _Ts>
using common_comparison_category_t = typename common_comparison_category<_Ts...>::type;



}}
# 13 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__utility/pair.h" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__compare/synth_three_way.h" 1 3
# 13 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__compare/synth_three_way.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__compare/three_way_comparable.h" 1 3
# 24 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__compare/three_way_comparable.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {



template<class _Tp, class _Cat>
concept __compares_as =
  same_as<common_comparison_category_t<_Tp, _Cat>, _Cat>;

template<class _Tp, class _Cat = partial_ordering>
concept three_way_comparable =
  __weakly_equality_comparable_with<_Tp, _Tp> &&
  __partially_ordered_with<_Tp, _Tp> &&
  requires(__make_const_lvalue_ref<_Tp> __a, __make_const_lvalue_ref<_Tp> __b) {
    { __a <=> __b } -> __compares_as<_Cat>;
  };

template<class _Tp, class _Up, class _Cat = partial_ordering>
concept three_way_comparable_with =
  three_way_comparable<_Tp, _Cat> &&
  three_way_comparable<_Up, _Cat> &&
  common_reference_with<__make_const_lvalue_ref<_Tp>, __make_const_lvalue_ref<_Up>> &&
  three_way_comparable<common_reference_t<__make_const_lvalue_ref<_Tp>, __make_const_lvalue_ref<_Up>>, _Cat> &&
  __weakly_equality_comparable_with<_Tp, _Up> &&
  __partially_ordered_with<_Tp, _Up> &&
  requires(__make_const_lvalue_ref<_Tp> __t, __make_const_lvalue_ref<_Up> __u) {
    { __t <=> __u } -> __compares_as<_Cat>;
    { __u <=> __t } -> __compares_as<_Cat>;
  };



}}
# 14 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__compare/synth_three_way.h" 2 3
# 20 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__compare/synth_three_way.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 32 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__compare/synth_three_way.h" 3
template <class _Tp, class _Up>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr auto __synth_three_way(const _Tp& __t, const _Up& __u)
  requires requires {
    { __t < __u } -> __boolean_testable;
    { __u < __t } -> __boolean_testable;
  }
{
  if constexpr (three_way_comparable_with<_Tp, _Up>) {
    return __t <=> __u;
  } else {
    if (__t < __u)
      return weak_ordering::less;
    if (__u < __t)
      return weak_ordering::greater;
    return weak_ordering::equivalent;
  }
}

template <class _Tp, class _Up = _Tp>
using __synth_three_way_result = decltype(std::__synth_three_way(std::declval<_Tp&>(), std::declval<_Up&>()));



}}
# 14 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__utility/pair.h" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__concepts/different_from.h" 1 3
# 18 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__concepts/different_from.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {



template <class _Tp, class _Up>
concept __different_from = !same_as<remove_cvref_t<_Tp>, remove_cvref_t<_Up>>;



}}
# 15 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__utility/pair.h" 2 3

# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__fwd/array.h" 1 3
# 17 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__fwd/array.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Tp, size_t _Size>
struct array;

}}
# 17 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__utility/pair.h" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__fwd/get.h" 1 3
# 16 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__fwd/get.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__fwd/subrange.h" 1 3
# 16 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__fwd/subrange.h" 3






namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

namespace ranges {

enum class subrange_kind : bool { unsized, sized };

template <input_or_output_iterator _Iter, sentinel_for<_Iter> _Sent, subrange_kind _Kind>
  requires(_Kind == subrange_kind::sized || !sized_sentinel_for<_Sent, _Iter>)
class subrange;

}

}}
# 17 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__fwd/get.h" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__fwd/tuple.h" 1 3
# 16 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__fwd/tuple.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {



template <class...>
class tuple;



}}
# 18 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__fwd/get.h" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__tuple/tuple_element.h" 1 3
# 13 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__tuple/tuple_element.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__tuple/tuple_indices.h" 1 3
# 13 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__tuple/tuple_indices.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__utility/integer_sequence.h" 1 3
# 18 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__utility/integer_sequence.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <size_t...> struct __tuple_indices;

template <class _IdxType, _IdxType... _Values>
struct __integer_sequence {
  template <template <class _OIdxType, _OIdxType...> class _ToIndexSeq, class _ToIndexType>
  using __convert = _ToIndexSeq<_ToIndexType, _Values...>;

  template <size_t _Sp>
  using __to_tuple_indices = __tuple_indices<(_Values + _Sp)...>;
};
# 77 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__utility/integer_sequence.h" 3
template <size_t _Ep, size_t _Sp>
using __make_indices_imp =
    typename __make_integer_seq<__integer_sequence, size_t, _Ep - _Sp>::template
    __to_tuple_indices<_Sp>;
# 90 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__utility/integer_sequence.h" 3
template<class _Tp, _Tp... _Ip>
struct integer_sequence
{
    typedef _Tp value_type;
    static_assert( is_integral<_Tp>::value,
                  "std::integer_sequence can only be instantiated with an integral type" );
    static
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    constexpr
    size_t
    size() noexcept { return sizeof...(_Ip); }
};

template<size_t... _Ip>
    using index_sequence = integer_sequence<size_t, _Ip...>;



template <class _Tp, _Tp _Ep>
using __make_integer_sequence __attribute__((__nodebug__)) = __make_integer_seq<integer_sequence, _Tp, _Ep>;
# 132 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__utility/integer_sequence.h" 3
template<class _Tp, _Tp _Np>
    using make_integer_sequence = __make_integer_sequence<_Tp, _Np>;

template<size_t _Np>
    using make_index_sequence = make_integer_sequence<size_t, _Np>;

template<class... _Tp>
    using index_sequence_for = make_index_sequence<sizeof...(_Tp)>;



template <size_t... _Index, class _Function>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr void __for_each_index_sequence(index_sequence<_Index...>, _Function __func) {
    (__func.template operator()<_Index>(), ...);
}




}}
# 14 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__tuple/tuple_indices.h" 2 3
# 18 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__tuple/tuple_indices.h" 3




namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <size_t...> struct __tuple_indices {};

template <size_t _Ep, size_t _Sp = 0>
struct __make_tuple_indices
{
    static_assert(_Sp <= _Ep, "__make_tuple_indices input error");
    typedef __make_indices_imp<_Ep, _Sp> type;
};

}}
# 14 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__tuple/tuple_element.h" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__tuple/tuple_types.h" 1 3
# 16 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__tuple/tuple_types.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class ..._Tp> struct __tuple_types {};

}}
# 15 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__tuple/tuple_element.h" 2 3
# 22 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__tuple/tuple_element.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <size_t _Ip, class _Tp> struct tuple_element;

template <size_t _Ip, class _Tp>
struct tuple_element<_Ip, const _Tp>
{
    typedef __attribute__((__nodebug__)) typename add_const<typename tuple_element<_Ip, _Tp>::type>::type type;
};

template <size_t _Ip, class _Tp>
struct tuple_element<_Ip, volatile _Tp>
{
    typedef __attribute__((__nodebug__)) typename add_volatile<typename tuple_element<_Ip, _Tp>::type>::type type;
};

template <size_t _Ip, class _Tp>
struct tuple_element<_Ip, const volatile _Tp>
{
    typedef __attribute__((__nodebug__)) typename add_cv<typename tuple_element<_Ip, _Tp>::type>::type type;
};
# 77 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__tuple/tuple_element.h" 3
template <size_t _Ip, class ..._Types>
struct tuple_element<_Ip, __tuple_types<_Types...> >
{
    static_assert(_Ip < sizeof...(_Types), "tuple_element index out of range");
    typedef __attribute__((__nodebug__)) __type_pack_element<_Ip, _Types...> type;
};


template <size_t _Ip, class ..._Tp>
using tuple_element_t __attribute__((__nodebug__)) = typename tuple_element <_Ip, _Tp...>::type;




}}
# 19 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__fwd/get.h" 2 3
# 23 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__fwd/get.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {



template <size_t _Ip, class ..._Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
typename tuple_element<_Ip, tuple<_Tp...> >::type&
get(tuple<_Tp...>&) noexcept;

template <size_t _Ip, class ..._Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
const typename tuple_element<_Ip, tuple<_Tp...> >::type&
get(const tuple<_Tp...>&) noexcept;

template <size_t _Ip, class ..._Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
typename tuple_element<_Ip, tuple<_Tp...> >::type&&
get(tuple<_Tp...>&&) noexcept;

template <size_t _Ip, class ..._Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
const typename tuple_element<_Ip, tuple<_Tp...> >::type&&
get(const tuple<_Tp...>&&) noexcept;



template <size_t _Ip, class _T1, class _T2>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
typename tuple_element<_Ip, pair<_T1, _T2> >::type&
get(pair<_T1, _T2>&) noexcept;

template <size_t _Ip, class _T1, class _T2>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
const typename tuple_element<_Ip, pair<_T1, _T2> >::type&
get(const pair<_T1, _T2>&) noexcept;


template <size_t _Ip, class _T1, class _T2>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
typename tuple_element<_Ip, pair<_T1, _T2> >::type&&
get(pair<_T1, _T2>&&) noexcept;

template <size_t _Ip, class _T1, class _T2>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
const typename tuple_element<_Ip, pair<_T1, _T2> >::type&&
get(const pair<_T1, _T2>&&) noexcept;


template <size_t _Ip, class _Tp, size_t _Size>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
_Tp&
get(array<_Tp, _Size>&) noexcept;

template <size_t _Ip, class _Tp, size_t _Size>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
const _Tp&
get(const array<_Tp, _Size>&) noexcept;


template <size_t _Ip, class _Tp, size_t _Size>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
_Tp&&
get(array<_Tp, _Size>&&) noexcept;

template <size_t _Ip, class _Tp, size_t _Size>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
const _Tp&&
get(const array<_Tp, _Size>&&) noexcept;




namespace ranges {

template <size_t _Index, class _Iter, class _Sent, subrange_kind _Kind>
  requires((_Index == 0 && copyable<_Iter>) || _Index == 1)
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr auto get(const subrange<_Iter, _Sent, _Kind>& __subrange);

template <size_t _Index, class _Iter, class _Sent, subrange_kind _Kind>
  requires(_Index < 2)
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr auto get(subrange<_Iter, _Sent, _Kind>&& __subrange);

}

using ranges::get;



}}
# 18 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__utility/pair.h" 2 3



# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__tuple/pair_like.h" 1 3
# 13 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__tuple/pair_like.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__tuple/tuple_like.h" 1 3
# 23 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__tuple/tuple_like.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {



template <class _Tp>
struct __tuple_like_impl : false_type {};

template <class... _Tp>
struct __tuple_like_impl<tuple<_Tp...> > : true_type {};

template <class _T1, class _T2>
struct __tuple_like_impl<pair<_T1, _T2> > : true_type {};

template <class _Tp, size_t _Size>
struct __tuple_like_impl<array<_Tp, _Size> > : true_type {};

template <class _Ip, class _Sp, ranges::subrange_kind _Kp>
struct __tuple_like_impl<ranges::subrange<_Ip, _Sp, _Kp> > : true_type {};

template <class _Tp>
concept __tuple_like = __tuple_like_impl<remove_cvref_t<_Tp>>::value;



}}
# 14 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__tuple/pair_like.h" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__tuple/tuple_size.h" 1 3
# 21 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__tuple/tuple_size.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Tp> struct tuple_size;


template <class _Tp, class...>
using __enable_if_tuple_size_imp = _Tp;

template <class _Tp>
struct tuple_size<__enable_if_tuple_size_imp<
    const _Tp,
    __enable_if_t<!is_volatile<_Tp>::value>,
    integral_constant<size_t, sizeof(tuple_size<_Tp>)>>>
    : public integral_constant<size_t, tuple_size<_Tp>::value> {};

template <class _Tp>
struct tuple_size<__enable_if_tuple_size_imp<
    volatile _Tp,
    __enable_if_t<!is_const<_Tp>::value>,
    integral_constant<size_t, sizeof(tuple_size<_Tp>)>>>
    : public integral_constant<size_t, tuple_size<_Tp>::value> {};

template <class _Tp>
struct tuple_size<__enable_if_tuple_size_imp<
    const volatile _Tp,
    integral_constant<size_t, sizeof(tuple_size<_Tp>)>>>
    : public integral_constant<size_t, tuple_size<_Tp>::value> {};
# 59 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__tuple/tuple_size.h" 3
template <class ..._Tp>
struct tuple_size<tuple<_Tp...> >
    : public integral_constant<size_t, sizeof...(_Tp)>
{
};

template <class ..._Tp>
struct tuple_size<__tuple_types<_Tp...> >
    : public integral_constant<size_t, sizeof...(_Tp)>
{
};



}}
# 15 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__tuple/pair_like.h" 2 3
# 19 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__tuple/pair_like.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {



template <class _Tp>
concept __pair_like = __tuple_like<_Tp> && tuple_size<remove_cvref_t<_Tp>>::value == 2;



}}
# 22 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__utility/pair.h" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__tuple/sfinae_helpers.h" 1 3
# 14 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__tuple/sfinae_helpers.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__tuple/make_tuple_types.h" 1 3
# 26 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__tuple/make_tuple_types.h" 3




namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {






template <class _TupleTypes, class _TupleIndices>
struct __make_tuple_types_flat;

template <template <class...> class _Tuple, class ..._Types, size_t ..._Idx>
struct __make_tuple_types_flat<_Tuple<_Types...>, __tuple_indices<_Idx...>> {

  template <class _Tp>
  using __apply_quals __attribute__((__nodebug__)) = __tuple_types<__apply_cv_t<_Tp, __type_pack_element<_Idx, _Types...>>...>;
};

template <class _Vt, size_t _Np, size_t ..._Idx>
struct __make_tuple_types_flat<array<_Vt, _Np>, __tuple_indices<_Idx...>> {
  template <size_t>
  using __value_type = _Vt;
  template <class _Tp>
  using __apply_quals = __tuple_types<__apply_cv_t<_Tp, __value_type<_Idx>>...>;
};

template <class _Tp, size_t _Ep = tuple_size<__libcpp_remove_reference_t<_Tp> >::value,
          size_t _Sp = 0,
          bool _SameSize = (_Ep == tuple_size<__libcpp_remove_reference_t<_Tp> >::value)>
struct __make_tuple_types
{
    static_assert(_Sp <= _Ep, "__make_tuple_types input error");
    using _RawTp = __remove_cv_t<__libcpp_remove_reference_t<_Tp> >;
    using _Maker = __make_tuple_types_flat<_RawTp, typename __make_tuple_indices<_Ep, _Sp>::type>;
    using type = typename _Maker::template __apply_quals<_Tp>;
};

template <class ..._Types, size_t _Ep>
struct __make_tuple_types<tuple<_Types...>, _Ep, 0, true> {
  typedef __attribute__((__nodebug__)) __tuple_types<_Types...> type;
};

template <class ..._Types, size_t _Ep>
struct __make_tuple_types<__tuple_types<_Types...>, _Ep, 0, true> {
  typedef __attribute__((__nodebug__)) __tuple_types<_Types...> type;
};

}}
# 15 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__tuple/sfinae_helpers.h" 2 3

# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__tuple/tuple_like_ext.h" 1 3
# 22 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__tuple/tuple_like_ext.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Tp> struct __tuple_like_ext : false_type {};

template <class _Tp> struct __tuple_like_ext<const _Tp> : public __tuple_like_ext<_Tp> {};
template <class _Tp> struct __tuple_like_ext<volatile _Tp> : public __tuple_like_ext<_Tp> {};
template <class _Tp> struct __tuple_like_ext<const volatile _Tp> : public __tuple_like_ext<_Tp> {};


template <class... _Tp> struct __tuple_like_ext<tuple<_Tp...> > : true_type {};


template <class _T1, class _T2> struct __tuple_like_ext<pair<_T1, _T2> > : true_type {};

template <class _Tp, size_t _Size> struct __tuple_like_ext<array<_Tp, _Size> > : true_type {};

template <class... _Tp> struct __tuple_like_ext<__tuple_types<_Tp...> > : true_type {};

}}
# 17 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__tuple/sfinae_helpers.h" 2 3




# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_assignable.h" 1 3
# 17 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_assignable.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Tp, class _Up>
struct is_assignable : _BoolConstant<__is_assignable(_Tp, _Up)> {};


template <class _Tp, class _Arg>
inline constexpr bool is_assignable_v = __is_assignable(_Tp, _Arg);


}}
# 22 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__tuple/sfinae_helpers.h" 2 3
# 31 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__tuple/sfinae_helpers.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {



template <bool ..._Preds>
struct __all_dummy;

template <bool ..._Pred>
struct __all : _IsSame<__all_dummy<_Pred...>, __all_dummy<((void)_Pred, true)...>> {};

struct __tuple_sfinae_base {
  template <template <class, class...> class _Trait,
            class ..._LArgs, class ..._RArgs>
  static auto __do_test(__tuple_types<_LArgs...>, __tuple_types<_RArgs...>)
    -> __all<__enable_if_t<_Trait<_LArgs, _RArgs>::value, bool>{true}...>;
  template <template <class...> class>
  static auto __do_test(...) -> false_type;

  template <class _FromArgs, class _ToArgs>
  using __constructible = decltype(__do_test<is_constructible>(_ToArgs{}, _FromArgs{}));
  template <class _FromArgs, class _ToArgs>
  using __convertible = decltype(__do_test<is_convertible>(_FromArgs{}, _ToArgs{}));
  template <class _FromArgs, class _ToArgs>
  using __assignable = decltype(__do_test<is_assignable>(_ToArgs{}, _FromArgs{}));
};



template <class _Tp, class _Up, bool = __tuple_like_ext<__libcpp_remove_reference_t<_Tp> >::value,
                                bool = __tuple_like_ext<_Up>::value>
struct __tuple_convertible
    : public false_type {};

template <class _Tp, class _Up>
struct __tuple_convertible<_Tp, _Up, true, true>
    : public __tuple_sfinae_base::__convertible<
      typename __make_tuple_types<_Tp>::type
    , typename __make_tuple_types<_Up>::type
    >
{};



template <class _Tp, class _Up, bool = __tuple_like_ext<__libcpp_remove_reference_t<_Tp> >::value,
                                bool = __tuple_like_ext<_Up>::value>
struct __tuple_constructible
    : public false_type {};

template <class _Tp, class _Up>
struct __tuple_constructible<_Tp, _Up, true, true>
    : public __tuple_sfinae_base::__constructible<
      typename __make_tuple_types<_Tp>::type
    , typename __make_tuple_types<_Up>::type
    >
{};



template <class _Tp, class _Up, bool = __tuple_like_ext<__libcpp_remove_reference_t<_Tp> >::value,
                                bool = __tuple_like_ext<_Up>::value>
struct __tuple_assignable
    : public false_type {};

template <class _Tp, class _Up>
struct __tuple_assignable<_Tp, _Up, true, true>
    : public __tuple_sfinae_base::__assignable<
      typename __make_tuple_types<_Tp>::type
    , typename __make_tuple_types<_Up&>::type
    >
{};


template <size_t _Ip, class ..._Tp>
struct tuple_element<_Ip, tuple<_Tp...> >
{
    typedef __attribute__((__nodebug__)) typename tuple_element<_Ip, __tuple_types<_Tp...> >::type type;
};

struct __attribute__((__visibility__("default"))) __check_tuple_constructor_fail {

    static __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr bool __enable_explicit_default() { return false; }
    static __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr bool __enable_implicit_default() { return false; }
    template <class ...>
    static __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr bool __enable_explicit() { return false; }
    template <class ...>
    static __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr bool __enable_implicit() { return false; }
    template <class ...>
    static __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr bool __enable_assign() { return false; }
};




template <bool _CanCopy, bool _CanMove>
struct __sfinae_ctor_base {};
template <>
struct __sfinae_ctor_base<false, false> {
  __sfinae_ctor_base() = default;
  __sfinae_ctor_base(__sfinae_ctor_base const&) = delete;
  __sfinae_ctor_base(__sfinae_ctor_base &&) = delete;
  __sfinae_ctor_base& operator=(__sfinae_ctor_base const&) = default;
  __sfinae_ctor_base& operator=(__sfinae_ctor_base&&) = default;
};
template <>
struct __sfinae_ctor_base<true, false> {
  __sfinae_ctor_base() = default;
  __sfinae_ctor_base(__sfinae_ctor_base const&) = default;
  __sfinae_ctor_base(__sfinae_ctor_base &&) = delete;
  __sfinae_ctor_base& operator=(__sfinae_ctor_base const&) = default;
  __sfinae_ctor_base& operator=(__sfinae_ctor_base&&) = default;
};
template <>
struct __sfinae_ctor_base<false, true> {
  __sfinae_ctor_base() = default;
  __sfinae_ctor_base(__sfinae_ctor_base const&) = delete;
  __sfinae_ctor_base(__sfinae_ctor_base &&) = default;
  __sfinae_ctor_base& operator=(__sfinae_ctor_base const&) = default;
  __sfinae_ctor_base& operator=(__sfinae_ctor_base&&) = default;
};

template <bool _CanCopy, bool _CanMove>
struct __sfinae_assign_base {};
template <>
struct __sfinae_assign_base<false, false> {
  __sfinae_assign_base() = default;
  __sfinae_assign_base(__sfinae_assign_base const&) = default;
  __sfinae_assign_base(__sfinae_assign_base &&) = default;
  __sfinae_assign_base& operator=(__sfinae_assign_base const&) = delete;
  __sfinae_assign_base& operator=(__sfinae_assign_base&&) = delete;
};
template <>
struct __sfinae_assign_base<true, false> {
  __sfinae_assign_base() = default;
  __sfinae_assign_base(__sfinae_assign_base const&) = default;
  __sfinae_assign_base(__sfinae_assign_base &&) = default;
  __sfinae_assign_base& operator=(__sfinae_assign_base const&) = default;
  __sfinae_assign_base& operator=(__sfinae_assign_base&&) = delete;
};
template <>
struct __sfinae_assign_base<false, true> {
  __sfinae_assign_base() = default;
  __sfinae_assign_base(__sfinae_assign_base const&) = default;
  __sfinae_assign_base(__sfinae_assign_base &&) = default;
  __sfinae_assign_base& operator=(__sfinae_assign_base const&) = delete;
  __sfinae_assign_base& operator=(__sfinae_assign_base&&) = default;
};


}}
# 23 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__utility/pair.h" 2 3
# 34 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__utility/pair.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_copy_assignable.h" 1 3
# 19 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_copy_assignable.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Tp>
struct is_copy_assignable
    : public integral_constant<
          bool,
          __is_assignable(__add_lvalue_reference_t<_Tp>, __add_lvalue_reference_t<typename add_const<_Tp>::type>)> {};


template <class _Tp>
inline constexpr bool is_copy_assignable_v = is_copy_assignable<_Tp>::value;


}}
# 35 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__utility/pair.h" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_default_constructible.h" 1 3
# 17 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_default_constructible.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Tp>
struct is_default_constructible : public integral_constant<bool, __is_constructible(_Tp)> {};


template <class _Tp>
inline constexpr bool is_default_constructible_v = __is_constructible(_Tp);


}}
# 36 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__utility/pair.h" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_implicitly_default_constructible.h" 1 3
# 18 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_implicitly_default_constructible.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {






template <class _Tp>
void __test_implicit_default_constructible(_Tp);

template <class _Tp, class = void, class = typename is_default_constructible<_Tp>::type>
struct __is_implicitly_default_constructible : false_type {};

template <class _Tp>
struct __is_implicitly_default_constructible<_Tp,
                                             decltype(std::__test_implicit_default_constructible<_Tp const&>({})),
                                             true_type> : true_type {};

template <class _Tp>
struct __is_implicitly_default_constructible<_Tp,
                                             decltype(std::__test_implicit_default_constructible<_Tp const&>({})),
                                             false_type> : false_type {};


}}
# 37 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__utility/pair.h" 2 3



# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_nothrow_copy_assignable.h" 1 3
# 19 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_nothrow_copy_assignable.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Tp>
struct is_nothrow_copy_assignable
    : public integral_constant<bool,
                               __is_nothrow_assignable(__add_lvalue_reference_t<_Tp>,
                                                       __add_lvalue_reference_t<typename add_const<_Tp>::type>)> {};


template <class _Tp>
inline constexpr bool is_nothrow_copy_assignable_v = is_nothrow_copy_assignable<_Tp>::value;


}}
# 41 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__utility/pair.h" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_nothrow_copy_constructible.h" 1 3
# 20 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_nothrow_copy_constructible.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 33 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_nothrow_copy_constructible.h" 3
template <class _Tp>
struct is_nothrow_copy_constructible
    : public integral_constant<
          bool,
          __is_nothrow_constructible(_Tp, typename add_lvalue_reference<typename add_const<_Tp>::type>::type)> {};




template <class _Tp>
inline constexpr bool is_nothrow_copy_constructible_v = is_nothrow_copy_constructible<_Tp>::value;


}}
# 42 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__utility/pair.h" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_nothrow_default_constructible.h" 1 3
# 17 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_nothrow_default_constructible.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Tp>
struct is_nothrow_default_constructible
    : public integral_constant<bool, __is_nothrow_constructible(_Tp)> {};


template <class _Tp>
inline constexpr bool is_nothrow_default_constructible_v = __is_nothrow_constructible(_Tp);


}}
# 43 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__utility/pair.h" 2 3





# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/unwrap_ref.h" 1 3
# 17 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/unwrap_ref.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Tp>
struct __unwrap_reference {
  typedef __attribute__((__nodebug__)) _Tp type;
};

template <class _Tp>
class reference_wrapper;

template <class _Tp>
struct __unwrap_reference<reference_wrapper<_Tp> > {
  typedef __attribute__((__nodebug__)) _Tp& type;
};

template <class _Tp>
struct decay;


template <class _Tp>
struct unwrap_reference : __unwrap_reference<_Tp> {};

template <class _Tp>
using unwrap_reference_t = typename unwrap_reference<_Tp>::type;

template <class _Tp>
struct unwrap_ref_decay : unwrap_reference<__decay_t<_Tp> > {};

template <class _Tp>
using unwrap_ref_decay_t = typename unwrap_ref_decay<_Tp>::type;


template <class _Tp>
struct __unwrap_ref_decay

    : unwrap_ref_decay<_Tp>



{
};

}}
# 49 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__utility/pair.h" 2 3



# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__utility/piecewise_construct.h" 1 3
# 16 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__utility/piecewise_construct.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

struct piecewise_construct_t { explicit piecewise_construct_t() = default; };


inline constexpr piecewise_construct_t piecewise_construct = piecewise_construct_t();




}}
# 53 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__utility/pair.h" 2 3
# 57 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__utility/pair.h" 3



# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__undef_macros" 1 3
# 61 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__utility/pair.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class, class>
struct __non_trivially_copyable_base {
  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
  __non_trivially_copyable_base() noexcept {}
  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
  __non_trivially_copyable_base(__non_trivially_copyable_base const&) noexcept {}
};


template <class _Tp>
struct __is_specialization_of_subrange : false_type {};

template <class _Iter, class _Sent, ranges::subrange_kind _Kind>
struct __is_specialization_of_subrange<ranges::subrange<_Iter, _Sent, _Kind>> : true_type {};


template <class _T1, class _T2>
struct pair



{
    using first_type = _T1;
    using second_type = _T2;

    _T1 first;
    _T2 second;

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) pair(pair const&) = default;
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) pair(pair&&) = default;
# 127 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__utility/pair.h" 3
    struct _CheckArgs {
      template <int&...>
      static __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr bool __enable_explicit_default() {
          return is_default_constructible<_T1>::value
              && is_default_constructible<_T2>::value
              && !__enable_implicit_default<>();
      }

      template <int&...>
      static __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr bool __enable_implicit_default() {
          return __is_implicitly_default_constructible<_T1>::value
              && __is_implicitly_default_constructible<_T2>::value;
      }

      template <class _U1, class _U2>
      static __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr bool __is_pair_constructible() {
          return is_constructible<first_type, _U1>::value
              && is_constructible<second_type, _U2>::value;
      }

      template <class _U1, class _U2>
      static __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr bool __is_implicit() {
          return is_convertible<_U1, first_type>::value
              && is_convertible<_U2, second_type>::value;
      }

      template <class _U1, class _U2>
      static __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr bool __enable_explicit() {
          return __is_pair_constructible<_U1, _U2>() && !__is_implicit<_U1, _U2>();
      }

      template <class _U1, class _U2>
      static __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr bool __enable_implicit() {
          return __is_pair_constructible<_U1, _U2>() && __is_implicit<_U1, _U2>();
      }
    };

    template <bool _MaybeEnable>
    using _CheckArgsDep __attribute__((__nodebug__)) = typename conditional<
      _MaybeEnable, _CheckArgs, __check_tuple_constructor_fail>::type;

    template<bool _Dummy = true, __enable_if_t<_CheckArgsDep<_Dummy>::__enable_explicit_default(), int> = 0>
    explicit __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    pair() noexcept(is_nothrow_default_constructible<first_type>::value && is_nothrow_default_constructible<second_type>::value)

        : first(), second() {}

    template<bool _Dummy = true, __enable_if_t<_CheckArgsDep<_Dummy>::__enable_implicit_default(), int> = 0>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    pair() noexcept(is_nothrow_default_constructible<first_type>::value && is_nothrow_default_constructible<second_type>::value)

        : first(), second() {}

    template <bool _Dummy = true,
              __enable_if_t<_CheckArgsDep<_Dummy>::template __enable_explicit<_T1 const&, _T2 const&>(), int> = 0>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    explicit pair(_T1 const& __t1, _T2 const& __t2)
        noexcept(is_nothrow_copy_constructible<first_type>::value && is_nothrow_copy_constructible<second_type>::value)

        : first(__t1), second(__t2) {}

    template<bool _Dummy = true,
             __enable_if_t<_CheckArgsDep<_Dummy>::template __enable_implicit<_T1 const&, _T2 const&>(), int> = 0>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    pair(_T1 const& __t1, _T2 const& __t2)
        noexcept(is_nothrow_copy_constructible<first_type>::value && is_nothrow_copy_constructible<second_type>::value)

        : first(__t1), second(__t2) {}

    template <

        class _U1 = _T1, class _U2 = _T2,



        __enable_if_t<_CheckArgs::template __enable_explicit<_U1, _U2>(), int> = 0
    >
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    explicit pair(_U1&& __u1, _U2&& __u2)
        noexcept((is_nothrow_constructible<first_type, _U1>::value && is_nothrow_constructible<second_type, _U2>::value))

        : first(std::forward<_U1>(__u1)), second(std::forward<_U2>(__u2)) {}

    template <

        class _U1 = _T1, class _U2 = _T2,



        __enable_if_t<_CheckArgs::template __enable_implicit<_U1, _U2>(), int> = 0
    >
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    pair(_U1&& __u1, _U2&& __u2)
        noexcept((is_nothrow_constructible<first_type, _U1>::value && is_nothrow_constructible<second_type, _U2>::value))

        : first(std::forward<_U1>(__u1)), second(std::forward<_U2>(__u2)) {}


    template<class _U1, class _U2, __enable_if_t<
            _CheckArgs::template __is_pair_constructible<_U1&, _U2&>()
    >* = nullptr>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    explicit(!_CheckArgs::template __is_implicit<_U1&, _U2&>()) pair(pair<_U1, _U2>& __p)
        noexcept((is_nothrow_constructible<first_type, _U1&>::value &&
                  is_nothrow_constructible<second_type, _U2&>::value))
        : first(__p.first), second(__p.second) {}


    template<class _U1, class _U2, __enable_if_t<_CheckArgs::template __enable_explicit<_U1 const&, _U2 const&>(), int> = 0>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    explicit pair(pair<_U1, _U2> const& __p)
        noexcept((is_nothrow_constructible<first_type, _U1 const&>::value && is_nothrow_constructible<second_type, _U2 const&>::value))

        : first(__p.first), second(__p.second) {}

    template<class _U1, class _U2, __enable_if_t<_CheckArgs::template __enable_implicit<_U1 const&, _U2 const&>(), int> = 0>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    pair(pair<_U1, _U2> const& __p)
        noexcept((is_nothrow_constructible<first_type, _U1 const&>::value && is_nothrow_constructible<second_type, _U2 const&>::value))

        : first(__p.first), second(__p.second) {}

    template<class _U1, class _U2, __enable_if_t<_CheckArgs::template __enable_explicit<_U1, _U2>(), int> = 0>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    explicit pair(pair<_U1, _U2>&&__p)
        noexcept((is_nothrow_constructible<first_type, _U1&&>::value && is_nothrow_constructible<second_type, _U2&&>::value))

        : first(std::forward<_U1>(__p.first)), second(std::forward<_U2>(__p.second)) {}

    template<class _U1, class _U2, __enable_if_t<_CheckArgs::template __enable_implicit<_U1, _U2>(), int> = 0>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    pair(pair<_U1, _U2>&& __p)
        noexcept((is_nothrow_constructible<first_type, _U1&&>::value && is_nothrow_constructible<second_type, _U2&&>::value))

        : first(std::forward<_U1>(__p.first)), second(std::forward<_U2>(__p.second)) {}


    template<class _U1, class _U2, __enable_if_t<
            _CheckArgs::template __is_pair_constructible<const _U1&&, const _U2&&>()
    >* = nullptr>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    explicit(!_CheckArgs::template __is_implicit<const _U1&&, const _U2&&>())
    pair(const pair<_U1, _U2>&& __p)
        noexcept(is_nothrow_constructible<first_type, const _U1&&>::value &&
                 is_nothrow_constructible<second_type, const _U2&&>::value)
        : first(std::move(__p.first)), second(std::move(__p.second)) {}




    template <class _PairLike>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) static constexpr bool __pair_like_explicit_wknd() {
        if constexpr (__pair_like<_PairLike>) {
            return !is_convertible_v<decltype(std::get<0>(std::declval<_PairLike&&>())), first_type> ||
                   !is_convertible_v<decltype(std::get<1>(std::declval<_PairLike&&>())), second_type>;
        }
        return false;
    }

    template <__pair_like _PairLike>
      requires(is_constructible_v<first_type, decltype(std::get<0>(std::declval<_PairLike&&>()))> &&
               is_constructible_v<second_type, decltype(std::get<1>(std::declval<_PairLike&&>()))>)
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr explicit(__pair_like_explicit_wknd<_PairLike>())
        pair(_PairLike&& __p)
        : first(std::get<0>(std::forward<_PairLike>(__p))), second(std::get<1>(std::forward<_PairLike>(__p))) {}


    template <class... _Args1, class... _Args2>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    pair(piecewise_construct_t __pc,
         tuple<_Args1...> __first_args, tuple<_Args2...> __second_args)
        noexcept((is_nothrow_constructible<first_type, _Args1...>::value && is_nothrow_constructible<second_type, _Args2...>::value))

        : pair(__pc, __first_args, __second_args,
                typename __make_tuple_indices<sizeof...(_Args1)>::type(),
                typename __make_tuple_indices<sizeof...(_Args2) >::type()) {}

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    pair& operator=(__conditional_t<
                        is_copy_assignable<first_type>::value &&
                        is_copy_assignable<second_type>::value,
                    pair, __nat> const& __p)
        noexcept(is_nothrow_copy_assignable<first_type>::value && is_nothrow_copy_assignable<second_type>::value)

    {
        first = __p.first;
        second = __p.second;
        return *this;
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    pair& operator=(__conditional_t<
                        is_move_assignable<first_type>::value &&
                        is_move_assignable<second_type>::value,
                    pair, __nat>&& __p)
        noexcept(is_nothrow_move_assignable<first_type>::value && is_nothrow_move_assignable<second_type>::value)

    {
        first = std::forward<first_type>(__p.first);
        second = std::forward<second_type>(__p.second);
        return *this;
    }

    template <class _U1, class _U2, __enable_if_t<
        is_assignable<first_type&, _U1 const&>::value &&
        is_assignable<second_type&, _U2 const&>::value
    >* = nullptr>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    pair& operator=(pair<_U1, _U2> const& __p) {
        first = __p.first;
        second = __p.second;
        return *this;
    }

    template <class _U1, class _U2, __enable_if_t<
        is_assignable<first_type&, _U1>::value &&
        is_assignable<second_type&, _U2>::value
    >* = nullptr>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    pair& operator=(pair<_U1, _U2>&& __p) {
        first = std::forward<_U1>(__p.first);
        second = std::forward<_U2>(__p.second);
        return *this;
    }


    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    const pair& operator=(pair const& __p) const
      noexcept(is_nothrow_copy_assignable_v<const first_type> &&
               is_nothrow_copy_assignable_v<const second_type>)
      requires(is_copy_assignable_v<const first_type> &&
               is_copy_assignable_v<const second_type>) {
        first = __p.first;
        second = __p.second;
        return *this;
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    const pair& operator=(pair&& __p) const
      noexcept(is_nothrow_assignable_v<const first_type&, first_type> &&
               is_nothrow_assignable_v<const second_type&, second_type>)
      requires(is_assignable_v<const first_type&, first_type> &&
               is_assignable_v<const second_type&, second_type>) {
        first = std::forward<first_type>(__p.first);
        second = std::forward<second_type>(__p.second);
        return *this;
    }

    template<class _U1, class _U2>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    const pair& operator=(const pair<_U1, _U2>& __p) const
      requires(is_assignable_v<const first_type&, const _U1&> &&
               is_assignable_v<const second_type&, const _U2&>) {
        first = __p.first;
        second = __p.second;
        return *this;
    }

    template<class _U1, class _U2>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    const pair& operator=(pair<_U1, _U2>&& __p) const
      requires(is_assignable_v<const first_type&, _U1> &&
               is_assignable_v<const second_type&, _U2>) {
        first = std::forward<_U1>(__p.first);
        second = std::forward<_U2>(__p.second);
        return *this;
    }

    template <__pair_like _PairLike>
      requires(__different_from<_PairLike, pair> &&
               !__is_specialization_of_subrange<remove_cvref_t<_PairLike>>::value &&
               is_assignable_v<first_type&, decltype(std::get<0>(std::declval<_PairLike>()))> &&
               is_assignable_v<second_type&, decltype(std::get<1>(std::declval<_PairLike>()))>)
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr pair& operator=(_PairLike&& __p) {
        first = std::get<0>(std::forward<_PairLike>(__p));
        second = std::get<1>(std::forward<_PairLike>(__p));
        return *this;
    }

    template <__pair_like _PairLike>
      requires(__different_from<_PairLike, pair> &&
               !__is_specialization_of_subrange<remove_cvref_t<_PairLike>>::value &&
               is_assignable_v<first_type const&, decltype(std::get<0>(std::declval<_PairLike>()))> &&
               is_assignable_v<second_type const&, decltype(std::get<1>(std::declval<_PairLike>()))>)
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr pair const& operator=(_PairLike&& __p) const {
        first = std::get<0>(std::forward<_PairLike>(__p));
        second = std::get<1>(std::forward<_PairLike>(__p));
        return *this;
    }
# 555 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__utility/pair.h" 3
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    void
    swap(pair& __p) noexcept(__is_nothrow_swappable<first_type>::value && __is_nothrow_swappable<second_type>::value)

    {
        using std::swap;
        swap(first, __p.first);
        swap(second, __p.second);
    }


    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    void swap(const pair& __p) const
        noexcept(__is_nothrow_swappable<const first_type>::value &&
                 __is_nothrow_swappable<const second_type>::value)
    {
        using std::swap;
        swap(first, __p.first);
        swap(second, __p.second);
    }

private:


    template <class... _Args1, class... _Args2, size_t... _I1, size_t... _I2>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    pair(piecewise_construct_t,
         tuple<_Args1...>& __first_args, tuple<_Args2...>& __second_args,
         __tuple_indices<_I1...>, __tuple_indices<_I2...>);

};


template<class _T1, class _T2>
pair(_T1, _T2) -> pair<_T1, _T2>;




template <class _T1, class _T2, class _U1, class _U2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
bool
operator==(const pair<_T1,_T2>& __x, const pair<_U1,_U2>& __y)
{
    return __x.first == __y.first && __x.second == __y.second;
}



template <class _T1, class _T2, class _U1, class _U2>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
common_comparison_category_t<
        __synth_three_way_result<_T1, _U1>,
        __synth_three_way_result<_T2, _U2> >
operator<=>(const pair<_T1,_T2>& __x, const pair<_U1,_U2>& __y)
{
    if (auto __c = std::__synth_three_way(__x.first, __y.first); __c != 0) {
      return __c;
    }
    return std::__synth_three_way(__x.second, __y.second);
}
# 662 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__utility/pair.h" 3
template <class _T1, class _T2, class _U1, class _U2, template<class> class _TQual, template<class> class _UQual>
    requires requires { typename pair<common_reference_t<_TQual<_T1>, _UQual<_U1>>,
                                      common_reference_t<_TQual<_T2>, _UQual<_U2>>>; }
struct basic_common_reference<pair<_T1, _T2>, pair<_U1, _U2>, _TQual, _UQual> {
    using type = pair<common_reference_t<_TQual<_T1>, _UQual<_U1>>,
                      common_reference_t<_TQual<_T2>, _UQual<_U2>>>;
};

template <class _T1, class _T2, class _U1, class _U2>
    requires requires { typename pair<common_type_t<_T1, _U1>, common_type_t<_T2, _U2>>; }
struct common_type<pair<_T1, _T2>, pair<_U1, _U2>> {
    using type = pair<common_type_t<_T1, _U1>, common_type_t<_T2, _U2>>;
};


template <class _T1, class _T2, __enable_if_t<__is_swappable<_T1>::value && __is_swappable<_T2>::value, int> = 0>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
void
swap(pair<_T1, _T2>& __x, pair<_T1, _T2>& __y)
                     noexcept((__is_nothrow_swappable<_T1>::value && __is_nothrow_swappable<_T2>::value))

{
    __x.swap(__y);
}


template <class _T1, class _T2>
  requires (__is_swappable<const _T1>::value &&
            __is_swappable<const _T2>::value)
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
void swap(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    noexcept(noexcept(__x.swap(__y)))
{
    __x.swap(__y);
}


template <class _T1, class _T2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
pair<typename __unwrap_ref_decay<_T1>::type, typename __unwrap_ref_decay<_T2>::type>
make_pair(_T1&& __t1, _T2&& __t2)
{
    return pair<typename __unwrap_ref_decay<_T1>::type, typename __unwrap_ref_decay<_T2>::type>
               (std::forward<_T1>(__t1), std::forward<_T2>(__t2));
}

template <class _T1, class _T2>
  struct tuple_size<pair<_T1, _T2> >
    : public integral_constant<size_t, 2> {};

template <size_t _Ip, class _T1, class _T2>
struct tuple_element<_Ip, pair<_T1, _T2> >
{
    static_assert(_Ip < 2, "Index out of bounds in std::tuple_element<std::pair<T1, T2>>");
};

template <class _T1, class _T2>
struct tuple_element<0, pair<_T1, _T2> >
{
    using type __attribute__((__nodebug__)) = _T1;
};

template <class _T1, class _T2>
struct tuple_element<1, pair<_T1, _T2> >
{
    using type __attribute__((__nodebug__)) = _T2;
};

template <size_t _Ip> struct __get_pair;

template <>
struct __get_pair<0>
{
    template <class _T1, class _T2>
    static
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    _T1&
    get(pair<_T1, _T2>& __p) noexcept {return __p.first;}

    template <class _T1, class _T2>
    static
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    const _T1&
    get(const pair<_T1, _T2>& __p) noexcept {return __p.first;}

    template <class _T1, class _T2>
    static
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    _T1&&
    get(pair<_T1, _T2>&& __p) noexcept {return std::forward<_T1>(__p.first);}

    template <class _T1, class _T2>
    static
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    const _T1&&
    get(const pair<_T1, _T2>&& __p) noexcept {return std::forward<const _T1>(__p.first);}
};

template <>
struct __get_pair<1>
{
    template <class _T1, class _T2>
    static
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    _T2&
    get(pair<_T1, _T2>& __p) noexcept {return __p.second;}

    template <class _T1, class _T2>
    static
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    const _T2&
    get(const pair<_T1, _T2>& __p) noexcept {return __p.second;}

    template <class _T1, class _T2>
    static
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    _T2&&
    get(pair<_T1, _T2>&& __p) noexcept {return std::forward<_T2>(__p.second);}

    template <class _T1, class _T2>
    static
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    const _T2&&
    get(const pair<_T1, _T2>&& __p) noexcept {return std::forward<const _T2>(__p.second);}
};

template <size_t _Ip, class _T1, class _T2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
typename tuple_element<_Ip, pair<_T1, _T2> >::type&
get(pair<_T1, _T2>& __p) noexcept
{
    return __get_pair<_Ip>::get(__p);
}

template <size_t _Ip, class _T1, class _T2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
const typename tuple_element<_Ip, pair<_T1, _T2> >::type&
get(const pair<_T1, _T2>& __p) noexcept
{
    return __get_pair<_Ip>::get(__p);
}

template <size_t _Ip, class _T1, class _T2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
typename tuple_element<_Ip, pair<_T1, _T2> >::type&&
get(pair<_T1, _T2>&& __p) noexcept
{
    return __get_pair<_Ip>::get(std::move(__p));
}

template <size_t _Ip, class _T1, class _T2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
const typename tuple_element<_Ip, pair<_T1, _T2> >::type&&
get(const pair<_T1, _T2>&& __p) noexcept
{
    return __get_pair<_Ip>::get(std::move(__p));
}


template <class _T1, class _T2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
constexpr _T1 & get(pair<_T1, _T2>& __p) noexcept
{
    return __get_pair<0>::get(__p);
}

template <class _T1, class _T2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
constexpr _T1 const & get(pair<_T1, _T2> const& __p) noexcept
{
    return __get_pair<0>::get(__p);
}

template <class _T1, class _T2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
constexpr _T1 && get(pair<_T1, _T2>&& __p) noexcept
{
    return __get_pair<0>::get(std::move(__p));
}

template <class _T1, class _T2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
constexpr _T1 const && get(pair<_T1, _T2> const&& __p) noexcept
{
    return __get_pair<0>::get(std::move(__p));
}

template <class _T1, class _T2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
constexpr _T1 & get(pair<_T2, _T1>& __p) noexcept
{
    return __get_pair<1>::get(__p);
}

template <class _T1, class _T2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
constexpr _T1 const & get(pair<_T2, _T1> const& __p) noexcept
{
    return __get_pair<1>::get(__p);
}

template <class _T1, class _T2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
constexpr _T1 && get(pair<_T2, _T1>&& __p) noexcept
{
    return __get_pair<1>::get(std::move(__p));
}

template <class _T1, class _T2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
constexpr _T1 const && get(pair<_T2, _T1> const&& __p) noexcept
{
    return __get_pair<1>::get(std::move(__p));
}



}}
# 20 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/unwrap_range.h" 2 3
# 23 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/unwrap_range.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {






template <class _Iter, class _Sent>
struct __unwrap_range_impl {
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) static constexpr auto __unwrap(_Iter __first, _Sent __sent)
    requires random_access_iterator<_Iter> && sized_sentinel_for<_Sent, _Iter>
  {
    auto __last = ranges::next(__first, __sent);
    return pair{std::__unwrap_iter(std::move(__first)), std::__unwrap_iter(std::move(__last))};
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) static constexpr auto __unwrap(_Iter __first, _Sent __last) {
    return pair{std::move(__first), std::move(__last)};
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) static constexpr auto
  __rewrap(_Iter __orig_iter, decltype(std::__unwrap_iter(std::move(__orig_iter))) __iter)
    requires random_access_iterator<_Iter> && sized_sentinel_for<_Sent, _Iter>
  {
    return std::__rewrap_iter(std::move(__orig_iter), std::move(__iter));
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) static constexpr auto __rewrap(const _Iter&, _Iter __iter)
    requires (!(random_access_iterator<_Iter> && sized_sentinel_for<_Sent, _Iter>))
  {
    return __iter;
  }
};

template <class _Iter>
struct __unwrap_range_impl<_Iter, _Iter> {
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) static constexpr auto __unwrap(_Iter __first, _Iter __last) {
    return pair{std::__unwrap_iter(std::move(__first)), std::__unwrap_iter(std::move(__last))};
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) static constexpr auto
  __rewrap(_Iter __orig_iter, decltype(std::__unwrap_iter(__orig_iter)) __iter) {
    return std::__rewrap_iter(std::move(__orig_iter), std::move(__iter));
  }
};

template <class _Iter, class _Sent>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr auto __unwrap_range(_Iter __first, _Sent __last) {
  return __unwrap_range_impl<_Iter, _Sent>::__unwrap(std::move(__first), std::move(__last));
}

template <
    class _Sent,
    class _Iter,
    class _Unwrapped = decltype(std::__unwrap_range(std::declval<_Iter>(), std::declval<_Sent>()))>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr _Iter __rewrap_range(_Iter __orig_iter, _Unwrapped __iter) {
  return __unwrap_range_impl<_Iter, _Sent>::__rewrap(std::move(__orig_iter), std::move(__iter));
}
# 95 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/unwrap_range.h" 3
}}
# 15 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/copy_move_common.h" 2 3



# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__string/constexpr_c_functions.h" 1 3
# 14 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__string/constexpr_c_functions.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__memory/construct_at.h" 1 3
# 15 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__memory/construct_at.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__iterator/access.h" 1 3
# 18 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__iterator/access.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Tp, size_t _Np>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
_Tp*
begin(_Tp (&__array)[_Np])
{
    return __array;
}

template <class _Tp, size_t _Np>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
_Tp*
end(_Tp (&__array)[_Np])
{
    return __array + _Np;
}



template <class _Cp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
auto
begin(_Cp& __c) -> decltype(__c.begin())
{
    return __c.begin();
}

template <class _Cp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
auto
begin(const _Cp& __c) -> decltype(__c.begin())
{
    return __c.begin();
}

template <class _Cp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
auto
end(_Cp& __c) -> decltype(__c.end())
{
    return __c.end();
}

template <class _Cp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
auto
end(const _Cp& __c) -> decltype(__c.end())
{
    return __c.end();
}



template <class _Cp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
auto cbegin(const _Cp& __c) -> decltype(std::begin(__c))
{
    return std::begin(__c);
}

template <class _Cp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
auto cend(const _Cp& __c) -> decltype(std::end(__c))
{
    return std::end(__c);
}
# 127 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__iterator/access.h" 3
}}
# 16 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__memory/construct_at.h" 2 3

# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__memory/voidify.h" 1 3
# 18 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__memory/voidify.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <typename _Tp>
__attribute__((__always_inline__)) __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr void* __voidify(_Tp& __from) {

  return const_cast<void*>(static_cast<const volatile void*>(std::addressof(__from)));
}

}}
# 18 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__memory/construct_at.h" 2 3





# 1 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/openmp_wrappers/new" 1 3
# 14 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/openmp_wrappers/new" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/new" 1 3
# 92 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/new" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__exception/exception.h" 1 3
# 22 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__exception/exception.h" 3


namespace std {
# 72 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__exception/exception.h" 3
class __attribute__((__visibility__("default"))) exception {
public:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) exception() noexcept {}
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) exception(const exception&) noexcept = default;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) exception& operator=(const exception&) noexcept = default;

  virtual ~exception() noexcept;
  virtual const char* what() const noexcept;
};

class __attribute__((__visibility__("default"))) bad_exception : public exception {
public:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) bad_exception() noexcept {}
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) bad_exception(const bad_exception&) noexcept = default;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) bad_exception& operator=(const bad_exception&) noexcept = default;
  ~bad_exception() noexcept override;
  const char* what() const noexcept override;
};


}
# 93 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/new" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/alignment_of.h" 1 3
# 18 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/alignment_of.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Tp>
struct alignment_of : public integral_constant<size_t, alignof(_Tp)> {};


template <class _Tp>
inline constexpr size_t alignment_of_v = alignof(_Tp);


}}
# 94 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/new" 2 3
# 108 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/new" 3
# 124 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/new" 3
namespace std
{


struct __attribute__((__visibility__("default"))) nothrow_t { explicit nothrow_t() = default; };
extern __attribute__((__visibility__("default"))) const nothrow_t nothrow;

class __attribute__((__visibility__("default"))) bad_alloc
    : public exception
{
public:
    bad_alloc() noexcept;
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) bad_alloc(const bad_alloc&) noexcept = default;
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) bad_alloc& operator=(const bad_alloc&) noexcept = default;
    ~bad_alloc() noexcept override;
    const char* what() const noexcept override;
};

class __attribute__((__visibility__("default"))) bad_array_new_length
    : public bad_alloc
{
public:
    bad_array_new_length() noexcept;
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) bad_array_new_length(const bad_array_new_length&) noexcept = default;
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) bad_array_new_length& operator=(const bad_array_new_length&) noexcept = default;
    ~bad_array_new_length() noexcept override;
    const char* what() const noexcept override;
};

typedef void (*new_handler)();
__attribute__((__visibility__("default"))) new_handler set_new_handler(new_handler) noexcept;
__attribute__((__visibility__("default"))) new_handler get_new_handler() noexcept;
# 177 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/new" 3
[[noreturn]] __attribute__((__visibility__("default"))) void __throw_bad_alloc();

[[noreturn]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
void __throw_bad_array_new_length()
{



    ::std::__libcpp_verbose_abort("bad_array_new_length was thrown in -fno-exceptions mode");

}




enum class align_val_t : size_t { };
# 201 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/new" 3
struct destroying_delete_t {
  explicit destroying_delete_t() = default;
};
inline constexpr destroying_delete_t destroying_delete{};


}
# 217 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/new" 3
[[__nodiscard__]] __attribute__((__visibility__("default"))) void* operator new(std::size_t __sz) ;
[[__nodiscard__]] __attribute__((__visibility__("default"))) void* operator new(std::size_t __sz, const std::nothrow_t&) noexcept __attribute__((__malloc__));
__attribute__((__visibility__("default"))) void operator delete(void* __p) noexcept;
__attribute__((__visibility__("default"))) void operator delete(void* __p, const std::nothrow_t&) noexcept;

__attribute__((__visibility__("default"))) void operator delete(void* __p, std::size_t __sz) noexcept;


[[__nodiscard__]] __attribute__((__visibility__("default"))) void* operator new[](std::size_t __sz) ;
[[__nodiscard__]] __attribute__((__visibility__("default"))) void* operator new[](std::size_t __sz, const std::nothrow_t&) noexcept __attribute__((__malloc__));
__attribute__((__visibility__("default"))) void operator delete[](void* __p) noexcept;
__attribute__((__visibility__("default"))) void operator delete[](void* __p, const std::nothrow_t&) noexcept;

__attribute__((__visibility__("default"))) void operator delete[](void* __p, std::size_t __sz) noexcept;



[[__nodiscard__]] __attribute__((__visibility__("default"))) void* operator new(std::size_t __sz, std::align_val_t) ;
[[__nodiscard__]] __attribute__((__visibility__("default"))) void* operator new(std::size_t __sz, std::align_val_t, const std::nothrow_t&) noexcept __attribute__((__malloc__));
__attribute__((__visibility__("default"))) void operator delete(void* __p, std::align_val_t) noexcept;
__attribute__((__visibility__("default"))) void operator delete(void* __p, std::align_val_t, const std::nothrow_t&) noexcept;

__attribute__((__visibility__("default"))) void operator delete(void* __p, std::size_t __sz, std::align_val_t) noexcept;


[[__nodiscard__]] __attribute__((__visibility__("default"))) void* operator new[](std::size_t __sz, std::align_val_t) ;
[[__nodiscard__]] __attribute__((__visibility__("default"))) void* operator new[](std::size_t __sz, std::align_val_t, const std::nothrow_t&) noexcept __attribute__((__malloc__));
__attribute__((__visibility__("default"))) void operator delete[](void* __p, std::align_val_t) noexcept;
__attribute__((__visibility__("default"))) void operator delete[](void* __p, std::align_val_t, const std::nothrow_t&) noexcept;

__attribute__((__visibility__("default"))) void operator delete[](void* __p, std::size_t __sz, std::align_val_t) noexcept;



[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) void* operator new (std::size_t, void* __p) noexcept {return __p;}
[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) void* operator new[](std::size_t, void* __p) noexcept {return __p;}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) void operator delete (void*, void*) noexcept {}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) void operator delete[](void*, void*) noexcept {}



namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

constexpr inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) bool __is_overaligned_for_new(size_t __align) noexcept {

  return __align > 16UL;



}

template <class ..._Args>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
void* __libcpp_operator_new(_Args ...__args) {

  return __builtin_operator_new(__args...);



}

template <class ..._Args>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
void __libcpp_operator_delete(_Args ...__args) {

  __builtin_operator_delete(__args...);



}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
void *__libcpp_allocate(size_t __size, size_t __align) {

  if (__is_overaligned_for_new(__align)) {
    const align_val_t __align_val = static_cast<align_val_t>(__align);
    return __libcpp_operator_new(__size, __align_val);
  }


  (void)__align;
  return __libcpp_operator_new(__size);
}

template <class ..._Args>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
void __do_deallocate_handle_size(void *__ptr, size_t __size, _Args ...__args) {

  (void)__size;
  return std::__libcpp_operator_delete(__ptr, __args...);



}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
void __libcpp_deallocate(void* __ptr, size_t __size, size_t __align) {




    if (__is_overaligned_for_new(__align)) {
      const align_val_t __align_val = static_cast<align_val_t>(__align);
      return __do_deallocate_handle_size(__ptr, __size, __align_val);
    } else {
      return __do_deallocate_handle_size(__ptr, __size);
    }

}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) void __libcpp_deallocate_unsized(void* __ptr, size_t __align) {




    if (__is_overaligned_for_new(__align)) {
      const align_val_t __align_val = static_cast<align_val_t>(__align);
      return __libcpp_operator_delete(__ptr, __align_val);
    } else {
      return __libcpp_operator_delete(__ptr);
    }

}

template <class _Tp>
[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
constexpr _Tp* __launder(_Tp* __p) noexcept
{
    static_assert (!(is_function<_Tp>::value), "can't launder functions" );
    static_assert (!(is_same<void, __remove_cv_t<_Tp> >::value), "can't launder cv-void" );
    return __builtin_launder(__p);
}


template <class _Tp>
[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
constexpr _Tp* launder(_Tp* __p) noexcept
{
    return std::__launder(__p);
}
# 370 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/new" 3
}}
# 15 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/openmp_wrappers/new" 2 3
# 27 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/openmp_wrappers/new" 3
inline void *operator new(long unsigned int size,
                          const std::nothrow_t &) noexcept {
  return ::operator new(size);
}

inline void *operator new[](long unsigned int size, const std::nothrow_t &) {
  return ::operator new(size);
}

inline void operator delete(void *ptr, const std::nothrow_t &)noexcept {
  ::operator delete(ptr);
}

inline void operator delete[](void *ptr,
                              const std::nothrow_t &) noexcept {
  ::operator delete(ptr);
}
# 24 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__memory/construct_at.h" 2 3
# 27 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__memory/construct_at.h" 3



# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__undef_macros" 1 3
# 31 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__memory/construct_at.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {





template <class _Tp, class... _Args, class = decltype(::new(std::declval<void*>()) _Tp(std::declval<_Args>()...))>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr _Tp* construct_at(_Tp* __location, _Args&&... __args) {
  ((void)0);
  return ::new (std::__voidify(*__location)) _Tp(std::forward<_Args>(__args)...);
}



template <class _Tp, class... _Args, class = decltype(::new(std::declval<void*>()) _Tp(std::declval<_Args>()...))>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr _Tp* __construct_at(_Tp* __location, _Args&&... __args) {

  return std::construct_at(__location, std::forward<_Args>(__args)...);




}






template <class _ForwardIterator>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
_ForwardIterator __destroy(_ForwardIterator, _ForwardIterator);

template <class _Tp, __enable_if_t<!is_array<_Tp>::value, int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
void __destroy_at(_Tp* __loc) {
    ((void)0);
    __loc->~_Tp();
}


template <class _Tp, __enable_if_t<is_array<_Tp>::value, int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
void __destroy_at(_Tp* __loc) {
    ((void)0);
    std::__destroy(std::begin(*__loc), std::end(*__loc));
}


template <class _ForwardIterator>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
_ForwardIterator __destroy(_ForwardIterator __first, _ForwardIterator __last) {
    for (; __first != __last; ++__first)
        std::__destroy_at(std::addressof(*__first));
    return __first;
}

template <class _BidirectionalIterator>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
_BidirectionalIterator __reverse_destroy(_BidirectionalIterator __first, _BidirectionalIterator __last) {
    while (__last != __first) {
        --__last;
        std::__destroy_at(std::addressof(*__last));
    }
    return __last;
}



template <class _Tp, enable_if_t<!is_array_v<_Tp>, int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
void destroy_at(_Tp* __loc) {
    std::__destroy_at(__loc);
}


template <class _Tp, enable_if_t<is_array_v<_Tp>, int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
void destroy_at(_Tp* __loc) {
  std::__destroy_at(__loc);
}


template <class _ForwardIterator>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
void destroy(_ForwardIterator __first, _ForwardIterator __last) {
  (void)std::__destroy(std::move(__first), std::move(__last));
}

template <class _ForwardIterator, class _Size>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
_ForwardIterator destroy_n(_ForwardIterator __first, _Size __n) {
    for (; __n > 0; (void)++__first, --__n)
        std::__destroy_at(std::addressof(*__first));
    return __first;
}



}}
# 15 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__string/constexpr_c_functions.h" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/datasizeof.h" 1 3
# 14 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/datasizeof.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_final.h" 1 3
# 17 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_final.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Tp>
struct __libcpp_is_final : public integral_constant<bool, __is_final(_Tp)> {};


template <class _Tp>
struct is_final : public integral_constant<bool, __is_final(_Tp)> {};



template <class _Tp>
inline constexpr bool is_final_v = __is_final(_Tp);


}}
# 15 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/datasizeof.h" 2 3
# 19 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/datasizeof.h" 3








namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Tp>
struct __libcpp_datasizeof {

  template <class = char>
  struct _FirstPaddingByte {
    [[__no_unique_address__]] _Tp __v_;
    char __first_padding_byte_;
  };
# 50 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/datasizeof.h" 3
  static const size_t value = __builtin_offsetof(_FirstPaddingByte<>, __first_padding_byte_);
};

}}
# 16 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__string/constexpr_c_functions.h" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_always_bitcastable.h" 1 3
# 17 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_always_bitcastable.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_trivially_copyable.h" 1 3
# 14 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_trivially_copyable.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/cstdint" 1 3
# 146 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/cstdint" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/stdint.h" 1 3
# 110 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/stdint.h" 3
# 124 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/stdint.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/stdint.h" 1 3
# 52 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/stdint.h" 3
# 1 "/usr/include/stdint.h" 1 3 4
# 26 "/usr/include/stdint.h" 3 4
# 1 "/usr/include/bits/libc-header-start.h" 1 3 4
# 27 "/usr/include/stdint.h" 2 3 4

# 1 "/usr/include/bits/wchar.h" 1 3 4
# 29 "/usr/include/stdint.h" 2 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 30 "/usr/include/stdint.h" 2 3 4







# 1 "/usr/include/bits/stdint-uintn.h" 1 3 4
# 24 "/usr/include/bits/stdint-uintn.h" 3 4
typedef __uint8_t uint8_t;
typedef __uint16_t uint16_t;
typedef __uint32_t uint32_t;
typedef __uint64_t uint64_t;
# 38 "/usr/include/stdint.h" 2 3 4





typedef __int_least8_t int_least8_t;
typedef __int_least16_t int_least16_t;
typedef __int_least32_t int_least32_t;
typedef __int_least64_t int_least64_t;


typedef __uint_least8_t uint_least8_t;
typedef __uint_least16_t uint_least16_t;
typedef __uint_least32_t uint_least32_t;
typedef __uint_least64_t uint_least64_t;





typedef signed char int_fast8_t;

typedef long int int_fast16_t;
typedef long int int_fast32_t;
typedef long int int_fast64_t;
# 71 "/usr/include/stdint.h" 3 4
typedef unsigned char uint_fast8_t;

typedef unsigned long int uint_fast16_t;
typedef unsigned long int uint_fast32_t;
typedef unsigned long int uint_fast64_t;
# 87 "/usr/include/stdint.h" 3 4
typedef long int intptr_t;


typedef unsigned long int uintptr_t;
# 101 "/usr/include/stdint.h" 3 4
typedef __intmax_t intmax_t;
typedef __uintmax_t uintmax_t;
# 53 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/stdint.h" 2 3
# 125 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/stdint.h" 2 3
# 147 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/cstdint" 2 3
# 158 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/cstdint" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

using ::int8_t __attribute__((__using_if_exists__));
using ::int16_t __attribute__((__using_if_exists__));
using ::int32_t __attribute__((__using_if_exists__));
using ::int64_t __attribute__((__using_if_exists__));

using ::uint8_t __attribute__((__using_if_exists__));
using ::uint16_t __attribute__((__using_if_exists__));
using ::uint32_t __attribute__((__using_if_exists__));
using ::uint64_t __attribute__((__using_if_exists__));

using ::int_least8_t __attribute__((__using_if_exists__));
using ::int_least16_t __attribute__((__using_if_exists__));
using ::int_least32_t __attribute__((__using_if_exists__));
using ::int_least64_t __attribute__((__using_if_exists__));

using ::uint_least8_t __attribute__((__using_if_exists__));
using ::uint_least16_t __attribute__((__using_if_exists__));
using ::uint_least32_t __attribute__((__using_if_exists__));
using ::uint_least64_t __attribute__((__using_if_exists__));

using ::int_fast8_t __attribute__((__using_if_exists__));
using ::int_fast16_t __attribute__((__using_if_exists__));
using ::int_fast32_t __attribute__((__using_if_exists__));
using ::int_fast64_t __attribute__((__using_if_exists__));

using ::uint_fast8_t __attribute__((__using_if_exists__));
using ::uint_fast16_t __attribute__((__using_if_exists__));
using ::uint_fast32_t __attribute__((__using_if_exists__));
using ::uint_fast64_t __attribute__((__using_if_exists__));

using ::intptr_t __attribute__((__using_if_exists__));
using ::uintptr_t __attribute__((__using_if_exists__));

using ::intmax_t __attribute__((__using_if_exists__));
using ::uintmax_t __attribute__((__using_if_exists__));

}}
# 15 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_trivially_copyable.h" 2 3
# 18 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_trivially_copyable.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Tp>
struct is_trivially_copyable : public integral_constant<bool, __is_trivially_copyable(_Tp)> {};


template <class _Tp>
inline constexpr bool is_trivially_copyable_v = __is_trivially_copyable(_Tp);



template <class _Tp>
inline constexpr bool __is_cheap_to_copy = is_trivially_copyable_v<_Tp> && sizeof(_Tp) <= sizeof(std::intmax_t);


}}
# 18 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_always_bitcastable.h" 2 3
# 22 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_always_bitcastable.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {







template <class _From, class _To>
struct __is_always_bitcastable {
  using _UnqualFrom = __remove_cv_t<_From>;
  using _UnqualTo = __remove_cv_t<_To>;


  static const bool value =

      (is_same<_UnqualFrom, _UnqualTo>::value && is_trivially_copyable<_UnqualFrom>::value) ||
# 74 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_always_bitcastable.h" 3
      (
        sizeof(_From) == sizeof(_To) &&
        is_integral<_From>::value &&
        is_integral<_To>::value &&
        !is_same<_UnqualTo, bool>::value
      );

};

}}
# 17 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__string/constexpr_c_functions.h" 2 3

# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_constant_evaluated.h" 1 3
# 16 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_constant_evaluated.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {


__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) inline constexpr bool is_constant_evaluated() noexcept {
  return __builtin_is_constant_evaluated();
}


__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) inline constexpr bool __libcpp_is_constant_evaluated() noexcept {
  return __builtin_is_constant_evaluated();
}

}}
# 19 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__string/constexpr_c_functions.h" 2 3

# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_equality_comparable.h" 1 3
# 24 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_equality_comparable.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Tp, class _Up, class = void>
struct __is_equality_comparable : false_type {};

template <class _Tp, class _Up>
struct __is_equality_comparable<_Tp, _Up, __void_t<decltype(std::declval<_Tp>() == std::declval<_Up>())> > : true_type {
};
# 47 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_equality_comparable.h" 3
template <class _Tp, class _Up>
struct __libcpp_is_trivially_equality_comparable_impl : false_type {};

template <class _Tp>
struct __libcpp_is_trivially_equality_comparable_impl<_Tp, _Tp>

    : integral_constant<bool, __is_trivially_equality_comparable(_Tp) && __is_equality_comparable<_Tp, _Tp>::value> {
};





template <class _Tp>
struct __libcpp_is_trivially_equality_comparable_impl<_Tp*, _Tp*> : true_type {};


template <class _Tp, class _Up>
struct __libcpp_is_trivially_equality_comparable_impl<_Tp*, _Up*>
    : integral_constant<
          bool,
          __is_equality_comparable<_Tp*, _Up*>::value &&
              (is_same<__remove_cv_t<_Tp>, __remove_cv_t<_Up> >::value || is_void<_Tp>::value || is_void<_Up>::value)> {
};

template <class _Tp, class _Up>
using __libcpp_is_trivially_equality_comparable =
    __libcpp_is_trivially_equality_comparable_impl<__remove_cv_t<_Tp>, __remove_cv_t<_Up> >;

}}
# 21 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__string/constexpr_c_functions.h" 2 3


# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_trivially_lexicographically_comparable.h" 1 3
# 22 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_trivially_lexicographically_comparable.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 45 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_trivially_lexicographically_comparable.h" 3
template <class _Tp, class _Up>
struct __libcpp_is_trivially_lexicographically_comparable
    : integral_constant<bool,
                        is_same<__remove_cv_t<_Tp>, __remove_cv_t<_Up> >::value && sizeof(_Tp) == 1 &&
                            is_unsigned<_Tp>::value> {};

}}
# 24 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__string/constexpr_c_functions.h" 2 3

# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__utility/is_pointer_in_range.h" 1 3
# 23 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__utility/is_pointer_in_range.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Tp, class _Up, class = void>
struct __is_less_than_comparable : false_type {};

template <class _Tp, class _Up>
struct __is_less_than_comparable<_Tp, _Up, __void_t<decltype(std::declval<_Tp>() < std::declval<_Up>())> > : true_type {
};

template <class _Tp, class _Up, __enable_if_t<__is_less_than_comparable<const _Tp*, const _Up*>::value, int> = 0>
constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) __attribute__((__no_sanitize__("address"))) bool __is_pointer_in_range(
    const _Tp* __begin, const _Tp* __end, const _Up* __ptr) {
  if (__libcpp_is_constant_evaluated()) {
    ((void)0);



    if (!__builtin_constant_p(__begin <= __ptr && __ptr < __end))
      return false;
  }


  return !__less<>()(__ptr, __begin) && __less<>()(__ptr, __end);
}

template <class _Tp, class _Up, __enable_if_t<!__is_less_than_comparable<const _Tp*, const _Up*>::value, int> = 0>
constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) __attribute__((__no_sanitize__("address"))) bool __is_pointer_in_range(
    const _Tp* __begin, const _Tp* __end, const _Up* __ptr) {
  if (__libcpp_is_constant_evaluated())
    return false;

  return reinterpret_cast<const char*>(__begin) <= reinterpret_cast<const char*>(__ptr) &&
         reinterpret_cast<const char*>(__ptr) < reinterpret_cast<const char*>(__end);
}

}}
# 26 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__string/constexpr_c_functions.h" 2 3
# 30 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__string/constexpr_c_functions.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {



enum class __element_count : size_t {};

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr size_t __constexpr_strlen(const char* __str) {
# 49 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__string/constexpr_c_functions.h" 3
  return __builtin_strlen(__str);
}




template <class _Tp, class _Up>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr int
__constexpr_memcmp(const _Tp* __lhs, const _Up* __rhs, __element_count __n) {
  static_assert(__libcpp_is_trivially_lexicographically_comparable<_Tp, _Up>::value,
                "_Tp and _Up have to be trivially lexicographically comparable");

  auto __count = static_cast<size_t>(__n);

  if (__libcpp_is_constant_evaluated()) {

    if (sizeof(_Tp) == 1 && !is_same<_Tp, bool>::value)
      return __builtin_memcmp(__lhs, __rhs, __count * sizeof(_Tp));


    while (__count != 0) {
      if (*__lhs < *__rhs)
        return -1;
      if (*__rhs < *__lhs)
        return 1;

      --__count;
      ++__lhs;
      ++__rhs;
    }
    return 0;
  } else {
    return __builtin_memcmp(__lhs, __rhs, __count * sizeof(_Tp));
  }
}




template <class _Tp, class _Up>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr bool
__constexpr_memcmp_equal(const _Tp* __lhs, const _Up* __rhs, __element_count __n) {
  static_assert(__libcpp_is_trivially_equality_comparable<_Tp, _Up>::value,
                "_Tp and _Up have to be trivially equality comparable");

  auto __count = static_cast<size_t>(__n);

  if (__libcpp_is_constant_evaluated()) {

    if (sizeof(_Tp) == 1 && is_integral<_Tp>::value && !is_same<_Tp, bool>::value)
      return __builtin_memcmp(__lhs, __rhs, __count * sizeof(_Tp)) == 0;

    while (__count != 0) {
      if (*__lhs != *__rhs)
        return false;

      --__count;
      ++__lhs;
      ++__rhs;
    }
    return true;
  } else {
    return __builtin_memcmp(__lhs, __rhs, __count * sizeof(_Tp)) == 0;
  }
}

template <class _Tp, class _Up>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr _Tp* __constexpr_memchr(_Tp* __str, _Up __value, size_t __count) {
  static_assert(sizeof(_Tp) == 1 && __libcpp_is_trivially_equality_comparable<_Tp, _Up>::value,
                "Calling memchr on non-trivially equality comparable types is unsafe.");

  if (__libcpp_is_constant_evaluated()) {


    if constexpr (is_same_v<remove_cv_t<_Tp>, char> && is_same_v<remove_cv_t<_Up>, char>)
      return __builtin_char_memchr(__str, __value, __count);


    for (; __count; --__count) {
      if (*__str == __value)
        return __str;
      ++__str;
    }
    return nullptr;
  } else {
    char __value_buffer = 0;
    __builtin_memcpy(&__value_buffer, &__value, sizeof(char));
    return static_cast<_Tp*>(__builtin_memchr(__str, __value_buffer, __count));
  }
}
# 150 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__string/constexpr_c_functions.h" 3
template <class _Tp, class _Up, __enable_if_t<is_assignable<_Tp&, _Up const&>::value, int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr _Tp& __assign_trivially_copyable(_Tp& __dest, _Up const& __src) {
  __dest = __src;
  return __dest;
}


template <class _Tp, class _Up, __enable_if_t<!is_assignable<_Tp&, _Up const&>::value &&
                                               is_assignable<_Tp&, _Up&&>::value, int> = 0>

__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr _Tp& __assign_trivially_copyable(_Tp& __dest, _Up& __src) {
  __dest =
      static_cast<_Up&&>(__src);
  return __dest;
}


template <class _Tp, class _Up, __enable_if_t<!is_assignable<_Tp&, _Up const&>::value &&
                                              !is_assignable<_Tp&, _Up&&>::value &&
                                               is_constructible<_Tp, _Up const&>::value, int> = 0>

__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr _Tp& __assign_trivially_copyable(_Tp& __dest, _Up const& __src) {


  std::__construct_at(std::addressof(__dest), __src);
  return __dest;
}


template <class _Tp, class _Up, __enable_if_t<!is_assignable<_Tp&, _Up const&>::value &&
                                              !is_assignable<_Tp&, _Up&&>::value &&
                                              !is_constructible<_Tp, _Up const&>::value &&
                                               is_constructible<_Tp, _Up&&>::value, int> = 0>

__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr _Tp& __assign_trivially_copyable(_Tp& __dest, _Up& __src) {


  std::__construct_at(
      std::addressof(__dest),
      static_cast<_Up&&>(__src));
  return __dest;
}

template <class _Tp, class _Up, __enable_if_t<__is_always_bitcastable<_Up, _Tp>::value, int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr _Tp*
__constexpr_memmove(_Tp* __dest, _Up* __src, __element_count __n) {
  size_t __count = static_cast<size_t>(__n);
  if (__libcpp_is_constant_evaluated()) {

    if (is_same<__remove_cv_t<_Tp>, __remove_cv_t<_Up> >::value) {
      ::__builtin_memmove(__dest, __src, __count * sizeof(_Tp));
      return __dest;
    }

    if (std::__is_pointer_in_range(__src, __src + __count, __dest)) {
      for (; __count > 0; --__count)
        std::__assign_trivially_copyable(__dest[__count - 1], __src[__count - 1]);
    } else {
      for (size_t __i = 0; __i != __count; ++__i)
        std::__assign_trivially_copyable(__dest[__i], __src[__i]);
    }
  } else if (__count > 0) {
    ::__builtin_memmove(__dest, __src, (__count - 1) * sizeof(_Tp) + __libcpp_datasizeof<_Tp>::value);
  }
  return __dest;
}

}}
# 19 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/copy_move_common.h" 2 3




# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_trivially_assignable.h" 1 3
# 17 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_trivially_assignable.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Tp, class _Arg>
struct is_trivially_assignable : integral_constant<bool, __is_trivially_assignable(_Tp, _Arg)> {};


template <class _Tp, class _Arg>
inline constexpr bool is_trivially_assignable_v = __is_trivially_assignable(_Tp, _Arg);


}}
# 24 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/copy_move_common.h" 2 3
# 32 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/copy_move_common.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {



template <class _From, class _To>
struct __can_lower_copy_assignment_to_memmove {
  static const bool value =

    __is_always_bitcastable<_From, _To>::value &&

    is_trivially_assignable<_To&, const _From&>::value &&

    !is_volatile<_From>::value &&
    !is_volatile<_To>::value;
};

template <class _From, class _To>
struct __can_lower_move_assignment_to_memmove {
  static const bool value =
    __is_always_bitcastable<_From, _To>::value &&
    is_trivially_assignable<_To&, _From&&>::value &&
    !is_volatile<_From>::value &&
    !is_volatile<_To>::value;
};



template <class _In, class _Out>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr pair<_In*, _Out*>
__copy_trivial_impl(_In* __first, _In* __last, _Out* __result) {
  const size_t __n = static_cast<size_t>(__last - __first);

  std::__constexpr_memmove(__result, __first, __element_count(__n));

  return std::make_pair(__last, __result + __n);
}

template <class _In, class _Out>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr pair<_In*, _Out*>
__copy_backward_trivial_impl(_In* __first, _In* __last, _Out* __result) {
  const size_t __n = static_cast<size_t>(__last - __first);
  __result -= __n;

  std::__constexpr_memmove(__result, __first, __element_count(__n));

  return std::make_pair(__last, __result);
}



template <class _F1, class _F2>
struct __overload : _F1, _F2 {
  using _F1::operator();
  using _F2::operator();
};

template <class _InIter, class _Sent, class _OutIter, class = void>
struct __can_rewrap : false_type {};

template <class _InIter, class _Sent, class _OutIter>
struct __can_rewrap<_InIter,
                    _Sent,
                    _OutIter,

                    __enable_if_t< is_copy_constructible<_InIter>::value &&
                                   is_copy_constructible<_OutIter>::value > > : true_type {};

template <class _Algorithm,
          class _InIter,
          class _Sent,
          class _OutIter,
          __enable_if_t<__can_rewrap<_InIter, _Sent, _OutIter>::value, int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr pair<_InIter, _OutIter>
__unwrap_and_dispatch(_InIter __first, _Sent __last, _OutIter __out_first) {
  auto __range = std::__unwrap_range(__first, std::move(__last));
  auto __result = _Algorithm()(std::move(__range.first), std::move(__range.second), std::__unwrap_iter(__out_first));
  return std::make_pair(std::__rewrap_range<_Sent>(std::move(__first), std::move(__result.first)),
                                 std::__rewrap_iter(std::move(__out_first), std::move(__result.second)));
}

template <class _Algorithm,
          class _InIter,
          class _Sent,
          class _OutIter,
          __enable_if_t<!__can_rewrap<_InIter, _Sent, _OutIter>::value, int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr pair<_InIter, _OutIter>
__unwrap_and_dispatch(_InIter __first, _Sent __last, _OutIter __out_first) {
  return _Algorithm()(std::move(__first), std::move(__last), std::move(__out_first));
}

template <class _AlgPolicy,
          class _NaiveAlgorithm,
          class _OptimizedAlgorithm,
          class _InIter,
          class _Sent,
          class _OutIter>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr pair<_InIter, _OutIter>
__dispatch_copy_or_move(_InIter __first, _Sent __last, _OutIter __out_first) {
  using _Algorithm = __overload<_NaiveAlgorithm, _OptimizedAlgorithm>;
  return std::__unwrap_and_dispatch<_Algorithm>(std::move(__first), std::move(__last), std::move(__out_first));
}

}}
# 13 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/copy.h" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/for_each_segment.h" 1 3
# 13 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/for_each_segment.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__iterator/segmented_iterator.h" 1 3
# 49 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__iterator/segmented_iterator.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Iterator>
struct __segmented_iterator_traits;
# 68 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__iterator/segmented_iterator.h" 3
template <class _Tp, size_t = 0>
struct __has_specialization : false_type {};

template <class _Tp>
struct __has_specialization<_Tp, sizeof(_Tp) * 0> : true_type {};

template <class _Iterator>
using __is_segmented_iterator = __has_specialization<__segmented_iterator_traits<_Iterator> >;

}}
# 14 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/for_each_segment.h" 2 3
# 17 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/for_each_segment.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {





template <class _SegmentedIterator, class _Functor>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr void
__for_each_segment(_SegmentedIterator __first, _SegmentedIterator __last, _Functor __func) {
  using _Traits = __segmented_iterator_traits<_SegmentedIterator>;

  auto __sfirst = _Traits::__segment(__first);
  auto __slast = _Traits::__segment(__last);


  if (__sfirst == __slast) {
    __func(_Traits::__local(__first), _Traits::__local(__last));
    return;
  }


  __func(_Traits::__local(__first), _Traits::__end(__sfirst));
  ++__sfirst;

  while (__sfirst != __slast) {
    __func(_Traits::__begin(__sfirst), _Traits::__end(__sfirst));
    ++__sfirst;
  }

  __func(_Traits::__begin(__sfirst), _Traits::__local(__last));
}

}}
# 14 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/copy.h" 2 3

# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/min.h" 1 3
# 14 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/min.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/min_element.h" 1 3
# 23 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/min_element.h" 3



# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__undef_macros" 1 3
# 27 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/min_element.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Comp, class _Iter, class _Sent, class _Proj>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
_Iter __min_element(_Iter __first, _Sent __last, _Comp __comp, _Proj& __proj) {
  if (__first == __last)
    return __first;

  _Iter __i = __first;
  while (++__i != __last)
    if (std::__invoke(__comp, std::__invoke(__proj, *__i), std::__invoke(__proj, *__first)))
      __first = __i;

  return __first;
}

template <class _Comp, class _Iter, class _Sent>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
_Iter __min_element(_Iter __first, _Sent __last, _Comp __comp) {
  auto __proj = __identity();
  return std::__min_element<_Comp>(std::move(__first), std::move(__last), __comp, __proj);
}

template <class _ForwardIterator, class _Compare>
[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr _ForwardIterator
min_element(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)
{
  static_assert(__has_forward_iterator_category<_ForwardIterator>::value,
      "std::min_element requires a ForwardIterator");
  static_assert(__is_callable<_Compare, decltype(*__first), decltype(*__first)>::value,
              "The comparator has to be callable");

  return std::__min_element<__comp_ref_type<_Compare> >(std::move(__first), std::move(__last), __comp);
}

template <class _ForwardIterator>
[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr _ForwardIterator
min_element(_ForwardIterator __first, _ForwardIterator __last)
{
    return std::min_element(__first, __last, __less<>());
}

}}
# 15 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/min.h" 2 3
# 20 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/min.h" 3



# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__undef_macros" 1 3
# 24 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/min.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Tp, class _Compare>
[[__nodiscard__]] inline
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
const _Tp&
min([[_Clang::__lifetimebound__]] const _Tp& __a, [[_Clang::__lifetimebound__]] const _Tp& __b, _Compare __comp)
{
    return __comp(__b, __a) ? __b : __a;
}

template <class _Tp>
[[__nodiscard__]] inline
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
const _Tp&
min([[_Clang::__lifetimebound__]] const _Tp& __a, [[_Clang::__lifetimebound__]] const _Tp& __b)
{
    return std::min(__a, __b, __less<>());
}



template<class _Tp, class _Compare>
[[__nodiscard__]] inline
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
_Tp
min(initializer_list<_Tp> __t, _Compare __comp)
{
    return *std::__min_element<__comp_ref_type<_Compare> >(__t.begin(), __t.end(), __comp);
}

template<class _Tp>
[[__nodiscard__]] inline
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
_Tp
min(initializer_list<_Tp> __t)
{
    return *std::min_element(__t.begin(), __t.end(), __less<>());
}



}}
# 16 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/copy.h" 2 3
# 24 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/copy.h" 3



# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__undef_macros" 1 3
# 28 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/copy.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class, class _InIter, class _Sent, class _OutIter>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr pair<_InIter, _OutIter> __copy(_InIter, _Sent, _OutIter);

template <class _AlgPolicy>
struct __copy_loop {
  template <class _InIter, class _Sent, class _OutIter>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr pair<_InIter, _OutIter>
  operator()(_InIter __first, _Sent __last, _OutIter __result) const {
    while (__first != __last) {
      *__result = *__first;
      ++__first;
      ++__result;
    }

    return std::make_pair(std::move(__first), std::move(__result));
  }

  template <class _InIter, class _OutIter>
  struct _CopySegment {
    using _Traits = __segmented_iterator_traits<_InIter>;

    _OutIter& __result_;

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) _CopySegment(_OutIter& __result) : __result_(__result) {}

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) void
    operator()(typename _Traits::__local_iterator __lfirst, typename _Traits::__local_iterator __llast) {
      __result_ = std::__copy<_AlgPolicy>(__lfirst, __llast, std::move(__result_)).second;
    }
  };

  template <class _InIter, class _OutIter, __enable_if_t<__is_segmented_iterator<_InIter>::value, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr pair<_InIter, _OutIter>
  operator()(_InIter __first, _InIter __last, _OutIter __result) const {
    std::__for_each_segment(__first, __last, _CopySegment<_InIter, _OutIter>(__result));
    return std::make_pair(__last, std::move(__result));
  }

  template <class _InIter,
            class _OutIter,
            __enable_if_t<__has_random_access_iterator_category<_InIter>::value &&
                              !__is_segmented_iterator<_InIter>::value && __is_segmented_iterator<_OutIter>::value,
                          int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr pair<_InIter, _OutIter>
  operator()(_InIter __first, _InIter __last, _OutIter __result) const {
    using _Traits = __segmented_iterator_traits<_OutIter>;
    using _DiffT = typename common_type<__iter_diff_t<_InIter>, __iter_diff_t<_OutIter> >::type;

    if (__first == __last)
      return std::make_pair(std::move(__first), std::move(__result));

    auto __local_first = _Traits::__local(__result);
    auto __segment_iterator = _Traits::__segment(__result);
    while (true) {
      auto __local_last = _Traits::__end(__segment_iterator);
      auto __size = std::min<_DiffT>(__local_last - __local_first, __last - __first);
      auto __iters = std::__copy<_AlgPolicy>(__first, __first + __size, __local_first);
      __first = std::move(__iters.first);

      if (__first == __last)
        return std::make_pair(std::move(__first), _Traits::__compose(__segment_iterator, std::move(__iters.second)));

      __local_first = _Traits::__begin(++__segment_iterator);
    }
  }
};

struct __copy_trivial {

  template <class _In, class _Out, __enable_if_t<__can_lower_copy_assignment_to_memmove<_In, _Out>::value, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr pair<_In*, _Out*>
  operator()(_In* __first, _In* __last, _Out* __result) const {
    return std::__copy_trivial_impl(__first, __last, __result);
  }
};

template <class _AlgPolicy, class _InIter, class _Sent, class _OutIter>
pair<_InIter, _OutIter> inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
__copy(_InIter __first, _Sent __last, _OutIter __result) {
  return std::__dispatch_copy_or_move<_AlgPolicy, __copy_loop<_AlgPolicy>, __copy_trivial>(
      std::move(__first), std::move(__last), std::move(__result));
}

template <class _InputIterator, class _OutputIterator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr _OutputIterator
copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result) {
  return std::__copy<_ClassicAlgPolicy>(__first, __last, __result).second;
}

}}
# 1768 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/algorithm" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/copy_backward.h" 1 3
# 24 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/copy_backward.h" 3



# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__undef_macros" 1 3
# 28 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/copy_backward.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _AlgPolicy, class _InIter, class _Sent, class _OutIter>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr pair<_InIter, _OutIter>
__copy_backward(_InIter __first, _Sent __last, _OutIter __result);

template <class _AlgPolicy>
struct __copy_backward_loop {
  template <class _InIter, class _Sent, class _OutIter>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr pair<_InIter, _OutIter>
  operator()(_InIter __first, _Sent __last, _OutIter __result) const {
    auto __last_iter = _IterOps<_AlgPolicy>::next(__first, __last);
    auto __original_last_iter = __last_iter;

    while (__first != __last_iter) {
      *--__result = *--__last_iter;
    }

    return std::make_pair(std::move(__original_last_iter), std::move(__result));
  }

  template <class _InIter, class _OutIter, __enable_if_t<__is_segmented_iterator<_InIter>::value, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr pair<_InIter, _OutIter>
  operator()(_InIter __first, _InIter __last, _OutIter __result) const {
    using _Traits = __segmented_iterator_traits<_InIter>;
    auto __sfirst = _Traits::__segment(__first);
    auto __slast = _Traits::__segment(__last);
    if (__sfirst == __slast) {
      auto __iters =
          std::__copy_backward<_AlgPolicy>(_Traits::__local(__first), _Traits::__local(__last), std::move(__result));
      return std::make_pair(__last, __iters.second);
    }

    __result =
        std::__copy_backward<_AlgPolicy>(_Traits::__begin(__slast), _Traits::__local(__last), std::move(__result))
            .second;
    --__slast;
    while (__sfirst != __slast) {
      __result =
          std::__copy_backward<_AlgPolicy>(_Traits::__begin(__slast), _Traits::__end(__slast), std::move(__result))
              .second;
      --__slast;
    }
    __result = std::__copy_backward<_AlgPolicy>(_Traits::__local(__first), _Traits::__end(__slast), std::move(__result))
                   .second;
    return std::make_pair(__last, std::move(__result));
  }

  template <class _InIter,
            class _OutIter,
            __enable_if_t<__has_random_access_iterator_category<_InIter>::value &&
                              !__is_segmented_iterator<_InIter>::value && __is_segmented_iterator<_OutIter>::value,
                          int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr pair<_InIter, _OutIter>
  operator()(_InIter __first, _InIter __last, _OutIter __result) const {
    using _Traits = __segmented_iterator_traits<_OutIter>;
    auto __orig_last = __last;
    auto __segment_iterator = _Traits::__segment(__result);


    if (__first == __last)
      return std::make_pair(__first, __result);

    auto __local_last = _Traits::__local(__result);
    while (true) {
      using _DiffT = typename common_type<__iter_diff_t<_InIter>, __iter_diff_t<_OutIter> >::type;

      auto __local_first = _Traits::__begin(__segment_iterator);
      auto __size = std::min<_DiffT>(__local_last - __local_first, __last - __first);
      auto __iter = std::__copy_backward<_AlgPolicy>(__last - __size, __last, __local_last).second;
      __last -= __size;

      if (__first == __last)
        return std::make_pair(std::move(__orig_last), _Traits::__compose(__segment_iterator, std::move(__iter)));
      --__segment_iterator;
      __local_last = _Traits::__end(__segment_iterator);
    }
  }
};

struct __copy_backward_trivial {

  template <class _In, class _Out,
            __enable_if_t<__can_lower_copy_assignment_to_memmove<_In, _Out>::value, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr pair<_In*, _Out*>
  operator()(_In* __first, _In* __last, _Out* __result) const {
    return std::__copy_backward_trivial_impl(__first, __last, __result);
  }
};

template <class _AlgPolicy, class _BidirectionalIterator1, class _Sentinel, class _BidirectionalIterator2>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr pair<_BidirectionalIterator1, _BidirectionalIterator2>
__copy_backward(_BidirectionalIterator1 __first, _Sentinel __last, _BidirectionalIterator2 __result) {
  return std::__dispatch_copy_or_move<_AlgPolicy, __copy_backward_loop<_AlgPolicy>, __copy_backward_trivial>(
      std::move(__first), std::move(__last), std::move(__result));
}

template <class _BidirectionalIterator1, class _BidirectionalIterator2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
_BidirectionalIterator2
copy_backward(_BidirectionalIterator1 __first, _BidirectionalIterator1 __last,
              _BidirectionalIterator2 __result)
{
  static_assert(std::is_copy_constructible<_BidirectionalIterator1>::value &&
                std::is_copy_constructible<_BidirectionalIterator1>::value, "Iterators must be copy constructible.");

  return std::__copy_backward<_ClassicAlgPolicy>(
      std::move(__first), std::move(__last), std::move(__result)).second;
}

}}
# 1769 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/algorithm" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/copy_if.h" 1 3
# 16 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/copy_if.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template<class _InputIterator, class _OutputIterator, class _Predicate>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
_OutputIterator
copy_if(_InputIterator __first, _InputIterator __last,
        _OutputIterator __result, _Predicate __pred)
{
    for (; __first != __last; ++__first)
    {
        if (__pred(*__first))
        {
            *__result = *__first;
            ++__result;
        }
    }
    return __result;
}

}}
# 1770 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/algorithm" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/copy_n.h" 1 3
# 20 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/copy_n.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template<class _InputIterator, class _Size, class _OutputIterator,
         __enable_if_t<__has_input_iterator_category<_InputIterator>::value &&
                       !__has_random_access_iterator_category<_InputIterator>::value, int> = 0>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
_OutputIterator
copy_n(_InputIterator __first, _Size __orig_n, _OutputIterator __result)
{
    typedef decltype(std::__convert_to_integral(__orig_n)) _IntegralSize;
    _IntegralSize __n = __orig_n;
    if (__n > 0)
    {
        *__result = *__first;
        ++__result;
        for (--__n; __n > 0; --__n)
        {
            ++__first;
            *__result = *__first;
            ++__result;
        }
    }
    return __result;
}

template<class _InputIterator, class _Size, class _OutputIterator,
         __enable_if_t<__has_random_access_iterator_category<_InputIterator>::value, int> = 0>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
_OutputIterator
copy_n(_InputIterator __first, _Size __orig_n, _OutputIterator __result)
{
    typedef typename iterator_traits<_InputIterator>::difference_type difference_type;
    typedef decltype(std::__convert_to_integral(__orig_n)) _IntegralSize;
    _IntegralSize __n = __orig_n;
    return std::copy(__first, __first + difference_type(__n), __result);
}

}}
# 1771 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/algorithm" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/count.h" 1 3
# 18 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/count.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _InputIterator, class _Tp>
[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    typename iterator_traits<_InputIterator>::difference_type
    count(_InputIterator __first, _InputIterator __last, const _Tp& __value) {
  typename iterator_traits<_InputIterator>::difference_type __r(0);
  for (; __first != __last; ++__first)
    if (*__first == __value)
      ++__r;
  return __r;
}

}}
# 1772 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/algorithm" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/count_if.h" 1 3
# 18 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/count_if.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _InputIterator, class _Predicate>
[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    typename iterator_traits<_InputIterator>::difference_type
    count_if(_InputIterator __first, _InputIterator __last, _Predicate __pred) {
  typename iterator_traits<_InputIterator>::difference_type __r(0);
  for (; __first != __last; ++__first)
    if (__pred(*__first))
      ++__r;
  return __r;
}

}}
# 1773 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/algorithm" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/equal.h" 1 3
# 31 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/equal.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _InputIterator1, class _InputIterator2, class _BinaryPredicate>
[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr bool __equal_iter_impl(
    _InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _BinaryPredicate& __pred) {
  for (; __first1 != __last1; ++__first1, (void)++__first2)
    if (!__pred(*__first1, *__first2))
      return false;
  return true;
}

template <
    class _Tp,
    class _Up,
    class _BinaryPredicate,
    __enable_if_t<__is_trivial_equality_predicate<_BinaryPredicate, _Tp, _Up>::value && !is_volatile<_Tp>::value &&
                      !is_volatile<_Up>::value && __libcpp_is_trivially_equality_comparable<_Tp, _Up>::value,
                  int> = 0>
[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr bool
__equal_iter_impl(_Tp* __first1, _Tp* __last1, _Up* __first2, _BinaryPredicate&) {
  return std::__constexpr_memcmp_equal(__first1, __first2, __element_count(__last1 - __first1));
}

template <class _InputIterator1, class _InputIterator2, class _BinaryPredicate>
[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr bool
equal(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _BinaryPredicate __pred) {
  return std::__equal_iter_impl(
      std::__unwrap_iter(__first1), std::__unwrap_iter(__last1), std::__unwrap_iter(__first2), __pred);
}

template <class _InputIterator1, class _InputIterator2>
[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr bool
equal(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2) {
  return std::equal(__first1, __last1, __first2, __equal_to());
}


template <class _BinaryPredicate, class _InputIterator1, class _InputIterator2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr bool
__equal(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2,
        _BinaryPredicate __pred, input_iterator_tag, input_iterator_tag) {
  for (; __first1 != __last1 && __first2 != __last2; ++__first1, (void)++__first2)
    if (!__pred(*__first1, *__first2))
      return false;
  return __first1 == __last1 && __first2 == __last2;
}

template <class _Iter1, class _Sent1, class _Iter2, class _Sent2, class _Pred, class _Proj1, class _Proj2>
[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr bool __equal_impl(
    _Iter1 __first1, _Sent1 __last1, _Iter2 __first2, _Sent2 __last2, _Pred& __comp, _Proj1& __proj1, _Proj2& __proj2) {
  while (__first1 != __last1 && __first2 != __last2) {
    if (!std::__invoke(__comp, std::__invoke(__proj1, *__first1), std::__invoke(__proj2, *__first2)))
      return false;
    ++__first1;
    ++__first2;
  }
  return __first1 == __last1 && __first2 == __last2;
}

template <class _Tp,
          class _Up,
          class _Pred,
          class _Proj1,
          class _Proj2,
          __enable_if_t<__is_trivial_equality_predicate<_Pred, _Tp, _Up>::value && __is_identity<_Proj1>::value &&
                            __is_identity<_Proj2>::value && !is_volatile<_Tp>::value && !is_volatile<_Up>::value &&
                            __libcpp_is_trivially_equality_comparable<_Tp, _Up>::value,
                        int> = 0>
[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr bool __equal_impl(
    _Tp* __first1, _Tp* __last1, _Up* __first2, _Up*, _Pred&, _Proj1&, _Proj2&) {
  return std::__constexpr_memcmp_equal(__first1, __first2, __element_count(__last1 - __first1));
}

template <class _BinaryPredicate, class _RandomAccessIterator1, class _RandomAccessIterator2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr bool
__equal(_RandomAccessIterator1 __first1, _RandomAccessIterator1 __last1, _RandomAccessIterator2 __first2,
        _RandomAccessIterator2 __last2, _BinaryPredicate __pred, random_access_iterator_tag,
        random_access_iterator_tag) {
  if (std::distance(__first1, __last1) != std::distance(__first2, __last2))
    return false;
  __identity __proj;
  return std::__equal_impl(
      std::__unwrap_iter(__first1),
      std::__unwrap_iter(__last1),
      std::__unwrap_iter(__first2),
      std::__unwrap_iter(__last2),
      __pred,
      __proj,
      __proj);
}

template <class _InputIterator1, class _InputIterator2, class _BinaryPredicate>
[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr bool
equal(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2,
      _BinaryPredicate __pred) {
  return std::__equal<_BinaryPredicate&>(
      __first1, __last1, __first2, __last2, __pred, typename iterator_traits<_InputIterator1>::iterator_category(),
      typename iterator_traits<_InputIterator2>::iterator_category());
}

template <class _InputIterator1, class _InputIterator2>
[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr bool
equal(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2) {
  return std::__equal(
      __first1,
      __last1,
      __first2,
      __last2,
      __equal_to(),
      typename iterator_traits<_InputIterator1>::iterator_category(),
      typename iterator_traits<_InputIterator2>::iterator_category());
}


}}
# 1774 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/algorithm" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/equal_range.h" 1 3
# 17 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/equal_range.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/upper_bound.h" 1 3
# 26 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/upper_bound.h" 3



# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__undef_macros" 1 3
# 30 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/upper_bound.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _AlgPolicy, class _Compare, class _Iter, class _Sent, class _Tp, class _Proj>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr _Iter
__upper_bound(_Iter __first, _Sent __last, const _Tp& __value, _Compare&& __comp, _Proj&& __proj) {
  auto __len = _IterOps<_AlgPolicy>::distance(__first, __last);
  while (__len != 0) {
    auto __half_len = std::__half_positive(__len);
    auto __mid = _IterOps<_AlgPolicy>::next(__first, __half_len);
    if (std::__invoke(__comp, __value, std::__invoke(__proj, *__mid)))
      __len = __half_len;
    else {
      __first = ++__mid;
      __len -= __half_len + 1;
    }
  }
  return __first;
}

template <class _ForwardIterator, class _Tp, class _Compare>
[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr _ForwardIterator
upper_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value, _Compare __comp) {
  static_assert(is_copy_constructible<_ForwardIterator>::value, "Iterator has to be copy constructible");
  return std::__upper_bound<_ClassicAlgPolicy>(
      std::move(__first), std::move(__last), __value, std::move(__comp), std::__identity());
}

template <class _ForwardIterator, class _Tp>
[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr _ForwardIterator
upper_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value) {
  return std::upper_bound(std::move(__first), std::move(__last), __value, __less<>());
}

}}
# 18 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/equal_range.h" 2 3
# 32 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/equal_range.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _AlgPolicy, class _Compare, class _Iter, class _Sent, class _Tp, class _Proj>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr pair<_Iter, _Iter>
__equal_range(_Iter __first, _Sent __last, const _Tp& __value, _Compare&& __comp, _Proj&& __proj) {
  auto __len = _IterOps<_AlgPolicy>::distance(__first, __last);
  _Iter __end = _IterOps<_AlgPolicy>::next(__first, __last);
  while (__len != 0) {
    auto __half_len = std::__half_positive(__len);
    _Iter __mid = _IterOps<_AlgPolicy>::next(__first, __half_len);
    if (std::__invoke(__comp, std::__invoke(__proj, *__mid), __value)) {
      __first = ++__mid;
      __len -= __half_len + 1;
    } else if (std::__invoke(__comp, __value, std::__invoke(__proj, *__mid))) {
      __end = __mid;
      __len = __half_len;
    } else {
      _Iter __mp1 = __mid;
      return pair<_Iter, _Iter>(
          std::__lower_bound<_AlgPolicy>(__first, __mid, __value, __comp, __proj),
          std::__upper_bound<_AlgPolicy>(++__mp1, __end, __value, __comp, __proj));
    }
  }
  return pair<_Iter, _Iter>(__first, __first);
}

template <class _ForwardIterator, class _Tp, class _Compare>
[[__nodiscard__]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr pair<_ForwardIterator, _ForwardIterator>
equal_range(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value, _Compare __comp) {
  static_assert(__is_callable<_Compare, decltype(*__first), const _Tp&>::value,
                "The comparator has to be callable");
  static_assert(is_copy_constructible<_ForwardIterator>::value,
                "Iterator has to be copy constructible");
  return std::__equal_range<_ClassicAlgPolicy>(
      std::move(__first),
      std::move(__last),
      __value,
      static_cast<__comp_ref_type<_Compare> >(__comp),
      std::__identity());
}

template <class _ForwardIterator, class _Tp>
[[__nodiscard__]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr pair<_ForwardIterator, _ForwardIterator>
equal_range(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value) {
  return std::equal_range(std::move(__first), std::move(__last), __value, __less<>());
}

}}
# 1775 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/algorithm" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/fill.h" 1 3
# 12 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/fill.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/fill_n.h" 1 3
# 18 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/fill_n.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {



template <class _OutputIterator, class _Size, class _Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
_OutputIterator
__fill_n(_OutputIterator __first, _Size __n, const _Tp& __value)
{
    for (; __n > 0; ++__first, (void) --__n)
        *__first = __value;
    return __first;
}

template <class _OutputIterator, class _Size, class _Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
_OutputIterator
fill_n(_OutputIterator __first, _Size __n, const _Tp& __value)
{
   return std::__fill_n(__first, std::__convert_to_integral(__n), __value);
}

}}
# 13 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/fill.h" 2 3
# 18 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/fill.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {



template <class _ForwardIterator, class _Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
void
__fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value, forward_iterator_tag)
{
    for (; __first != __last; ++__first)
        *__first = __value;
}

template <class _RandomAccessIterator, class _Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
void
__fill(_RandomAccessIterator __first, _RandomAccessIterator __last, const _Tp& __value, random_access_iterator_tag)
{
    std::fill_n(__first, __last - __first, __value);
}

template <class _ForwardIterator, class _Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
void
fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value)
{
    std::__fill(__first, __last, __value, typename iterator_traits<_ForwardIterator>::iterator_category());
}

}}
# 1776 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/algorithm" 2 3

# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/find.h" 1 3
# 15 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/find.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__bit/countr.h" 1 3
# 12 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__bit/countr.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__bit/rotate.h" 1 3
# 19 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__bit/rotate.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr _Tp __rotr(_Tp __t, int __cnt) noexcept {
  static_assert(__libcpp_is_unsigned_integer<_Tp>::value, "__rotr requires an unsigned integer type");
  const unsigned int __dig = numeric_limits<_Tp>::digits;
  if ((__cnt % __dig) == 0)
    return __t;

  if (__cnt < 0) {
    __cnt *= -1;
    return (__t << (__cnt % __dig)) | (__t >> (__dig - (__cnt % __dig)));
  }

  return (__t >> (__cnt % __dig)) | (__t << (__dig - (__cnt % __dig)));
}

template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr _Tp __rotl(_Tp __t, int __cnt) noexcept {
  return std::__rotr(__t, -__cnt);
}



template <__libcpp_unsigned_integer _Tp>
[[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr _Tp rotl(_Tp __t, int __cnt) noexcept {
  return std::__rotl(__t, __cnt);
}

template <__libcpp_unsigned_integer _Tp>
[[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr _Tp rotr(_Tp __t, int __cnt) noexcept {
  return std::__rotr(__t, __cnt);
}



}}
# 13 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__bit/countr.h" 2 3
# 19 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__bit/countr.h" 3



# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__undef_macros" 1 3
# 23 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__bit/countr.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
int __libcpp_ctz(unsigned __x) noexcept { return __builtin_ctz(__x); }

[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
int __libcpp_ctz(unsigned long __x) noexcept { return __builtin_ctzl(__x); }

[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
int __libcpp_ctz(unsigned long long __x) noexcept { return __builtin_ctzll(__x); }



template <__libcpp_unsigned_integer _Tp>
[[__nodiscard__]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr int countr_zero(_Tp __t) noexcept {
  if (__t == 0)
    return numeric_limits<_Tp>::digits;

  if (sizeof(_Tp) <= sizeof(unsigned int))
    return std::__libcpp_ctz(static_cast<unsigned int>(__t));
  else if (sizeof(_Tp) <= sizeof(unsigned long))
    return std::__libcpp_ctz(static_cast<unsigned long>(__t));
  else if (sizeof(_Tp) <= sizeof(unsigned long long))
    return std::__libcpp_ctz(static_cast<unsigned long long>(__t));
  else {
    int __ret = 0;
    const unsigned int __ulldigits = numeric_limits<unsigned long long>::digits;
    while (static_cast<unsigned long long>(__t) == 0uLL) {
      __ret += __ulldigits;
      __t >>= __ulldigits;
    }
    return __ret + std::__libcpp_ctz(static_cast<unsigned long long>(__t));
  }
}

template <__libcpp_unsigned_integer _Tp>
[[__nodiscard__]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr int countr_one(_Tp __t) noexcept {
  return __t != numeric_limits<_Tp>::max() ? std::countr_zero(static_cast<_Tp>(~__t)) : numeric_limits<_Tp>::digits;
}



}}
# 16 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/find.h" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__bit/invert_if.h" 1 3
# 17 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__bit/invert_if.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <bool _Invert, class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr _Tp __invert_if(_Tp __v) {
  if (_Invert)
    return ~__v;
  return __v;
}

}}
# 17 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/find.h" 2 3



# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__fwd/bit_reference.h" 1 3
# 16 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__fwd/bit_reference.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Cp, bool _IsConst, typename _Cp::__storage_type = 0>
class __bit_iterator;

}}
# 21 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/find.h" 2 3




# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/cwchar" 1 3
# 112 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/cwchar" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/cwctype" 1 3
# 54 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/cwctype" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/cctype" 1 3
# 40 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/cctype" 3
# 1 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/llvm_libc_wrappers/ctype.h" 1 3
# 16 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/llvm_libc_wrappers/ctype.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/ctype.h" 1 3
# 36 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/ctype.h" 3



# 1 "/usr/include/ctype.h" 1 3 4
# 28 "/usr/include/ctype.h" 3 4
extern "C" {
# 46 "/usr/include/ctype.h" 3 4
enum
{
  _ISupper = ((0) < 8 ? ((1 << (0)) << 8) : ((1 << (0)) >> 8)),
  _ISlower = ((1) < 8 ? ((1 << (1)) << 8) : ((1 << (1)) >> 8)),
  _ISalpha = ((2) < 8 ? ((1 << (2)) << 8) : ((1 << (2)) >> 8)),
  _ISdigit = ((3) < 8 ? ((1 << (3)) << 8) : ((1 << (3)) >> 8)),
  _ISxdigit = ((4) < 8 ? ((1 << (4)) << 8) : ((1 << (4)) >> 8)),
  _ISspace = ((5) < 8 ? ((1 << (5)) << 8) : ((1 << (5)) >> 8)),
  _ISprint = ((6) < 8 ? ((1 << (6)) << 8) : ((1 << (6)) >> 8)),
  _ISgraph = ((7) < 8 ? ((1 << (7)) << 8) : ((1 << (7)) >> 8)),
  _ISblank = ((8) < 8 ? ((1 << (8)) << 8) : ((1 << (8)) >> 8)),
  _IScntrl = ((9) < 8 ? ((1 << (9)) << 8) : ((1 << (9)) >> 8)),
  _ISpunct = ((10) < 8 ? ((1 << (10)) << 8) : ((1 << (10)) >> 8)),
  _ISalnum = ((11) < 8 ? ((1 << (11)) << 8) : ((1 << (11)) >> 8))
};
# 79 "/usr/include/ctype.h" 3 4
extern const unsigned short int **__ctype_b_loc (void)
     throw () __attribute__ ((__const__));
extern const __int32_t **__ctype_tolower_loc (void)
     throw () __attribute__ ((__const__));
extern const __int32_t **__ctype_toupper_loc (void)
     throw () __attribute__ ((__const__));
# 108 "/usr/include/ctype.h" 3 4
extern int isalnum (int) throw ();
extern int isalpha (int) throw ();
extern int iscntrl (int) throw ();
extern int isdigit (int) throw ();
extern int islower (int) throw ();
extern int isgraph (int) throw ();
extern int isprint (int) throw ();
extern int ispunct (int) throw ();
extern int isspace (int) throw ();
extern int isupper (int) throw ();
extern int isxdigit (int) throw ();



extern int tolower (int __c) throw ();


extern int toupper (int __c) throw ();




extern int isblank (int) throw ();




extern int isctype (int __c, int __mask) throw ();






extern int isascii (int __c) throw ();



extern int toascii (int __c) throw ();



extern int _toupper (int) throw ();
extern int _tolower (int) throw ();
# 174 "/usr/include/ctype.h" 3 4
extern __inline __attribute__ ((__gnu_inline__)) int isalnum (int __c) throw () { return (*__ctype_b_loc ())[(int) (__c)] & (unsigned short int) _ISalnum; }
extern __inline __attribute__ ((__gnu_inline__)) int isalpha (int __c) throw () { return (*__ctype_b_loc ())[(int) (__c)] & (unsigned short int) _ISalpha; }
extern __inline __attribute__ ((__gnu_inline__)) int iscntrl (int __c) throw () { return (*__ctype_b_loc ())[(int) (__c)] & (unsigned short int) _IScntrl; }
extern __inline __attribute__ ((__gnu_inline__)) int isdigit (int __c) throw () { return (*__ctype_b_loc ())[(int) (__c)] & (unsigned short int) _ISdigit; }
extern __inline __attribute__ ((__gnu_inline__)) int islower (int __c) throw () { return (*__ctype_b_loc ())[(int) (__c)] & (unsigned short int) _ISlower; }
extern __inline __attribute__ ((__gnu_inline__)) int isgraph (int __c) throw () { return (*__ctype_b_loc ())[(int) (__c)] & (unsigned short int) _ISgraph; }
extern __inline __attribute__ ((__gnu_inline__)) int isprint (int __c) throw () { return (*__ctype_b_loc ())[(int) (__c)] & (unsigned short int) _ISprint; }
extern __inline __attribute__ ((__gnu_inline__)) int ispunct (int __c) throw () { return (*__ctype_b_loc ())[(int) (__c)] & (unsigned short int) _ISpunct; }
extern __inline __attribute__ ((__gnu_inline__)) int isspace (int __c) throw () { return (*__ctype_b_loc ())[(int) (__c)] & (unsigned short int) _ISspace; }
extern __inline __attribute__ ((__gnu_inline__)) int isupper (int __c) throw () { return (*__ctype_b_loc ())[(int) (__c)] & (unsigned short int) _ISupper; }
extern __inline __attribute__ ((__gnu_inline__)) int isxdigit (int __c) throw () { return (*__ctype_b_loc ())[(int) (__c)] & (unsigned short int) _ISxdigit; }

extern __inline __attribute__ ((__gnu_inline__)) int isblank (int __c) throw () { return (*__ctype_b_loc ())[(int) (__c)] & (unsigned short int) _ISblank; }
# 206 "/usr/include/ctype.h" 3 4
extern __inline __attribute__ ((__gnu_inline__)) int
 tolower (int __c) throw ()
{
  return __c >= -128 && __c < 256 ? (*__ctype_tolower_loc ())[__c] : __c;
}

extern __inline __attribute__ ((__gnu_inline__)) int
 toupper (int __c) throw ()
{
  return __c >= -128 && __c < 256 ? (*__ctype_toupper_loc ())[__c] : __c;
}
# 251 "/usr/include/ctype.h" 3 4
extern int isalnum_l (int, locale_t) throw ();
extern int isalpha_l (int, locale_t) throw ();
extern int iscntrl_l (int, locale_t) throw ();
extern int isdigit_l (int, locale_t) throw ();
extern int islower_l (int, locale_t) throw ();
extern int isgraph_l (int, locale_t) throw ();
extern int isprint_l (int, locale_t) throw ();
extern int ispunct_l (int, locale_t) throw ();
extern int isspace_l (int, locale_t) throw ();
extern int isupper_l (int, locale_t) throw ();
extern int isxdigit_l (int, locale_t) throw ();

extern int isblank_l (int, locale_t) throw ();



extern int __tolower_l (int __c, locale_t __l) throw ();
extern int tolower_l (int __c, locale_t __l) throw ();


extern int __toupper_l (int __c, locale_t __l) throw ();
extern int toupper_l (int __c, locale_t __l) throw ();
# 327 "/usr/include/ctype.h" 3 4
}
# 40 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/ctype.h" 2 3
# 17 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/llvm_libc_wrappers/ctype.h" 2 3
# 41 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/cctype" 2 3
# 51 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/cctype" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 112 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/cctype" 3
using ::isalnum __attribute__((__using_if_exists__));
using ::isalpha __attribute__((__using_if_exists__));
using ::isblank __attribute__((__using_if_exists__));
using ::iscntrl __attribute__((__using_if_exists__));
using ::isdigit __attribute__((__using_if_exists__));
using ::isgraph __attribute__((__using_if_exists__));
using ::islower __attribute__((__using_if_exists__));
using ::isprint __attribute__((__using_if_exists__));
using ::ispunct __attribute__((__using_if_exists__));
using ::isspace __attribute__((__using_if_exists__));
using ::isupper __attribute__((__using_if_exists__));
using ::isxdigit __attribute__((__using_if_exists__));
using ::tolower __attribute__((__using_if_exists__));
using ::toupper __attribute__((__using_if_exists__));

}}
# 55 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/cwctype" 2 3

# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/wctype.h" 1 3
# 55 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/wctype.h" 3
# 67 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/wctype.h" 3
# 1 "/usr/include/wctype.h" 1 3 4
# 28 "/usr/include/wctype.h" 3 4
# 1 "/usr/include/bits/types/wint_t.h" 1 3 4
# 20 "/usr/include/bits/types/wint_t.h" 3 4
typedef unsigned int wint_t;
# 29 "/usr/include/wctype.h" 2 3 4
# 38 "/usr/include/wctype.h" 3 4
# 1 "/usr/include/bits/wctype-wchar.h" 1 3 4
# 38 "/usr/include/bits/wctype-wchar.h" 3 4
typedef unsigned long int wctype_t;
# 56 "/usr/include/bits/wctype-wchar.h" 3 4
enum
{
  __ISwupper = 0,
  __ISwlower = 1,
  __ISwalpha = 2,
  __ISwdigit = 3,
  __ISwxdigit = 4,
  __ISwspace = 5,
  __ISwprint = 6,
  __ISwgraph = 7,
  __ISwblank = 8,
  __ISwcntrl = 9,
  __ISwpunct = 10,
  __ISwalnum = 11,

  _ISwupper = ((__ISwupper) < 8 ? (int) ((1UL << (__ISwupper)) << 24) : ((__ISwupper) < 16 ? (int) ((1UL << (__ISwupper)) << 8) : ((__ISwupper) < 24 ? (int) ((1UL << (__ISwupper)) >> 8) : (int) ((1UL << (__ISwupper)) >> 24)))),
  _ISwlower = ((__ISwlower) < 8 ? (int) ((1UL << (__ISwlower)) << 24) : ((__ISwlower) < 16 ? (int) ((1UL << (__ISwlower)) << 8) : ((__ISwlower) < 24 ? (int) ((1UL << (__ISwlower)) >> 8) : (int) ((1UL << (__ISwlower)) >> 24)))),
  _ISwalpha = ((__ISwalpha) < 8 ? (int) ((1UL << (__ISwalpha)) << 24) : ((__ISwalpha) < 16 ? (int) ((1UL << (__ISwalpha)) << 8) : ((__ISwalpha) < 24 ? (int) ((1UL << (__ISwalpha)) >> 8) : (int) ((1UL << (__ISwalpha)) >> 24)))),
  _ISwdigit = ((__ISwdigit) < 8 ? (int) ((1UL << (__ISwdigit)) << 24) : ((__ISwdigit) < 16 ? (int) ((1UL << (__ISwdigit)) << 8) : ((__ISwdigit) < 24 ? (int) ((1UL << (__ISwdigit)) >> 8) : (int) ((1UL << (__ISwdigit)) >> 24)))),
  _ISwxdigit = ((__ISwxdigit) < 8 ? (int) ((1UL << (__ISwxdigit)) << 24) : ((__ISwxdigit) < 16 ? (int) ((1UL << (__ISwxdigit)) << 8) : ((__ISwxdigit) < 24 ? (int) ((1UL << (__ISwxdigit)) >> 8) : (int) ((1UL << (__ISwxdigit)) >> 24)))),
  _ISwspace = ((__ISwspace) < 8 ? (int) ((1UL << (__ISwspace)) << 24) : ((__ISwspace) < 16 ? (int) ((1UL << (__ISwspace)) << 8) : ((__ISwspace) < 24 ? (int) ((1UL << (__ISwspace)) >> 8) : (int) ((1UL << (__ISwspace)) >> 24)))),
  _ISwprint = ((__ISwprint) < 8 ? (int) ((1UL << (__ISwprint)) << 24) : ((__ISwprint) < 16 ? (int) ((1UL << (__ISwprint)) << 8) : ((__ISwprint) < 24 ? (int) ((1UL << (__ISwprint)) >> 8) : (int) ((1UL << (__ISwprint)) >> 24)))),
  _ISwgraph = ((__ISwgraph) < 8 ? (int) ((1UL << (__ISwgraph)) << 24) : ((__ISwgraph) < 16 ? (int) ((1UL << (__ISwgraph)) << 8) : ((__ISwgraph) < 24 ? (int) ((1UL << (__ISwgraph)) >> 8) : (int) ((1UL << (__ISwgraph)) >> 24)))),
  _ISwblank = ((__ISwblank) < 8 ? (int) ((1UL << (__ISwblank)) << 24) : ((__ISwblank) < 16 ? (int) ((1UL << (__ISwblank)) << 8) : ((__ISwblank) < 24 ? (int) ((1UL << (__ISwblank)) >> 8) : (int) ((1UL << (__ISwblank)) >> 24)))),
  _ISwcntrl = ((__ISwcntrl) < 8 ? (int) ((1UL << (__ISwcntrl)) << 24) : ((__ISwcntrl) < 16 ? (int) ((1UL << (__ISwcntrl)) << 8) : ((__ISwcntrl) < 24 ? (int) ((1UL << (__ISwcntrl)) >> 8) : (int) ((1UL << (__ISwcntrl)) >> 24)))),
  _ISwpunct = ((__ISwpunct) < 8 ? (int) ((1UL << (__ISwpunct)) << 24) : ((__ISwpunct) < 16 ? (int) ((1UL << (__ISwpunct)) << 8) : ((__ISwpunct) < 24 ? (int) ((1UL << (__ISwpunct)) >> 8) : (int) ((1UL << (__ISwpunct)) >> 24)))),
  _ISwalnum = ((__ISwalnum) < 8 ? (int) ((1UL << (__ISwalnum)) << 24) : ((__ISwalnum) < 16 ? (int) ((1UL << (__ISwalnum)) << 8) : ((__ISwalnum) < 24 ? (int) ((1UL << (__ISwalnum)) >> 8) : (int) ((1UL << (__ISwalnum)) >> 24))))
};



extern "C" {







extern int iswalnum (wint_t __wc) throw ();





extern int iswalpha (wint_t __wc) throw ();


extern int iswcntrl (wint_t __wc) throw ();



extern int iswdigit (wint_t __wc) throw ();



extern int iswgraph (wint_t __wc) throw ();




extern int iswlower (wint_t __wc) throw ();


extern int iswprint (wint_t __wc) throw ();




extern int iswpunct (wint_t __wc) throw ();




extern int iswspace (wint_t __wc) throw ();




extern int iswupper (wint_t __wc) throw ();




extern int iswxdigit (wint_t __wc) throw ();





extern int iswblank (wint_t __wc) throw ();
# 155 "/usr/include/bits/wctype-wchar.h" 3 4
extern wctype_t wctype (const char *__property) throw ();



extern int iswctype (wint_t __wc, wctype_t __desc) throw ();






extern wint_t towlower (wint_t __wc) throw ();


extern wint_t towupper (wint_t __wc) throw ();

}
# 39 "/usr/include/wctype.h" 2 3 4





extern "C" {



typedef const __int32_t *wctrans_t;



extern wctrans_t wctrans (const char *__property) throw ();


extern wint_t towctrans (wint_t __wc, wctrans_t __desc) throw ();







extern int iswalnum_l (wint_t __wc, locale_t __locale) throw ();





extern int iswalpha_l (wint_t __wc, locale_t __locale) throw ();


extern int iswcntrl_l (wint_t __wc, locale_t __locale) throw ();



extern int iswdigit_l (wint_t __wc, locale_t __locale) throw ();



extern int iswgraph_l (wint_t __wc, locale_t __locale) throw ();




extern int iswlower_l (wint_t __wc, locale_t __locale) throw ();


extern int iswprint_l (wint_t __wc, locale_t __locale) throw ();




extern int iswpunct_l (wint_t __wc, locale_t __locale) throw ();




extern int iswspace_l (wint_t __wc, locale_t __locale) throw ();




extern int iswupper_l (wint_t __wc, locale_t __locale) throw ();




extern int iswxdigit_l (wint_t __wc, locale_t __locale) throw ();




extern int iswblank_l (wint_t __wc, locale_t __locale) throw ();



extern wctype_t wctype_l (const char *__property, locale_t __locale)
     throw ();



extern int iswctype_l (wint_t __wc, wctype_t __desc, locale_t __locale)
     throw ();






extern wint_t towlower_l (wint_t __wc, locale_t __locale) throw ();


extern wint_t towupper_l (wint_t __wc, locale_t __locale) throw ();



extern wctrans_t wctrans_l (const char *__property, locale_t __locale)
     throw ();


extern wint_t towctrans_l (wint_t __wc, wctrans_t __desc,
      locale_t __locale) throw ();



}
# 68 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/wctype.h" 2 3
# 57 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/cwctype" 2 3
# 68 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/cwctype" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {


using ::wint_t __attribute__((__using_if_exists__));
using ::wctrans_t __attribute__((__using_if_exists__));
using ::wctype_t __attribute__((__using_if_exists__));
using ::iswalnum __attribute__((__using_if_exists__));
using ::iswalpha __attribute__((__using_if_exists__));
using ::iswblank __attribute__((__using_if_exists__));
using ::iswcntrl __attribute__((__using_if_exists__));
using ::iswdigit __attribute__((__using_if_exists__));
using ::iswgraph __attribute__((__using_if_exists__));
using ::iswlower __attribute__((__using_if_exists__));
using ::iswprint __attribute__((__using_if_exists__));
using ::iswpunct __attribute__((__using_if_exists__));
using ::iswspace __attribute__((__using_if_exists__));
using ::iswupper __attribute__((__using_if_exists__));
using ::iswxdigit __attribute__((__using_if_exists__));
using ::iswctype __attribute__((__using_if_exists__));
using ::wctype __attribute__((__using_if_exists__));
using ::towlower __attribute__((__using_if_exists__));
using ::towupper __attribute__((__using_if_exists__));
using ::towctrans __attribute__((__using_if_exists__));
using ::wctrans __attribute__((__using_if_exists__));


}}
# 113 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/cwchar" 2 3

# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/wchar.h" 1 3
# 109 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/wchar.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/stddef.h" 1 3
# 110 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/wchar.h" 2 3
# 117 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/wchar.h" 3
# 126 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/wchar.h" 3
# 1 "/usr/include/wchar.h" 1 3 4
# 27 "/usr/include/wchar.h" 3 4
# 1 "/usr/include/bits/libc-header-start.h" 1 3 4
# 28 "/usr/include/wchar.h" 2 3 4







# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/stddef.h" 1 3 4
# 15 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/stddef.h" 3


# 1 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/stddef.h" 1 3
# 59 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/stddef.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/__stddef_size_t.h" 1 3
# 15 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/__stddef_size_t.h" 3
typedef long unsigned int size_t;
# 60 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/stddef.h" 2 3
# 69 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/stddef.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/__stddef_wchar_t.h" 1 3
# 70 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/stddef.h" 2 3




# 1 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/__stddef_null.h" 1 3
# 75 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/stddef.h" 2 3
# 18 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/stddef.h" 2 3
# 36 "/usr/include/wchar.h" 2 3 4


# 1 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/stdarg.h" 1 3 4
# 33 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/stdarg.h" 3 4
# 1 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/__stdarg___gnuc_va_list.h" 1 3 4
# 12 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/__stdarg___gnuc_va_list.h" 3 4
typedef __builtin_va_list __gnuc_va_list;
# 34 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/stdarg.h" 2 3 4
# 39 "/usr/include/wchar.h" 2 3 4



# 1 "/usr/include/bits/types/mbstate_t.h" 1 3 4



# 1 "/usr/include/bits/types/__mbstate_t.h" 1 3 4
# 13 "/usr/include/bits/types/__mbstate_t.h" 3 4
typedef struct
{
  int __count;
  union
  {
    unsigned int __wch;
    char __wchb[4];
  } __value;
} __mbstate_t;
# 5 "/usr/include/bits/types/mbstate_t.h" 2 3 4

typedef __mbstate_t mbstate_t;
# 43 "/usr/include/wchar.h" 2 3 4
# 1 "/usr/include/bits/types/__FILE.h" 1 3 4



struct _IO_FILE;
typedef struct _IO_FILE __FILE;
# 44 "/usr/include/wchar.h" 2 3 4


# 1 "/usr/include/bits/types/FILE.h" 1 3 4



struct _IO_FILE;


typedef struct _IO_FILE FILE;
# 47 "/usr/include/wchar.h" 2 3 4
# 79 "/usr/include/wchar.h" 3 4
extern "C" {



struct tm;



extern wchar_t *wcscpy (wchar_t *__restrict __dest,
   const wchar_t *__restrict __src)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern wchar_t *wcsncpy (wchar_t *__restrict __dest,
    const wchar_t *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern wchar_t *wcscat (wchar_t *__restrict __dest,
   const wchar_t *__restrict __src)
     throw () __attribute__ ((__nonnull__ (1, 2)));

extern wchar_t *wcsncat (wchar_t *__restrict __dest,
    const wchar_t *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int wcscmp (const wchar_t *__s1, const wchar_t *__s2)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern int wcsncmp (const wchar_t *__s1, const wchar_t *__s2, size_t __n)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));



extern int wcscasecmp (const wchar_t *__s1, const wchar_t *__s2) throw ();


extern int wcsncasecmp (const wchar_t *__s1, const wchar_t *__s2,
   size_t __n) throw ();



extern int wcscasecmp_l (const wchar_t *__s1, const wchar_t *__s2,
    locale_t __loc) throw ();

extern int wcsncasecmp_l (const wchar_t *__s1, const wchar_t *__s2,
     size_t __n, locale_t __loc) throw ();




extern int wcscoll (const wchar_t *__s1, const wchar_t *__s2) throw ();



extern size_t wcsxfrm (wchar_t *__restrict __s1,
         const wchar_t *__restrict __s2, size_t __n) throw ();







extern int wcscoll_l (const wchar_t *__s1, const wchar_t *__s2,
        locale_t __loc) throw ();




extern size_t wcsxfrm_l (wchar_t *__s1, const wchar_t *__s2,
    size_t __n, locale_t __loc) throw ();


extern wchar_t *wcsdup (const wchar_t *__s) throw () __attribute__ ((__malloc__));




extern "C++" wchar_t *wcschr (wchar_t *__wcs, wchar_t __wc)
     throw () __asm ("wcschr") __attribute__ ((__pure__));
extern "C++" const wchar_t *wcschr (const wchar_t *__wcs, wchar_t __wc)
     throw () __asm ("wcschr") __attribute__ ((__pure__));






extern "C++" wchar_t *wcsrchr (wchar_t *__wcs, wchar_t __wc)
     throw () __asm ("wcsrchr") __attribute__ ((__pure__));
extern "C++" const wchar_t *wcsrchr (const wchar_t *__wcs, wchar_t __wc)
     throw () __asm ("wcsrchr") __attribute__ ((__pure__));
# 181 "/usr/include/wchar.h" 3 4
extern wchar_t *wcschrnul (const wchar_t *__s, wchar_t __wc)
     throw () __attribute__ ((__pure__));




extern size_t wcscspn (const wchar_t *__wcs, const wchar_t *__reject)
     throw () __attribute__ ((__pure__));


extern size_t wcsspn (const wchar_t *__wcs, const wchar_t *__accept)
     throw () __attribute__ ((__pure__));


extern "C++" wchar_t *wcspbrk (wchar_t *__wcs, const wchar_t *__accept)
     throw () __asm ("wcspbrk") __attribute__ ((__pure__));
extern "C++" const wchar_t *wcspbrk (const wchar_t *__wcs,
         const wchar_t *__accept)
     throw () __asm ("wcspbrk") __attribute__ ((__pure__));






extern "C++" wchar_t *wcsstr (wchar_t *__haystack, const wchar_t *__needle)
     throw () __asm ("wcsstr") __attribute__ ((__pure__));
extern "C++" const wchar_t *wcsstr (const wchar_t *__haystack,
        const wchar_t *__needle)
     throw () __asm ("wcsstr") __attribute__ ((__pure__));






extern wchar_t *wcstok (wchar_t *__restrict __s,
   const wchar_t *__restrict __delim,
   wchar_t **__restrict __ptr) throw ();


extern size_t wcslen (const wchar_t *__s) throw () __attribute__ ((__pure__));




extern "C++" wchar_t *wcswcs (wchar_t *__haystack, const wchar_t *__needle)
     throw () __asm ("wcswcs") __attribute__ ((__pure__));
extern "C++" const wchar_t *wcswcs (const wchar_t *__haystack,
        const wchar_t *__needle)
     throw () __asm ("wcswcs") __attribute__ ((__pure__));
# 240 "/usr/include/wchar.h" 3 4
extern size_t wcsnlen (const wchar_t *__s, size_t __maxlen)
     throw () __attribute__ ((__pure__));





extern "C++" wchar_t *wmemchr (wchar_t *__s, wchar_t __c, size_t __n)
     throw () __asm ("wmemchr") __attribute__ ((__pure__));
extern "C++" const wchar_t *wmemchr (const wchar_t *__s, wchar_t __c,
         size_t __n)
     throw () __asm ("wmemchr") __attribute__ ((__pure__));






extern int wmemcmp (const wchar_t *__s1, const wchar_t *__s2, size_t __n)
     throw () __attribute__ ((__pure__));


extern wchar_t *wmemcpy (wchar_t *__restrict __s1,
    const wchar_t *__restrict __s2, size_t __n) throw ();



extern wchar_t *wmemmove (wchar_t *__s1, const wchar_t *__s2, size_t __n)
     throw ();


extern wchar_t *wmemset (wchar_t *__s, wchar_t __c, size_t __n) throw ();




extern wchar_t *wmempcpy (wchar_t *__restrict __s1,
     const wchar_t *__restrict __s2, size_t __n)
     throw ();





extern wint_t btowc (int __c) throw ();



extern int wctob (wint_t __c) throw ();



extern int mbsinit (const mbstate_t *__ps) throw () __attribute__ ((__pure__));



extern size_t mbrtowc (wchar_t *__restrict __pwc,
         const char *__restrict __s, size_t __n,
         mbstate_t *__restrict __p) throw ();


extern size_t wcrtomb (char *__restrict __s, wchar_t __wc,
         mbstate_t *__restrict __ps) throw ();


extern size_t __mbrlen (const char *__restrict __s, size_t __n,
   mbstate_t *__restrict __ps) throw ();
extern size_t mbrlen (const char *__restrict __s, size_t __n,
        mbstate_t *__restrict __ps) throw ();







extern wint_t __btowc_alias (int __c) __asm ("btowc");
extern __inline __attribute__ ((__gnu_inline__)) wint_t
 btowc (int __c) throw ()
{ return (__builtin_constant_p (__c) && __c >= '\0' && __c <= '\x7f'
   ? (wint_t) __c : __btowc_alias (__c)); }

extern int __wctob_alias (wint_t __c) __asm ("wctob");
extern __inline __attribute__ ((__gnu_inline__)) int
 wctob (wint_t __wc) throw ()
{ return (__builtin_constant_p (__wc) && __wc >= L'\0' && __wc <= L'\x7f'
   ? (int) __wc : __wctob_alias (__wc)); }

extern __inline __attribute__ ((__gnu_inline__)) size_t
 mbrlen (const char *__restrict __s, size_t __n, mbstate_t *__restrict __ps) throw ()

{ return (__ps != __null
   ? mbrtowc (__null, __s, __n, __ps) : __mbrlen (__s, __n, __null)); }




extern size_t mbsrtowcs (wchar_t *__restrict __dst,
    const char **__restrict __src, size_t __len,
    mbstate_t *__restrict __ps) throw ();



extern size_t wcsrtombs (char *__restrict __dst,
    const wchar_t **__restrict __src, size_t __len,
    mbstate_t *__restrict __ps) throw ();





extern size_t mbsnrtowcs (wchar_t *__restrict __dst,
     const char **__restrict __src, size_t __nmc,
     size_t __len, mbstate_t *__restrict __ps) throw ();



extern size_t wcsnrtombs (char *__restrict __dst,
     const wchar_t **__restrict __src,
     size_t __nwc, size_t __len,
     mbstate_t *__restrict __ps) throw ();






extern int wcwidth (wchar_t __c) throw ();



extern int wcswidth (const wchar_t *__s, size_t __n) throw ();





extern double wcstod (const wchar_t *__restrict __nptr,
        wchar_t **__restrict __endptr) throw ();



extern float wcstof (const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr) throw ();
extern long double wcstold (const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr) throw ();
# 396 "/usr/include/wchar.h" 3 4
extern _Float32 wcstof32 (const wchar_t *__restrict __nptr,
     wchar_t **__restrict __endptr) throw ();



extern _Float64 wcstof64 (const wchar_t *__restrict __nptr,
     wchar_t **__restrict __endptr) throw ();
# 411 "/usr/include/wchar.h" 3 4
extern _Float32x wcstof32x (const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr) throw ();



extern _Float64x wcstof64x (const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr) throw ();
# 428 "/usr/include/wchar.h" 3 4
extern long int wcstol (const wchar_t *__restrict __nptr,
   wchar_t **__restrict __endptr, int __base) throw ();



extern unsigned long int wcstoul (const wchar_t *__restrict __nptr,
      wchar_t **__restrict __endptr, int __base)
     throw ();




__extension__
extern long long int wcstoll (const wchar_t *__restrict __nptr,
         wchar_t **__restrict __endptr, int __base)
     throw ();



__extension__
extern unsigned long long int wcstoull (const wchar_t *__restrict __nptr,
     wchar_t **__restrict __endptr,
     int __base) throw ();





__extension__
extern long long int wcstoq (const wchar_t *__restrict __nptr,
        wchar_t **__restrict __endptr, int __base)
     throw ();



__extension__
extern unsigned long long int wcstouq (const wchar_t *__restrict __nptr,
           wchar_t **__restrict __endptr,
           int __base) throw ();






extern long int wcstol_l (const wchar_t *__restrict __nptr,
     wchar_t **__restrict __endptr, int __base,
     locale_t __loc) throw ();

extern unsigned long int wcstoul_l (const wchar_t *__restrict __nptr,
        wchar_t **__restrict __endptr,
        int __base, locale_t __loc) throw ();

__extension__
extern long long int wcstoll_l (const wchar_t *__restrict __nptr,
    wchar_t **__restrict __endptr,
    int __base, locale_t __loc) throw ();

__extension__
extern unsigned long long int wcstoull_l (const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr,
       int __base, locale_t __loc)
     throw ();

extern double wcstod_l (const wchar_t *__restrict __nptr,
   wchar_t **__restrict __endptr, locale_t __loc)
     throw ();

extern float wcstof_l (const wchar_t *__restrict __nptr,
         wchar_t **__restrict __endptr, locale_t __loc)
     throw ();

extern long double wcstold_l (const wchar_t *__restrict __nptr,
         wchar_t **__restrict __endptr,
         locale_t __loc) throw ();
# 511 "/usr/include/wchar.h" 3 4
extern _Float32 wcstof32_l (const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr,
       locale_t __loc) throw ();



extern _Float64 wcstof64_l (const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr,
       locale_t __loc) throw ();
# 529 "/usr/include/wchar.h" 3 4
extern _Float32x wcstof32x_l (const wchar_t *__restrict __nptr,
         wchar_t **__restrict __endptr,
         locale_t __loc) throw ();



extern _Float64x wcstof64x_l (const wchar_t *__restrict __nptr,
         wchar_t **__restrict __endptr,
         locale_t __loc) throw ();
# 551 "/usr/include/wchar.h" 3 4
extern wchar_t *wcpcpy (wchar_t *__restrict __dest,
   const wchar_t *__restrict __src) throw ();



extern wchar_t *wcpncpy (wchar_t *__restrict __dest,
    const wchar_t *__restrict __src, size_t __n)
     throw ();
# 567 "/usr/include/wchar.h" 3 4
extern __FILE *open_wmemstream (wchar_t **__bufloc, size_t *__sizeloc) throw ();





extern int fwide (__FILE *__fp, int __mode) throw ();






extern int fwprintf (__FILE *__restrict __stream,
       const wchar_t *__restrict __format, ...)
                                                           ;




extern int wprintf (const wchar_t *__restrict __format, ...)
                                                           ;

extern int swprintf (wchar_t *__restrict __s, size_t __n,
       const wchar_t *__restrict __format, ...)
     throw () ;





extern int vfwprintf (__FILE *__restrict __s,
        const wchar_t *__restrict __format,
        __gnuc_va_list __arg)
                                                           ;




extern int vwprintf (const wchar_t *__restrict __format,
       __gnuc_va_list __arg)
                                                           ;


extern int vswprintf (wchar_t *__restrict __s, size_t __n,
        const wchar_t *__restrict __format,
        __gnuc_va_list __arg)
     throw () ;






extern int fwscanf (__FILE *__restrict __stream,
      const wchar_t *__restrict __format, ...)
                                                          ;




extern int wscanf (const wchar_t *__restrict __format, ...)
                                                          ;

extern int swscanf (const wchar_t *__restrict __s,
      const wchar_t *__restrict __format, ...)
     throw () ;
# 673 "/usr/include/wchar.h" 3 4
extern int vfwscanf (__FILE *__restrict __s,
       const wchar_t *__restrict __format,
       __gnuc_va_list __arg)
                                                          ;




extern int vwscanf (const wchar_t *__restrict __format,
      __gnuc_va_list __arg)
                                                          ;

extern int vswscanf (const wchar_t *__restrict __s,
       const wchar_t *__restrict __format,
       __gnuc_va_list __arg)
     throw () ;
# 727 "/usr/include/wchar.h" 3 4
extern wint_t fgetwc (__FILE *__stream);
extern wint_t getwc (__FILE *__stream);





extern wint_t getwchar (void);






extern wint_t fputwc (wchar_t __wc, __FILE *__stream);
extern wint_t putwc (wchar_t __wc, __FILE *__stream);





extern wint_t putwchar (wchar_t __wc);







extern wchar_t *fgetws (wchar_t *__restrict __ws, int __n,
   __FILE *__restrict __stream);





extern int fputws (const wchar_t *__restrict __ws,
     __FILE *__restrict __stream);






extern wint_t ungetwc (wint_t __wc, __FILE *__stream);
# 782 "/usr/include/wchar.h" 3 4
extern wint_t getwc_unlocked (__FILE *__stream);
extern wint_t getwchar_unlocked (void);







extern wint_t fgetwc_unlocked (__FILE *__stream);







extern wint_t fputwc_unlocked (wchar_t __wc, __FILE *__stream);
# 808 "/usr/include/wchar.h" 3 4
extern wint_t putwc_unlocked (wchar_t __wc, __FILE *__stream);
extern wint_t putwchar_unlocked (wchar_t __wc);
# 818 "/usr/include/wchar.h" 3 4
extern wchar_t *fgetws_unlocked (wchar_t *__restrict __ws, int __n,
     __FILE *__restrict __stream);







extern int fputws_unlocked (const wchar_t *__restrict __ws,
       __FILE *__restrict __stream);






extern size_t wcsftime (wchar_t *__restrict __s, size_t __maxsize,
   const wchar_t *__restrict __format,
   const struct tm *__restrict __tp) throw ();




extern size_t wcsftime_l (wchar_t *__restrict __s, size_t __maxsize,
     const wchar_t *__restrict __format,
     const struct tm *__restrict __tp,
     locale_t __loc) throw ();
# 857 "/usr/include/wchar.h" 3 4
}
# 127 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/wchar.h" 2 3
# 115 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/cwchar" 2 3
# 126 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/cwchar" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

using ::mbstate_t __attribute__((__using_if_exists__));
using ::size_t __attribute__((__using_if_exists__));
using ::tm __attribute__((__using_if_exists__));
using ::wint_t __attribute__((__using_if_exists__));
using ::FILE __attribute__((__using_if_exists__));
using ::fwprintf __attribute__((__using_if_exists__));
using ::fwscanf __attribute__((__using_if_exists__));
using ::swprintf __attribute__((__using_if_exists__));
using ::vfwprintf __attribute__((__using_if_exists__));
using ::vswprintf __attribute__((__using_if_exists__));
using ::swscanf __attribute__((__using_if_exists__));
using ::vfwscanf __attribute__((__using_if_exists__));
using ::vswscanf __attribute__((__using_if_exists__));
using ::fgetwc __attribute__((__using_if_exists__));
using ::fgetws __attribute__((__using_if_exists__));
using ::fputwc __attribute__((__using_if_exists__));
using ::fputws __attribute__((__using_if_exists__));
using ::fwide __attribute__((__using_if_exists__));
using ::getwc __attribute__((__using_if_exists__));
using ::putwc __attribute__((__using_if_exists__));
using ::ungetwc __attribute__((__using_if_exists__));
using ::wcstod __attribute__((__using_if_exists__));
using ::wcstof __attribute__((__using_if_exists__));
using ::wcstold __attribute__((__using_if_exists__));
using ::wcstol __attribute__((__using_if_exists__));
using ::wcstoll __attribute__((__using_if_exists__));
using ::wcstoul __attribute__((__using_if_exists__));
using ::wcstoull __attribute__((__using_if_exists__));
using ::wcscpy __attribute__((__using_if_exists__));
using ::wcsncpy __attribute__((__using_if_exists__));
using ::wcscat __attribute__((__using_if_exists__));
using ::wcsncat __attribute__((__using_if_exists__));
using ::wcscmp __attribute__((__using_if_exists__));
using ::wcscoll __attribute__((__using_if_exists__));
using ::wcsncmp __attribute__((__using_if_exists__));
using ::wcsxfrm __attribute__((__using_if_exists__));
using ::wcschr __attribute__((__using_if_exists__));
using ::wcspbrk __attribute__((__using_if_exists__));
using ::wcsrchr __attribute__((__using_if_exists__));
using ::wcsstr __attribute__((__using_if_exists__));
using ::wmemchr __attribute__((__using_if_exists__));
using ::wcscspn __attribute__((__using_if_exists__));
using ::wcslen __attribute__((__using_if_exists__));
using ::wcsspn __attribute__((__using_if_exists__));
using ::wcstok __attribute__((__using_if_exists__));
using ::wmemcmp __attribute__((__using_if_exists__));
using ::wmemcpy __attribute__((__using_if_exists__));
using ::wmemmove __attribute__((__using_if_exists__));
using ::wmemset __attribute__((__using_if_exists__));
using ::wcsftime __attribute__((__using_if_exists__));
using ::btowc __attribute__((__using_if_exists__));
using ::wctob __attribute__((__using_if_exists__));
using ::mbsinit __attribute__((__using_if_exists__));
using ::mbrlen __attribute__((__using_if_exists__));
using ::mbrtowc __attribute__((__using_if_exists__));
using ::wcrtomb __attribute__((__using_if_exists__));
using ::mbsrtowcs __attribute__((__using_if_exists__));
using ::wcsrtombs __attribute__((__using_if_exists__));

using ::getwchar __attribute__((__using_if_exists__));
using ::vwscanf __attribute__((__using_if_exists__));
using ::wscanf __attribute__((__using_if_exists__));

using ::putwchar __attribute__((__using_if_exists__));
using ::vwprintf __attribute__((__using_if_exists__));
using ::wprintf __attribute__((__using_if_exists__));

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr size_t __constexpr_wcslen(const wchar_t* __str) {

  return __builtin_wcslen(__str);
# 209 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/cwchar" 3
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr int
__constexpr_wmemcmp(const wchar_t* __lhs, const wchar_t* __rhs, size_t __count) {

  return __builtin_wmemcmp(__lhs, __rhs, __count);
# 227 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/cwchar" 3
}

template <class _Tp, class _Up>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr _Tp* __constexpr_wmemchr(_Tp* __str, _Up __value, size_t __count) {
  static_assert(sizeof(_Tp) == sizeof(wchar_t)&& alignof(_Tp) >= alignof(wchar_t) &&
                    __libcpp_is_trivially_equality_comparable<_Tp, _Tp>::value,
                "Calling wmemchr on non-trivially equality comparable types is unsafe.");


  if (!__libcpp_is_constant_evaluated()) {
    wchar_t __value_buffer = 0;
    __builtin_memcpy(&__value_buffer, &__value, sizeof(wchar_t));
    return reinterpret_cast<_Tp*>(
        __builtin_wmemchr(reinterpret_cast<__apply_cv_t<_Tp, wchar_t>*>(__str), __value_buffer, __count));
  }

  else if constexpr (is_same_v<remove_cv_t<_Tp>, wchar_t>)
    return __builtin_wmemchr(__str, __value, __count);



  for (; __count; --__count) {
    if (*__str == __value)
      return __str;
    ++__str;
  }
  return nullptr;
}

}}
# 26 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/find.h" 2 3
# 30 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/find.h" 3



# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__undef_macros" 1 3
# 34 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/find.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {


template <class _Iter, class _Sent, class _Tp, class _Proj>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr _Iter
__find_impl(_Iter __first, _Sent __last, const _Tp& __value, _Proj& __proj) {
  for (; __first != __last; ++__first)
    if (std::__invoke(__proj, *__first) == __value)
      break;
  return __first;
}


template <class _Tp,
          class _Up,
          class _Proj,
          __enable_if_t<__is_identity<_Proj>::value && __libcpp_is_trivially_equality_comparable<_Tp, _Up>::value &&
                            sizeof(_Tp) == 1,
                        int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr _Tp*
__find_impl(_Tp* __first, _Tp* __last, const _Up& __value, _Proj&) {
  if (auto __ret = std::__constexpr_memchr(__first, __value, __last - __first))
    return __ret;
  return __last;
}


template <class _Tp,
          class _Up,
          class _Proj,
          __enable_if_t<__is_identity<_Proj>::value && __libcpp_is_trivially_equality_comparable<_Tp, _Up>::value &&
                            sizeof(_Tp) == sizeof(wchar_t) && alignof(_Tp) >= alignof(wchar_t),
                        int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr _Tp*
__find_impl(_Tp* __first, _Tp* __last, const _Up& __value, _Proj&) {
  if (auto __ret = std::__constexpr_wmemchr(__first, __value, __last - __first))
    return __ret;
  return __last;
}



template <bool _ToFind, class _Cp, bool _IsConst>
constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) __bit_iterator<_Cp, _IsConst>
__find_bool(__bit_iterator<_Cp, _IsConst> __first, typename _Cp::size_type __n) {
  using _It = __bit_iterator<_Cp, _IsConst>;
  using __storage_type = typename _It::__storage_type;

  const int __bits_per_word = _It::__bits_per_word;

  if (__first.__ctz_ != 0) {
    __storage_type __clz_f = static_cast<__storage_type>(__bits_per_word - __first.__ctz_);
    __storage_type __dn = std::min(__clz_f, __n);
    __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz_f - __dn));
    __storage_type __b = std::__invert_if<!_ToFind>(*__first.__seg_) & __m;
    if (__b)
      return _It(__first.__seg_, static_cast<unsigned>(std::__libcpp_ctz(__b)));
    if (__n == __dn)
      return __first + __n;
    __n -= __dn;
    ++__first.__seg_;
  }

  for (; __n >= __bits_per_word; ++__first.__seg_, __n -= __bits_per_word) {
    __storage_type __b = std::__invert_if<!_ToFind>(*__first.__seg_);
    if (__b)
      return _It(__first.__seg_, static_cast<unsigned>(std::__libcpp_ctz(__b)));
  }

  if (__n > 0) {
    __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
    __storage_type __b = std::__invert_if<!_ToFind>(*__first.__seg_) & __m;
    if (__b)
      return _It(__first.__seg_, static_cast<unsigned>(std::__libcpp_ctz(__b)));
  }
  return _It(__first.__seg_, static_cast<unsigned>(__n));
}

template <class _Cp, bool _IsConst, class _Tp, class _Proj, __enable_if_t<__is_identity<_Proj>::value, int> = 0>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr __bit_iterator<_Cp, _IsConst>
__find_impl(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last, const _Tp& __value, _Proj&) {
  if (static_cast<bool>(__value))
    return std::__find_bool<true>(__first, static_cast<typename _Cp::size_type>(__last - __first));
  return std::__find_bool<false>(__first, static_cast<typename _Cp::size_type>(__last - __first));
}

template <class _InputIterator, class _Tp>
[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr _InputIterator
find(_InputIterator __first, _InputIterator __last, const _Tp& __value) {
  __identity __proj;
  return std::__rewrap_iter(
      __first, std::__find_impl(std::__unwrap_iter(__first), std::__unwrap_iter(__last), __value, __proj));
}

}}
# 1778 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/algorithm" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/find_end.h" 1 3
# 15 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/find_end.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/search.h" 1 3
# 27 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/search.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _AlgPolicy,
          class _Iter1, class _Sent1,
          class _Iter2, class _Sent2,
          class _Pred,
          class _Proj1,
          class _Proj2>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
pair<_Iter1, _Iter1> __search_forward_impl(_Iter1 __first1, _Sent1 __last1,
                                           _Iter2 __first2, _Sent2 __last2,
                                           _Pred& __pred,
                                           _Proj1& __proj1,
                                           _Proj2& __proj2) {
  if (__first2 == __last2)
    return std::make_pair(__first1, __first1);
  while (true) {

    while (true) {
      if (__first1 == __last1) {
        _IterOps<_AlgPolicy>::__advance_to(__first1, __last1);
        return std::make_pair(__first1, __first1);
      }
      if (std::__invoke(__pred, std::__invoke(__proj1, *__first1), std::__invoke(__proj2, *__first2)))
        break;
      ++__first1;
    }

    _Iter1 __m1 = __first1;
    _Iter2 __m2 = __first2;
    while (true) {
      if (++__m2 == __last2)
        return std::make_pair(__first1, ++__m1);
      if (++__m1 == __last1) {
        return std::make_pair(__m1, __m1);
      }


      if (!std::__invoke(__pred, std::__invoke(__proj1, *__m1), std::__invoke(__proj2, *__m2)))
      {
        ++__first1;
        break;
      }
    }
  }
}

template <class _AlgPolicy,
          class _Iter1, class _Sent1,
          class _Iter2, class _Sent2,
          class _Pred,
          class _Proj1,
          class _Proj2,
          class _DiffT1,
          class _DiffT2>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
pair<_Iter1, _Iter1> __search_random_access_impl(_Iter1 __first1, _Sent1 __last1,
                                                 _Iter2 __first2, _Sent2 __last2,
                                                 _Pred& __pred,
                                                 _Proj1& __proj1,
                                                 _Proj2& __proj2,
                                                 _DiffT1 __size1,
                                                 _DiffT2 __size2) {
  const _Iter1 __s = __first1 + __size1 - _DiffT1(__size2 - 1);

  while (true) {
    while (true) {
      if (__first1 == __s) {
        _IterOps<_AlgPolicy>::__advance_to(__first1, __last1);
        return std::make_pair(__first1, __first1);
      }
      if (std::__invoke(__pred, std::__invoke(__proj1, *__first1), std::__invoke(__proj2, *__first2)))
        break;
      ++__first1;
    }

    _Iter1 __m1 = __first1;
    _Iter2 __m2 = __first2;
    while (true) {
      if (++__m2 == __last2)
        return std::make_pair(__first1, __first1 + _DiffT1(__size2));
      ++__m1;
      if (!std::__invoke(__pred, std::__invoke(__proj1, *__m1), std::__invoke(__proj2, *__m2))) {
        ++__first1;
        break;
      }
    }
  }
}

template <class _Iter1, class _Sent1,
          class _Iter2, class _Sent2,
          class _Pred,
          class _Proj1,
          class _Proj2>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
pair<_Iter1, _Iter1> __search_impl(_Iter1 __first1, _Sent1 __last1,
                                   _Iter2 __first2, _Sent2 __last2,
                                   _Pred& __pred,
                                   _Proj1& __proj1,
                                   _Proj2& __proj2,
                                   __enable_if_t<__has_random_access_iterator_category<_Iter1>::value
                                              && __has_random_access_iterator_category<_Iter2>::value>* = nullptr) {

  auto __size2 = __last2 - __first2;
  if (__size2 == 0)
    return std::make_pair(__first1, __first1);

  auto __size1 = __last1 - __first1;
  if (__size1 < __size2) {
    return std::make_pair(__last1, __last1);
  }

  return std::__search_random_access_impl<_ClassicAlgPolicy>(__first1, __last1,
                                                             __first2, __last2,
                                                             __pred,
                                                             __proj1,
                                                             __proj2,
                                                             __size1,
                                                             __size2);
}

template <class _Iter1, class _Sent1,
          class _Iter2, class _Sent2,
          class _Pred,
          class _Proj1,
          class _Proj2>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
pair<_Iter1, _Iter1> __search_impl(_Iter1 __first1, _Sent1 __last1,
                                   _Iter2 __first2, _Sent2 __last2,
                                   _Pred& __pred,
                                   _Proj1& __proj1,
                                   _Proj2& __proj2,
                                   __enable_if_t<__has_forward_iterator_category<_Iter1>::value
                                              && __has_forward_iterator_category<_Iter2>::value
                                              && !(__has_random_access_iterator_category<_Iter1>::value
                                                && __has_random_access_iterator_category<_Iter2>::value)>* = nullptr) {
  return std::__search_forward_impl<_ClassicAlgPolicy>(__first1, __last1,
                                                       __first2, __last2,
                                                       __pred,
                                                       __proj1,
                                                       __proj2);
}

template <class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>
[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
_ForwardIterator1 search(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
                         _ForwardIterator2 __first2, _ForwardIterator2 __last2,
                         _BinaryPredicate __pred) {
  static_assert(__is_callable<_BinaryPredicate, decltype(*__first1), decltype(*__first2)>::value,
                "BinaryPredicate has to be callable");
  auto __proj = __identity();
  return std::__search_impl(__first1, __last1, __first2, __last2, __pred, __proj, __proj).first;
}

template <class _ForwardIterator1, class _ForwardIterator2>
[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
_ForwardIterator1 search(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
                         _ForwardIterator2 __first2, _ForwardIterator2 __last2) {
  return std::search(__first1, __last1, __first2, __last2, __equal_to());
}


template <class _ForwardIterator, class _Searcher>
[[__nodiscard__]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr _ForwardIterator
search(_ForwardIterator __f, _ForwardIterator __l, const _Searcher& __s) {
  return __s(__f, __l).first;
}



}}
# 16 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/find_end.h" 2 3






# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__iterator/reverse_iterator.h" 1 3
# 14 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__iterator/reverse_iterator.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__compare/compare_three_way_result.h" 1 3
# 18 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__compare/compare_three_way_result.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {



template<class, class, class>
struct __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) __compare_three_way_result { };

template<class _Tp, class _Up>
struct __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) __compare_three_way_result<_Tp, _Up, decltype(
  std::declval<__make_const_lvalue_ref<_Tp>>() <=> std::declval<__make_const_lvalue_ref<_Up>>(), void()
)> {
    using type = decltype(std::declval<__make_const_lvalue_ref<_Tp>>() <=> std::declval<__make_const_lvalue_ref<_Up>>());
};

template<class _Tp, class _Up = _Tp>
struct compare_three_way_result : __compare_three_way_result<_Tp, _Up, void> { };

template<class _Tp, class _Up = _Tp>
using compare_three_way_result_t = typename compare_three_way_result<_Tp, _Up>::type;



}}
# 15 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__iterator/reverse_iterator.h" 2 3








# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__iterator/iterator.h" 1 3
# 18 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__iterator/iterator.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template<class _Category, class _Tp, class _Distance = ptrdiff_t,
         class _Pointer = _Tp*, class _Reference = _Tp&>
struct __attribute__((__deprecated__)) iterator
{
    typedef _Tp value_type;
    typedef _Distance difference_type;
    typedef _Pointer pointer;
    typedef _Reference reference;
    typedef _Category iterator_category;
};

}}
# 24 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__iterator/reverse_iterator.h" 2 3








# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__ranges/subrange.h" 1 3
# 28 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__ranges/subrange.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__ranges/dangling.h" 1 3
# 20 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__ranges/dangling.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {



namespace ranges {
struct dangling {
  dangling() = default;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr dangling(auto&&...) noexcept {}
};

template <range _Rp>
using borrowed_iterator_t = _If<borrowed_range<_Rp>, iterator_t<_Rp>, dangling>;


}



}}
# 29 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__ranges/subrange.h" 2 3


# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__ranges/view_interface.h" 1 3
# 23 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__ranges/view_interface.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__ranges/empty.h" 1 3
# 21 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__ranges/empty.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {





namespace ranges {
namespace __empty {
  template <class _Tp>
  concept __member_empty =
    __workaround_52970<_Tp> &&
    requires(_Tp&& __t) {
      bool(__t.empty());
    };

  template<class _Tp>
  concept __can_invoke_size =
    !__member_empty<_Tp> &&
    requires(_Tp&& __t) { ranges::size(__t); };

  template <class _Tp>
  concept __can_compare_begin_end =
    !__member_empty<_Tp> &&
    !__can_invoke_size<_Tp> &&
    requires(_Tp&& __t) {
      bool(ranges::begin(__t) == ranges::end(__t));
      { ranges::begin(__t) } -> forward_iterator;
    };

  struct __fn {
    template <__member_empty _Tp>
    [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr bool operator()(_Tp&& __t) const
        noexcept(noexcept(bool(__t.empty()))) {
      return bool(__t.empty());
    }

    template <__can_invoke_size _Tp>
    [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr bool operator()(_Tp&& __t) const
        noexcept(noexcept(ranges::size(__t))) {
      return ranges::size(__t) == 0;
    }

    template<__can_compare_begin_end _Tp>
    [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr bool operator()(_Tp&& __t) const
        noexcept(noexcept(bool(ranges::begin(__t) == ranges::end(__t)))) {
      return ranges::begin(__t) == ranges::end(__t);
    }
  };
}

inline namespace __cpo {
  inline constexpr auto empty = __empty::__fn{};
}
}



}}
# 24 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__ranges/view_interface.h" 2 3
# 30 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__ranges/view_interface.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {



namespace ranges {

template<class _Derived>
  requires is_class_v<_Derived> && same_as<_Derived, remove_cv_t<_Derived>>
class view_interface {
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
  constexpr _Derived& __derived() noexcept {
    static_assert(sizeof(_Derived) && derived_from<_Derived, view_interface> && view<_Derived>);
    return static_cast<_Derived&>(*this);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
  constexpr _Derived const& __derived() const noexcept {
    static_assert(sizeof(_Derived) && derived_from<_Derived, view_interface> && view<_Derived>);
    return static_cast<_Derived const&>(*this);
  }

public:
  template<class _D2 = _Derived>
  [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr bool empty()
    requires forward_range<_D2>
  {
    return ranges::begin(__derived()) == ranges::end(__derived());
  }

  template<class _D2 = _Derived>
  [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr bool empty() const
    requires forward_range<const _D2>
  {
    return ranges::begin(__derived()) == ranges::end(__derived());
  }

  template<class _D2 = _Derived>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
  constexpr explicit operator bool()
    requires requires (_D2& __t) { ranges::empty(__t); }
  {
    return !ranges::empty(__derived());
  }

  template<class _D2 = _Derived>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
  constexpr explicit operator bool() const
    requires requires (const _D2& __t) { ranges::empty(__t); }
  {
    return !ranges::empty(__derived());
  }

  template<class _D2 = _Derived>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
  constexpr auto data()
    requires contiguous_iterator<iterator_t<_D2>>
  {
    return std::to_address(ranges::begin(__derived()));
  }

  template<class _D2 = _Derived>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
  constexpr auto data() const
    requires range<const _D2> && contiguous_iterator<iterator_t<const _D2>>
  {
    return std::to_address(ranges::begin(__derived()));
  }

  template<class _D2 = _Derived>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
  constexpr auto size()
    requires forward_range<_D2> && sized_sentinel_for<sentinel_t<_D2>, iterator_t<_D2>>
  {
    return std::__to_unsigned_like(ranges::end(__derived()) - ranges::begin(__derived()));
  }

  template<class _D2 = _Derived>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
  constexpr auto size() const
    requires forward_range<const _D2> && sized_sentinel_for<sentinel_t<const _D2>, iterator_t<const _D2>>
  {
    return std::__to_unsigned_like(ranges::end(__derived()) - ranges::begin(__derived()));
  }

  template<class _D2 = _Derived>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
  constexpr decltype(auto) front()
    requires forward_range<_D2>
  {
    ((void)0);

    return *ranges::begin(__derived());
  }

  template<class _D2 = _Derived>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
  constexpr decltype(auto) front() const
    requires forward_range<const _D2>
  {
    ((void)0);

    return *ranges::begin(__derived());
  }

  template<class _D2 = _Derived>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
  constexpr decltype(auto) back()
    requires bidirectional_range<_D2> && common_range<_D2>
  {
    ((void)0);

    return *ranges::prev(ranges::end(__derived()));
  }

  template<class _D2 = _Derived>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
  constexpr decltype(auto) back() const
    requires bidirectional_range<const _D2> && common_range<const _D2>
  {
    ((void)0);

    return *ranges::prev(ranges::end(__derived()));
  }

  template<random_access_range _RARange = _Derived>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
  constexpr decltype(auto) operator[](range_difference_t<_RARange> __index)
  {
    return ranges::begin(__derived())[__index];
  }

  template<random_access_range _RARange = const _Derived>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
  constexpr decltype(auto) operator[](range_difference_t<_RARange> __index) const
  {
    return ranges::begin(__derived())[__index];
  }
};

}



}}
# 32 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__ranges/subrange.h" 2 3
# 47 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__ranges/subrange.h" 3



# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__undef_macros" 1 3
# 51 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__ranges/subrange.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {



namespace ranges {
  template<class _From, class _To>
  concept __uses_nonqualification_pointer_conversion =
    is_pointer_v<_From> && is_pointer_v<_To> &&
    !convertible_to<remove_pointer_t<_From>(*)[], remove_pointer_t<_To>(*)[]>;

  template<class _From, class _To>
  concept __convertible_to_non_slicing =
    convertible_to<_From, _To> &&
    !__uses_nonqualification_pointer_conversion<decay_t<_From>, decay_t<_To>>;

  template<class _Pair, class _Iter, class _Sent>
  concept __pair_like_convertible_from =
    !range<_Pair> && __pair_like<_Pair> &&
    constructible_from<_Pair, _Iter, _Sent> &&
    __convertible_to_non_slicing<_Iter, tuple_element_t<0, _Pair>> &&
    convertible_to<_Sent, tuple_element_t<1, _Pair>>;

  template<input_or_output_iterator _Iter, sentinel_for<_Iter> _Sent = _Iter,
           subrange_kind _Kind = sized_sentinel_for<_Sent, _Iter>
             ? subrange_kind::sized
             : subrange_kind::unsized>
    requires (_Kind == subrange_kind::sized || !sized_sentinel_for<_Sent, _Iter>)
  class subrange
    : public view_interface<subrange<_Iter, _Sent, _Kind>>
  {
  public:

    static constexpr bool _StoreSize = (_Kind == subrange_kind::sized && !sized_sentinel_for<_Sent, _Iter>);

  private:
    static constexpr bool _MustProvideSizeAtConstruction = !_StoreSize;
    struct _Empty { __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr _Empty(auto) noexcept { } };
    using _Size = conditional_t<_StoreSize, make_unsigned_t<iter_difference_t<_Iter>>, _Empty>;
    [[__no_unique_address__]] _Iter __begin_ = _Iter();
    [[__no_unique_address__]] _Sent __end_ = _Sent();
    [[__no_unique_address__]] _Size __size_ = 0;

  public:
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    subrange() requires default_initializable<_Iter> = default;

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    constexpr subrange(__convertible_to_non_slicing<_Iter> auto __iter, _Sent __sent)
      requires _MustProvideSizeAtConstruction
      : __begin_(std::move(__iter)), __end_(std::move(__sent))
    { }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    constexpr subrange(__convertible_to_non_slicing<_Iter> auto __iter, _Sent __sent,
                       make_unsigned_t<iter_difference_t<_Iter>> __n)
      requires (_Kind == subrange_kind::sized)
      : __begin_(std::move(__iter)), __end_(std::move(__sent)), __size_(__n)
    {
      if constexpr (sized_sentinel_for<_Sent, _Iter>)
        ((void)0);

    }

    template<__different_from<subrange> _Range>
      requires borrowed_range<_Range> &&
               __convertible_to_non_slicing<iterator_t<_Range>, _Iter> &&
               convertible_to<sentinel_t<_Range>, _Sent>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    constexpr subrange(_Range&& __range)
      requires (!_StoreSize)
      : subrange(ranges::begin(__range), ranges::end(__range))
    { }

    template<__different_from<subrange> _Range>
      requires borrowed_range<_Range> &&
               __convertible_to_non_slicing<iterator_t<_Range>, _Iter> &&
               convertible_to<sentinel_t<_Range>, _Sent>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    constexpr subrange(_Range&& __range)
      requires _StoreSize && sized_range<_Range>
      : subrange(__range, ranges::size(__range))
    { }

    template<borrowed_range _Range>
      requires __convertible_to_non_slicing<iterator_t<_Range>, _Iter> &&
               convertible_to<sentinel_t<_Range>, _Sent>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    constexpr subrange(_Range&& __range, make_unsigned_t<iter_difference_t<_Iter>> __n)
      requires (_Kind == subrange_kind::sized)
      : subrange(ranges::begin(__range), ranges::end(__range), __n)
    { }

    template<__different_from<subrange> _Pair>
      requires __pair_like_convertible_from<_Pair, const _Iter&, const _Sent&>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    constexpr operator _Pair() const {
      return _Pair(__begin_, __end_);
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    constexpr _Iter begin() const requires copyable<_Iter> {
      return __begin_;
    }

    [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr _Iter begin() requires (!copyable<_Iter>) {
      return std::move(__begin_);
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    constexpr _Sent end() const {
      return __end_;
    }

    [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr bool empty() const {
      return __begin_ == __end_;
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    constexpr make_unsigned_t<iter_difference_t<_Iter>> size() const
      requires (_Kind == subrange_kind::sized)
    {
      if constexpr (_StoreSize)
        return __size_;
      else
        return std::__to_unsigned_like(__end_ - __begin_);
    }

    [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr subrange next(iter_difference_t<_Iter> __n = 1) const&
      requires forward_iterator<_Iter>
    {
      auto __tmp = *this;
      __tmp.advance(__n);
      return __tmp;
    }

    [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr subrange next(iter_difference_t<_Iter> __n = 1) && {
      advance(__n);
      return std::move(*this);
    }

    [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr subrange prev(iter_difference_t<_Iter> __n = 1) const
      requires bidirectional_iterator<_Iter>
    {
      auto __tmp = *this;
      __tmp.advance(-__n);
      return __tmp;
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    constexpr subrange& advance(iter_difference_t<_Iter> __n) {
      if constexpr (bidirectional_iterator<_Iter>) {
        if (__n < 0) {
          ranges::advance(__begin_, __n);
          if constexpr (_StoreSize)
            __size_ += std::__to_unsigned_like(-__n);
          return *this;
        }
      }

      auto __d = __n - ranges::advance(__begin_, __n, __end_);
      if constexpr (_StoreSize)
        __size_ -= std::__to_unsigned_like(__d);
      return *this;
    }
  };

  template<input_or_output_iterator _Iter, sentinel_for<_Iter> _Sent>
  subrange(_Iter, _Sent) -> subrange<_Iter, _Sent>;

  template<input_or_output_iterator _Iter, sentinel_for<_Iter> _Sent>
  subrange(_Iter, _Sent, make_unsigned_t<iter_difference_t<_Iter>>)
    -> subrange<_Iter, _Sent, subrange_kind::sized>;

  template<borrowed_range _Range>
  subrange(_Range&&) -> subrange<iterator_t<_Range>, sentinel_t<_Range>,
                                 (sized_range<_Range> || sized_sentinel_for<sentinel_t<_Range>, iterator_t<_Range>>)
                                   ? subrange_kind::sized : subrange_kind::unsized>;

  template<borrowed_range _Range>
  subrange(_Range&&, make_unsigned_t<range_difference_t<_Range>>)
    -> subrange<iterator_t<_Range>, sentinel_t<_Range>, subrange_kind::sized>;

  template<size_t _Index, class _Iter, class _Sent, subrange_kind _Kind>
    requires ((_Index == 0 && copyable<_Iter>) || _Index == 1)
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
  constexpr auto get(const subrange<_Iter, _Sent, _Kind>& __subrange) {
    if constexpr (_Index == 0)
      return __subrange.begin();
    else
      return __subrange.end();
  }

  template<size_t _Index, class _Iter, class _Sent, subrange_kind _Kind>
    requires (_Index < 2)
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
  constexpr auto get(subrange<_Iter, _Sent, _Kind>&& __subrange) {
    if constexpr (_Index == 0)
      return __subrange.begin();
    else
      return __subrange.end();
  }

  template<class _Ip, class _Sp, subrange_kind _Kp>
  inline constexpr bool enable_borrowed_range<subrange<_Ip, _Sp, _Kp>> = true;

  template<range _Rp>
  using borrowed_subrange_t = _If<borrowed_range<_Rp>, subrange<iterator_t<_Rp>>, dangling>;
}



using ranges::get;



template<class _Ip, class _Sp, ranges::subrange_kind _Kp>
struct tuple_size<ranges::subrange<_Ip, _Sp, _Kp>> : integral_constant<size_t, 2> {};

template<class _Ip, class _Sp, ranges::subrange_kind _Kp>
struct tuple_element<0, ranges::subrange<_Ip, _Sp, _Kp>> {
  using type = _Ip;
};

template<class _Ip, class _Sp, ranges::subrange_kind _Kp>
struct tuple_element<1, ranges::subrange<_Ip, _Sp, _Kp>> {
  using type = _Sp;
};

template<class _Ip, class _Sp, ranges::subrange_kind _Kp>
struct tuple_element<0, const ranges::subrange<_Ip, _Sp, _Kp>> {
  using type = _Ip;
};

template<class _Ip, class _Sp, ranges::subrange_kind _Kp>
struct tuple_element<1, const ranges::subrange<_Ip, _Sp, _Kp>> {
  using type = _Sp;
};



}}
# 33 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__iterator/reverse_iterator.h" 2 3
# 45 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__iterator/reverse_iterator.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

#pragma GCC diagnostic push
# 49 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__iterator/reverse_iterator.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
# 49 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__iterator/reverse_iterator.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
template <class _Iter>
class reverse_iterator

    : public iterator<typename iterator_traits<_Iter>::iterator_category,
                      typename iterator_traits<_Iter>::value_type,
                      typename iterator_traits<_Iter>::difference_type,
                      typename iterator_traits<_Iter>::pointer,
                      typename iterator_traits<_Iter>::reference>

{
#pragma GCC diagnostic pop
private:

    _Iter __t_;



    static_assert(__has_bidirectional_iterator_category<_Iter>::value || bidirectional_iterator<_Iter>,
        "reverse_iterator<It> requires It to be a bidirectional iterator.");


protected:
    _Iter current;
public:
    using iterator_type = _Iter;

    using iterator_category = _If<__has_random_access_iterator_category<_Iter>::value,
                                  random_access_iterator_tag,
                                  typename iterator_traits<_Iter>::iterator_category>;
    using pointer = typename iterator_traits<_Iter>::pointer;

    using iterator_concept = _If<random_access_iterator<_Iter>, random_access_iterator_tag, bidirectional_iterator_tag>;
    using value_type = iter_value_t<_Iter>;
    using difference_type = iter_difference_t<_Iter>;
    using reference = iter_reference_t<_Iter>;







    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    reverse_iterator() : __t_(), current() {}

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    explicit reverse_iterator(_Iter __x) : __t_(__x), current(__x) {}

    template <class _Up, class = __enable_if_t<
        !is_same<_Up, _Iter>::value && is_convertible<_Up const&, _Iter>::value
    > >
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    reverse_iterator(const reverse_iterator<_Up>& __u)
        : __t_(__u.base()), current(__u.base())
    { }

    template <class _Up, class = __enable_if_t<
        !is_same<_Up, _Iter>::value &&
        is_convertible<_Up const&, _Iter>::value &&
        is_assignable<_Iter&, _Up const&>::value
    > >
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    reverse_iterator& operator=(const reverse_iterator<_Up>& __u) {
        __t_ = current = __u.base();
        return *this;
    }
# 142 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__iterator/reverse_iterator.h" 3
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    _Iter base() const {return current;}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    reference operator*() const {_Iter __tmp = current; return *--__tmp;}


    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    constexpr pointer operator->() const
      requires is_pointer_v<_Iter> || requires(const _Iter __i) { __i.operator->(); }
    {
      if constexpr (is_pointer_v<_Iter>) {
        return std::prev(current);
      } else {
        return std::prev(current).operator->();
      }
    }







    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    reverse_iterator& operator++() {--current; return *this;}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    reverse_iterator operator++(int) {reverse_iterator __tmp(*this); --current; return __tmp;}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    reverse_iterator& operator--() {++current; return *this;}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    reverse_iterator operator--(int) {reverse_iterator __tmp(*this); ++current; return __tmp;}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    reverse_iterator operator+(difference_type __n) const {return reverse_iterator(current - __n);}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    reverse_iterator& operator+=(difference_type __n) {current -= __n; return *this;}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    reverse_iterator operator-(difference_type __n) const {return reverse_iterator(current + __n);}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    reverse_iterator& operator-=(difference_type __n) {current += __n; return *this;}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    reference operator[](difference_type __n) const {return *(*this + __n);}


    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) friend constexpr
    iter_rvalue_reference_t<_Iter> iter_move(const reverse_iterator& __i)
      noexcept(is_nothrow_copy_constructible_v<_Iter> &&
          noexcept(ranges::iter_move(--std::declval<_Iter&>()))) {
      auto __tmp = __i.base();
      return ranges::iter_move(--__tmp);
    }

    template <indirectly_swappable<_Iter> _Iter2>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) friend constexpr
    void iter_swap(const reverse_iterator& __x, const reverse_iterator<_Iter2>& __y)
      noexcept(is_nothrow_copy_constructible_v<_Iter> &&
          is_nothrow_copy_constructible_v<_Iter2> &&
          noexcept(ranges::iter_swap(--std::declval<_Iter&>(), --std::declval<_Iter2&>()))) {
      auto __xtmp = __x.base();
      auto __ytmp = __y.base();
      ranges::iter_swap(--__xtmp, --__ytmp);
    }

};

template <class _Iter1, class _Iter2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
bool
operator==(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)

    requires requires {
      { __x.base() == __y.base() } -> convertible_to<bool>;
    }

{
    return __x.base() == __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
bool
operator<(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)

    requires requires {
        { __x.base() > __y.base() } -> convertible_to<bool>;
      }

{
    return __x.base() > __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
bool
operator!=(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)

    requires requires {
      { __x.base() != __y.base() } -> convertible_to<bool>;
    }

{
    return __x.base() != __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
bool
operator>(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)

    requires requires {
        { __x.base() < __y.base() } -> convertible_to<bool>;
      }

{
    return __x.base() < __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
bool
operator>=(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)

    requires requires {
        { __x.base() <= __y.base() } -> convertible_to<bool>;
      }

{
    return __x.base() <= __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
bool
operator<=(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)

    requires requires {
        { __x.base() >= __y.base() } -> convertible_to<bool>;
      }

{
    return __x.base() >= __y.base();
}


template <class _Iter1, three_way_comparable_with<_Iter1> _Iter2>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
compare_three_way_result_t<_Iter1, _Iter2>
operator<=>(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)
{
    return __y.base() <=> __x.base();
}



template <class _Iter1, class _Iter2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
auto
operator-(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)
-> decltype(__y.base() - __x.base())
{
    return __y.base() - __x.base();
}
# 313 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__iterator/reverse_iterator.h" 3
template <class _Iter>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
reverse_iterator<_Iter>
operator+(typename reverse_iterator<_Iter>::difference_type __n, const reverse_iterator<_Iter>& __x)
{
    return reverse_iterator<_Iter>(__x.base() - __n);
}


template <class _Iter1, class _Iter2>
  requires (!sized_sentinel_for<_Iter1, _Iter2>)
inline constexpr bool disable_sized_sentinel_for<reverse_iterator<_Iter1>, reverse_iterator<_Iter2>> = true;



template <class _Iter>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
reverse_iterator<_Iter> make_reverse_iterator(_Iter __i)
{
    return reverse_iterator<_Iter>(__i);
}
# 363 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__iterator/reverse_iterator.h" 3
template <class _Iter>
class __unconstrained_reverse_iterator {
  _Iter __iter_;

public:
  static_assert(__has_bidirectional_iterator_category<_Iter>::value || bidirectional_iterator<_Iter>);

  using iterator_type = _Iter;
  using iterator_category =
      _If<__has_random_access_iterator_category<_Iter>::value, random_access_iterator_tag, __iterator_category_type<_Iter>>;
  using pointer = __iterator_pointer_type<_Iter>;
  using value_type = iter_value_t<_Iter>;
  using difference_type = iter_difference_t<_Iter>;
  using reference = iter_reference_t<_Iter>;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr __unconstrained_reverse_iterator() = default;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr __unconstrained_reverse_iterator(const __unconstrained_reverse_iterator&) = default;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr explicit __unconstrained_reverse_iterator(_Iter __iter) : __iter_(__iter) {}

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr _Iter base() const { return __iter_; }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr reference operator*() const {
    auto __tmp = __iter_;
    return *--__tmp;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr pointer operator->() const {
    if constexpr (is_pointer_v<_Iter>) {
      return std::prev(__iter_);
    } else {
      return std::prev(__iter_).operator->();
    }
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) friend constexpr
  iter_rvalue_reference_t<_Iter> iter_move(const __unconstrained_reverse_iterator& __i)
    noexcept(is_nothrow_copy_constructible_v<_Iter> &&
        noexcept(ranges::iter_move(--std::declval<_Iter&>()))) {
    auto __tmp = __i.base();
    return ranges::iter_move(--__tmp);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr __unconstrained_reverse_iterator& operator++() {
    --__iter_;
    return *this;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr __unconstrained_reverse_iterator operator++(int) {
    auto __tmp = *this;
    --__iter_;
    return __tmp;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr __unconstrained_reverse_iterator& operator--() {
    ++__iter_;
    return *this;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr __unconstrained_reverse_iterator operator--(int) {
    auto __tmp = *this;
    ++__iter_;
    return __tmp;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr __unconstrained_reverse_iterator& operator+=(difference_type __n) {
    __iter_ -= __n;
    return *this;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr __unconstrained_reverse_iterator& operator-=(difference_type __n) {
    __iter_ += __n;
    return *this;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr __unconstrained_reverse_iterator operator+(difference_type __n) const {
    return __unconstrained_reverse_iterator(__iter_ - __n);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr __unconstrained_reverse_iterator operator-(difference_type __n) const {
    return __unconstrained_reverse_iterator(__iter_ + __n);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr difference_type operator-(const __unconstrained_reverse_iterator& __other) const {
    return __other.__iter_ - __iter_;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr auto operator[](difference_type __n) const { return *(*this + __n); }



  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) friend constexpr bool
  operator==(const __unconstrained_reverse_iterator& __lhs, const __unconstrained_reverse_iterator& __rhs) {
    return __lhs.base() == __rhs.base();
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) friend constexpr bool
  operator!=(const __unconstrained_reverse_iterator& __lhs, const __unconstrained_reverse_iterator& __rhs) {
    return __lhs.base() != __rhs.base();
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) friend constexpr bool
  operator<(const __unconstrained_reverse_iterator& __lhs, const __unconstrained_reverse_iterator& __rhs) {
    return __lhs.base() > __rhs.base();
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) friend constexpr bool
  operator>(const __unconstrained_reverse_iterator& __lhs, const __unconstrained_reverse_iterator& __rhs) {
    return __lhs.base() < __rhs.base();
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) friend constexpr bool
  operator<=(const __unconstrained_reverse_iterator& __lhs, const __unconstrained_reverse_iterator& __rhs) {
    return __lhs.base() >= __rhs.base();
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) friend constexpr bool
  operator>=(const __unconstrained_reverse_iterator& __lhs, const __unconstrained_reverse_iterator& __rhs) {
    return __lhs.base() <= __rhs.base();
  }
};



template <template <class> class _RevIter1, template <class> class _RevIter2, class _Iter>
struct __unwrap_reverse_iter_impl {
  using _UnwrappedIter = decltype(__unwrap_iter_impl<_Iter>::__unwrap(std::declval<_Iter>()));
  using _ReverseWrapper = _RevIter1<_RevIter2<_Iter> >;

  static __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr _ReverseWrapper
  __rewrap(_ReverseWrapper __orig_iter, _UnwrappedIter __unwrapped_iter) {
    return _ReverseWrapper(
        _RevIter2<_Iter>(__unwrap_iter_impl<_Iter>::__rewrap(__orig_iter.base().base(), __unwrapped_iter)));
  }

  static __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr _UnwrappedIter __unwrap(_ReverseWrapper __i) noexcept {
    return __unwrap_iter_impl<_Iter>::__unwrap(__i.base().base());
  }
};


template <ranges::bidirectional_range _Range>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr ranges::
    subrange<reverse_iterator<ranges::iterator_t<_Range>>, reverse_iterator<ranges::iterator_t<_Range>>>
    __reverse_range(_Range&& __range) {
  auto __first = ranges::begin(__range);
  return {std::make_reverse_iterator(ranges::next(__first, ranges::end(__range))), std::make_reverse_iterator(__first)};
}


template <class _Iter, bool __b>
struct __unwrap_iter_impl<reverse_iterator<reverse_iterator<_Iter> >, __b>
    : __unwrap_reverse_iter_impl<reverse_iterator, reverse_iterator, _Iter> {};



template <class _Iter, bool __b>
struct __unwrap_iter_impl<reverse_iterator<__unconstrained_reverse_iterator<_Iter>>, __b>
    : __unwrap_reverse_iter_impl<reverse_iterator, __unconstrained_reverse_iterator, _Iter> {};

template <class _Iter, bool __b>
struct __unwrap_iter_impl<__unconstrained_reverse_iterator<reverse_iterator<_Iter>>, __b>
    : __unwrap_reverse_iter_impl<__unconstrained_reverse_iterator, reverse_iterator, _Iter> {};

template <class _Iter, bool __b>
struct __unwrap_iter_impl<__unconstrained_reverse_iterator<__unconstrained_reverse_iterator<_Iter>>, __b>
    : __unwrap_reverse_iter_impl<__unconstrained_reverse_iterator, __unconstrained_reverse_iterator, _Iter> {};



}}
# 23 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/find_end.h" 2 3
# 27 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/find_end.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <
    class _AlgPolicy,
    class _Iter1,
    class _Sent1,
    class _Iter2,
    class _Sent2,
    class _Pred,
    class _Proj1,
    class _Proj2>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) inline constexpr pair<_Iter1, _Iter1> __find_end_impl(
    _Iter1 __first1,
    _Sent1 __last1,
    _Iter2 __first2,
    _Sent2 __last2,
    _Pred& __pred,
    _Proj1& __proj1,
    _Proj2& __proj2,
    forward_iterator_tag,
    forward_iterator_tag) {

  _Iter1 __match_first = _IterOps<_AlgPolicy>::next(__first1, __last1);
  _Iter1 __match_last = __match_first;
  if (__first2 == __last2)
    return pair<_Iter1, _Iter1>(__match_last, __match_last);
  while (true) {
    while (true) {
      if (__first1 == __last1)
        return pair<_Iter1, _Iter1>(__match_first, __match_last);
      if (std::__invoke(__pred, std::__invoke(__proj1, *__first1), std::__invoke(__proj2, *__first2)))
        break;
      ++__first1;
    }

    _Iter1 __m1 = __first1;
    _Iter2 __m2 = __first2;
    while (true) {
      if (++__m2 == __last2) {
        __match_first = __first1;
        __match_last = ++__m1;
        ++__first1;
        break;
      }
      if (++__m1 == __last1)
        return pair<_Iter1, _Iter1>(__match_first, __match_last);

      if (!std::__invoke(__pred, std::__invoke(__proj1, *__m1), std::__invoke(__proj2, *__m2)))
      {
        ++__first1;
        break;
      }
    }
  }
}

template <
    class _IterOps,
    class _Pred,
    class _Iter1,
    class _Sent1,
    class _Iter2,
    class _Sent2,
    class _Proj1,
    class _Proj2>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr _Iter1 __find_end(
    _Iter1 __first1,
    _Sent1 __sent1,
    _Iter2 __first2,
    _Sent2 __sent2,
    _Pred& __pred,
    _Proj1& __proj1,
    _Proj2& __proj2,
    bidirectional_iterator_tag,
    bidirectional_iterator_tag) {
  auto __last1 = _IterOps::next(__first1, __sent1);
  auto __last2 = _IterOps::next(__first2, __sent2);

  if (__first2 == __last2)
    return __last1;
  _Iter1 __l1 = __last1;
  _Iter2 __l2 = __last2;
  --__l2;
  while (true) {

    while (true) {
      if (__first1 == __l1)
        return __last1;
      if (std::__invoke(__pred, std::__invoke(__proj1, *--__l1), std::__invoke(__proj2, *__l2)))
        break;
    }

    _Iter1 __m1 = __l1;
    _Iter2 __m2 = __l2;
    while (true) {
      if (__m2 == __first2)
        return __m1;
      if (__m1 == __first1)
        return __last1;


      if (!std::__invoke(__pred, std::__invoke(__proj1, *--__m1), std::__invoke(__proj2, *--__m2)))
      {
        break;
      }
    }
  }
}

template <
    class _AlgPolicy,
    class _Pred,
    class _Iter1,
    class _Sent1,
    class _Iter2,
    class _Sent2,
    class _Proj1,
    class _Proj2>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr _Iter1 __find_end(
    _Iter1 __first1,
    _Sent1 __sent1,
    _Iter2 __first2,
    _Sent2 __sent2,
    _Pred& __pred,
    _Proj1& __proj1,
    _Proj2& __proj2,
    random_access_iterator_tag,
    random_access_iterator_tag) {
  typedef typename iterator_traits<_Iter1>::difference_type _D1;
  auto __last1 = _IterOps<_AlgPolicy>::next(__first1, __sent1);
  auto __last2 = _IterOps<_AlgPolicy>::next(__first2, __sent2);

  auto __len2 = __last2 - __first2;
  if (__len2 == 0)
    return __last1;
  auto __len1 = __last1 - __first1;
  if (__len1 < __len2)
    return __last1;
  const _Iter1 __s = __first1 + _D1(__len2 - 1);
  _Iter1 __l1 = __last1;
  _Iter2 __l2 = __last2;
  --__l2;
  while (true) {
    while (true) {
      if (__s == __l1)
        return __last1;
      if (std::__invoke(__pred, std::__invoke(__proj1, *--__l1), std::__invoke(__proj2, *__l2)))
        break;
    }
    _Iter1 __m1 = __l1;
    _Iter2 __m2 = __l2;
    while (true) {
      if (__m2 == __first2)
        return __m1;

      if (!std::__invoke(__pred, std::__invoke(__proj1, *--__m1), std::__invoke(*--__m2))) {
        break;
      }
    }
  }
}

template <class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>
[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
_ForwardIterator1 __find_end_classic(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
                                     _ForwardIterator2 __first2, _ForwardIterator2 __last2,
                                     _BinaryPredicate& __pred) {
  auto __proj = __identity();
  return std::__find_end_impl<_ClassicAlgPolicy>(
             __first1,
             __last1,
             __first2,
             __last2,
             __pred,
             __proj,
             __proj,
             typename iterator_traits<_ForwardIterator1>::iterator_category(),
             typename iterator_traits<_ForwardIterator2>::iterator_category())
      .first;
}

template <class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>
[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
_ForwardIterator1 find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
                           _ForwardIterator2 __first2, _ForwardIterator2 __last2,
                           _BinaryPredicate __pred) {
  return std::__find_end_classic(__first1, __last1, __first2, __last2, __pred);
}

template <class _ForwardIterator1, class _ForwardIterator2>
[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
_ForwardIterator1 find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
                           _ForwardIterator2 __first2, _ForwardIterator2 __last2) {
  return std::find_end(__first1, __last1, __first2, __last2, __equal_to());
}

}}
# 1779 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/algorithm" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/find_first_of.h" 1 3
# 19 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/find_first_of.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
constexpr _ForwardIterator1 __find_first_of_ce(_ForwardIterator1 __first1,
                                                                   _ForwardIterator1 __last1,
                                                                   _ForwardIterator2 __first2,
                                                                   _ForwardIterator2 __last2,
                                                                   _BinaryPredicate&& __pred) {
  for (; __first1 != __last1; ++__first1)
    for (_ForwardIterator2 __j = __first2; __j != __last2; ++__j)
      if (__pred(*__first1, *__j))
        return __first1;
  return __last1;
}

template <class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>
[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr _ForwardIterator1
find_first_of(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2,
              _ForwardIterator2 __last2, _BinaryPredicate __pred) {
  return std::__find_first_of_ce(__first1, __last1, __first2, __last2, __pred);
}

template <class _ForwardIterator1, class _ForwardIterator2>
[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr _ForwardIterator1 find_first_of(
    _ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2, _ForwardIterator2 __last2) {
  return std::__find_first_of_ce(__first1, __last1, __first2, __last2, __equal_to());
}

}}
# 1780 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/algorithm" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/find_if.h" 1 3
# 17 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/find_if.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _InputIterator, class _Predicate>
[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr _InputIterator
find_if(_InputIterator __first, _InputIterator __last, _Predicate __pred) {
  for (; __first != __last; ++__first)
    if (__pred(*__first))
      break;
  return __first;
}

}}
# 1781 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/algorithm" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/find_if_not.h" 1 3
# 17 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/find_if_not.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _InputIterator, class _Predicate>
[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr _InputIterator
find_if_not(_InputIterator __first, _InputIterator __last, _Predicate __pred) {
  for (; __first != __last; ++__first)
    if (!__pred(*__first))
      break;
  return __first;
}

}}
# 1782 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/algorithm" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/for_each.h" 1 3
# 17 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/for_each.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _InputIterator, class _Function>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr _Function for_each(_InputIterator __first,
                                                                                  _InputIterator __last,
                                                                                  _Function __f) {
  for (; __first != __last; ++__first)
    __f(*__first);
  return __f;
}

}}
# 1783 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/algorithm" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/for_each_n.h" 1 3
# 18 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/for_each_n.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {



template <class _InputIterator, class _Size, class _Function>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr _InputIterator for_each_n(_InputIterator __first,
                                                                                         _Size __orig_n,
                                                                                         _Function __f) {
  typedef decltype(std::__convert_to_integral(__orig_n)) _IntegralSize;
  _IntegralSize __n = __orig_n;
  while (__n > 0) {
    __f(*__first);
    ++__first;
    --__n;
  }
  return __first;
}



}}
# 1784 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/algorithm" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/generate.h" 1 3
# 16 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/generate.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _ForwardIterator, class _Generator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
void
generate(_ForwardIterator __first, _ForwardIterator __last, _Generator __gen)
{
    for (; __first != __last; ++__first)
        *__first = __gen();
}

}}
# 1785 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/algorithm" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/generate_n.h" 1 3
# 17 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/generate_n.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _OutputIterator, class _Size, class _Generator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
_OutputIterator
generate_n(_OutputIterator __first, _Size __orig_n, _Generator __gen)
{
    typedef decltype(std::__convert_to_integral(__orig_n)) _IntegralSize;
    _IntegralSize __n = __orig_n;
    for (; __n > 0; ++__first, (void) --__n)
        *__first = __gen();
    return __first;
}

}}
# 1786 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/algorithm" 2 3

# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/in_found_result.h" 1 3
# 19 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/in_found_result.h" 3




namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

namespace ranges {
template <class _InIter1>
struct in_found_result {
  [[__no_unique_address__]] _InIter1 in;
  bool found;

  template <class _InIter2>
    requires convertible_to<const _InIter1&, _InIter2>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr operator in_found_result<_InIter2>() const & {
    return {in, found};
  }

  template <class _InIter2>
    requires convertible_to<_InIter1, _InIter2>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr operator in_found_result<_InIter2>() && {
    return {std::move(in), found};
  }
};
}

}}
# 1788 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/algorithm" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/in_fun_result.h" 1 3
# 19 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/in_fun_result.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {



namespace ranges {
template <class _InIter1, class _Func1>
struct in_fun_result {
  [[__no_unique_address__]] _InIter1 in;
  [[__no_unique_address__]] _Func1 fun;

  template <class _InIter2, class _Func2>
    requires convertible_to<const _InIter1&, _InIter2> && convertible_to<const _Func1&, _Func2>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr operator in_fun_result<_InIter2, _Func2>() const & {
    return {in, fun};
  }

  template <class _InIter2, class _Func2>
    requires convertible_to<_InIter1, _InIter2> && convertible_to<_Func1, _Func2>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr operator in_fun_result<_InIter2, _Func2>() && {
    return {std::move(in), std::move(fun)};
  }
};
}



}}
# 1789 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/algorithm" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/in_in_out_result.h" 1 3
# 19 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/in_in_out_result.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {



namespace ranges {

template <class _InIter1, class _InIter2, class _OutIter1>
struct in_in_out_result {
  [[__no_unique_address__]] _InIter1 in1;
  [[__no_unique_address__]] _InIter2 in2;
  [[__no_unique_address__]] _OutIter1 out;

  template <class _InIter3, class _InIter4, class _OutIter2>
    requires convertible_to<const _InIter1&, _InIter3>
          && convertible_to<const _InIter2&, _InIter4> && convertible_to<const _OutIter1&, _OutIter2>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
  operator in_in_out_result<_InIter3, _InIter4, _OutIter2>() const& {
    return {in1, in2, out};
  }

  template <class _InIter3, class _InIter4, class _OutIter2>
    requires convertible_to<_InIter1, _InIter3>
          && convertible_to<_InIter2, _InIter4> && convertible_to<_OutIter1, _OutIter2>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
  operator in_in_out_result<_InIter3, _InIter4, _OutIter2>() && {
    return {std::move(in1), std::move(in2), std::move(out)};
  }
};

}



}}
# 1790 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/algorithm" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/in_in_result.h" 1 3
# 19 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/in_in_result.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {



namespace ranges {

template <class _InIter1, class _InIter2>
struct in_in_result {
  [[__no_unique_address__]] _InIter1 in1;
  [[__no_unique_address__]] _InIter2 in2;

  template <class _InIter3, class _InIter4>
    requires convertible_to<const _InIter1&, _InIter3> && convertible_to<const _InIter2&, _InIter4>
   __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
   operator in_in_result<_InIter3, _InIter4>() const & {
    return {in1, in2};
  }

  template <class _InIter3, class _InIter4>
    requires convertible_to<_InIter1, _InIter3> && convertible_to<_InIter2, _InIter4>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
  operator in_in_result<_InIter3, _InIter4>() && {
    return {std::move(in1), std::move(in2)};
  }
};

}



}}
# 1791 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/algorithm" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/in_out_out_result.h" 1 3
# 19 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/in_out_out_result.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {



namespace ranges {
template <class _InIter1, class _OutIter1, class _OutIter2>
struct in_out_out_result {
  [[__no_unique_address__]] _InIter1 in;
  [[__no_unique_address__]] _OutIter1 out1;
  [[__no_unique_address__]] _OutIter2 out2;

  template <class _InIter2, class _OutIter3, class _OutIter4>
    requires convertible_to<const _InIter1&, _InIter2>
          && convertible_to<const _OutIter1&, _OutIter3> && convertible_to<const _OutIter2&, _OutIter4>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
  operator in_out_out_result<_InIter2, _OutIter3, _OutIter4>() const& {
    return {in, out1, out2};
  }

  template <class _InIter2, class _OutIter3, class _OutIter4>
    requires convertible_to<_InIter1, _InIter2>
          && convertible_to<_OutIter1, _OutIter3> && convertible_to<_OutIter2, _OutIter4>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
  operator in_out_out_result<_InIter2, _OutIter3, _OutIter4>() && {
    return {std::move(in), std::move(out1), std::move(out2)};
  }
};
}



}}
# 1792 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/algorithm" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/in_out_result.h" 1 3
# 19 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/in_out_result.h" 3



# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__undef_macros" 1 3
# 23 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/in_out_result.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {



namespace ranges {

template<class _InIter1, class _OutIter1>
struct in_out_result {
  [[__no_unique_address__]] _InIter1 in;
  [[__no_unique_address__]] _OutIter1 out;

  template <class _InIter2, class _OutIter2>
    requires convertible_to<const _InIter1&, _InIter2> && convertible_to<const _OutIter1&, _OutIter2>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
  constexpr operator in_out_result<_InIter2, _OutIter2>() const & {
    return {in, out};
  }

  template <class _InIter2, class _OutIter2>
    requires convertible_to<_InIter1, _InIter2> && convertible_to<_OutIter1, _OutIter2>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
  constexpr operator in_out_result<_InIter2, _OutIter2>() && {
    return {std::move(in), std::move(out)};
  }
};

}



}}
# 1793 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/algorithm" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/includes.h" 1 3
# 23 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/includes.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Iter1, class _Sent1, class _Iter2, class _Sent2, class _Comp, class _Proj1, class _Proj2>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr bool
__includes(_Iter1 __first1, _Sent1 __last1, _Iter2 __first2, _Sent2 __last2,
           _Comp&& __comp, _Proj1&& __proj1, _Proj2&& __proj2) {
  for (; __first2 != __last2; ++__first1) {
    if (__first1 == __last1 || std::__invoke(
          __comp, std::__invoke(__proj2, *__first2), std::__invoke(__proj1, *__first1)))
      return false;
    if (!std::__invoke(__comp, std::__invoke(__proj1, *__first1), std::__invoke(__proj2, *__first2)))
      ++__first2;
  }
  return true;
}

template <class _InputIterator1, class _InputIterator2, class _Compare>
[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr bool includes(
    _InputIterator1 __first1,
    _InputIterator1 __last1,
    _InputIterator2 __first2,
    _InputIterator2 __last2,
    _Compare __comp) {
  static_assert(__is_callable<_Compare, decltype(*__first1), decltype(*__first2)>::value,
      "Comparator has to be callable");

  return std::__includes(
      std::move(__first1),
      std::move(__last1),
      std::move(__first2),
      std::move(__last2),
      static_cast<__comp_ref_type<_Compare> >(__comp),
      __identity(),
      __identity());
}

template <class _InputIterator1, class _InputIterator2>
[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr bool
includes(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2) {
  return std::includes(std::move(__first1), std::move(__last1), std::move(__first2), std::move(__last2), __less<>());
}

}}
# 1794 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/algorithm" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/inplace_merge.h" 1 3
# 17 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/inplace_merge.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/move.h" 1 3
# 25 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/move.h" 3



# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__undef_macros" 1 3
# 29 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/move.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _AlgPolicy, class _InIter, class _Sent, class _OutIter>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr pair<_InIter, _OutIter>
__move(_InIter __first, _Sent __last, _OutIter __result);

template <class _AlgPolicy>
struct __move_loop {
  template <class _InIter, class _Sent, class _OutIter>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr pair<_InIter, _OutIter>
  operator()(_InIter __first, _Sent __last, _OutIter __result) const {
    while (__first != __last) {
      *__result = _IterOps<_AlgPolicy>::__iter_move(__first);
      ++__first;
      ++__result;
    }
    return std::make_pair(std::move(__first), std::move(__result));
  }

  template <class _InIter, class _OutIter>
  struct _MoveSegment {
    using _Traits = __segmented_iterator_traits<_InIter>;

    _OutIter& __result_;

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) _MoveSegment(_OutIter& __result) : __result_(__result) {}

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) void
    operator()(typename _Traits::__local_iterator __lfirst, typename _Traits::__local_iterator __llast) {
      __result_ = std::__move<_AlgPolicy>(__lfirst, __llast, std::move(__result_)).second;
    }
  };

  template <class _InIter, class _OutIter, __enable_if_t<__is_segmented_iterator<_InIter>::value, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr pair<_InIter, _OutIter>
  operator()(_InIter __first, _InIter __last, _OutIter __result) const {
    std::__for_each_segment(__first, __last, _MoveSegment<_InIter, _OutIter>(__result));
    return std::make_pair(__last, std::move(__result));
  }

  template <class _InIter,
            class _OutIter,
            __enable_if_t<__has_random_access_iterator_category<_InIter>::value &&
                              !__is_segmented_iterator<_InIter>::value && __is_segmented_iterator<_OutIter>::value,
                          int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr pair<_InIter, _OutIter>
  operator()(_InIter __first, _InIter __last, _OutIter __result) const {
    using _Traits = __segmented_iterator_traits<_OutIter>;
    using _DiffT = typename common_type<__iter_diff_t<_InIter>, __iter_diff_t<_OutIter> >::type;

    if (__first == __last)
      return std::make_pair(std::move(__first), std::move(__result));

    auto __local_first = _Traits::__local(__result);
    auto __segment_iterator = _Traits::__segment(__result);
    while (true) {
      auto __local_last = _Traits::__end(__segment_iterator);
      auto __size = std::min<_DiffT>(__local_last - __local_first, __last - __first);
      auto __iters = std::__move<_AlgPolicy>(__first, __first + __size, __local_first);
      __first = std::move(__iters.first);

      if (__first == __last)
        return std::make_pair(std::move(__first), _Traits::__compose(__segment_iterator, std::move(__iters.second)));

      __local_first = _Traits::__begin(++__segment_iterator);
    }
  }
};

struct __move_trivial {

  template <class _In, class _Out,
            __enable_if_t<__can_lower_move_assignment_to_memmove<_In, _Out>::value, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr pair<_In*, _Out*>
  operator()(_In* __first, _In* __last, _Out* __result) const {
    return std::__copy_trivial_impl(__first, __last, __result);
  }
};

template <class _AlgPolicy, class _InIter, class _Sent, class _OutIter>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr pair<_InIter, _OutIter>
__move(_InIter __first, _Sent __last, _OutIter __result) {
  return std::__dispatch_copy_or_move<_AlgPolicy, __move_loop<_AlgPolicy>, __move_trivial>(
      std::move(__first), std::move(__last), std::move(__result));
}

template <class _InputIterator, class _OutputIterator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr _OutputIterator
move(_InputIterator __first, _InputIterator __last, _OutputIterator __result) {
  static_assert(is_copy_constructible<_InputIterator>::value, "Iterators has to be copy constructible.");
  static_assert(is_copy_constructible<_OutputIterator>::value, "The output iterator has to be copy constructible.");

  return std::__move<_ClassicAlgPolicy>(std::move(__first), std::move(__last), std::move(__result)).second;
}

}}
# 18 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/inplace_merge.h" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/rotate.h" 1 3
# 14 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/rotate.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/move_backward.h" 1 3
# 24 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/move_backward.h" 3



# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__undef_macros" 1 3
# 28 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/move_backward.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _AlgPolicy, class _BidirectionalIterator1, class _Sentinel, class _BidirectionalIterator2>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr pair<_BidirectionalIterator1, _BidirectionalIterator2>
__move_backward(_BidirectionalIterator1 __first, _Sentinel __last, _BidirectionalIterator2 __result);

template <class _AlgPolicy>
struct __move_backward_loop {
  template <class _InIter, class _Sent, class _OutIter>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr pair<_InIter, _OutIter>
  operator()(_InIter __first, _Sent __last, _OutIter __result) const {
    auto __last_iter = _IterOps<_AlgPolicy>::next(__first, __last);
    auto __original_last_iter = __last_iter;

    while (__first != __last_iter) {
      *--__result = _IterOps<_AlgPolicy>::__iter_move(--__last_iter);
    }

    return std::make_pair(std::move(__original_last_iter), std::move(__result));
  }

  template <class _InIter, class _OutIter, __enable_if_t<__is_segmented_iterator<_InIter>::value, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr pair<_InIter, _OutIter>
  operator()(_InIter __first, _InIter __last, _OutIter __result) const {
    using _Traits = __segmented_iterator_traits<_InIter>;
    auto __sfirst = _Traits::__segment(__first);
    auto __slast = _Traits::__segment(__last);
    if (__sfirst == __slast) {
      auto __iters =
          std::__move_backward<_AlgPolicy>(_Traits::__local(__first), _Traits::__local(__last), std::move(__result));
      return std::make_pair(__last, __iters.second);
    }

    __result =
        std::__move_backward<_AlgPolicy>(_Traits::__begin(__slast), _Traits::__local(__last), std::move(__result))
            .second;
    --__slast;
    while (__sfirst != __slast) {
      __result =
          std::__move_backward<_AlgPolicy>(_Traits::__begin(__slast), _Traits::__end(__slast), std::move(__result))
              .second;
      --__slast;
    }
    __result = std::__move_backward<_AlgPolicy>(_Traits::__local(__first), _Traits::__end(__slast), std::move(__result))
                   .second;
    return std::make_pair(__last, std::move(__result));
  }

  template <class _InIter,
            class _OutIter,
            __enable_if_t<__has_random_access_iterator_category<_InIter>::value &&
                              !__is_segmented_iterator<_InIter>::value && __is_segmented_iterator<_OutIter>::value,
                          int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr pair<_InIter, _OutIter>
  operator()(_InIter __first, _InIter __last, _OutIter __result) const {
    using _Traits = __segmented_iterator_traits<_OutIter>;
    using _DiffT = typename common_type<__iter_diff_t<_InIter>, __iter_diff_t<_OutIter> >::type;


    if (__first == __last)
      return std::make_pair(__first, __result);

    auto __orig_last = __last;

    auto __local_last = _Traits::__local(__result);
    auto __segment_iterator = _Traits::__segment(__result);
    while (true) {
      auto __local_first = _Traits::__begin(__segment_iterator);
      auto __size = std::min<_DiffT>(__local_last - __local_first, __last - __first);
      auto __iter = std::__move_backward<_AlgPolicy>(__last - __size, __last, __local_last).second;
      __last -= __size;

      if (__first == __last)
        return std::make_pair(std::move(__orig_last), _Traits::__compose(__segment_iterator, std::move(__iter)));

      __local_last = _Traits::__end(--__segment_iterator);
    }
  }
};

struct __move_backward_trivial {

  template <class _In, class _Out,
            __enable_if_t<__can_lower_move_assignment_to_memmove<_In, _Out>::value, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr pair<_In*, _Out*>
  operator()(_In* __first, _In* __last, _Out* __result) const {
    return std::__copy_backward_trivial_impl(__first, __last, __result);
  }
};

template <class _AlgPolicy, class _BidirectionalIterator1, class _Sentinel, class _BidirectionalIterator2>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr pair<_BidirectionalIterator1, _BidirectionalIterator2>
__move_backward(_BidirectionalIterator1 __first, _Sentinel __last, _BidirectionalIterator2 __result) {
  static_assert(std::is_copy_constructible<_BidirectionalIterator1>::value &&
                std::is_copy_constructible<_BidirectionalIterator1>::value, "Iterators must be copy constructible.");

  return std::__dispatch_copy_or_move<_AlgPolicy, __move_backward_loop<_AlgPolicy>, __move_backward_trivial>(
      std::move(__first), std::move(__last), std::move(__result));
}

template <class _BidirectionalIterator1, class _BidirectionalIterator2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr _BidirectionalIterator2
move_backward(_BidirectionalIterator1 __first, _BidirectionalIterator1 __last, _BidirectionalIterator2 __result) {
  return std::__move_backward<_ClassicAlgPolicy>(std::move(__first), std::move(__last), std::move(__result)).second;
}

}}
# 15 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/rotate.h" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/swap_ranges.h" 1 3
# 19 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/swap_ranges.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {


template <class _AlgPolicy, class _ForwardIterator1, class _Sentinel1, class _ForwardIterator2, class _Sentinel2>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
pair<_ForwardIterator1, _ForwardIterator2>
__swap_ranges(_ForwardIterator1 __first1, _Sentinel1 __last1, _ForwardIterator2 __first2, _Sentinel2 __last2) {
  while (__first1 != __last1 && __first2 != __last2) {
    _IterOps<_AlgPolicy>::iter_swap(__first1, __first2);
    ++__first1;
    ++__first2;
  }

  return pair<_ForwardIterator1, _ForwardIterator2>(std::move(__first1), std::move(__first2));
}


template <class _AlgPolicy, class _ForwardIterator1, class _Sentinel1, class _ForwardIterator2>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
pair<_ForwardIterator1, _ForwardIterator2>
__swap_ranges(_ForwardIterator1 __first1, _Sentinel1 __last1, _ForwardIterator2 __first2) {
  while (__first1 != __last1) {
    _IterOps<_AlgPolicy>::iter_swap(__first1, __first2);
    ++__first1;
    ++__first2;
  }

  return pair<_ForwardIterator1, _ForwardIterator2>(std::move(__first1), std::move(__first2));
}

template <class _ForwardIterator1, class _ForwardIterator2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr _ForwardIterator2
swap_ranges(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2) {
  return std::__swap_ranges<_ClassicAlgPolicy>(
      std::move(__first1), std::move(__last1), std::move(__first2)).second;
}

}}
# 16 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/rotate.h" 2 3


# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_trivially_move_assignable.h" 1 3
# 19 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_trivially_move_assignable.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Tp>
struct is_trivially_move_assignable
    : public integral_constant<
          bool,
          __is_trivially_assignable(__add_lvalue_reference_t<_Tp>, __add_rvalue_reference_t<_Tp>)> {};


template <class _Tp>
inline constexpr bool is_trivially_move_assignable_v = is_trivially_move_assignable<_Tp>::value;


}}
# 19 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/rotate.h" 2 3
# 24 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/rotate.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _AlgPolicy, class _ForwardIterator>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr _ForwardIterator
__rotate_left(_ForwardIterator __first, _ForwardIterator __last)
{
    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;
    using _Ops = _IterOps<_AlgPolicy>;

    value_type __tmp = _Ops::__iter_move(__first);
    _ForwardIterator __lm1 = std::__move<_AlgPolicy>(
        _Ops::next(__first), __last, __first).second;
    *__lm1 = std::move(__tmp);
    return __lm1;
}

template <class _AlgPolicy, class _BidirectionalIterator>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr _BidirectionalIterator
__rotate_right(_BidirectionalIterator __first, _BidirectionalIterator __last)
{
    typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;
    using _Ops = _IterOps<_AlgPolicy>;

    _BidirectionalIterator __lm1 = _Ops::prev(__last);
    value_type __tmp = _Ops::__iter_move(__lm1);
    _BidirectionalIterator __fp1 = std::__move_backward<_AlgPolicy>(__first, __lm1, std::move(__last)).second;
    *__first = std::move(__tmp);
    return __fp1;
}

template <class _AlgPolicy, class _ForwardIterator>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr _ForwardIterator
__rotate_forward(_ForwardIterator __first, _ForwardIterator __middle, _ForwardIterator __last)
{
    _ForwardIterator __i = __middle;
    while (true)
    {
        _IterOps<_AlgPolicy>::iter_swap(__first, __i);
        ++__first;
        if (++__i == __last)
            break;
        if (__first == __middle)
            __middle = __i;
    }
    _ForwardIterator __r = __first;
    if (__first != __middle)
    {
        __i = __middle;
        while (true)
        {
            _IterOps<_AlgPolicy>::iter_swap(__first, __i);
            ++__first;
            if (++__i == __last)
            {
                if (__first == __middle)
                    break;
                __i = __middle;
            }
            else if (__first == __middle)
                __middle = __i;
        }
    }
    return __r;
}

template<typename _Integral>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
constexpr _Integral
__algo_gcd(_Integral __x, _Integral __y)
{
    do
    {
        _Integral __t = __x % __y;
        __x = __y;
        __y = __t;
    } while (__y);
    return __x;
}

template <class _AlgPolicy, typename _RandomAccessIterator>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr _RandomAccessIterator
__rotate_gcd(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last)
{
    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;
    using _Ops = _IterOps<_AlgPolicy>;

    const difference_type __m1 = __middle - __first;
    const difference_type __m2 = _Ops::distance(__middle, __last);
    if (__m1 == __m2)
    {
        std::__swap_ranges<_AlgPolicy>(__first, __middle, __middle, __last);
        return __middle;
    }
    const difference_type __g = std::__algo_gcd(__m1, __m2);
    for (_RandomAccessIterator __p = __first + __g; __p != __first;)
    {
        value_type __t(_Ops::__iter_move(--__p));
        _RandomAccessIterator __p1 = __p;
        _RandomAccessIterator __p2 = __p1 + __m1;
        do
        {
            *__p1 = _Ops::__iter_move(__p2);
            __p1 = __p2;
            const difference_type __d = _Ops::distance(__p2, __last);
            if (__m1 < __d)
                __p2 += __m1;
            else
                __p2 = __first + (__m1 - __d);
        } while (__p2 != __p);
        *__p1 = std::move(__t);
    }
    return __first + __m2;
}

template <class _AlgPolicy, class _ForwardIterator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
constexpr _ForwardIterator
__rotate_impl(_ForwardIterator __first, _ForwardIterator __middle, _ForwardIterator __last,
         std::forward_iterator_tag)
{
    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;
    if (is_trivially_move_assignable<value_type>::value)
    {
        if (_IterOps<_AlgPolicy>::next(__first) == __middle)
            return std::__rotate_left<_AlgPolicy>(__first, __last);
    }
    return std::__rotate_forward<_AlgPolicy>(__first, __middle, __last);
}

template <class _AlgPolicy, class _BidirectionalIterator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
constexpr _BidirectionalIterator
__rotate_impl(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last,
         bidirectional_iterator_tag)
{
    typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;
    if (is_trivially_move_assignable<value_type>::value)
    {
        if (_IterOps<_AlgPolicy>::next(__first) == __middle)
            return std::__rotate_left<_AlgPolicy>(__first, __last);
        if (_IterOps<_AlgPolicy>::next(__middle) == __last)
            return std::__rotate_right<_AlgPolicy>(__first, __last);
    }
    return std::__rotate_forward<_AlgPolicy>(__first, __middle, __last);
}

template <class _AlgPolicy, class _RandomAccessIterator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
constexpr _RandomAccessIterator
__rotate_impl(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last,
         random_access_iterator_tag)
{
    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;
    if (is_trivially_move_assignable<value_type>::value)
    {
        if (_IterOps<_AlgPolicy>::next(__first) == __middle)
            return std::__rotate_left<_AlgPolicy>(__first, __last);
        if (_IterOps<_AlgPolicy>::next(__middle) == __last)
            return std::__rotate_right<_AlgPolicy>(__first, __last);
        return std::__rotate_gcd<_AlgPolicy>(__first, __middle, __last);
    }
    return std::__rotate_forward<_AlgPolicy>(__first, __middle, __last);
}

template <class _AlgPolicy, class _Iterator, class _Sentinel>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
pair<_Iterator, _Iterator>
__rotate(_Iterator __first, _Iterator __middle, _Sentinel __last) {
  using _Ret = pair<_Iterator, _Iterator>;
  _Iterator __last_iter = _IterOps<_AlgPolicy>::next(__middle, __last);

  if (__first == __middle)
      return _Ret(__last_iter, __last_iter);
  if (__middle == __last)
      return _Ret(std::move(__first), std::move(__last_iter));

  using _IterCategory = typename _IterOps<_AlgPolicy>::template __iterator_category<_Iterator>;
  auto __result = std::__rotate_impl<_AlgPolicy>(
      std::move(__first), std::move(__middle), __last_iter, _IterCategory());

  return _Ret(std::move(__result), std::move(__last_iter));
}

template <class _ForwardIterator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
constexpr _ForwardIterator
rotate(_ForwardIterator __first, _ForwardIterator __middle, _ForwardIterator __last)
{
  return std::__rotate<_ClassicAlgPolicy>(
      std::move(__first), std::move(__middle), std::move(__last)).first;
}

}}
# 19 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/inplace_merge.h" 2 3







# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__memory/destruct_n.h" 1 3
# 14 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__memory/destruct_n.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_trivially_destructible.h" 1 3
# 18 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_trivially_destructible.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {



template <class _Tp>
struct is_trivially_destructible
    : public integral_constant<bool, __is_trivially_destructible(_Tp)> {};
# 41 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_trivially_destructible.h" 3
template <class _Tp>
inline constexpr bool is_trivially_destructible_v = is_trivially_destructible<_Tp>::value;


}}
# 15 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__memory/destruct_n.h" 2 3
# 19 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__memory/destruct_n.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

struct __destruct_n
{
private:
    size_t __size_;

    template <class _Tp>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) void __process(_Tp* __p, false_type) noexcept
        {for (size_t __i = 0; __i < __size_; ++__i, ++__p) __p->~_Tp();}

    template <class _Tp>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) void __process(_Tp*, true_type) noexcept
        {}

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) void __incr(false_type) noexcept
        {++__size_;}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) void __incr(true_type) noexcept
        {}

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) void __set(size_t __s, false_type) noexcept
        {__size_ = __s;}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) void __set(size_t, true_type) noexcept
        {}
public:
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) explicit __destruct_n(size_t __s) noexcept
        : __size_(__s) {}

    template <class _Tp>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) void __incr() noexcept
        {__incr(integral_constant<bool, is_trivially_destructible<_Tp>::value>());}

    template <class _Tp>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) void __set(size_t __s, _Tp*) noexcept
        {__set(__s, integral_constant<bool, is_trivially_destructible<_Tp>::value>());}

    template <class _Tp>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) void operator()(_Tp* __p) noexcept
        {__process(__p, integral_constant<bool, is_trivially_destructible<_Tp>::value>());}
};

}}
# 27 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/inplace_merge.h" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__memory/temporary_buffer.h" 1 3
# 21 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__memory/temporary_buffer.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Tp>
[[__nodiscard__]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) __attribute__((__no_sanitize__("cfi"))) __attribute__((__deprecated__))
pair<_Tp*, ptrdiff_t>
get_temporary_buffer(ptrdiff_t __n) noexcept
{
    pair<_Tp*, ptrdiff_t> __r(0, 0);
    const ptrdiff_t __m = (~ptrdiff_t(0) ^
                           ptrdiff_t(ptrdiff_t(1) << (sizeof(ptrdiff_t) * 8 - 1)))
                           / sizeof(_Tp);
    if (__n > __m)
        __n = __m;
    while (__n > 0)
    {

    if (__is_overaligned_for_new(alignof(_Tp)))
        {
            align_val_t __al =
                align_val_t(alignment_of<_Tp>::value);
            __r.first = static_cast<_Tp*>(::operator new(
                __n * sizeof(_Tp), __al, nothrow));
        } else {
            __r.first = static_cast<_Tp*>(::operator new(
                __n * sizeof(_Tp), nothrow));
        }
# 60 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__memory/temporary_buffer.h" 3
        if (__r.first)
        {
            __r.second = __n;
            break;
        }
        __n /= 2;
    }
    return __r;
}

template <class _Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) __attribute__((__deprecated__))
void return_temporary_buffer(_Tp* __p) noexcept
{
  std::__libcpp_deallocate_unsized((void*)__p, alignof(_Tp));
}

struct __return_temporary_buffer
{
#pragma GCC diagnostic push
# 79 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__memory/temporary_buffer.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
# 79 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__memory/temporary_buffer.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
    template <class _Tp>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) void operator()(_Tp* __p) const {std::return_temporary_buffer(__p);}
#pragma GCC diagnostic pop
};

}}
# 28 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/inplace_merge.h" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__memory/unique_ptr.h" 1 3
# 13 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__memory/unique_ptr.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__compare/compare_three_way.h" 1 3
# 19 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__compare/compare_three_way.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {



struct compare_three_way
{
    template<class _T1, class _T2>
        requires three_way_comparable_with<_T1, _T2>
    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    auto operator()(_T1&& __t, _T2&& __u) const
        noexcept(noexcept(std::forward<_T1>(__t) <=> std::forward<_T2>(__u)))
        { return std::forward<_T1>(__t) <=> std::forward<_T2>(__u); }

    using is_transparent = void;
};



}}
# 14 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__memory/unique_ptr.h" 2 3



# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__functional/hash.h" 1 3
# 14 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__functional/hash.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__functional/unary_function.h" 1 3
# 16 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__functional/unary_function.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 31 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__functional/unary_function.h" 3
template <class _Arg, class _Result> struct __unary_function_keep_layout_base {




};
# 45 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__functional/unary_function.h" 3
template <class _Arg, class _Result>
using __unary_function = __unary_function_keep_layout_base<_Arg, _Result>;


}}
# 15 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__functional/hash.h" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__fwd/hash.h" 1 3
# 16 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__fwd/hash.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class>
struct hash;

}}
# 16 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__functional/hash.h" 2 3
# 28 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__functional/hash.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/cstring" 1 3
# 63 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/cstring" 3
# 1 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/llvm_libc_wrappers/string.h" 1 3
# 19 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/llvm_libc_wrappers/string.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/string.h" 1 3
# 58 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/string.h" 3



# 1 "/usr/include/string.h" 1 3 4
# 26 "/usr/include/string.h" 3 4
# 1 "/usr/include/bits/libc-header-start.h" 1 3 4
# 27 "/usr/include/string.h" 2 3 4

extern "C" {




# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/stddef.h" 1 3 4
# 15 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/stddef.h" 3


# 1 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/stddef.h" 1 3
# 59 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/stddef.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/__stddef_size_t.h" 1 3
# 15 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/__stddef_size_t.h" 3
typedef long unsigned int size_t;
# 60 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/stddef.h" 2 3
# 74 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/stddef.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/__stddef_null.h" 1 3
# 75 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/stddef.h" 2 3
# 18 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/stddef.h" 2 3
# 34 "/usr/include/string.h" 2 3 4
# 43 "/usr/include/string.h" 3 4
extern void *memcpy (void *__restrict __dest, const void *__restrict __src,
       size_t __n) throw () __attribute__ ((__nonnull__ (1, 2)));


extern void *memmove (void *__dest, const void *__src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));





extern void *memccpy (void *__restrict __dest, const void *__restrict __src,
        int __c, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern void *memset (void *__s, int __c, size_t __n) throw () __attribute__ ((__nonnull__ (1)));


extern int memcmp (const void *__s1, const void *__s2, size_t __n)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));



extern "C++"
{
extern void *memchr (void *__s, int __c, size_t __n)
      throw () __asm ("memchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern const void *memchr (const void *__s, int __c, size_t __n)
      throw () __asm ("memchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) void *
memchr (void *__s, int __c, size_t __n) throw ()
{
  return __builtin_memchr (__s, __c, __n);
}

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) const void *
memchr (const void *__s, int __c, size_t __n) throw ()
{
  return __builtin_memchr (__s, __c, __n);
}

}
# 99 "/usr/include/string.h" 3 4
extern "C++" void *rawmemchr (void *__s, int __c)
     throw () __asm ("rawmemchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern "C++" const void *rawmemchr (const void *__s, int __c)
     throw () __asm ("rawmemchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));







extern "C++" void *memrchr (void *__s, int __c, size_t __n)
      throw () __asm ("memrchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern "C++" const void *memrchr (const void *__s, int __c, size_t __n)
      throw () __asm ("memrchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 122 "/usr/include/string.h" 3 4
extern char *strcpy (char *__restrict __dest, const char *__restrict __src)
     throw () __attribute__ ((__nonnull__ (1, 2)));

extern char *strncpy (char *__restrict __dest,
        const char *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern char *strcat (char *__restrict __dest, const char *__restrict __src)
     throw () __attribute__ ((__nonnull__ (1, 2)));

extern char *strncat (char *__restrict __dest, const char *__restrict __src,
        size_t __n) throw () __attribute__ ((__nonnull__ (1, 2)));


extern int strcmp (const char *__s1, const char *__s2)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern int strncmp (const char *__s1, const char *__s2, size_t __n)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strcoll (const char *__s1, const char *__s2)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern size_t strxfrm (char *__restrict __dest,
         const char *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (2)));






extern int strcoll_l (const char *__s1, const char *__s2, locale_t __l)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));


extern size_t strxfrm_l (char *__dest, const char *__src, size_t __n,
    locale_t __l) throw () __attribute__ ((__nonnull__ (2, 4)));





extern char *strdup (const char *__s)
     throw () __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));






extern char *strndup (const char *__string, size_t __n)
     throw () __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));
# 204 "/usr/include/string.h" 3 4
extern "C++"
{
extern char *strchr (char *__s, int __c)
     throw () __asm ("strchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern const char *strchr (const char *__s, int __c)
     throw () __asm ("strchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) char *
strchr (char *__s, int __c) throw ()
{
  return __builtin_strchr (__s, __c);
}

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) const char *
strchr (const char *__s, int __c) throw ()
{
  return __builtin_strchr (__s, __c);
}

}






extern "C++"
{
extern char *strrchr (char *__s, int __c)
     throw () __asm ("strrchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern const char *strrchr (const char *__s, int __c)
     throw () __asm ("strrchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) char *
strrchr (char *__s, int __c) throw ()
{
  return __builtin_strrchr (__s, __c);
}

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) const char *
strrchr (const char *__s, int __c) throw ()
{
  return __builtin_strrchr (__s, __c);
}

}
# 261 "/usr/include/string.h" 3 4
extern "C++" char *strchrnul (char *__s, int __c)
     throw () __asm ("strchrnul") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern "C++" const char *strchrnul (const char *__s, int __c)
     throw () __asm ("strchrnul") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 273 "/usr/include/string.h" 3 4
extern size_t strcspn (const char *__s, const char *__reject)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern size_t strspn (const char *__s, const char *__accept)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern "C++"
{
extern char *strpbrk (char *__s, const char *__accept)
     throw () __asm ("strpbrk") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
extern const char *strpbrk (const char *__s, const char *__accept)
     throw () __asm ("strpbrk") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) char *
strpbrk (char *__s, const char *__accept) throw ()
{
  return __builtin_strpbrk (__s, __accept);
}

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) const char *
strpbrk (const char *__s, const char *__accept) throw ()
{
  return __builtin_strpbrk (__s, __accept);
}

}






extern "C++"
{
extern char *strstr (char *__haystack, const char *__needle)
     throw () __asm ("strstr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
extern const char *strstr (const char *__haystack, const char *__needle)
     throw () __asm ("strstr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) char *
strstr (char *__haystack, const char *__needle) throw ()
{
  return __builtin_strstr (__haystack, __needle);
}

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) const char *
strstr (const char *__haystack, const char *__needle) throw ()
{
  return __builtin_strstr (__haystack, __needle);
}

}







extern char *strtok (char *__restrict __s, const char *__restrict __delim)
     throw () __attribute__ ((__nonnull__ (2)));



extern char *__strtok_r (char *__restrict __s,
    const char *__restrict __delim,
    char **__restrict __save_ptr)
     throw () __attribute__ ((__nonnull__ (2, 3)));

extern char *strtok_r (char *__restrict __s, const char *__restrict __delim,
         char **__restrict __save_ptr)
     throw () __attribute__ ((__nonnull__ (2, 3)));





extern "C++" char *strcasestr (char *__haystack, const char *__needle)
     throw () __asm ("strcasestr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
extern "C++" const char *strcasestr (const char *__haystack,
         const char *__needle)
     throw () __asm ("strcasestr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 369 "/usr/include/string.h" 3 4
extern void *memmem (const void *__haystack, size_t __haystacklen,
       const void *__needle, size_t __needlelen)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 3)));



extern void *__mempcpy (void *__restrict __dest,
   const void *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern void *mempcpy (void *__restrict __dest,
        const void *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern size_t strlen (const char *__s)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));




extern size_t strnlen (const char *__string, size_t __maxlen)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));




extern char *strerror (int __errnum) throw ();
# 421 "/usr/include/string.h" 3 4
extern char *strerror_r (int __errnum, char *__buf, size_t __buflen)
     throw () __attribute__ ((__nonnull__ (2))) ;





extern char *strerror_l (int __errnum, locale_t __l) throw ();



# 1 "/usr/include/strings.h" 1 3 4
# 23 "/usr/include/strings.h" 3 4
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/stddef.h" 1 3 4
# 15 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/stddef.h" 3


# 1 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/stddef.h" 1 3
# 59 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/stddef.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/__stddef_size_t.h" 1 3
# 15 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/__stddef_size_t.h" 3
typedef long unsigned int size_t;
# 60 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/stddef.h" 2 3
# 18 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/stddef.h" 2 3
# 24 "/usr/include/strings.h" 2 3 4






extern "C" {



extern int bcmp (const void *__s1, const void *__s2, size_t __n)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern void bcopy (const void *__src, void *__dest, size_t __n)
  throw () __attribute__ ((__nonnull__ (1, 2)));


extern void bzero (void *__s, size_t __n) throw () __attribute__ ((__nonnull__ (1)));
# 68 "/usr/include/strings.h" 3 4
extern char *index (const char *__s, int __c)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 96 "/usr/include/strings.h" 3 4
extern char *rindex (const char *__s, int __c)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));






extern int ffs (int __i) throw () __attribute__ ((__const__));





extern int ffsl (long int __l) throw () __attribute__ ((__const__));
__extension__ extern int ffsll (long long int __ll)
     throw () __attribute__ ((__const__));



extern int strcasecmp (const char *__s1, const char *__s2)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strncasecmp (const char *__s1, const char *__s2, size_t __n)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));






extern int strcasecmp_l (const char *__s1, const char *__s2, locale_t __loc)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));



extern int strncasecmp_l (const char *__s1, const char *__s2,
     size_t __n, locale_t __loc)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 4)));


}
# 433 "/usr/include/string.h" 2 3 4



extern void explicit_bzero (void *__s, size_t __n) throw () __attribute__ ((__nonnull__ (1)));



extern char *strsep (char **__restrict __stringp,
       const char *__restrict __delim)
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern char *strsignal (int __sig) throw ();


extern char *__stpcpy (char *__restrict __dest, const char *__restrict __src)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern char *stpcpy (char *__restrict __dest, const char *__restrict __src)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern char *__stpncpy (char *__restrict __dest,
   const char *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern char *stpncpy (char *__restrict __dest,
        const char *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern int strverscmp (const char *__s1, const char *__s2)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern char *strfry (char *__string) throw () __attribute__ ((__nonnull__ (1)));


extern void *memfrob (void *__s, size_t __n) throw () __attribute__ ((__nonnull__ (1)));







extern "C++" char *basename (char *__filename)
     throw () __asm ("basename") __attribute__ ((__nonnull__ (1)));
extern "C++" const char *basename (const char *__filename)
     throw () __asm ("basename") __attribute__ ((__nonnull__ (1)));
# 499 "/usr/include/string.h" 3 4
}
# 62 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/string.h" 2 3
# 20 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/llvm_libc_wrappers/string.h" 2 3
# 64 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/cstring" 2 3
# 75 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/cstring" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

using ::size_t __attribute__((__using_if_exists__));
using ::memcpy __attribute__((__using_if_exists__));
using ::memmove __attribute__((__using_if_exists__));
using ::strcpy __attribute__((__using_if_exists__));
using ::strncpy __attribute__((__using_if_exists__));
using ::strcat __attribute__((__using_if_exists__));
using ::strncat __attribute__((__using_if_exists__));
using ::memcmp __attribute__((__using_if_exists__));
using ::strcmp __attribute__((__using_if_exists__));
using ::strncmp __attribute__((__using_if_exists__));
using ::strcoll __attribute__((__using_if_exists__));
using ::strxfrm __attribute__((__using_if_exists__));
using ::memchr __attribute__((__using_if_exists__));
using ::strchr __attribute__((__using_if_exists__));
using ::strcspn __attribute__((__using_if_exists__));
using ::strpbrk __attribute__((__using_if_exists__));
using ::strrchr __attribute__((__using_if_exists__));
using ::strspn __attribute__((__using_if_exists__));
using ::strstr __attribute__((__using_if_exists__));
using ::strtok __attribute__((__using_if_exists__));
using ::memset __attribute__((__using_if_exists__));
using ::strerror __attribute__((__using_if_exists__));
using ::strlen __attribute__((__using_if_exists__));

}}
# 29 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__functional/hash.h" 2 3
# 33 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__functional/hash.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Size>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
_Size
__loadword(const void* __p)
{
    _Size __r;
    std::memcpy(&__r, __p, sizeof(__r));
    return __r;
}




template <class _Size, size_t = sizeof(_Size)*8>
struct __murmur2_or_cityhash;

template <class _Size>
struct __murmur2_or_cityhash<_Size, 32>
{
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) __attribute__((__no_sanitize__("unsigned-integer-overflow")))
    _Size operator()(const void* __key, _Size __len) const {

      const _Size __m = 0x5bd1e995;
      const _Size __r = 24;
      _Size __h = __len;
      const unsigned char* __data = static_cast<const unsigned char*>(__key);
      for (; __len >= 4; __data += 4, __len -= 4)
      {
          _Size __k = std::__loadword<_Size>(__data);
          __k *= __m;
          __k ^= __k >> __r;
          __k *= __m;
          __h *= __m;
          __h ^= __k;
      }
      switch (__len)
      {
      case 3:
          __h ^= static_cast<_Size>(__data[2] << 16);
          [[fallthrough]];
      case 2:
          __h ^= static_cast<_Size>(__data[1] << 8);
          [[fallthrough]];
      case 1:
          __h ^= __data[0];
          __h *= __m;
      }
      __h ^= __h >> 13;
      __h *= __m;
      __h ^= __h >> 15;
      return __h;
    }
};

template <class _Size>
struct __murmur2_or_cityhash<_Size, 64>
{

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) __attribute__((__no_sanitize__("unsigned-integer-overflow")))
  _Size operator()(const void* __key, _Size __len) const {
    const char* __s = static_cast<const char*>(__key);
    if (__len <= 32) {
        if (__len <= 16) {
        return __hash_len_0_to_16(__s, __len);
        } else {
        return __hash_len_17_to_32(__s, __len);
        }
    } else if (__len <= 64) {
        return __hash_len_33_to_64(__s, __len);
    }



    _Size __x = std::__loadword<_Size>(__s + __len - 40);
    _Size __y = std::__loadword<_Size>(__s + __len - 16) +
                std::__loadword<_Size>(__s + __len - 56);
    _Size __z = __hash_len_16(std::__loadword<_Size>(__s + __len - 48) + __len,
                            std::__loadword<_Size>(__s + __len - 24));
    pair<_Size, _Size> __v = __weak_hash_len_32_with_seeds(__s + __len - 64, __len, __z);
    pair<_Size, _Size> __w = __weak_hash_len_32_with_seeds(__s + __len - 32, __y + __k1, __x);
    __x = __x * __k1 + std::__loadword<_Size>(__s);


    __len = (__len - 1) & ~static_cast<_Size>(63);
    do {
        __x = __rotate(__x + __y + __v.first + std::__loadword<_Size>(__s + 8), 37) * __k1;
        __y = __rotate(__y + __v.second + std::__loadword<_Size>(__s + 48), 42) * __k1;
        __x ^= __w.second;
        __y += __v.first + std::__loadword<_Size>(__s + 40);
        __z = __rotate(__z + __w.first, 33) * __k1;
        __v = __weak_hash_len_32_with_seeds(__s, __v.second * __k1, __x + __w.first);
        __w = __weak_hash_len_32_with_seeds(__s + 32, __z + __w.second,
                                            __y + std::__loadword<_Size>(__s + 16));
        std::swap(__z, __x);
        __s += 64;
        __len -= 64;
    } while (__len != 0);
    return __hash_len_16(
        __hash_len_16(__v.first, __w.first) + __shift_mix(__y) * __k1 + __z,
        __hash_len_16(__v.second, __w.second) + __x);
  }

  private:

    static const _Size __k0 = 0xc3a5c85c97cb3127ULL;
    static const _Size __k1 = 0xb492b66fbe98f273ULL;
    static const _Size __k2 = 0x9ae16a3b2f90404fULL;
    static const _Size __k3 = 0xc949d7c7509e6557ULL;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
  static _Size __rotate(_Size __val, int __shift) {
    return __shift == 0 ? __val : ((__val >> __shift) | (__val << (64 - __shift)));
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
  static _Size __rotate_by_at_least_1(_Size __val, int __shift) {
    return (__val >> __shift) | (__val << (64 - __shift));
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
  static _Size __shift_mix(_Size __val) {
    return __val ^ (__val >> 47);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) __attribute__((__no_sanitize__("unsigned-integer-overflow")))
  static _Size __hash_len_16(_Size __u, _Size __v) {
    const _Size __mul = 0x9ddfea08eb382d69ULL;
    _Size __a = (__u ^ __v) * __mul;
    __a ^= (__a >> 47);
    _Size __b = (__v ^ __a) * __mul;
    __b ^= (__b >> 47);
    __b *= __mul;
    return __b;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) __attribute__((__no_sanitize__("unsigned-integer-overflow")))
  static _Size __hash_len_0_to_16(const char* __s, _Size __len) {
    if (__len > 8) {
      const _Size __a = std::__loadword<_Size>(__s);
      const _Size __b = std::__loadword<_Size>(__s + __len - 8);
      return __hash_len_16(__a, __rotate_by_at_least_1(__b + __len, __len)) ^ __b;
    }
    if (__len >= 4) {
      const uint32_t __a = std::__loadword<uint32_t>(__s);
      const uint32_t __b = std::__loadword<uint32_t>(__s + __len - 4);



      return __hash_len_16(__len + (__a << 3), __b);

    }
    if (__len > 0) {
      const unsigned char __a = static_cast<unsigned char>(__s[0]);
      const unsigned char __b = static_cast<unsigned char>(__s[__len >> 1]);
      const unsigned char __c = static_cast<unsigned char>(__s[__len - 1]);
      const uint32_t __y = static_cast<uint32_t>(__a) +
                           (static_cast<uint32_t>(__b) << 8);
      const uint32_t __z = __len + (static_cast<uint32_t>(__c) << 2);
      return __shift_mix(__y * __k2 ^ __z * __k3) * __k2;
    }
    return __k2;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) __attribute__((__no_sanitize__("unsigned-integer-overflow")))
  static _Size __hash_len_17_to_32(const char *__s, _Size __len) {
    const _Size __a = std::__loadword<_Size>(__s) * __k1;
    const _Size __b = std::__loadword<_Size>(__s + 8);
    const _Size __c = std::__loadword<_Size>(__s + __len - 8) * __k2;
    const _Size __d = std::__loadword<_Size>(__s + __len - 16) * __k0;
    return __hash_len_16(__rotate(__a - __b, 43) + __rotate(__c, 30) + __d,
                         __a + __rotate(__b ^ __k3, 20) - __c + __len);
  }



  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) __attribute__((__no_sanitize__("unsigned-integer-overflow")))
  static pair<_Size, _Size> __weak_hash_len_32_with_seeds(
      _Size __w, _Size __x, _Size __y, _Size __z, _Size __a, _Size __b)
  {
    __a += __w;
    __b = __rotate(__b + __a + __z, 21);
    const _Size __c = __a;
    __a += __x;
    __a += __y;
    __b += __rotate(__a, 44);
    return pair<_Size, _Size>(__a + __z, __b + __c);
  }


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) __attribute__((__no_sanitize__("unsigned-integer-overflow")))
  static pair<_Size, _Size> __weak_hash_len_32_with_seeds(
      const char* __s, _Size __a, _Size __b)
  {
    return __weak_hash_len_32_with_seeds(std::__loadword<_Size>(__s),
                                         std::__loadword<_Size>(__s + 8),
                                         std::__loadword<_Size>(__s + 16),
                                         std::__loadword<_Size>(__s + 24),
                                         __a,
                                         __b);
  }


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) __attribute__((__no_sanitize__("unsigned-integer-overflow")))
  static _Size __hash_len_33_to_64(const char *__s, size_t __len) {
    _Size __z = std::__loadword<_Size>(__s + 24);
    _Size __a = std::__loadword<_Size>(__s) +
                (__len + std::__loadword<_Size>(__s + __len - 16)) * __k0;
    _Size __b = __rotate(__a + __z, 52);
    _Size __c = __rotate(__a, 37);
    __a += std::__loadword<_Size>(__s + 8);
    __c += __rotate(__a, 7);
    __a += std::__loadword<_Size>(__s + 16);
    _Size __vf = __a + __z;
    _Size __vs = __b + __rotate(__a, 31) + __c;
    __a = std::__loadword<_Size>(__s + 16) + std::__loadword<_Size>(__s + __len - 32);
    __z += std::__loadword<_Size>(__s + __len - 8);
    __b = __rotate(__a + __z, 52);
    __c = __rotate(__a, 37);
    __a += std::__loadword<_Size>(__s + __len - 24);
    __c += __rotate(__a, 7);
    __a += std::__loadword<_Size>(__s + __len - 16);
    _Size __wf = __a + __z;
    _Size __ws = __b + __rotate(__a, 31) + __c;
    _Size __r = __shift_mix((__vf + __ws) * __k2 + (__wf + __vs) * __k0);
    return __shift_mix(__r * __k0 + __vs) * __k2;
  }
};

template <class _Tp, size_t = sizeof(_Tp) / sizeof(size_t)>
struct __scalar_hash;

template <class _Tp>
struct __scalar_hash<_Tp, 0>
    : public __unary_function<_Tp, size_t>
{
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    size_t operator()(_Tp __v) const noexcept
    {
        union
        {
            _Tp __t;
            size_t __a;
        } __u;
        __u.__a = 0;
        __u.__t = __v;
        return __u.__a;
    }
};

template <class _Tp>
struct __scalar_hash<_Tp, 1>
    : public __unary_function<_Tp, size_t>
{
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    size_t operator()(_Tp __v) const noexcept
    {
        union
        {
            _Tp __t;
            size_t __a;
        } __u;
        __u.__t = __v;
        return __u.__a;
    }
};

template <class _Tp>
struct __scalar_hash<_Tp, 2>
    : public __unary_function<_Tp, size_t>
{
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    size_t operator()(_Tp __v) const noexcept
    {
        union
        {
            _Tp __t;
            struct
            {
                size_t __a;
                size_t __b;
            } __s;
        } __u;
        __u.__t = __v;
        return __murmur2_or_cityhash<size_t>()(&__u, sizeof(__u));
    }
};

template <class _Tp>
struct __scalar_hash<_Tp, 3>
    : public __unary_function<_Tp, size_t>
{
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    size_t operator()(_Tp __v) const noexcept
    {
        union
        {
            _Tp __t;
            struct
            {
                size_t __a;
                size_t __b;
                size_t __c;
            } __s;
        } __u;
        __u.__t = __v;
        return __murmur2_or_cityhash<size_t>()(&__u, sizeof(__u));
    }
};

template <class _Tp>
struct __scalar_hash<_Tp, 4>
    : public __unary_function<_Tp, size_t>
{
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    size_t operator()(_Tp __v) const noexcept
    {
        union
        {
            _Tp __t;
            struct
            {
                size_t __a;
                size_t __b;
                size_t __c;
                size_t __d;
            } __s;
        } __u;
        __u.__t = __v;
        return __murmur2_or_cityhash<size_t>()(&__u, sizeof(__u));
    }
};

struct _PairT {
  size_t first;
  size_t second;
};

__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
inline size_t __hash_combine(size_t __lhs, size_t __rhs) noexcept {
    typedef __scalar_hash<_PairT> _HashT;
    const _PairT __p = {__lhs, __rhs};
    return _HashT()(__p);
}

template<class _Tp>
struct hash<_Tp*>
    : public __unary_function<_Tp*, size_t>
{
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    size_t operator()(_Tp* __v) const noexcept
    {
        union
        {
            _Tp* __t;
            size_t __a;
        } __u;
        __u.__t = __v;
        return __murmur2_or_cityhash<size_t>()(&__u, sizeof(__u));
    }
};

template <>
struct hash<bool>
    : public __unary_function<bool, size_t>
{
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    size_t operator()(bool __v) const noexcept {return static_cast<size_t>(__v);}
};

template <>
struct hash<char>
    : public __unary_function<char, size_t>
{
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    size_t operator()(char __v) const noexcept {return static_cast<size_t>(__v);}
};

template <>
struct hash<signed char>
    : public __unary_function<signed char, size_t>
{
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    size_t operator()(signed char __v) const noexcept {return static_cast<size_t>(__v);}
};

template <>
struct hash<unsigned char>
    : public __unary_function<unsigned char, size_t>
{
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    size_t operator()(unsigned char __v) const noexcept {return static_cast<size_t>(__v);}
};


template <>
struct hash<char8_t>
    : public __unary_function<char8_t, size_t>
{
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    size_t operator()(char8_t __v) const noexcept {return static_cast<size_t>(__v);}
};


template <>
struct hash<char16_t>
    : public __unary_function<char16_t, size_t>
{
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    size_t operator()(char16_t __v) const noexcept {return static_cast<size_t>(__v);}
};

template <>
struct hash<char32_t>
    : public __unary_function<char32_t, size_t>
{
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    size_t operator()(char32_t __v) const noexcept {return static_cast<size_t>(__v);}
};


template <>
struct hash<wchar_t>
    : public __unary_function<wchar_t, size_t>
{
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    size_t operator()(wchar_t __v) const noexcept {return static_cast<size_t>(__v);}
};


template <>
struct hash<short>
    : public __unary_function<short, size_t>
{
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    size_t operator()(short __v) const noexcept {return static_cast<size_t>(__v);}
};

template <>
struct hash<unsigned short>
    : public __unary_function<unsigned short, size_t>
{
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    size_t operator()(unsigned short __v) const noexcept {return static_cast<size_t>(__v);}
};

template <>
struct hash<int>
    : public __unary_function<int, size_t>
{
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    size_t operator()(int __v) const noexcept {return static_cast<size_t>(__v);}
};

template <>
struct hash<unsigned int>
    : public __unary_function<unsigned int, size_t>
{
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    size_t operator()(unsigned int __v) const noexcept {return static_cast<size_t>(__v);}
};

template <>
struct hash<long>
    : public __unary_function<long, size_t>
{
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    size_t operator()(long __v) const noexcept {return static_cast<size_t>(__v);}
};

template <>
struct hash<unsigned long>
    : public __unary_function<unsigned long, size_t>
{
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    size_t operator()(unsigned long __v) const noexcept {return static_cast<size_t>(__v);}
};

template <>
struct hash<long long>
    : public __scalar_hash<long long>
{
};

template <>
struct hash<unsigned long long>
    : public __scalar_hash<unsigned long long>
{
};



template <>
struct hash<__int128_t>
    : public __scalar_hash<__int128_t>
{
};

template <>
struct hash<__uint128_t>
    : public __scalar_hash<__uint128_t>
{
};



template <>
struct hash<float>
    : public __scalar_hash<float>
{
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    size_t operator()(float __v) const noexcept
    {

       if (__v == 0.0f)
           return 0;
        return __scalar_hash<float>::operator()(__v);
    }
};

template <>
struct hash<double>
    : public __scalar_hash<double>
{
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    size_t operator()(double __v) const noexcept
    {

       if (__v == 0.0)
           return 0;
        return __scalar_hash<double>::operator()(__v);
    }
};

template <>
struct hash<long double>
    : public __scalar_hash<long double>
{
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    size_t operator()(long double __v) const noexcept
    {

        if (__v == 0.0L)
            return 0;
# 601 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__functional/hash.h" 3
        union
        {
            long double __t;
            struct
            {
                size_t __a;
                size_t __b;
            } __s;
        } __u;
        __u.__s.__a = 0;
        __u.__s.__b = 0;
        __u.__t = __v;
        return __u.__s.__a ^ __u.__s.__b;



    }
};

template <class _Tp, bool = is_enum<_Tp>::value>
struct __enum_hash
    : public __unary_function<_Tp, size_t>
{
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    size_t operator()(_Tp __v) const noexcept
    {
        typedef typename underlying_type<_Tp>::type type;
        return hash<type>()(static_cast<type>(__v));
    }
};
template <class _Tp>
struct __enum_hash<_Tp, false> {
    __enum_hash() = delete;
    __enum_hash(__enum_hash const&) = delete;
    __enum_hash& operator=(__enum_hash const&) = delete;
};

template <class _Tp>
struct hash : public __enum_hash<_Tp>
{
};



template <>
struct hash<nullptr_t>
  : public __unary_function<nullptr_t, size_t>
{
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    size_t operator()(nullptr_t) const noexcept {
        return 662607004ull;
    }
};



template <class _Key, class _Hash>
using __check_hash_requirements __attribute__((__nodebug__)) = integral_constant<bool,
    is_copy_constructible<_Hash>::value &&
    is_move_constructible<_Hash>::value &&
    __invokable_r<size_t, _Hash, _Key const&>::value
>;

template <class _Key, class _Hash = hash<_Key> >
using __has_enabled_hash __attribute__((__nodebug__)) = integral_constant<bool,
    __check_hash_requirements<_Key, _Hash>::value &&
    is_default_constructible<_Hash>::value
>;


template <class _Type, class>
using __enable_hash_helper_imp __attribute__((__nodebug__)) = _Type;

template <class _Type, class ..._Keys>
using __enable_hash_helper __attribute__((__nodebug__)) = __enable_hash_helper_imp<_Type,
  __enable_if_t<__all<__has_enabled_hash<_Keys>::value...>::value>
>;







}}
# 18 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__memory/unique_ptr.h" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__functional/operations.h" 1 3
# 14 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__functional/operations.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__functional/binary_function.h" 1 3
# 17 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__functional/binary_function.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 33 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__functional/binary_function.h" 3
template <class _Arg1, class _Arg2, class _Result> struct __binary_function_keep_layout_base {





};
# 48 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__functional/binary_function.h" 3
template <class _Arg1, class _Arg2, class _Result>
using __binary_function = __binary_function_keep_layout_base<_Arg1, _Arg2, _Result>;


}}
# 15 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__functional/operations.h" 2 3


# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/operation_traits.h" 1 3
# 17 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/operation_traits.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Pred, class _Lhs, class _Rhs>
struct __is_trivial_plus_operation : false_type {};

}}
# 18 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__functional/operations.h" 2 3
# 23 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__functional/operations.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {




template <class _Tp = void>



struct plus
    : __binary_function<_Tp, _Tp, _Tp>
{
    typedef _Tp __result_type;
    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    _Tp operator()(const _Tp& __x, const _Tp& __y) const
        {return __x + __y;}
};
template <class... _Tag> [[maybe_unused]] plus(typename _Tag::__allow_ctad...)->plus<_Tag...>;

template <class _Tp>
struct __is_trivial_plus_operation<plus<_Tp>, _Tp, _Tp> : true_type {};


template <class _Tp, class _Up>
struct __is_trivial_plus_operation<plus<>, _Tp, _Up> : true_type {};



template <>
struct plus<void>
{
    template <class _T1, class _T2>
    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    auto operator()(_T1&& __t, _T2&& __u) const
        noexcept(noexcept(std::forward<_T1>(__t) + std::forward<_T2>(__u)))
        -> decltype( std::forward<_T1>(__t) + std::forward<_T2>(__u))
        { return std::forward<_T1>(__t) + std::forward<_T2>(__u); }
    typedef void is_transparent;
};



template <class _Tp = void>



struct minus
    : __binary_function<_Tp, _Tp, _Tp>
{
    typedef _Tp __result_type;
    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    _Tp operator()(const _Tp& __x, const _Tp& __y) const
        {return __x - __y;}
};
template <class... _Tag> [[maybe_unused]] minus(typename _Tag::__allow_ctad...)->minus<_Tag...>;


template <>
struct minus<void>
{
    template <class _T1, class _T2>
    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    auto operator()(_T1&& __t, _T2&& __u) const
        noexcept(noexcept(std::forward<_T1>(__t) - std::forward<_T2>(__u)))
        -> decltype( std::forward<_T1>(__t) - std::forward<_T2>(__u))
        { return std::forward<_T1>(__t) - std::forward<_T2>(__u); }
    typedef void is_transparent;
};



template <class _Tp = void>



struct multiplies
    : __binary_function<_Tp, _Tp, _Tp>
{
    typedef _Tp __result_type;
    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    _Tp operator()(const _Tp& __x, const _Tp& __y) const
        {return __x * __y;}
};
template <class... _Tag> [[maybe_unused]] multiplies(typename _Tag::__allow_ctad...)->multiplies<_Tag...>;


template <>
struct multiplies<void>
{
    template <class _T1, class _T2>
    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    auto operator()(_T1&& __t, _T2&& __u) const
        noexcept(noexcept(std::forward<_T1>(__t) * std::forward<_T2>(__u)))
        -> decltype( std::forward<_T1>(__t) * std::forward<_T2>(__u))
        { return std::forward<_T1>(__t) * std::forward<_T2>(__u); }
    typedef void is_transparent;
};



template <class _Tp = void>



struct divides
    : __binary_function<_Tp, _Tp, _Tp>
{
    typedef _Tp __result_type;
    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    _Tp operator()(const _Tp& __x, const _Tp& __y) const
        {return __x / __y;}
};
template <class... _Tag> [[maybe_unused]] divides(typename _Tag::__allow_ctad...)->divides<_Tag...>;


template <>
struct divides<void>
{
    template <class _T1, class _T2>
    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    auto operator()(_T1&& __t, _T2&& __u) const
        noexcept(noexcept(std::forward<_T1>(__t) / std::forward<_T2>(__u)))
        -> decltype( std::forward<_T1>(__t) / std::forward<_T2>(__u))
        { return std::forward<_T1>(__t) / std::forward<_T2>(__u); }
    typedef void is_transparent;
};



template <class _Tp = void>



struct modulus
    : __binary_function<_Tp, _Tp, _Tp>
{
    typedef _Tp __result_type;
    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    _Tp operator()(const _Tp& __x, const _Tp& __y) const
        {return __x % __y;}
};
template <class... _Tag> [[maybe_unused]] modulus(typename _Tag::__allow_ctad...)->modulus<_Tag...>;


template <>
struct modulus<void>
{
    template <class _T1, class _T2>
    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    auto operator()(_T1&& __t, _T2&& __u) const
        noexcept(noexcept(std::forward<_T1>(__t) % std::forward<_T2>(__u)))
        -> decltype( std::forward<_T1>(__t) % std::forward<_T2>(__u))
        { return std::forward<_T1>(__t) % std::forward<_T2>(__u); }
    typedef void is_transparent;
};



template <class _Tp = void>



struct negate
    : __unary_function<_Tp, _Tp>
{
    typedef _Tp __result_type;
    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    _Tp operator()(const _Tp& __x) const
        {return -__x;}
};
template <class... _Tag> [[maybe_unused]] negate(typename _Tag::__allow_ctad...)->negate<_Tag...>;


template <>
struct negate<void>
{
    template <class _Tp>
    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    auto operator()(_Tp&& __x) const
        noexcept(noexcept(- std::forward<_Tp>(__x)))
        -> decltype( - std::forward<_Tp>(__x))
        { return - std::forward<_Tp>(__x); }
    typedef void is_transparent;
};





template <class _Tp = void>



struct bit_and
    : __binary_function<_Tp, _Tp, _Tp>
{
    typedef _Tp __result_type;
    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    _Tp operator()(const _Tp& __x, const _Tp& __y) const
        {return __x & __y;}
};
template <class... _Tag> [[maybe_unused]] bit_and(typename _Tag::__allow_ctad...)->bit_and<_Tag...>;


template <>
struct bit_and<void>
{
    template <class _T1, class _T2>
    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    auto operator()(_T1&& __t, _T2&& __u) const
        noexcept(noexcept(std::forward<_T1>(__t) & std::forward<_T2>(__u)))
        -> decltype( std::forward<_T1>(__t) & std::forward<_T2>(__u))
        { return std::forward<_T1>(__t) & std::forward<_T2>(__u); }
    typedef void is_transparent;
};



template <class _Tp = void>
struct bit_not
    : __unary_function<_Tp, _Tp>
{
    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    _Tp operator()(const _Tp& __x) const
        {return ~__x;}
};
template <class... _Tag> [[maybe_unused]] bit_not(typename _Tag::__allow_ctad...)->bit_not<_Tag...>;

template <>
struct bit_not<void>
{
    template <class _Tp>
    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    auto operator()(_Tp&& __x) const
        noexcept(noexcept(~std::forward<_Tp>(__x)))
        -> decltype( ~std::forward<_Tp>(__x))
        { return ~std::forward<_Tp>(__x); }
    typedef void is_transparent;
};



template <class _Tp = void>



struct bit_or
    : __binary_function<_Tp, _Tp, _Tp>
{
    typedef _Tp __result_type;
    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    _Tp operator()(const _Tp& __x, const _Tp& __y) const
        {return __x | __y;}
};
template <class... _Tag> [[maybe_unused]] bit_or(typename _Tag::__allow_ctad...)->bit_or<_Tag...>;


template <>
struct bit_or<void>
{
    template <class _T1, class _T2>
    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    auto operator()(_T1&& __t, _T2&& __u) const
        noexcept(noexcept(std::forward<_T1>(__t) | std::forward<_T2>(__u)))
        -> decltype( std::forward<_T1>(__t) | std::forward<_T2>(__u))
        { return std::forward<_T1>(__t) | std::forward<_T2>(__u); }
    typedef void is_transparent;
};



template <class _Tp = void>



struct bit_xor
    : __binary_function<_Tp, _Tp, _Tp>
{
    typedef _Tp __result_type;
    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    _Tp operator()(const _Tp& __x, const _Tp& __y) const
        {return __x ^ __y;}
};
template <class... _Tag> [[maybe_unused]] bit_xor(typename _Tag::__allow_ctad...)->bit_xor<_Tag...>;


template <>
struct bit_xor<void>
{
    template <class _T1, class _T2>
    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    auto operator()(_T1&& __t, _T2&& __u) const
        noexcept(noexcept(std::forward<_T1>(__t) ^ std::forward<_T2>(__u)))
        -> decltype( std::forward<_T1>(__t) ^ std::forward<_T2>(__u))
        { return std::forward<_T1>(__t) ^ std::forward<_T2>(__u); }
    typedef void is_transparent;
};





template <class _Tp = void>



struct equal_to
    : __binary_function<_Tp, _Tp, bool>
{
    typedef bool __result_type;
    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    bool operator()(const _Tp& __x, const _Tp& __y) const
        {return __x == __y;}
};
template <class... _Tag> [[maybe_unused]] equal_to(typename _Tag::__allow_ctad...)->equal_to<_Tag...>;


template <>
struct equal_to<void>
{
    template <class _T1, class _T2>
    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    auto operator()(_T1&& __t, _T2&& __u) const
        noexcept(noexcept(std::forward<_T1>(__t) == std::forward<_T2>(__u)))
        -> decltype( std::forward<_T1>(__t) == std::forward<_T2>(__u))
        { return std::forward<_T1>(__t) == std::forward<_T2>(__u); }
    typedef void is_transparent;
};


template <class _Tp>
struct __is_trivial_equality_predicate<equal_to<_Tp>, _Tp, _Tp> : true_type {};


template <class _Tp>
struct __is_trivial_equality_predicate<equal_to<>, _Tp, _Tp> : true_type {};



template <class _Tp = void>



struct not_equal_to
    : __binary_function<_Tp, _Tp, bool>
{
    typedef bool __result_type;
    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    bool operator()(const _Tp& __x, const _Tp& __y) const
        {return __x != __y;}
};
template <class... _Tag> [[maybe_unused]] not_equal_to(typename _Tag::__allow_ctad...)->not_equal_to<_Tag...>;


template <>
struct not_equal_to<void>
{
    template <class _T1, class _T2>
    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    auto operator()(_T1&& __t, _T2&& __u) const
        noexcept(noexcept(std::forward<_T1>(__t) != std::forward<_T2>(__u)))
        -> decltype( std::forward<_T1>(__t) != std::forward<_T2>(__u))
        { return std::forward<_T1>(__t) != std::forward<_T2>(__u); }
    typedef void is_transparent;
};



template <class _Tp = void>



struct less
    : __binary_function<_Tp, _Tp, bool>
{
    typedef bool __result_type;
    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    bool operator()(const _Tp& __x, const _Tp& __y) const
        {return __x < __y;}
};
template <class... _Tag> [[maybe_unused]] less(typename _Tag::__allow_ctad...)->less<_Tag...>;


template <>
struct less<void>
{
    template <class _T1, class _T2>
    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    auto operator()(_T1&& __t, _T2&& __u) const
        noexcept(noexcept(std::forward<_T1>(__t) < std::forward<_T2>(__u)))
        -> decltype( std::forward<_T1>(__t) < std::forward<_T2>(__u))
        { return std::forward<_T1>(__t) < std::forward<_T2>(__u); }
    typedef void is_transparent;
};



template <class _Tp = void>



struct less_equal
    : __binary_function<_Tp, _Tp, bool>
{
    typedef bool __result_type;
    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    bool operator()(const _Tp& __x, const _Tp& __y) const
        {return __x <= __y;}
};
template <class... _Tag> [[maybe_unused]] less_equal(typename _Tag::__allow_ctad...)->less_equal<_Tag...>;


template <>
struct less_equal<void>
{
    template <class _T1, class _T2>
    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    auto operator()(_T1&& __t, _T2&& __u) const
        noexcept(noexcept(std::forward<_T1>(__t) <= std::forward<_T2>(__u)))
        -> decltype( std::forward<_T1>(__t) <= std::forward<_T2>(__u))
        { return std::forward<_T1>(__t) <= std::forward<_T2>(__u); }
    typedef void is_transparent;
};



template <class _Tp = void>



struct greater_equal
    : __binary_function<_Tp, _Tp, bool>
{
    typedef bool __result_type;
    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    bool operator()(const _Tp& __x, const _Tp& __y) const
        {return __x >= __y;}
};
template <class... _Tag> [[maybe_unused]] greater_equal(typename _Tag::__allow_ctad...)->greater_equal<_Tag...>;


template <>
struct greater_equal<void>
{
    template <class _T1, class _T2>
    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    auto operator()(_T1&& __t, _T2&& __u) const
        noexcept(noexcept(std::forward<_T1>(__t) >= std::forward<_T2>(__u)))
        -> decltype( std::forward<_T1>(__t) >= std::forward<_T2>(__u))
        { return std::forward<_T1>(__t) >= std::forward<_T2>(__u); }
    typedef void is_transparent;
};



template <class _Tp = void>



struct greater
    : __binary_function<_Tp, _Tp, bool>
{
    typedef bool __result_type;
    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    bool operator()(const _Tp& __x, const _Tp& __y) const
        {return __x > __y;}
};
template <class... _Tag> [[maybe_unused]] greater(typename _Tag::__allow_ctad...)->greater<_Tag...>;


template <>
struct greater<void>
{
    template <class _T1, class _T2>
    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    auto operator()(_T1&& __t, _T2&& __u) const
        noexcept(noexcept(std::forward<_T1>(__t) > std::forward<_T2>(__u)))
        -> decltype( std::forward<_T1>(__t) > std::forward<_T2>(__u))
        { return std::forward<_T1>(__t) > std::forward<_T2>(__u); }
    typedef void is_transparent;
};





template <class _Tp = void>



struct logical_and
    : __binary_function<_Tp, _Tp, bool>
{
    typedef bool __result_type;
    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    bool operator()(const _Tp& __x, const _Tp& __y) const
        {return __x && __y;}
};
template <class... _Tag> [[maybe_unused]] logical_and(typename _Tag::__allow_ctad...)->logical_and<_Tag...>;


template <>
struct logical_and<void>
{
    template <class _T1, class _T2>
    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    auto operator()(_T1&& __t, _T2&& __u) const
        noexcept(noexcept(std::forward<_T1>(__t) && std::forward<_T2>(__u)))
        -> decltype( std::forward<_T1>(__t) && std::forward<_T2>(__u))
        { return std::forward<_T1>(__t) && std::forward<_T2>(__u); }
    typedef void is_transparent;
};



template <class _Tp = void>



struct logical_not
    : __unary_function<_Tp, bool>
{
    typedef bool __result_type;
    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    bool operator()(const _Tp& __x) const
        {return !__x;}
};
template <class... _Tag> [[maybe_unused]] logical_not(typename _Tag::__allow_ctad...)->logical_not<_Tag...>;


template <>
struct logical_not<void>
{
    template <class _Tp>
    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    auto operator()(_Tp&& __x) const
        noexcept(noexcept(!std::forward<_Tp>(__x)))
        -> decltype( !std::forward<_Tp>(__x))
        { return !std::forward<_Tp>(__x); }
    typedef void is_transparent;
};



template <class _Tp = void>



struct logical_or
    : __binary_function<_Tp, _Tp, bool>
{
    typedef bool __result_type;
    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    bool operator()(const _Tp& __x, const _Tp& __y) const
        {return __x || __y;}
};
template <class... _Tag> [[maybe_unused]] logical_or(typename _Tag::__allow_ctad...)->logical_or<_Tag...>;


template <>
struct logical_or<void>
{
    template <class _T1, class _T2>
    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    auto operator()(_T1&& __t, _T2&& __u) const
        noexcept(noexcept(std::forward<_T1>(__t) || std::forward<_T2>(__u)))
        -> decltype( std::forward<_T1>(__t) || std::forward<_T2>(__u))
        { return std::forward<_T1>(__t) || std::forward<_T2>(__u); }
    typedef void is_transparent;
};


}}
# 19 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__memory/unique_ptr.h" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__memory/allocator_traits.h" 1 3
# 18 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__memory/allocator_traits.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_empty.h" 1 3
# 17 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_empty.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Tp>
struct is_empty : public integral_constant<bool, __is_empty(_Tp)> {};


template <class _Tp>
inline constexpr bool is_empty_v = __is_empty(_Tp);


}}
# 19 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__memory/allocator_traits.h" 2 3
# 29 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__memory/allocator_traits.h" 3



# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__undef_macros" 1 3
# 33 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__memory/allocator_traits.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {






template <class _Tp, class = void> struct __has_pointer : false_type { }; template <class _Tp> struct __has_pointer<_Tp, __void_t<typename _Tp:: pointer > > : true_type { };
template <class _Tp, class _Alloc,
          class _RawAlloc = __libcpp_remove_reference_t<_Alloc>,
          bool = __has_pointer<_RawAlloc>::value>
struct __pointer {
    using type __attribute__((__nodebug__)) = typename _RawAlloc::pointer;
};
template <class _Tp, class _Alloc, class _RawAlloc>
struct __pointer<_Tp, _Alloc, _RawAlloc, false> {
    using type __attribute__((__nodebug__)) = _Tp*;
};


template <class _Tp, class = void> struct __has_const_pointer : false_type { }; template <class _Tp> struct __has_const_pointer<_Tp, __void_t<typename _Tp:: const_pointer > > : true_type { };
template <class _Tp, class _Ptr, class _Alloc,
          bool = __has_const_pointer<_Alloc>::value>
struct __const_pointer {
    using type __attribute__((__nodebug__)) = typename _Alloc::const_pointer;
};
template <class _Tp, class _Ptr, class _Alloc>
struct __const_pointer<_Tp, _Ptr, _Alloc, false> {



    using type __attribute__((__nodebug__)) = typename pointer_traits<_Ptr>::template rebind<const _Tp>;

};


template <class _Tp, class = void> struct __has_void_pointer : false_type { }; template <class _Tp> struct __has_void_pointer<_Tp, __void_t<typename _Tp:: void_pointer > > : true_type { };
template <class _Ptr, class _Alloc,
          bool = __has_void_pointer<_Alloc>::value>
struct __void_pointer {
    using type __attribute__((__nodebug__)) = typename _Alloc::void_pointer;
};
template <class _Ptr, class _Alloc>
struct __void_pointer<_Ptr, _Alloc, false> {



    using type __attribute__((__nodebug__)) = typename pointer_traits<_Ptr>::template rebind<void>;

};


template <class _Tp, class = void> struct __has_const_void_pointer : false_type { }; template <class _Tp> struct __has_const_void_pointer<_Tp, __void_t<typename _Tp:: const_void_pointer > > : true_type { };
template <class _Ptr, class _Alloc,
          bool = __has_const_void_pointer<_Alloc>::value>
struct __const_void_pointer {
    using type __attribute__((__nodebug__)) = typename _Alloc::const_void_pointer;
};
template <class _Ptr, class _Alloc>
struct __const_void_pointer<_Ptr, _Alloc, false> {



    using type __attribute__((__nodebug__)) = typename pointer_traits<_Ptr>::template rebind<const void>;

};


template <class _Tp, class = void> struct __has_size_type : false_type { }; template <class _Tp> struct __has_size_type<_Tp, __void_t<typename _Tp:: size_type > > : true_type { };
template <class _Alloc, class _DiffType, bool = __has_size_type<_Alloc>::value>
struct __size_type : make_unsigned<_DiffType> { };
template <class _Alloc, class _DiffType>
struct __size_type<_Alloc, _DiffType, true> {
    using type __attribute__((__nodebug__)) = typename _Alloc::size_type;
};


template <class _Tp, class = void> struct __has_alloc_traits_difference_type : false_type { }; template <class _Tp> struct __has_alloc_traits_difference_type<_Tp, __void_t<typename _Tp:: difference_type > > : true_type { };
template <class _Alloc, class _Ptr, bool = __has_alloc_traits_difference_type<_Alloc>::value>
struct __alloc_traits_difference_type {
    using type __attribute__((__nodebug__)) = typename pointer_traits<_Ptr>::difference_type;
};
template <class _Alloc, class _Ptr>
struct __alloc_traits_difference_type<_Alloc, _Ptr, true> {
    using type __attribute__((__nodebug__)) = typename _Alloc::difference_type;
};


template <class _Tp, class = void> struct __has_propagate_on_container_copy_assignment : false_type { }; template <class _Tp> struct __has_propagate_on_container_copy_assignment<_Tp, __void_t<typename _Tp:: propagate_on_container_copy_assignment > > : true_type { };
template <class _Alloc, bool = __has_propagate_on_container_copy_assignment<_Alloc>::value>
struct __propagate_on_container_copy_assignment : false_type { };
template <class _Alloc>
struct __propagate_on_container_copy_assignment<_Alloc, true> {
    using type __attribute__((__nodebug__)) = typename _Alloc::propagate_on_container_copy_assignment;
};


template <class _Tp, class = void> struct __has_propagate_on_container_move_assignment : false_type { }; template <class _Tp> struct __has_propagate_on_container_move_assignment<_Tp, __void_t<typename _Tp:: propagate_on_container_move_assignment > > : true_type { };
template <class _Alloc, bool = __has_propagate_on_container_move_assignment<_Alloc>::value>
struct __propagate_on_container_move_assignment : false_type { };
template <class _Alloc>
struct __propagate_on_container_move_assignment<_Alloc, true> {
    using type __attribute__((__nodebug__)) = typename _Alloc::propagate_on_container_move_assignment;
};


template <class _Tp, class = void> struct __has_propagate_on_container_swap : false_type { }; template <class _Tp> struct __has_propagate_on_container_swap<_Tp, __void_t<typename _Tp:: propagate_on_container_swap > > : true_type { };
template <class _Alloc, bool = __has_propagate_on_container_swap<_Alloc>::value>
struct __propagate_on_container_swap : false_type { };
template <class _Alloc>
struct __propagate_on_container_swap<_Alloc, true> {
    using type __attribute__((__nodebug__)) = typename _Alloc::propagate_on_container_swap;
};


template <class _Tp, class = void> struct __has_is_always_equal : false_type { }; template <class _Tp> struct __has_is_always_equal<_Tp, __void_t<typename _Tp:: is_always_equal > > : true_type { };
template <class _Alloc, bool = __has_is_always_equal<_Alloc>::value>
struct __is_always_equal : is_empty<_Alloc> { };
template <class _Alloc>
struct __is_always_equal<_Alloc, true> {
    using type __attribute__((__nodebug__)) = typename _Alloc::is_always_equal;
};


#pragma GCC diagnostic push
# 158 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__memory/allocator_traits.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
# 158 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__memory/allocator_traits.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
template <class _Tp, class _Up, class = void>
struct __has_rebind_other : false_type { };
template <class _Tp, class _Up>
struct __has_rebind_other<_Tp, _Up, __void_t<typename _Tp::template rebind<_Up>::other> > : true_type { };

template <class _Tp, class _Up, bool = __has_rebind_other<_Tp, _Up>::value>
struct __allocator_traits_rebind {
  static_assert(__has_rebind_other<_Tp, _Up>::value, "This allocator has to implement rebind");
  using type __attribute__((__nodebug__)) = typename _Tp::template rebind<_Up>::other;
};
template <template <class, class...> class _Alloc, class _Tp, class ..._Args, class _Up>
struct __allocator_traits_rebind<_Alloc<_Tp, _Args...>, _Up, true> {
    using type __attribute__((__nodebug__)) = typename _Alloc<_Tp, _Args...>::template rebind<_Up>::other;
};
template <template <class, class...> class _Alloc, class _Tp, class ..._Args, class _Up>
struct __allocator_traits_rebind<_Alloc<_Tp, _Args...>, _Up, false> {
    using type __attribute__((__nodebug__)) = _Alloc<_Up, _Args...>;
};
#pragma GCC diagnostic pop

template<class _Alloc, class _Tp>
using __allocator_traits_rebind_t = typename __allocator_traits_rebind<_Alloc, _Tp>::type;

#pragma GCC diagnostic push
# 182 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__memory/allocator_traits.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
# 182 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__memory/allocator_traits.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"


template <class _Alloc, class _SizeType, class _ConstVoidPtr, class = void>
struct __has_allocate_hint : false_type { };

template <class _Alloc, class _SizeType, class _ConstVoidPtr>
struct __has_allocate_hint<_Alloc, _SizeType, _ConstVoidPtr, decltype(
    (void)std::declval<_Alloc>().allocate(std::declval<_SizeType>(), std::declval<_ConstVoidPtr>())
)> : true_type { };


template <class, class _Alloc, class ..._Args>
struct __has_construct_impl : false_type { };

template <class _Alloc, class ..._Args>
struct __has_construct_impl<decltype(
    (void)std::declval<_Alloc>().construct(std::declval<_Args>()...)
), _Alloc, _Args...> : true_type { };

template <class _Alloc, class ..._Args>
struct __has_construct : __has_construct_impl<void, _Alloc, _Args...> { };


template <class _Alloc, class _Pointer, class = void>
struct __has_destroy : false_type { };

template <class _Alloc, class _Pointer>
struct __has_destroy<_Alloc, _Pointer, decltype(
    (void)std::declval<_Alloc>().destroy(std::declval<_Pointer>())
)> : true_type { };


template <class _Alloc, class = void>
struct __has_max_size : false_type { };

template <class _Alloc>
struct __has_max_size<_Alloc, decltype(
    (void)std::declval<_Alloc&>().max_size()
)> : true_type { };


template <class _Alloc, class = void>
struct __has_select_on_container_copy_construction : false_type { };

template <class _Alloc>
struct __has_select_on_container_copy_construction<_Alloc, decltype(
    (void)std::declval<_Alloc>().select_on_container_copy_construction()
)> : true_type { };

#pragma GCC diagnostic pop

template <class _Alloc>
struct allocator_traits
{
    using allocator_type = _Alloc;
    using value_type = typename allocator_type::value_type;
    using pointer = typename __pointer<value_type, allocator_type>::type;
    using const_pointer = typename __const_pointer<value_type, pointer, allocator_type>::type;
    using void_pointer = typename __void_pointer<pointer, allocator_type>::type;
    using const_void_pointer = typename __const_void_pointer<pointer, allocator_type>::type;
    using difference_type = typename __alloc_traits_difference_type<allocator_type, pointer>::type;
    using size_type = typename __size_type<allocator_type, difference_type>::type;
    using propagate_on_container_copy_assignment = typename __propagate_on_container_copy_assignment<allocator_type>::type;
    using propagate_on_container_move_assignment = typename __propagate_on_container_move_assignment<allocator_type>::type;
    using propagate_on_container_swap = typename __propagate_on_container_swap<allocator_type>::type;
    using is_always_equal = typename __is_always_equal<allocator_type>::type;


    template <class _Tp>
    using rebind_alloc = __allocator_traits_rebind_t<allocator_type, _Tp>;
    template <class _Tp>
    using rebind_traits = allocator_traits<rebind_alloc<_Tp> >;
# 266 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__memory/allocator_traits.h" 3
    [[__nodiscard__]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    static pointer allocate(allocator_type& __a, size_type __n) {
        return __a.allocate(__n);
    }

    template <class _Ap = _Alloc, class =
        __enable_if_t<__has_allocate_hint<_Ap, size_type, const_void_pointer>::value> >
    [[__nodiscard__]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    static pointer allocate(allocator_type& __a, size_type __n, const_void_pointer __hint) {
#pragma GCC diagnostic push
# 275 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__memory/allocator_traits.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
# 275 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__memory/allocator_traits.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
        return __a.allocate(__n, __hint);
#pragma GCC diagnostic pop
    }
    template <class _Ap = _Alloc, class = void, class =
        __enable_if_t<!__has_allocate_hint<_Ap, size_type, const_void_pointer>::value> >
    [[__nodiscard__]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    static pointer allocate(allocator_type& __a, size_type __n, const_void_pointer) {
        return __a.allocate(__n);
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    static void deallocate(allocator_type& __a, pointer __p, size_type __n) noexcept {
        __a.deallocate(__p, __n);
    }

    template <class _Tp, class... _Args, class =
        __enable_if_t<__has_construct<allocator_type, _Tp*, _Args...>::value> >
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    static void construct(allocator_type& __a, _Tp* __p, _Args&&... __args) {
#pragma GCC diagnostic push
# 295 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__memory/allocator_traits.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
# 295 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__memory/allocator_traits.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
        __a.construct(__p, std::forward<_Args>(__args)...);
#pragma GCC diagnostic pop
    }
    template <class _Tp, class... _Args, class = void, class =
        __enable_if_t<!__has_construct<allocator_type, _Tp*, _Args...>::value> >
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    static void construct(allocator_type&, _Tp* __p, _Args&&... __args) {

        std::construct_at(__p, std::forward<_Args>(__args)...);



    }

    template <class _Tp, class =
        __enable_if_t<__has_destroy<allocator_type, _Tp*>::value> >
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    static void destroy(allocator_type& __a, _Tp* __p) {
#pragma GCC diagnostic push
# 314 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__memory/allocator_traits.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
# 314 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__memory/allocator_traits.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
        __a.destroy(__p);
#pragma GCC diagnostic pop
    }
    template <class _Tp, class = void, class =
        __enable_if_t<!__has_destroy<allocator_type, _Tp*>::value> >
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    static void destroy(allocator_type&, _Tp* __p) {

        std::destroy_at(__p);



    }

    template <class _Ap = _Alloc, class =
        __enable_if_t<__has_max_size<const _Ap>::value> >
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    static size_type max_size(const allocator_type& __a) noexcept {
#pragma GCC diagnostic push
# 333 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__memory/allocator_traits.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
# 333 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__memory/allocator_traits.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
        return __a.max_size();
#pragma GCC diagnostic pop
    }
    template <class _Ap = _Alloc, class = void, class =
        __enable_if_t<!__has_max_size<const _Ap>::value> >
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    static size_type max_size(const allocator_type&) noexcept {
        return numeric_limits<size_type>::max() / sizeof(value_type);
    }

    template <class _Ap = _Alloc, class =
        __enable_if_t<__has_select_on_container_copy_construction<const _Ap>::value> >
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    static allocator_type select_on_container_copy_construction(const allocator_type& __a) {
        return __a.select_on_container_copy_construction();
    }
    template <class _Ap = _Alloc, class = void, class =
        __enable_if_t<!__has_select_on_container_copy_construction<const _Ap>::value> >
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    static allocator_type select_on_container_copy_construction(const allocator_type& __a) {
        return __a;
    }
};


template <class _Traits, class _Tp>
using __rebind_alloc __attribute__((__nodebug__)) = typename _Traits::template rebind_alloc<_Tp>;






template <class _Tp>
struct __is_default_allocator : false_type { };

template <class> class allocator;

template <class _Tp>
struct __is_default_allocator<allocator<_Tp> > : true_type { };


template <class _Alloc, class = void>
struct __is_cpp17_move_insertable
    : is_move_constructible<typename _Alloc::value_type>
{ };

template <class _Alloc>
struct __is_cpp17_move_insertable<_Alloc, __enable_if_t<
    !__is_default_allocator<_Alloc>::value &&
    __has_construct<_Alloc, typename _Alloc::value_type*, typename _Alloc::value_type&&>::value
> > : true_type { };


template <class _Alloc, class = void>
struct __is_cpp17_copy_insertable
    : integral_constant<bool,
        is_copy_constructible<typename _Alloc::value_type>::value &&
        __is_cpp17_move_insertable<_Alloc>::value
    >
{ };

template <class _Alloc>
struct __is_cpp17_copy_insertable<_Alloc, __enable_if_t<
    !__is_default_allocator<_Alloc>::value &&
    __has_construct<_Alloc, typename _Alloc::value_type*, const typename _Alloc::value_type&>::value
> >
    : __is_cpp17_move_insertable<_Alloc>
{ };
# 425 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__memory/allocator_traits.h" 3
}}
# 20 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__memory/unique_ptr.h" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__memory/auto_ptr.h" 1 3
# 17 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__memory/auto_ptr.h" 3
# 21 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__memory/unique_ptr.h" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__memory/compressed_pair.h" 1 3
# 18 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__memory/compressed_pair.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/dependent_type.h" 1 3
# 16 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/dependent_type.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Tp, bool>
struct __dependent_type : public _Tp {};

}}
# 19 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__memory/compressed_pair.h" 2 3
# 32 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__memory/compressed_pair.h" 3



# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__undef_macros" 1 3
# 36 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__memory/compressed_pair.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {


struct __default_init_tag {};
struct __value_init_tag {};

template <class _Tp, int _Idx, bool _CanBeEmptyBase = is_empty<_Tp>::value && !__libcpp_is_final<_Tp>::value>
struct __compressed_pair_elem {
  using _ParamT = _Tp;
  using reference = _Tp&;
  using const_reference = const _Tp&;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr explicit __compressed_pair_elem(__default_init_tag) {}
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr explicit __compressed_pair_elem(__value_init_tag) : __value_() {}

  template <class _Up, class = __enable_if_t<!is_same<__compressed_pair_elem, __decay_t<_Up> >::value> >
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
  explicit __compressed_pair_elem(_Up&& __u) : __value_(std::forward<_Up>(__u)) {}


  template <class... _Args, size_t... _Indices>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
  explicit __compressed_pair_elem(piecewise_construct_t, tuple<_Args...> __args, __tuple_indices<_Indices...>)
      : __value_(std::forward<_Args>(std::get<_Indices>(__args))...) {}


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr reference __get() noexcept { return __value_; }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr const_reference __get() const noexcept { return __value_; }

private:
  _Tp __value_;
};

template <class _Tp, int _Idx>
struct __compressed_pair_elem<_Tp, _Idx, true> : private _Tp {
  using _ParamT = _Tp;
  using reference = _Tp&;
  using const_reference = const _Tp&;
  using __value_type = _Tp;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr explicit __compressed_pair_elem() = default;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr explicit __compressed_pair_elem(__default_init_tag) {}
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr explicit __compressed_pair_elem(__value_init_tag) : __value_type() {}

  template <class _Up, class = __enable_if_t<!is_same<__compressed_pair_elem, __decay_t<_Up> >::value> >
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
  explicit __compressed_pair_elem(_Up&& __u) : __value_type(std::forward<_Up>(__u)) {}


  template <class... _Args, size_t... _Indices>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
  __compressed_pair_elem(piecewise_construct_t, tuple<_Args...> __args, __tuple_indices<_Indices...>)
      : __value_type(std::forward<_Args>(std::get<_Indices>(__args))...) {}


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr reference __get() noexcept { return *this; }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr const_reference __get() const noexcept { return *this; }
};

template <class _T1, class _T2>
class __compressed_pair : private __compressed_pair_elem<_T1, 0>,
                          private __compressed_pair_elem<_T2, 1> {
public:




  static_assert((!is_same<_T1, _T2>::value),
    "__compressed_pair cannot be instantiated when T1 and T2 are the same type; "
    "The current implementation is NOT ABI-compatible with the previous implementation for this configuration");

  using _Base1 __attribute__((__nodebug__)) = __compressed_pair_elem<_T1, 0>;
  using _Base2 __attribute__((__nodebug__)) = __compressed_pair_elem<_T2, 1>;

  template <bool _Dummy = true,
    class = __enable_if_t<
        __dependent_type<is_default_constructible<_T1>, _Dummy>::value &&
        __dependent_type<is_default_constructible<_T2>, _Dummy>::value
    >
  >
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
  explicit __compressed_pair() : _Base1(__value_init_tag()), _Base2(__value_init_tag()) {}

  template <class _U1, class _U2>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
  explicit __compressed_pair(_U1&& __t1, _U2&& __t2) : _Base1(std::forward<_U1>(__t1)), _Base2(std::forward<_U2>(__t2)) {}


  template <class... _Args1, class... _Args2>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
  explicit __compressed_pair(piecewise_construct_t __pc, tuple<_Args1...> __first_args,
                             tuple<_Args2...> __second_args)
      : _Base1(__pc, std::move(__first_args), typename __make_tuple_indices<sizeof...(_Args1)>::type()),
        _Base2(__pc, std::move(__second_args), typename __make_tuple_indices<sizeof...(_Args2)>::type()) {}


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
  typename _Base1::reference first() noexcept {
    return static_cast<_Base1&>(*this).__get();
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
  typename _Base1::const_reference first() const noexcept {
    return static_cast<_Base1 const&>(*this).__get();
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
  typename _Base2::reference second() noexcept {
    return static_cast<_Base2&>(*this).__get();
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
  typename _Base2::const_reference second() const noexcept {
    return static_cast<_Base2 const&>(*this).__get();
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr static
  _Base1* __get_first_base(__compressed_pair* __pair) noexcept {
    return static_cast<_Base1*>(__pair);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr static
  _Base2* __get_second_base(__compressed_pair* __pair) noexcept {
    return static_cast<_Base2*>(__pair);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
  void swap(__compressed_pair& __x)
      noexcept(__is_nothrow_swappable<_T1>::value && __is_nothrow_swappable<_T2>::value) {
    using std::swap;
    swap(first(), __x.first());
    swap(second(), __x.second());
  }
};

template <class _T1, class _T2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
void swap(__compressed_pair<_T1, _T2>& __x, __compressed_pair<_T1, _T2>& __y)
    noexcept(__is_nothrow_swappable<_T1>::value && __is_nothrow_swappable<_T2>::value) {
  __x.swap(__y);
}

}}
# 22 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__memory/unique_ptr.h" 2 3
# 38 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__memory/unique_ptr.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/type_identity.h" 1 3
# 16 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/type_identity.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Tp>
struct __type_identity {
  typedef _Tp type;
};

template <class _Tp>
using __type_identity_t __attribute__((__nodebug__)) = typename __type_identity<_Tp>::type;


template <class _Tp>
struct type_identity {
  typedef _Tp type;
};
template <class _Tp>
using type_identity_t = typename type_identity<_Tp>::type;


}}
# 39 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__memory/unique_ptr.h" 2 3
# 45 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__memory/unique_ptr.h" 3



# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__undef_macros" 1 3
# 49 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__memory/unique_ptr.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Tp>
struct default_delete {
    static_assert(!is_function<_Tp>::value,
                  "default_delete cannot be instantiated for function types");

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr default_delete() noexcept = default;



  template <class _Up, __enable_if_t<is_convertible<_Up*, _Tp*>::value, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr default_delete(
      const default_delete<_Up>&) noexcept {}

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr void operator()(_Tp* __ptr) const noexcept {
    static_assert(sizeof(_Tp) >= 0, "cannot delete an incomplete type");
    static_assert(!is_void<_Tp>::value, "cannot delete an incomplete type");
    delete __ptr;
  }
};

template <class _Tp>
struct default_delete<_Tp[]> {
private:
  template <class _Up>
  struct _EnableIfConvertible
      : enable_if<is_convertible<_Up(*)[], _Tp(*)[]>::value> {};

public:

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr default_delete() noexcept = default;




  template <class _Up>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
  default_delete(const default_delete<_Up[]>&, typename _EnableIfConvertible<_Up>::type* = 0) noexcept {}

  template <class _Up>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr typename _EnableIfConvertible<_Up>::type
  operator()(_Up* __ptr) const noexcept {
    static_assert(sizeof(_Up) >= 0, "cannot delete an incomplete type");
    delete[] __ptr;
  }
};

template <class _Deleter>
struct __unique_ptr_deleter_sfinae {
  static_assert(!is_reference<_Deleter>::value, "incorrect specialization");
  typedef const _Deleter& __lval_ref_type;
  typedef _Deleter&& __good_rval_ref_type;
  typedef true_type __enable_rval_overload;
};

template <class _Deleter>
struct __unique_ptr_deleter_sfinae<_Deleter const&> {
  typedef const _Deleter& __lval_ref_type;
  typedef const _Deleter&& __bad_rval_ref_type;
  typedef false_type __enable_rval_overload;
};

template <class _Deleter>
struct __unique_ptr_deleter_sfinae<_Deleter&> {
  typedef _Deleter& __lval_ref_type;
  typedef _Deleter&& __bad_rval_ref_type;
  typedef false_type __enable_rval_overload;
};







template <class _Tp, class _Dp = default_delete<_Tp> >
class unique_ptr {
public:
  typedef _Tp element_type;
  typedef _Dp deleter_type;
  typedef __attribute__((__nodebug__)) typename __pointer<_Tp, deleter_type>::type pointer;

  static_assert(!is_rvalue_reference<deleter_type>::value,
                "the specified deleter type cannot be an rvalue reference");

private:
  __compressed_pair<pointer, deleter_type> __ptr_;

  struct __nat { int __for_bool_; };

  typedef __attribute__((__nodebug__)) __unique_ptr_deleter_sfinae<_Dp> _DeleterSFINAE;

  template <bool _Dummy>
  using _LValRefType __attribute__((__nodebug__)) =
      typename __dependent_type<_DeleterSFINAE, _Dummy>::__lval_ref_type;

  template <bool _Dummy>
  using _GoodRValRefType __attribute__((__nodebug__)) =
      typename __dependent_type<_DeleterSFINAE, _Dummy>::__good_rval_ref_type;

  template <bool _Dummy>
  using _BadRValRefType __attribute__((__nodebug__)) =
      typename __dependent_type<_DeleterSFINAE, _Dummy>::__bad_rval_ref_type;

  template <bool _Dummy, class _Deleter = typename __dependent_type<
                             __type_identity<deleter_type>, _Dummy>::type>
  using _EnableIfDeleterDefaultConstructible __attribute__((__nodebug__)) =
      __enable_if_t<is_default_constructible<_Deleter>::value &&
                         !is_pointer<_Deleter>::value>;

  template <class _ArgType>
  using _EnableIfDeleterConstructible __attribute__((__nodebug__)) =
      __enable_if_t<is_constructible<deleter_type, _ArgType>::value>;

  template <class _UPtr, class _Up>
  using _EnableIfMoveConvertible __attribute__((__nodebug__)) = __enable_if_t<
      is_convertible<typename _UPtr::pointer, pointer>::value &&
      !is_array<_Up>::value
  >;

  template <class _UDel>
  using _EnableIfDeleterConvertible __attribute__((__nodebug__)) = __enable_if_t<
      (is_reference<_Dp>::value && is_same<_Dp, _UDel>::value) ||
      (!is_reference<_Dp>::value && is_convertible<_UDel, _Dp>::value)
    >;

  template <class _UDel>
  using _EnableIfDeleterAssignable = __enable_if_t<
      is_assignable<_Dp&, _UDel&&>::value
    >;

public:
  template <bool _Dummy = true,
            class = _EnableIfDeleterDefaultConstructible<_Dummy> >
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
  constexpr unique_ptr() noexcept : __ptr_(__value_init_tag(), __value_init_tag()) {}

  template <bool _Dummy = true,
            class = _EnableIfDeleterDefaultConstructible<_Dummy> >
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
  constexpr unique_ptr(nullptr_t) noexcept : __ptr_(__value_init_tag(), __value_init_tag()) {}

  template <bool _Dummy = true, class = _EnableIfDeleterDefaultConstructible<_Dummy> >
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr explicit unique_ptr(pointer __p) noexcept
      : __ptr_(__p, __value_init_tag()) {}

  template <bool _Dummy = true, class = _EnableIfDeleterConstructible<_LValRefType<_Dummy> > >
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr unique_ptr(pointer __p, _LValRefType<_Dummy> __d) noexcept
      : __ptr_(__p, __d) {}

  template <bool _Dummy = true, class = _EnableIfDeleterConstructible<_GoodRValRefType<_Dummy> > >
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
  unique_ptr(pointer __p, _GoodRValRefType<_Dummy> __d) noexcept : __ptr_(__p, std::move(__d)) {
    static_assert(!is_reference<deleter_type>::value,
                  "rvalue deleter bound to reference");
  }

  template <bool _Dummy = true,
            class = _EnableIfDeleterConstructible<_BadRValRefType<_Dummy> > >
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
  unique_ptr(pointer __p, _BadRValRefType<_Dummy> __d) = delete;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr unique_ptr(unique_ptr&& __u) noexcept
      : __ptr_(__u.release(), std::forward<deleter_type>(__u.get_deleter())) {}

  template <class _Up,
            class _Ep,
            class = _EnableIfMoveConvertible<unique_ptr<_Up, _Ep>, _Up>,
            class = _EnableIfDeleterConvertible<_Ep> >
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr unique_ptr(unique_ptr<_Up, _Ep>&& __u) noexcept
      : __ptr_(__u.release(), std::forward<_Ep>(__u.get_deleter())) {}
# 231 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__memory/unique_ptr.h" 3
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr unique_ptr& operator=(unique_ptr&& __u) noexcept {
    reset(__u.release());
    __ptr_.second() = std::forward<deleter_type>(__u.get_deleter());
    return *this;
  }

  template <class _Up,
            class _Ep,
            class = _EnableIfMoveConvertible<unique_ptr<_Up, _Ep>, _Up>,
            class = _EnableIfDeleterAssignable<_Ep> >
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr unique_ptr& operator=(unique_ptr<_Up, _Ep>&& __u) noexcept {
    reset(__u.release());
    __ptr_.second() = std::forward<_Ep>(__u.get_deleter());
    return *this;
  }
# 263 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__memory/unique_ptr.h" 3
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr ~unique_ptr() { reset(); }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr unique_ptr& operator=(nullptr_t) noexcept {
    reset();
    return *this;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr __add_lvalue_reference_t<_Tp> operator*() const {
    return *__ptr_.first();
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr pointer operator->() const noexcept {
    return __ptr_.first();
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr pointer get() const noexcept { return __ptr_.first(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr deleter_type& get_deleter() noexcept {
    return __ptr_.second();
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr const deleter_type& get_deleter() const noexcept {
    return __ptr_.second();
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr explicit operator bool() const noexcept {
    return __ptr_.first() != nullptr;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr pointer release() noexcept {
    pointer __t = __ptr_.first();
    __ptr_.first() = pointer();
    return __t;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr void reset(pointer __p = pointer()) noexcept {
    pointer __tmp = __ptr_.first();
    __ptr_.first() = __p;
    if (__tmp)
      __ptr_.second()(__tmp);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr void swap(unique_ptr& __u) noexcept {
    __ptr_.swap(__u.__ptr_);
  }
};


template <class _Tp, class _Dp>
class unique_ptr<_Tp[], _Dp> {
public:
  typedef _Tp element_type;
  typedef _Dp deleter_type;
  typedef typename __pointer<_Tp, deleter_type>::type pointer;

private:
  __compressed_pair<pointer, deleter_type> __ptr_;

  template <class _From>
  struct _CheckArrayPointerConversion : is_same<_From, pointer> {};

  template <class _FromElem>
  struct _CheckArrayPointerConversion<_FromElem*>
      : integral_constant<bool,
          is_same<_FromElem*, pointer>::value ||
            (is_same<pointer, element_type*>::value &&
             is_convertible<_FromElem(*)[], element_type(*)[]>::value)
      >
  {};

  typedef __unique_ptr_deleter_sfinae<_Dp> _DeleterSFINAE;

  template <bool _Dummy>
  using _LValRefType __attribute__((__nodebug__)) =
      typename __dependent_type<_DeleterSFINAE, _Dummy>::__lval_ref_type;

  template <bool _Dummy>
  using _GoodRValRefType __attribute__((__nodebug__)) =
      typename __dependent_type<_DeleterSFINAE, _Dummy>::__good_rval_ref_type;

  template <bool _Dummy>
  using _BadRValRefType __attribute__((__nodebug__)) =
      typename __dependent_type<_DeleterSFINAE, _Dummy>::__bad_rval_ref_type;

  template <bool _Dummy, class _Deleter = typename __dependent_type<
                             __type_identity<deleter_type>, _Dummy>::type>
  using _EnableIfDeleterDefaultConstructible __attribute__((__nodebug__)) =
      __enable_if_t<is_default_constructible<_Deleter>::value &&
                         !is_pointer<_Deleter>::value>;

  template <class _ArgType>
  using _EnableIfDeleterConstructible __attribute__((__nodebug__)) =
      __enable_if_t<is_constructible<deleter_type, _ArgType>::value>;

  template <class _Pp>
  using _EnableIfPointerConvertible __attribute__((__nodebug__)) = __enable_if_t<
      _CheckArrayPointerConversion<_Pp>::value
  >;

  template <class _UPtr, class _Up,
        class _ElemT = typename _UPtr::element_type>
  using _EnableIfMoveConvertible __attribute__((__nodebug__)) = __enable_if_t<
      is_array<_Up>::value &&
      is_same<pointer, element_type*>::value &&
      is_same<typename _UPtr::pointer, _ElemT*>::value &&
      is_convertible<_ElemT(*)[], element_type(*)[]>::value
    >;

  template <class _UDel>
  using _EnableIfDeleterConvertible __attribute__((__nodebug__)) = __enable_if_t<
      (is_reference<_Dp>::value && is_same<_Dp, _UDel>::value) ||
      (!is_reference<_Dp>::value && is_convertible<_UDel, _Dp>::value)
    >;

  template <class _UDel>
  using _EnableIfDeleterAssignable __attribute__((__nodebug__)) = __enable_if_t<
      is_assignable<_Dp&, _UDel&&>::value
    >;

public:
  template <bool _Dummy = true,
            class = _EnableIfDeleterDefaultConstructible<_Dummy> >
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
  constexpr unique_ptr() noexcept : __ptr_(__value_init_tag(), __value_init_tag()) {}

  template <bool _Dummy = true,
            class = _EnableIfDeleterDefaultConstructible<_Dummy> >
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
  constexpr unique_ptr(nullptr_t) noexcept : __ptr_(__value_init_tag(), __value_init_tag()) {}

  template <class _Pp,
            bool _Dummy = true,
            class = _EnableIfDeleterDefaultConstructible<_Dummy>,
            class = _EnableIfPointerConvertible<_Pp> >
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr explicit unique_ptr(_Pp __p) noexcept
      : __ptr_(__p, __value_init_tag()) {}

  template <class _Pp,
            bool _Dummy = true,
            class = _EnableIfDeleterConstructible<_LValRefType<_Dummy> >,
            class = _EnableIfPointerConvertible<_Pp> >
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr unique_ptr(_Pp __p, _LValRefType<_Dummy> __d) noexcept
      : __ptr_(__p, __d) {}

  template <bool _Dummy = true, class = _EnableIfDeleterConstructible<_LValRefType<_Dummy> > >
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr unique_ptr(nullptr_t, _LValRefType<_Dummy> __d) noexcept
      : __ptr_(nullptr, __d) {}

  template <class _Pp,
            bool _Dummy = true,
            class = _EnableIfDeleterConstructible<_GoodRValRefType<_Dummy> >,
            class = _EnableIfPointerConvertible<_Pp> >
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr unique_ptr(_Pp __p, _GoodRValRefType<_Dummy> __d) noexcept
      : __ptr_(__p, std::move(__d)) {
    static_assert(!is_reference<deleter_type>::value,
                  "rvalue deleter bound to reference");
  }

  template <bool _Dummy = true, class = _EnableIfDeleterConstructible<_GoodRValRefType<_Dummy> > >
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr unique_ptr(nullptr_t, _GoodRValRefType<_Dummy> __d) noexcept
      : __ptr_(nullptr, std::move(__d)) {
    static_assert(!is_reference<deleter_type>::value,
                  "rvalue deleter bound to reference");
  }

  template <class _Pp, bool _Dummy = true,
            class = _EnableIfDeleterConstructible<_BadRValRefType<_Dummy> >,
            class = _EnableIfPointerConvertible<_Pp> >
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
  unique_ptr(_Pp __p, _BadRValRefType<_Dummy> __d) = delete;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr unique_ptr(unique_ptr&& __u) noexcept
      : __ptr_(__u.release(), std::forward<deleter_type>(__u.get_deleter())) {}

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr unique_ptr& operator=(unique_ptr&& __u) noexcept {
    reset(__u.release());
    __ptr_.second() = std::forward<deleter_type>(__u.get_deleter());
    return *this;
  }

  template <class _Up,
            class _Ep,
            class = _EnableIfMoveConvertible<unique_ptr<_Up, _Ep>, _Up>,
            class = _EnableIfDeleterConvertible<_Ep> >
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr unique_ptr(unique_ptr<_Up, _Ep>&& __u) noexcept
      : __ptr_(__u.release(), std::forward<_Ep>(__u.get_deleter())) {}

  template <class _Up,
            class _Ep,
            class = _EnableIfMoveConvertible<unique_ptr<_Up, _Ep>, _Up>,
            class = _EnableIfDeleterAssignable<_Ep> >
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr unique_ptr& operator=(unique_ptr<_Up, _Ep>&& __u) noexcept {
    reset(__u.release());
    __ptr_.second() = std::forward<_Ep>(__u.get_deleter());
    return *this;
  }





public:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr ~unique_ptr() { reset(); }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr unique_ptr& operator=(nullptr_t) noexcept {
    reset();
    return *this;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr __add_lvalue_reference_t<_Tp>
  operator[](size_t __i) const {
    return __ptr_.first()[__i];
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr pointer get() const noexcept { return __ptr_.first(); }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr deleter_type& get_deleter() noexcept {
    return __ptr_.second();
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr const deleter_type& get_deleter() const noexcept {
    return __ptr_.second();
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr explicit operator bool() const noexcept {
    return __ptr_.first() != nullptr;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr pointer release() noexcept {
    pointer __t = __ptr_.first();
    __ptr_.first() = pointer();
    return __t;
  }

  template <class _Pp, __enable_if_t<_CheckArrayPointerConversion<_Pp>::value, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
  void reset(_Pp __p) noexcept {
    pointer __tmp = __ptr_.first();
    __ptr_.first() = __p;
    if (__tmp)
      __ptr_.second()(__tmp);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr void reset(nullptr_t = nullptr) noexcept {
    pointer __tmp = __ptr_.first();
    __ptr_.first() = nullptr;
    if (__tmp)
      __ptr_.second()(__tmp);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr void swap(unique_ptr& __u) noexcept {
    __ptr_.swap(__u.__ptr_);
  }
};

template <class _Tp, class _Dp, __enable_if_t<__is_swappable<_Dp>::value, int> = 0>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    void
    swap(unique_ptr<_Tp, _Dp>& __x, unique_ptr<_Tp, _Dp>& __y) noexcept {
  __x.swap(__y);
}

template <class _T1, class _D1, class _T2, class _D2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr bool
operator==(const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {
  return __x.get() == __y.get();
}
# 531 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__memory/unique_ptr.h" 3
template <class _T1, class _D1, class _T2, class _D2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
bool
operator< (const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y)
{
    typedef typename unique_ptr<_T1, _D1>::pointer _P1;
    typedef typename unique_ptr<_T2, _D2>::pointer _P2;
    typedef typename common_type<_P1, _P2>::type _Vp;
    return less<_Vp>()(__x.get(), __y.get());
}

template <class _T1, class _D1, class _T2, class _D2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
bool
operator> (const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {return __y < __x;}

template <class _T1, class _D1, class _T2, class _D2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
bool
operator<=(const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {return !(__y < __x);}

template <class _T1, class _D1, class _T2, class _D2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
bool
operator>=(const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {return !(__x < __y);}



template <class _T1, class _D1, class _T2, class _D2>
requires three_way_comparable_with<typename unique_ptr<_T1, _D1>::pointer,
                                   typename unique_ptr<_T2, _D2>::pointer>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
compare_three_way_result_t<typename unique_ptr<_T1, _D1>::pointer,
                           typename unique_ptr<_T2, _D2>::pointer>
operator<=>(const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {
   return compare_three_way()(__x.get(), __y.get());
}


template <class _T1, class _D1>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr bool
operator==(const unique_ptr<_T1, _D1>& __x, nullptr_t) noexcept {
  return !__x;
}
# 602 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__memory/unique_ptr.h" 3
template <class _T1, class _D1>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr bool
operator<(const unique_ptr<_T1, _D1>& __x, nullptr_t) {
  typedef typename unique_ptr<_T1, _D1>::pointer _P1;
  return less<_P1>()(__x.get(), nullptr);
}

template <class _T1, class _D1>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr bool
operator<(nullptr_t, const unique_ptr<_T1, _D1>& __x) {
  typedef typename unique_ptr<_T1, _D1>::pointer _P1;
  return less<_P1>()(nullptr, __x.get());
}

template <class _T1, class _D1>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr bool
operator>(const unique_ptr<_T1, _D1>& __x, nullptr_t) {
  return nullptr < __x;
}

template <class _T1, class _D1>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr bool
operator>(nullptr_t, const unique_ptr<_T1, _D1>& __x) {
  return __x < nullptr;
}

template <class _T1, class _D1>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr bool
operator<=(const unique_ptr<_T1, _D1>& __x, nullptr_t) {
  return !(nullptr < __x);
}

template <class _T1, class _D1>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr bool
operator<=(nullptr_t, const unique_ptr<_T1, _D1>& __x) {
  return !(__x < nullptr);
}

template <class _T1, class _D1>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr bool
operator>=(const unique_ptr<_T1, _D1>& __x, nullptr_t) {
  return !(__x < nullptr);
}

template <class _T1, class _D1>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr bool
operator>=(nullptr_t, const unique_ptr<_T1, _D1>& __x) {
  return !(nullptr < __x);
}


template <class _T1, class _D1>
  requires three_way_comparable<
      typename unique_ptr<_T1, _D1>::pointer> __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
      compare_three_way_result_t<typename unique_ptr<_T1, _D1>::pointer>
operator<=>(const unique_ptr<_T1, _D1>& __x, nullptr_t) {
   return compare_three_way()(__x.get(), static_cast<typename unique_ptr<_T1, _D1>::pointer>(nullptr));
}




template<class _Tp>
struct __unique_if
{
    typedef unique_ptr<_Tp> __unique_single;
};

template<class _Tp>
struct __unique_if<_Tp[]>
{
    typedef unique_ptr<_Tp[]> __unique_array_unknown_bound;
};

template<class _Tp, size_t _Np>
struct __unique_if<_Tp[_Np]>
{
    typedef void __unique_array_known_bound;
};

template <class _Tp, class... _Args>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr typename __unique_if<_Tp>::__unique_single
make_unique(_Args&&... __args) {
  return unique_ptr<_Tp>(new _Tp(std::forward<_Args>(__args)...));
}

template <class _Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr typename __unique_if<_Tp>::__unique_array_unknown_bound
make_unique(size_t __n) {
  typedef __remove_extent_t<_Tp> _Up;
  return unique_ptr<_Tp>(new _Up[__n]());
}

template<class _Tp, class... _Args>
    typename __unique_if<_Tp>::__unique_array_known_bound
    make_unique(_Args&&...) = delete;





template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr typename __unique_if<_Tp>::__unique_single
make_unique_for_overwrite() {
  return unique_ptr<_Tp>(new _Tp);
}

template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr typename __unique_if<_Tp>::__unique_array_unknown_bound
make_unique_for_overwrite(size_t __n) {
  return unique_ptr<_Tp>(new __remove_extent_t<_Tp>[__n]);
}

template<class _Tp, class... _Args>
typename __unique_if<_Tp>::__unique_array_known_bound make_unique_for_overwrite(_Args&&...) = delete;



template <class _Tp> struct hash;

template <class _Tp, class _Dp>



struct hash<__enable_hash_helper<
    unique_ptr<_Tp, _Dp>, typename unique_ptr<_Tp, _Dp>::pointer> >

{





    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    size_t operator()(const unique_ptr<_Tp, _Dp>& __ptr) const
    {
        typedef typename unique_ptr<_Tp, _Dp>::pointer pointer;
        return hash<pointer>()(__ptr.get());
    }
};

}}
# 29 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/inplace_merge.h" 2 3
# 34 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/inplace_merge.h" 3



# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__undef_macros" 1 3
# 38 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/inplace_merge.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Predicate>
class __invert
{
private:
    _Predicate __p_;
public:
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) __invert() {}

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    explicit __invert(_Predicate __p) : __p_(__p) {}

    template <class _T1>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    bool operator()(const _T1& __x) {return !__p_(__x);}

    template <class _T1, class _T2>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    bool operator()(const _T1& __x, const _T2& __y) {return __p_(__y, __x);}
};

template <class _AlgPolicy, class _Compare, class _InputIterator1, class _Sent1,
          class _InputIterator2, class _Sent2, class _OutputIterator>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
void __half_inplace_merge(_InputIterator1 __first1, _Sent1 __last1,
                          _InputIterator2 __first2, _Sent2 __last2,
                          _OutputIterator __result, _Compare&& __comp)
{
    for (; __first1 != __last1; ++__result)
    {
        if (__first2 == __last2)
        {
            std::__move<_AlgPolicy>(__first1, __last1, __result);
            return;
        }

        if (__comp(*__first2, *__first1))
        {
            *__result = _IterOps<_AlgPolicy>::__iter_move(__first2);
            ++__first2;
        }
        else
        {
            *__result = _IterOps<_AlgPolicy>::__iter_move(__first1);
            ++__first1;
        }
    }

}

template <class _AlgPolicy, class _Compare, class _BidirectionalIterator>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
void __buffered_inplace_merge(
    _BidirectionalIterator __first,
    _BidirectionalIterator __middle,
    _BidirectionalIterator __last,
    _Compare&& __comp,
    typename iterator_traits<_BidirectionalIterator>::difference_type __len1,
    typename iterator_traits<_BidirectionalIterator>::difference_type __len2,
    typename iterator_traits<_BidirectionalIterator>::value_type* __buff) {
  typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;
    __destruct_n __d(0);
    unique_ptr<value_type, __destruct_n&> __h2(__buff, __d);
    if (__len1 <= __len2)
    {
        value_type* __p = __buff;
        for (_BidirectionalIterator __i = __first; __i != __middle; __d.template __incr<value_type>(), (void) ++__i, (void) ++__p)
            ::new ((void*)__p) value_type(_IterOps<_AlgPolicy>::__iter_move(__i));
        std::__half_inplace_merge<_AlgPolicy>(__buff, __p, __middle, __last, __first, __comp);
    }
    else
    {
        value_type* __p = __buff;
        for (_BidirectionalIterator __i = __middle; __i != __last; __d.template __incr<value_type>(), (void) ++__i, (void) ++__p)
            ::new ((void*)__p) value_type(_IterOps<_AlgPolicy>::__iter_move(__i));
        typedef __unconstrained_reverse_iterator<_BidirectionalIterator> _RBi;
        typedef __unconstrained_reverse_iterator<value_type*> _Rv;
        typedef __invert<_Compare> _Inverted;
        std::__half_inplace_merge<_AlgPolicy>(_Rv(__p), _Rv(__buff),
                                    _RBi(__middle), _RBi(__first),
                                    _RBi(__last), _Inverted(__comp));
    }
}

template <class _AlgPolicy, class _Compare, class _BidirectionalIterator>
void __inplace_merge(
    _BidirectionalIterator __first,
    _BidirectionalIterator __middle,
    _BidirectionalIterator __last,
    _Compare&& __comp,
    typename iterator_traits<_BidirectionalIterator>::difference_type __len1,
    typename iterator_traits<_BidirectionalIterator>::difference_type __len2,
    typename iterator_traits<_BidirectionalIterator>::value_type* __buff,
    ptrdiff_t __buff_size) {
    using _Ops = _IterOps<_AlgPolicy>;

    typedef typename iterator_traits<_BidirectionalIterator>::difference_type difference_type;
    while (true)
    {

        if (__len2 == 0)
            return;
        if (__len1 <= __buff_size || __len2 <= __buff_size)
            return std::__buffered_inplace_merge<_AlgPolicy>
                   (__first, __middle, __last, __comp, __len1, __len2, __buff);

        for (; true; ++__first, (void) --__len1)
        {
            if (__len1 == 0)
                return;
            if (__comp(*__middle, *__first))
                break;
        }
# 161 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/inplace_merge.h" 3
        _BidirectionalIterator __m1;
        _BidirectionalIterator __m2;
        difference_type __len11;
        difference_type __len21;

        if (__len1 < __len2)
        {
            __len21 = __len2 / 2;
            __m2 = __middle;
            _Ops::advance(__m2, __len21);
            __m1 = std::__upper_bound<_AlgPolicy>(__first, __middle, *__m2, __comp, std::__identity());
            __len11 = _Ops::distance(__first, __m1);
        }
        else
        {
            if (__len1 == 1)
            {

              _Ops::iter_swap(__first, __middle);
                return;
            }

            __len11 = __len1 / 2;
            __m1 = __first;
            _Ops::advance(__m1, __len11);
            __m2 = std::lower_bound(__middle, __last, *__m1, __comp);
            __len21 = _Ops::distance(__middle, __m2);
        }
        difference_type __len12 = __len1 - __len11;
        difference_type __len22 = __len2 - __len21;


        __middle = std::__rotate<_AlgPolicy>(__m1, __middle, __m2).first;


        if (__len11 + __len21 < __len12 + __len22)
        {
            std::__inplace_merge<_AlgPolicy>(
                __first, __m1, __middle, __comp, __len11, __len21, __buff, __buff_size);
            __first = __middle;
            __middle = __m2;
            __len1 = __len12;
            __len2 = __len22;
        }
        else
        {
            std::__inplace_merge<_AlgPolicy>(
                __middle, __m2, __last, __comp, __len12, __len22, __buff, __buff_size);
            __last = __middle;
            __middle = __m1;
            __len1 = __len11;
            __len2 = __len21;
        }
    }
}

template <class _AlgPolicy, class _BidirectionalIterator, class _Compare>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
void
__inplace_merge(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last,
              _Compare&& __comp)
{
    typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;
    typedef typename iterator_traits<_BidirectionalIterator>::difference_type difference_type;
    difference_type __len1 = _IterOps<_AlgPolicy>::distance(__first, __middle);
    difference_type __len2 = _IterOps<_AlgPolicy>::distance(__middle, __last);
    difference_type __buf_size = std::min(__len1, __len2);

#pragma GCC diagnostic push
# 229 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/inplace_merge.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
# 229 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/inplace_merge.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
    pair<value_type*, ptrdiff_t> __buf = std::get_temporary_buffer<value_type>(__buf_size);
#pragma GCC diagnostic pop
    unique_ptr<value_type, __return_temporary_buffer> __h(__buf.first);
    return std::__inplace_merge<_AlgPolicy>(
        std::move(__first), std::move(__middle), std::move(__last), __comp, __len1, __len2, __buf.first, __buf.second);
}

template <class _BidirectionalIterator, class _Compare>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) void inplace_merge(
    _BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last, _Compare __comp) {
  std::__inplace_merge<_ClassicAlgPolicy>(
      std::move(__first), std::move(__middle), std::move(__last), static_cast<__comp_ref_type<_Compare> >(__comp));
}

template <class _BidirectionalIterator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
void
inplace_merge(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last)
{
    std::inplace_merge(std::move(__first), std::move(__middle), std::move(__last), __less<>());
}

}}
# 1795 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/algorithm" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/is_heap.h" 1 3
# 14 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/is_heap.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/is_heap_until.h" 1 3
# 19 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/is_heap_until.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Compare, class _RandomAccessIterator>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr _RandomAccessIterator
__is_heap_until(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare&& __comp)
{
    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
    difference_type __len = __last - __first;
    difference_type __p = 0;
    difference_type __c = 1;
    _RandomAccessIterator __pp = __first;
    while (__c < __len)
    {
        _RandomAccessIterator __cp = __first + __c;
        if (__comp(*__pp, *__cp))
            return __cp;
        ++__c;
        ++__cp;
        if (__c == __len)
            return __last;
        if (__comp(*__pp, *__cp))
            return __cp;
        ++__p;
        ++__pp;
        __c = 2 * __p + 1;
    }
    return __last;
}

template <class _RandomAccessIterator, class _Compare>
[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr _RandomAccessIterator
is_heap_until(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
{
    return std::__is_heap_until(__first, __last, static_cast<__comp_ref_type<_Compare> >(__comp));
}

template<class _RandomAccessIterator>
[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr _RandomAccessIterator
is_heap_until(_RandomAccessIterator __first, _RandomAccessIterator __last)
{
    return std::__is_heap_until(__first, __last, __less<>());
}

}}
# 15 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/is_heap.h" 2 3
# 20 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/is_heap.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _RandomAccessIterator, class _Compare>
[[__nodiscard__]] inline
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
bool
is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
{
    return std::__is_heap_until(__first, __last, static_cast<__comp_ref_type<_Compare> >(__comp)) == __last;
}

template<class _RandomAccessIterator>
[[__nodiscard__]] inline
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
bool
is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
{
    return std::is_heap(__first, __last, __less<>());
}

}}
# 1796 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/algorithm" 2 3

# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/is_partitioned.h" 1 3
# 16 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/is_partitioned.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _InputIterator, class _Predicate>
[[__nodiscard__]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr bool
is_partitioned(_InputIterator __first, _InputIterator __last, _Predicate __pred)
{
    for (; __first != __last; ++__first)
        if (!__pred(*__first))
            break;
    if ( __first == __last )
        return true;
    ++__first;
    for (; __first != __last; ++__first)
        if (__pred(*__first))
            return false;
    return true;
}

}}
# 1798 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/algorithm" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/is_permutation.h" 1 3
# 27 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/is_permutation.h" 3



# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__undef_macros" 1 3
# 31 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/is_permutation.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Iter1, class _Sent1, class _Iter2, class _Sent2, class = void>
struct _ConstTimeDistance : false_type {};



template <class _Iter1, class _Sent1, class _Iter2, class _Sent2>
struct _ConstTimeDistance<_Iter1, _Sent1, _Iter2, _Sent2, __enable_if_t<
  sized_sentinel_for<_Sent1, _Iter1> &&
  sized_sentinel_for<_Sent2, _Iter2>
>> : true_type {};
# 58 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/is_permutation.h" 3
template <class _AlgPolicy,
          class _Iter1, class _Sent1, class _Iter2, class _Sent2,
          class _Proj1, class _Proj2, class _Pred>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr bool
__is_permutation_impl(_Iter1 __first1, _Sent1 __last1, _Iter2 __first2, _Sent2 __last2,
                      _Pred&& __pred, _Proj1&& __proj1, _Proj2&& __proj2) {
  using _D1 = __iter_diff_t<_Iter1>;

  for (auto __i = __first1; __i != __last1; ++__i) {

    auto __match = __first1;
    for (; __match != __i; ++__match) {
      if (std::__invoke(__pred, std::__invoke(__proj1, *__match), std::__invoke(__proj1, *__i)))
        break;
    }

    if (__match == __i) {

      _D1 __c2 = 0;
      for (auto __j = __first2; __j != __last2; ++__j) {
        if (std::__invoke(__pred, std::__invoke(__proj1, *__i), std::__invoke(__proj2, *__j)))
          ++__c2;
      }
      if (__c2 == 0)
        return false;


      _D1 __c1 = 1;
      for (auto __j = _IterOps<_AlgPolicy>::next(__i); __j != __last1; ++__j) {
        if (std::__invoke(__pred, std::__invoke(__proj1, *__i), std::__invoke(__proj1, *__j)))
          ++__c1;
      }
      if (__c1 != __c2)
        return false;
    }
  }

  return true;
}


template <class _AlgPolicy, class _ForwardIterator1, class _Sentinel1, class _ForwardIterator2, class _BinaryPredicate>
[[__nodiscard__]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr bool
__is_permutation(_ForwardIterator1 __first1, _Sentinel1 __last1, _ForwardIterator2 __first2,
                 _BinaryPredicate&& __pred) {

  for (; __first1 != __last1; ++__first1, (void)++__first2) {
    if (!__pred(*__first1, *__first2))
      break;
  }

  if (__first1 == __last1)
    return true;


  using _D1 = __iter_diff_t<_ForwardIterator1>;
  _D1 __l1 = _IterOps<_AlgPolicy>::distance(__first1, __last1);
  if (__l1 == _D1(1))
    return false;
  auto __last2 = _IterOps<_AlgPolicy>::next(__first2, __l1);

  return std::__is_permutation_impl<_AlgPolicy>(
      std::move(__first1), std::move(__last1), std::move(__first2), std::move(__last2),
      __pred, __identity(), __identity());
}


template <class _AlgPolicy,
          class _Iter1, class _Sent1, class _Iter2, class _Sent2,
          class _Proj1, class _Proj2, class _Pred>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr bool
__is_permutation(_Iter1 __first1, _Sent1 __last1, _Iter2 __first2, _Sent2 __last2,
                 _Pred&& __pred, _Proj1&& __proj1, _Proj2&& __proj2,
                                        false_type) {

  while (__first1 != __last1 && __first2 != __last2) {
    if (!std::__invoke(__pred, std::__invoke(__proj1, *__first1), std::__invoke(__proj2, *__first2)))
      break;
    ++__first1;
    ++__first2;
  }

  if (__first1 == __last1)
    return __first2 == __last2;
  if (__first2 == __last2)
    return false;

  using _D1 = __iter_diff_t<_Iter1>;
  _D1 __l1 = _IterOps<_AlgPolicy>::distance(__first1, __last1);

  using _D2 = __iter_diff_t<_Iter2>;
  _D2 __l2 = _IterOps<_AlgPolicy>::distance(__first2, __last2);
  if (__l1 != __l2)
    return false;

  return std::__is_permutation_impl<_AlgPolicy>(
      std::move(__first1), std::move(__last1), std::move(__first2), std::move(__last2),
      __pred, __proj1, __proj2);
}


template <class _AlgPolicy,
          class _Iter1, class _Sent1, class _Iter2, class _Sent2,
          class _Proj1, class _Proj2, class _Pred>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr bool
__is_permutation(_Iter1 __first1, _Sent1 __last1, _Iter2 __first2, _Sent2 __last2,
                 _Pred&& __pred, _Proj1&& __proj1, _Proj2&& __proj2,
                                        true_type) {
  if (std::distance(__first1, __last1) != std::distance(__first2, __last2))
    return false;
  return std::__is_permutation<_AlgPolicy>(
      std::move(__first1), std::move(__last1), std::move(__first2), std::move(__last2),
      __pred, __proj1, __proj2,
                             false_type());
}


template <class _AlgPolicy,
          class _Iter1, class _Sent1, class _Iter2, class _Sent2,
          class _Proj1, class _Proj2, class _Pred>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr bool
__is_permutation(_Iter1 __first1, _Sent1 __last1, _Iter2 __first2, _Sent2 __last2,
                 _Pred&& __pred, _Proj1&& __proj1, _Proj2&& __proj2) {
  return std::__is_permutation<_AlgPolicy>(
      std::move(__first1), std::move(__last1), std::move(__first2), std::move(__last2),
      __pred, __proj1, __proj2,
      _ConstTimeDistance<_Iter1, _Sent1, _Iter2, _Sent2>());
}




template <class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>
[[__nodiscard__]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr bool
is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2,
               _BinaryPredicate __pred) {
  static_assert(__is_callable<_BinaryPredicate, decltype(*__first1), decltype(*__first2)>::value,
      "The predicate has to be callable");

  return std::__is_permutation<_ClassicAlgPolicy>(
      std::move(__first1), std::move(__last1), std::move(__first2), __pred);
}


template <class _ForwardIterator1, class _ForwardIterator2>
[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr bool
is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2) {
  return std::is_permutation(__first1, __last1, __first2, __equal_to());
}




template <class _ForwardIterator1, class _ForwardIterator2>
[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr bool is_permutation(
    _ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2, _ForwardIterator2 __last2) {
  return std::__is_permutation<_ClassicAlgPolicy>(
      std::move(__first1),
      std::move(__last1),
      std::move(__first2),
      std::move(__last2),
      __equal_to(),
      __identity(),
      __identity());
}


template <class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>
[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr bool
is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2,
               _ForwardIterator2 __last2, _BinaryPredicate __pred) {
  static_assert(__is_callable<_BinaryPredicate, decltype(*__first1), decltype(*__first2)>::value,
      "The predicate has to be callable");

  return std::__is_permutation<_ClassicAlgPolicy>(
      std::move(__first1), std::move(__last1), std::move(__first2), std::move(__last2),
      __pred, __identity(), __identity());
}



}}
# 1799 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/algorithm" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/is_sorted.h" 1 3
# 14 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/is_sorted.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/is_sorted_until.h" 1 3
# 19 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/is_sorted_until.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Compare, class _ForwardIterator>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr _ForwardIterator
__is_sorted_until(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)
{
    if (__first != __last)
    {
        _ForwardIterator __i = __first;
        while (++__i != __last)
        {
            if (__comp(*__i, *__first))
                return __i;
            __first = __i;
        }
    }
    return __last;
}

template <class _ForwardIterator, class _Compare>
[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr _ForwardIterator
is_sorted_until(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)
{
    return std::__is_sorted_until<__comp_ref_type<_Compare> >(__first, __last, __comp);
}

template<class _ForwardIterator>
[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr _ForwardIterator
is_sorted_until(_ForwardIterator __first, _ForwardIterator __last)
{
    return std::is_sorted_until(__first, __last, __less<>());
}

}}
# 15 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/is_sorted.h" 2 3
# 20 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/is_sorted.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _ForwardIterator, class _Compare>
[[__nodiscard__]] inline
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
bool
is_sorted(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)
{
    return std::__is_sorted_until<__comp_ref_type<_Compare> >(__first, __last, __comp) == __last;
}

template<class _ForwardIterator>
[[__nodiscard__]] inline
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
bool
is_sorted(_ForwardIterator __first, _ForwardIterator __last)
{
    return std::is_sorted(__first, __last, __less<>());
}

}}
# 1800 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/algorithm" 2 3


# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/lexicographical_compare.h" 1 3
# 19 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/lexicographical_compare.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Compare, class _InputIterator1, class _InputIterator2>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr bool
__lexicographical_compare(_InputIterator1 __first1, _InputIterator1 __last1,
                          _InputIterator2 __first2, _InputIterator2 __last2, _Compare __comp)
{
    for (; __first2 != __last2; ++__first1, (void) ++__first2)
    {
        if (__first1 == __last1 || __comp(*__first1, *__first2))
            return true;
        if (__comp(*__first2, *__first1))
            return false;
    }
    return false;
}

template <class _InputIterator1, class _InputIterator2, class _Compare>
[[__nodiscard__]] inline
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
bool
lexicographical_compare(_InputIterator1 __first1, _InputIterator1 __last1,
                        _InputIterator2 __first2, _InputIterator2 __last2, _Compare __comp)
{
    return std::__lexicographical_compare<__comp_ref_type<_Compare> >(__first1, __last1, __first2, __last2, __comp);
}

template <class _InputIterator1, class _InputIterator2>
[[__nodiscard__]] inline
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
bool
lexicographical_compare(_InputIterator1 __first1, _InputIterator1 __last1,
                        _InputIterator2 __first2, _InputIterator2 __last2)
{
    return std::lexicographical_compare(__first1, __last1, __first2, __last2, __less<>());
}

}}
# 1803 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/algorithm" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/lexicographical_compare_three_way.h" 1 3
# 13 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/lexicographical_compare_three_way.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/three_way_comp_ref_type.h" 1 3
# 19 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/three_way_comp_ref_type.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {



template <class _Comp>
struct __debug_three_way_comp {
  _Comp& __comp_;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr __debug_three_way_comp(_Comp& __c) : __comp_(__c) {}

  template <class _Tp, class _Up>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr auto operator()(const _Tp& __x, const _Up& __y) {
    auto __r = __comp_(__x, __y);
    if constexpr (__comparison_category<decltype(__comp_(__x, __y))>)
      __do_compare_assert(__y, __x, __r);
    return __r;
  }

  template <class _Tp, class _Up>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr auto operator()(_Tp& __x, _Up& __y) {
    auto __r = __comp_(__x, __y);
    if constexpr (__comparison_category<decltype(__comp_(__x, __y))>)
      __do_compare_assert(__y, __x, __r);
    return __r;
  }

  template <class _LHS, class _RHS, class _Order>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr void __do_compare_assert(_LHS& __l, _RHS& __r, _Order __o) {
    _Order __expected = __o;
    if (__o == _Order::less)
      __expected = _Order::greater;
    if (__o == _Order::greater)
      __expected = _Order::less;
    ((void)0);
    (void)__l;
    (void)__r;
  }
};







template <class _Comp>
using __three_way_comp_ref_type = _Comp&;




}}
# 14 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/lexicographical_compare_three_way.h" 2 3
# 25 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/lexicographical_compare_three_way.h" 3



# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__undef_macros" 1 3
# 29 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/lexicographical_compare_three_way.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {





template <class _InputIterator1, class _InputIterator2, class _Cmp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr auto __lexicographical_compare_three_way_fast_path(
    _InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _Cmp& __comp)
    -> decltype(__comp(*__first1, *__first2)) {
  static_assert(
      signed_integral<__iter_diff_t<_InputIterator1>>, "Using a non-integral difference_type is undefined behavior.");
  static_assert(
      signed_integral<__iter_diff_t<_InputIterator2>>, "Using a non-integral difference_type is undefined behavior.");

  using _Len1 = __iter_diff_t<_InputIterator1>;
  using _Len2 = __iter_diff_t<_InputIterator2>;
  using _Common = common_type_t<_Len1, _Len2>;

  _Len1 __len1 = __last1 - __first1;
  _Len2 __len2 = __last2 - __first2;
  _Common __min_len = std::min<_Common>(__len1, __len2);

  for (_Common __i = 0; __i < __min_len; ++__i) {
    auto __c = __comp(*__first1, *__first2);
    if (__c != 0) {
      return __c;
    }
    ++__first1;
    ++__first2;
  }

  return __len1 <=> __len2;
}


template <class _InputIterator1, class _InputIterator2, class _Cmp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr auto __lexicographical_compare_three_way_slow_path(
    _InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _Cmp& __comp)
    -> decltype(__comp(*__first1, *__first2)) {
  while (true) {
    bool __exhausted1 = __first1 == __last1;
    bool __exhausted2 = __first2 == __last2;

    if (__exhausted1 || __exhausted2) {
      if (!__exhausted1)
        return strong_ordering::greater;
      if (!__exhausted2)
        return strong_ordering::less;
      return strong_ordering::equal;
    }

    auto __c = __comp(*__first1, *__first2);
    if (__c != 0) {
      return __c;
    }

    ++__first1;
    ++__first2;
  }
}

template <class _InputIterator1, class _InputIterator2, class _Cmp>
[[__nodiscard__]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr auto lexicographical_compare_three_way(
    _InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _Cmp __comp)
    -> decltype(__comp(*__first1, *__first2)) {
  static_assert(__comparison_category<decltype(__comp(*__first1, *__first2))>,
                "The comparator passed to lexicographical_compare_three_way must return a comparison category type.");
  static_assert(std::is_copy_constructible_v<_InputIterator1>, "Iterators must be copy constructible.");
  static_assert(std::is_copy_constructible_v<_InputIterator2>, "Iterators must be copy constructible.");
  __three_way_comp_ref_type<_Cmp> __wrapped_comp_ref(__comp);
  if constexpr (__has_random_access_iterator_category<_InputIterator1>::value &&
                __has_random_access_iterator_category<_InputIterator2>::value) {
    return std::__lexicographical_compare_three_way_fast_path(
        std::move(__first1), std::move(__last1), std::move(__first2), std::move(__last2), __wrapped_comp_ref);
  } else {

    return std::__lexicographical_compare_three_way_slow_path(
        std::move(__first1), std::move(__last1), std::move(__first2), std::move(__last2), __wrapped_comp_ref);
  }
}

template <class _InputIterator1, class _InputIterator2>
[[__nodiscard__]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr auto lexicographical_compare_three_way(
    _InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2) {
  return std::lexicographical_compare_three_way(
      std::move(__first1), std::move(__last1), std::move(__first2), std::move(__last2), std::compare_three_way());
}



}}
# 1804 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/algorithm" 2 3

# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/make_heap.h" 1 3
# 15 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/make_heap.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/sift_down.h" 1 3
# 20 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/sift_down.h" 3



# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__undef_macros" 1 3
# 24 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/sift_down.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _AlgPolicy, class _Compare, class _RandomAccessIterator>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr void
__sift_down(_RandomAccessIterator __first, _Compare&& __comp,
            typename iterator_traits<_RandomAccessIterator>::difference_type __len,
            _RandomAccessIterator __start)
{
    using _Ops = _IterOps<_AlgPolicy>;

    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;


    difference_type __child = __start - __first;

    if (__len < 2 || (__len - 2) / 2 < __child)
        return;

    __child = 2 * __child + 1;
    _RandomAccessIterator __child_i = __first + __child;

    if ((__child + 1) < __len && __comp(*__child_i, *(__child_i + difference_type(1)))) {

        ++__child_i;
        ++__child;
    }


    if (__comp(*__child_i, *__start))

        return;

    value_type __top(_Ops::__iter_move(__start));
    do
    {

        *__start = _Ops::__iter_move(__child_i);
        __start = __child_i;

        if ((__len - 2) / 2 < __child)
            break;


        __child = 2 * __child + 1;
        __child_i = __first + __child;

        if ((__child + 1) < __len && __comp(*__child_i, *(__child_i + difference_type(1)))) {

            ++__child_i;
            ++__child;
        }


    } while (!__comp(*__child_i, __top));
    *__start = std::move(__top);
}

template <class _AlgPolicy, class _Compare, class _RandomAccessIterator>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr _RandomAccessIterator
__floyd_sift_down(_RandomAccessIterator __first, _Compare&& __comp,
                  typename iterator_traits<_RandomAccessIterator>::difference_type __len)
{
    using difference_type = typename iterator_traits<_RandomAccessIterator>::difference_type;
    ((void)0);

    _RandomAccessIterator __hole = __first;
    _RandomAccessIterator __child_i = __first;
    difference_type __child = 0;

    while (true) {
        __child_i += difference_type(__child + 1);
        __child = 2 * __child + 1;

        if ((__child + 1) < __len && __comp(*__child_i, *(__child_i + difference_type(1)))) {

            ++__child_i;
            ++__child;
        }


        *__hole = _IterOps<_AlgPolicy>::__iter_move(__child_i);
        __hole = __child_i;


        if (__child > (__len - 2) / 2)
            return __hole;
    }
}

}}
# 16 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/make_heap.h" 2 3
# 22 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/make_heap.h" 3



# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__undef_macros" 1 3
# 26 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/make_heap.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _AlgPolicy, class _Compare, class _RandomAccessIterator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
void __make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare&& __comp) {
  __comp_ref_type<_Compare> __comp_ref = __comp;

  using difference_type = typename iterator_traits<_RandomAccessIterator>::difference_type;
  difference_type __n = __last - __first;
  if (__n > 1) {

    for (difference_type __start = (__n - 2) / 2; __start >= 0; --__start) {
        std::__sift_down<_AlgPolicy>(__first, __comp_ref, __n, __first + __start);
    }
  }
}

template <class _RandomAccessIterator, class _Compare>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
void make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp) {
  std::__make_heap<_ClassicAlgPolicy>(std::move(__first), std::move(__last), __comp);
}

template <class _RandomAccessIterator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
void make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last) {
  std::make_heap(std::move(__first), std::move(__last), __less<>());
}

}}
# 1806 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/algorithm" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/max.h" 1 3
# 14 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/max.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/max_element.h" 1 3
# 19 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/max_element.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Compare, class _ForwardIterator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr _ForwardIterator
__max_element(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)
{
    static_assert(__has_forward_iterator_category<_ForwardIterator>::value,
        "std::max_element requires a ForwardIterator");
    if (__first != __last)
    {
        _ForwardIterator __i = __first;
        while (++__i != __last)
            if (__comp(*__first, *__i))
                __first = __i;
    }
    return __first;
}

template <class _ForwardIterator, class _Compare>
[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr _ForwardIterator
max_element(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)
{
    return std::__max_element<__comp_ref_type<_Compare> >(__first, __last, __comp);
}


template <class _ForwardIterator>
[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr _ForwardIterator
max_element(_ForwardIterator __first, _ForwardIterator __last)
{
    return std::max_element(__first, __last, __less<>());
}

}}
# 15 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/max.h" 2 3
# 20 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/max.h" 3



# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__undef_macros" 1 3
# 24 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/max.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Tp, class _Compare>
[[__nodiscard__]] inline
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
const _Tp&
max([[_Clang::__lifetimebound__]] const _Tp& __a, [[_Clang::__lifetimebound__]] const _Tp& __b, _Compare __comp)
{
    return __comp(__a, __b) ? __b : __a;
}

template <class _Tp>
[[__nodiscard__]] inline
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
const _Tp&
max([[_Clang::__lifetimebound__]] const _Tp& __a, [[_Clang::__lifetimebound__]] const _Tp& __b)
{
    return std::max(__a, __b, __less<>());
}



template<class _Tp, class _Compare>
[[__nodiscard__]] inline
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
_Tp
max(initializer_list<_Tp> __t, _Compare __comp)
{
    return *std::__max_element<__comp_ref_type<_Compare> >(__t.begin(), __t.end(), __comp);
}

template<class _Tp>
[[__nodiscard__]] inline
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
_Tp
max(initializer_list<_Tp> __t)
{
    return *std::max_element(__t.begin(), __t.end(), __less<>());
}



}}
# 1807 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/algorithm" 2 3

# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/merge.h" 1 3
# 20 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/merge.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
_OutputIterator
__merge(_InputIterator1 __first1, _InputIterator1 __last1,
        _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)
{
    for (; __first1 != __last1; ++__result)
    {
        if (__first2 == __last2)
            return std::copy(__first1, __last1, __result);
        if (__comp(*__first2, *__first1))
        {
            *__result = *__first2;
            ++__first2;
        }
        else
        {
            *__result = *__first1;
            ++__first1;
        }
    }
    return std::copy(__first2, __last2, __result);
}

template <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _Compare>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
_OutputIterator
merge(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)
{
    return std::__merge<__comp_ref_type<_Compare> >(__first1, __last1, __first2, __last2, __result, __comp);
}

template <class _InputIterator1, class _InputIterator2, class _OutputIterator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
_OutputIterator
merge(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)
{
    return std::merge(__first1, __last1, __first2, __last2, __result, __less<>());
}

}}
# 1809 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/algorithm" 2 3


# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/min_max_result.h" 1 3
# 19 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/min_max_result.h" 3



# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__undef_macros" 1 3
# 23 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/min_max_result.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {



namespace ranges {

template <class _T1>
struct min_max_result {
  [[__no_unique_address__]] _T1 min;
  [[__no_unique_address__]] _T1 max;

  template <class _T2>
    requires convertible_to<const _T1&, _T2>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr operator min_max_result<_T2>() const & {
    return {min, max};
  }

  template <class _T2>
    requires convertible_to<_T1, _T2>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr operator min_max_result<_T2>() && {
    return {std::move(min), std::move(max)};
  }
};

}



}}
# 1812 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/algorithm" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/minmax.h" 1 3
# 13 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/minmax.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/minmax_element.h" 1 3
# 22 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/minmax_element.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Comp, class _Proj>
class _MinmaxElementLessFunc {
  _Comp& __comp_;
  _Proj& __proj_;

public:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
  _MinmaxElementLessFunc(_Comp& __comp, _Proj& __proj) : __comp_(__comp), __proj_(__proj) {}

  template <class _Iter>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
  bool operator()(_Iter& __it1, _Iter& __it2) {
    return std::__invoke(__comp_, std::__invoke(__proj_, *__it1), std::__invoke(__proj_, *__it2));
  }
};

template <class _Iter, class _Sent, class _Proj, class _Comp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
pair<_Iter, _Iter> __minmax_element_impl(_Iter __first, _Sent __last, _Comp& __comp, _Proj& __proj) {
  auto __less = _MinmaxElementLessFunc<_Comp, _Proj>(__comp, __proj);

  pair<_Iter, _Iter> __result(__first, __first);
  if (__first == __last || ++__first == __last)
    return __result;

  if (__less(__first, __result.first))
    __result.first = __first;
  else
    __result.second = __first;

  while (++__first != __last) {
    _Iter __i = __first;
    if (++__first == __last) {
      if (__less(__i, __result.first))
        __result.first = __i;
      else if (!__less(__i, __result.second))
        __result.second = __i;
      return __result;
    }

    if (__less(__first, __i)) {
      if (__less(__first, __result.first))
        __result.first = __first;
    if (!__less(__i, __result.second))
      __result.second = __i;
    } else {
      if (__less(__i, __result.first))
        __result.first = __i;
      if (!__less(__first, __result.second))
        __result.second = __first;
    }
  }

  return __result;
}

template <class _ForwardIterator, class _Compare>
[[__nodiscard__]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
pair<_ForwardIterator, _ForwardIterator>
minmax_element(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp) {
  static_assert(__has_forward_iterator_category<_ForwardIterator>::value,
                "std::minmax_element requires a ForwardIterator");
  static_assert(__is_callable<_Compare, decltype(*__first), decltype(*__first)>::value,
                "The comparator has to be callable");
  auto __proj = __identity();
  return std::__minmax_element_impl(__first, __last, __comp, __proj);
}

template <class _ForwardIterator>
[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
pair<_ForwardIterator, _ForwardIterator> minmax_element(_ForwardIterator __first, _ForwardIterator __last) {
    return std::minmax_element(__first, __last, __less<>());
}

}}
# 14 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/minmax.h" 2 3
# 22 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/minmax.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template<class _Tp, class _Compare>
[[__nodiscard__]] inline
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
pair<const _Tp&, const _Tp&>
minmax([[_Clang::__lifetimebound__]] const _Tp& __a, [[_Clang::__lifetimebound__]] const _Tp& __b, _Compare __comp)
{
    return __comp(__b, __a) ? pair<const _Tp&, const _Tp&>(__b, __a) :
                              pair<const _Tp&, const _Tp&>(__a, __b);
}

template<class _Tp>
[[__nodiscard__]] inline
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
pair<const _Tp&, const _Tp&>
minmax([[_Clang::__lifetimebound__]] const _Tp& __a, [[_Clang::__lifetimebound__]] const _Tp& __b)
{
    return std::minmax(__a, __b, __less<>());
}



template<class _Tp, class _Compare>
[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
pair<_Tp, _Tp> minmax(initializer_list<_Tp> __t, _Compare __comp) {
    static_assert(__is_callable<_Compare, _Tp, _Tp>::value, "The comparator has to be callable");
    __identity __proj;
    auto __ret = std::__minmax_element_impl(__t.begin(), __t.end(), __comp, __proj);
    return pair<_Tp, _Tp>(*__ret.first, *__ret.second);
}

template<class _Tp>
[[__nodiscard__]] inline
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
pair<_Tp, _Tp>
minmax(initializer_list<_Tp> __t)
{
    return std::minmax(__t, __less<>());
}



}}
# 1813 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/algorithm" 2 3

# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/mismatch.h" 1 3
# 20 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/mismatch.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _InputIterator1, class _InputIterator2, class _BinaryPredicate>
[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    constexpr pair<_InputIterator1, _InputIterator2>
    mismatch(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _BinaryPredicate __pred) {
  for (; __first1 != __last1; ++__first1, (void)++__first2)
    if (!__pred(*__first1, *__first2))
      break;
  return pair<_InputIterator1, _InputIterator2>(__first1, __first2);
}

template <class _InputIterator1, class _InputIterator2>
[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    constexpr pair<_InputIterator1, _InputIterator2>
    mismatch(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2) {
  return std::mismatch(__first1, __last1, __first2, __equal_to());
}


template <class _InputIterator1, class _InputIterator2, class _BinaryPredicate>
[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    constexpr pair<_InputIterator1, _InputIterator2>
    mismatch(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2,
             _BinaryPredicate __pred) {
  for (; __first1 != __last1 && __first2 != __last2; ++__first1, (void)++__first2)
    if (!__pred(*__first1, *__first2))
      break;
  return pair<_InputIterator1, _InputIterator2>(__first1, __first2);
}

template <class _InputIterator1, class _InputIterator2>
[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    constexpr pair<_InputIterator1, _InputIterator2>
    mismatch(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2) {
  return std::mismatch(__first1, __last1, __first2, __last2, __equal_to());
}


}}
# 1815 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/algorithm" 2 3


# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/next_permutation.h" 1 3
# 15 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/next_permutation.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/reverse.h" 1 3
# 20 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/reverse.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _AlgPolicy, class _BidirectionalIterator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
void
__reverse_impl(_BidirectionalIterator __first, _BidirectionalIterator __last, bidirectional_iterator_tag)
{
    while (__first != __last)
    {
        if (__first == --__last)
            break;
        _IterOps<_AlgPolicy>::iter_swap(__first, __last);
        ++__first;
    }
}

template <class _AlgPolicy, class _RandomAccessIterator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
void
__reverse_impl(_RandomAccessIterator __first, _RandomAccessIterator __last, random_access_iterator_tag)
{
    if (__first != __last)
        for (; __first < --__last; ++__first)
            _IterOps<_AlgPolicy>::iter_swap(__first, __last);
}

template <class _AlgPolicy, class _BidirectionalIterator, class _Sentinel>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
void __reverse(_BidirectionalIterator __first, _Sentinel __last) {
  using _IterCategory = typename _IterOps<_AlgPolicy>::template __iterator_category<_BidirectionalIterator>;
  std::__reverse_impl<_AlgPolicy>(std::move(__first), std::move(__last), _IterCategory());
}

template <class _BidirectionalIterator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
void
reverse(_BidirectionalIterator __first, _BidirectionalIterator __last)
{
  std::__reverse<_ClassicAlgPolicy>(std::move(__first), std::move(__last));
}

}}
# 16 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/next_permutation.h" 2 3
# 23 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/next_permutation.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _AlgPolicy, class _Compare, class _BidirectionalIterator, class _Sentinel>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr pair<_BidirectionalIterator, bool>
__next_permutation(_BidirectionalIterator __first, _Sentinel __last, _Compare&& __comp)
{
    using _Result = pair<_BidirectionalIterator, bool>;

    _BidirectionalIterator __last_iter = _IterOps<_AlgPolicy>::next(__first, __last);
    _BidirectionalIterator __i = __last_iter;
    if (__first == __last || __first == --__i)
        return _Result(std::move(__last_iter), false);

    while (true)
    {
        _BidirectionalIterator __ip1 = __i;
        if (__comp(*--__i, *__ip1))
        {
            _BidirectionalIterator __j = __last_iter;
            while (!__comp(*__i, *--__j))
                ;
            _IterOps<_AlgPolicy>::iter_swap(__i, __j);
            std::__reverse<_AlgPolicy>(__ip1, __last_iter);
            return _Result(std::move(__last_iter), true);
        }
        if (__i == __first)
        {
            std::__reverse<_AlgPolicy>(__first, __last_iter);
            return _Result(std::move(__last_iter), false);
        }
    }
}

template <class _BidirectionalIterator, class _Compare>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
bool
next_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last, _Compare __comp)
{
  return std::__next_permutation<_ClassicAlgPolicy>(
      std::move(__first), std::move(__last), static_cast<__comp_ref_type<_Compare> >(__comp)).second;
}

template <class _BidirectionalIterator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
bool
next_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last)
{
    return std::next_permutation(__first, __last, __less<>());
}

}}
# 1818 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/algorithm" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/none_of.h" 1 3
# 17 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/none_of.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _InputIterator, class _Predicate>
[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr bool
none_of(_InputIterator __first, _InputIterator __last, _Predicate __pred) {
  for (; __first != __last; ++__first)
    if (__pred(*__first))
      return false;
  return true;
}

}}
# 1819 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/algorithm" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/nth_element.h" 1 3
# 15 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/nth_element.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/sort.h" 1 3
# 17 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/sort.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/partial_sort.h" 1 3
# 17 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/partial_sort.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/sort_heap.h" 1 3
# 15 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/sort_heap.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pop_heap.h" 1 3
# 15 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pop_heap.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/push_heap.h" 1 3
# 23 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/push_heap.h" 3



# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__undef_macros" 1 3
# 27 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/push_heap.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _AlgPolicy, class _Compare, class _RandomAccessIterator>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
void __sift_up(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare&& __comp,
        typename iterator_traits<_RandomAccessIterator>::difference_type __len) {
  using value_type = typename iterator_traits<_RandomAccessIterator>::value_type;

  if (__len > 1) {
    __len = (__len - 2) / 2;
    _RandomAccessIterator __ptr = __first + __len;

    if (__comp(*__ptr, *--__last)) {
      value_type __t(_IterOps<_AlgPolicy>::__iter_move(__last));
      do {
        *__last = _IterOps<_AlgPolicy>::__iter_move(__ptr);
        __last = __ptr;
        if (__len == 0)
          break;
        __len = (__len - 1) / 2;
        __ptr = __first + __len;
      } while (__comp(*__ptr, __t));

      *__last = std::move(__t);
    }
  }
}

template <class _AlgPolicy, class _RandomAccessIterator, class _Compare>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
void __push_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare& __comp) {
  typename iterator_traits<_RandomAccessIterator>::difference_type __len = __last - __first;
  std::__sift_up<_AlgPolicy, __comp_ref_type<_Compare> >(std::move(__first), std::move(__last), __comp, __len);
}

template <class _RandomAccessIterator, class _Compare>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
void push_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp) {
  static_assert(std::is_copy_constructible<_RandomAccessIterator>::value, "Iterators must be copy constructible.");
  static_assert(std::is_copy_assignable<_RandomAccessIterator>::value, "Iterators must be copy assignable.");

  std::__push_heap<_ClassicAlgPolicy>(std::move(__first), std::move(__last), __comp);
}

template <class _RandomAccessIterator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
void push_heap(_RandomAccessIterator __first, _RandomAccessIterator __last) {
  std::push_heap(std::move(__first), std::move(__last), __less<>());
}

}}
# 16 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pop_heap.h" 2 3
# 26 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pop_heap.h" 3



# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__undef_macros" 1 3
# 30 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pop_heap.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _AlgPolicy, class _Compare, class _RandomAccessIterator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
void __pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare& __comp,
    typename iterator_traits<_RandomAccessIterator>::difference_type __len) {
  ((void)0);

  __comp_ref_type<_Compare> __comp_ref = __comp;

  using value_type = typename iterator_traits<_RandomAccessIterator>::value_type;
  if (__len > 1) {
    value_type __top = _IterOps<_AlgPolicy>::__iter_move(__first);
    _RandomAccessIterator __hole = std::__floyd_sift_down<_AlgPolicy>(__first, __comp_ref, __len);
    --__last;

    if (__hole == __last) {
      *__hole = std::move(__top);
    } else {
      *__hole = _IterOps<_AlgPolicy>::__iter_move(__last);
      ++__hole;
      *__last = std::move(__top);
      std::__sift_up<_AlgPolicy>(__first, __hole, __comp_ref, __hole - __first);
    }
  }
}

template <class _RandomAccessIterator, class _Compare>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
void pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp) {
  static_assert(std::is_copy_constructible<_RandomAccessIterator>::value, "Iterators must be copy constructible.");
  static_assert(std::is_copy_assignable<_RandomAccessIterator>::value, "Iterators must be copy assignable.");

  typename iterator_traits<_RandomAccessIterator>::difference_type __len = __last - __first;
  std::__pop_heap<_ClassicAlgPolicy>(std::move(__first), std::move(__last), __comp, __len);
}

template <class _RandomAccessIterator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
void pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last) {
  std::pop_heap(std::move(__first), std::move(__last), __less<>());
}

}}
# 16 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/sort_heap.h" 2 3

# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__debug_utils/strict_weak_ordering_check.h" 1 3
# 22 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__debug_utils/strict_weak_ordering_check.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _RandomAccessIterator, class _Comp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr void
__check_strict_weak_ordering_sorted(_RandomAccessIterator __first, _RandomAccessIterator __last, _Comp& __comp) {
# 69 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__debug_utils/strict_weak_ordering_check.h" 3
  (void)__first;
  (void)__last;
  (void)__comp;

}

}}
# 18 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/sort_heap.h" 2 3
# 25 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/sort_heap.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _AlgPolicy, class _Compare, class _RandomAccessIterator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
void __sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare&& __comp) {
  _RandomAccessIterator __saved_last = __last;
  __comp_ref_type<_Compare> __comp_ref = __comp;

  using difference_type = typename iterator_traits<_RandomAccessIterator>::difference_type;
  for (difference_type __n = __last - __first; __n > 1; --__last, (void) --__n)
    std::__pop_heap<_AlgPolicy>(__first, __last, __comp_ref, __n);
  std::__check_strict_weak_ordering_sorted(__first, __saved_last, __comp_ref);
}

template <class _RandomAccessIterator, class _Compare>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
void sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp) {
  static_assert(std::is_copy_constructible<_RandomAccessIterator>::value, "Iterators must be copy constructible.");
  static_assert(std::is_copy_assignable<_RandomAccessIterator>::value, "Iterators must be copy assignable.");

  std::__sort_heap<_ClassicAlgPolicy>(std::move(__first), std::move(__last), __comp);
}

template <class _RandomAccessIterator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
void sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last) {
  std::sort_heap(std::move(__first), std::move(__last), __less<>());
}

}}
# 18 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/partial_sort.h" 2 3

# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__debug_utils/randomize_range.h" 1 3
# 21 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__debug_utils/randomize_range.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _AlgPolicy, class _Iterator, class _Sentinel>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
void __debug_randomize_range(_Iterator __first, _Sentinel __last) {
# 36 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__debug_utils/randomize_range.h" 3
  (void)__first;
  (void)__last;

}

}}
# 20 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/partial_sort.h" 2 3
# 27 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/partial_sort.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _AlgPolicy, class _Compare, class _RandomAccessIterator, class _Sentinel>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
_RandomAccessIterator __partial_sort_impl(
    _RandomAccessIterator __first, _RandomAccessIterator __middle, _Sentinel __last, _Compare&& __comp) {
  if (__first == __middle) {
    return _IterOps<_AlgPolicy>::next(__middle, __last);
  }

  std::__make_heap<_AlgPolicy>(__first, __middle, __comp);

  typename iterator_traits<_RandomAccessIterator>::difference_type __len = __middle - __first;
  _RandomAccessIterator __i = __middle;
  for (; __i != __last; ++__i)
  {
      if (__comp(*__i, *__first))
      {
          _IterOps<_AlgPolicy>::iter_swap(__i, __first);
          std::__sift_down<_AlgPolicy>(__first, __comp, __len, __first);
      }
  }
  std::__sort_heap<_AlgPolicy>(std::move(__first), std::move(__middle), __comp);

  return __i;
}

template <class _AlgPolicy, class _Compare, class _RandomAccessIterator, class _Sentinel>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
_RandomAccessIterator __partial_sort(_RandomAccessIterator __first, _RandomAccessIterator __middle, _Sentinel __last,
                                     _Compare& __comp) {
  if (__first == __middle)
      return _IterOps<_AlgPolicy>::next(__middle, __last);

  std::__debug_randomize_range<_AlgPolicy>(__first, __last);

  auto __last_iter =
      std::__partial_sort_impl<_AlgPolicy>(__first, __middle, __last, static_cast<__comp_ref_type<_Compare> >(__comp));

  std::__debug_randomize_range<_AlgPolicy>(__middle, __last);

  return __last_iter;
}

template <class _RandomAccessIterator, class _Compare>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
void
partial_sort(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last,
             _Compare __comp)
{
  static_assert(std::is_copy_constructible<_RandomAccessIterator>::value, "Iterators must be copy constructible.");
  static_assert(std::is_copy_assignable<_RandomAccessIterator>::value, "Iterators must be copy assignable.");

  (void)std::__partial_sort<_ClassicAlgPolicy>(std::move(__first), std::move(__middle), std::move(__last), __comp);
}

template <class _RandomAccessIterator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
void
partial_sort(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last)
{
    std::partial_sort(__first, __middle, __last, __less<>());
}

}}
# 18 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/sort.h" 2 3


# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__bit/blsr.h" 1 3
# 16 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__bit/blsr.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr unsigned __libcpp_blsr(unsigned __x) noexcept {
  return __x ^ (__x & -__x);
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr unsigned long __libcpp_blsr(unsigned long __x) noexcept {
  return __x ^ (__x & -__x);
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr unsigned long long __libcpp_blsr(unsigned long long __x) noexcept {
  return __x ^ (__x & -__x);
}

}}
# 21 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/sort.h" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__bit/countl.h" 1 3
# 20 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__bit/countl.h" 3



# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__undef_macros" 1 3
# 24 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__bit/countl.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
int __libcpp_clz(unsigned __x) noexcept { return __builtin_clz(__x); }

[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
int __libcpp_clz(unsigned long __x) noexcept { return __builtin_clzl(__x); }

[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
int __libcpp_clz(unsigned long long __x) noexcept { return __builtin_clzll(__x); }


inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
int __libcpp_clz(__uint128_t __x) noexcept {
# 48 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__bit/countl.h" 3
  return ((__x >> 64) == 0)
           ? (64 + __builtin_clzll(static_cast<unsigned long long>(__x)))
           : __builtin_clzll(static_cast<unsigned long long>(__x >> 64));
}


template<class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
int __countl_zero(_Tp __t) noexcept
{
    static_assert(__libcpp_is_unsigned_integer<_Tp>::value, "__countl_zero requires an unsigned integer type");
    if (__t == 0)
        return numeric_limits<_Tp>::digits;

    if (sizeof(_Tp) <= sizeof(unsigned int))
        return std::__libcpp_clz(static_cast<unsigned int>(__t))
              - (numeric_limits<unsigned int>::digits - numeric_limits<_Tp>::digits);
    else if (sizeof(_Tp) <= sizeof(unsigned long))
        return std::__libcpp_clz(static_cast<unsigned long>(__t))
              - (numeric_limits<unsigned long>::digits - numeric_limits<_Tp>::digits);
    else if (sizeof(_Tp) <= sizeof(unsigned long long))
        return std::__libcpp_clz(static_cast<unsigned long long>(__t))
              - (numeric_limits<unsigned long long>::digits - numeric_limits<_Tp>::digits);
    else
    {
        int __ret = 0;
        int __iter = 0;
        const unsigned int __ulldigits = numeric_limits<unsigned long long>::digits;
        while (true) {
            __t = std::__rotl(__t, __ulldigits);
            if ((__iter = std::__countl_zero(static_cast<unsigned long long>(__t))) != __ulldigits)
                break;
            __ret += __iter;
            }
        return __ret + __iter;
    }
}



template <__libcpp_unsigned_integer _Tp>
[[__nodiscard__]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr int countl_zero(_Tp __t) noexcept {
  return std::__countl_zero(__t);
}

template <__libcpp_unsigned_integer _Tp>
[[__nodiscard__]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr int countl_one(_Tp __t) noexcept {
  return __t != numeric_limits<_Tp>::max() ? std::countl_zero(static_cast<_Tp>(~__t)) : numeric_limits<_Tp>::digits;
}



}}
# 22 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/sort.h" 2 3





# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__functional/ranges_operations.h" 1 3
# 22 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__functional/ranges_operations.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {



namespace ranges {

struct equal_to {
  template <class _Tp, class _Up>
  requires equality_comparable_with<_Tp, _Up>
  [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr bool operator()(_Tp &&__t, _Up &&__u) const
      noexcept(noexcept(bool(std::forward<_Tp>(__t) == std::forward<_Up>(__u)))) {
    return std::forward<_Tp>(__t) == std::forward<_Up>(__u);
  }

  using is_transparent = void;
};

struct not_equal_to {
  template <class _Tp, class _Up>
  requires equality_comparable_with<_Tp, _Up>
  [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr bool operator()(_Tp &&__t, _Up &&__u) const
      noexcept(noexcept(bool(!(std::forward<_Tp>(__t) == std::forward<_Up>(__u))))) {
    return !(std::forward<_Tp>(__t) == std::forward<_Up>(__u));
  }

  using is_transparent = void;
};

struct less {
  template <class _Tp, class _Up>
  requires totally_ordered_with<_Tp, _Up>
  [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr bool operator()(_Tp &&__t, _Up &&__u) const
      noexcept(noexcept(bool(std::forward<_Tp>(__t) < std::forward<_Up>(__u)))) {
    return std::forward<_Tp>(__t) < std::forward<_Up>(__u);
  }

  using is_transparent = void;
};

struct less_equal {
  template <class _Tp, class _Up>
  requires totally_ordered_with<_Tp, _Up>
  [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr bool operator()(_Tp &&__t, _Up &&__u) const
      noexcept(noexcept(bool(!(std::forward<_Up>(__u) < std::forward<_Tp>(__t))))) {
    return !(std::forward<_Up>(__u) < std::forward<_Tp>(__t));
  }

  using is_transparent = void;
};

struct greater {
  template <class _Tp, class _Up>
  requires totally_ordered_with<_Tp, _Up>
  [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr bool operator()(_Tp &&__t, _Up &&__u) const
      noexcept(noexcept(bool(std::forward<_Up>(__u) < std::forward<_Tp>(__t)))) {
    return std::forward<_Up>(__u) < std::forward<_Tp>(__t);
  }

  using is_transparent = void;
};

struct greater_equal {
  template <class _Tp, class _Up>
  requires totally_ordered_with<_Tp, _Up>
  [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr bool operator()(_Tp &&__t, _Up &&__u) const
      noexcept(noexcept(bool(!(std::forward<_Tp>(__t) < std::forward<_Up>(__u))))) {
    return !(std::forward<_Tp>(__t) < std::forward<_Up>(__u));
  }

  using is_transparent = void;
};

}

template <class _Lhs, class _Rhs>
struct __is_trivial_equality_predicate<ranges::equal_to, _Lhs, _Rhs> : true_type {};



}}
# 28 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/sort.h" 2 3







# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/climits" 1 3
# 43 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/climits" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/limits.h" 1 3
# 44 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/limits.h" 3
# 66 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/limits.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/limits.h" 1 3
# 21 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/limits.h" 3
# 1 "/usr/include/limits.h" 1 3 4
# 26 "/usr/include/limits.h" 3 4
# 1 "/usr/include/bits/libc-header-start.h" 1 3 4
# 27 "/usr/include/limits.h" 2 3 4
# 183 "/usr/include/limits.h" 3 4
# 1 "/usr/include/bits/posix1_lim.h" 1 3 4
# 27 "/usr/include/bits/posix1_lim.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 28 "/usr/include/bits/posix1_lim.h" 2 3 4
# 161 "/usr/include/bits/posix1_lim.h" 3 4
# 1 "/usr/include/bits/local_lim.h" 1 3 4
# 38 "/usr/include/bits/local_lim.h" 3 4
# 1 "/usr/include/linux/limits.h" 1 3 4
# 39 "/usr/include/bits/local_lim.h" 2 3 4
# 162 "/usr/include/bits/posix1_lim.h" 2 3 4
# 184 "/usr/include/limits.h" 2 3 4



# 1 "/usr/include/bits/posix2_lim.h" 1 3 4
# 188 "/usr/include/limits.h" 2 3 4



# 1 "/usr/include/bits/xopen_lim.h" 1 3 4
# 64 "/usr/include/bits/xopen_lim.h" 3 4
# 1 "/usr/include/bits/uio_lim.h" 1 3 4
# 65 "/usr/include/bits/xopen_lim.h" 2 3 4
# 192 "/usr/include/limits.h" 2 3 4
# 22 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/limits.h" 2 3
# 67 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/limits.h" 2 3
# 44 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/climits" 2 3
# 55 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/climits" 3
# 36 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/sort.h" 2 3
# 40 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/sort.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {



template <class _AlgPolicy, class _Compare, class _ForwardIterator>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
constexpr unsigned __sort3(_ForwardIterator __x, _ForwardIterator __y, _ForwardIterator __z,
                                               _Compare __c) {
  using _Ops = _IterOps<_AlgPolicy>;

  unsigned __r = 0;
  if (!__c(*__y, *__x))
  {
    if (!__c(*__z, *__y))
      return __r;

    _Ops::iter_swap(__y, __z);
    __r = 1;
    if (__c(*__y, *__x))
    {
      _Ops::iter_swap(__x, __y);
      __r = 2;
    }
    return __r;
  }
  if (__c(*__z, *__y))
  {
    _Ops::iter_swap(__x, __z);
    __r = 1;
    return __r;
  }
  _Ops::iter_swap(__x, __y);
  __r = 1;
  if (__c(*__z, *__y))
  {
    _Ops::iter_swap(__y, __z);
    __r = 2;
  }
  return __r;
}



template <class _AlgPolicy, class _Compare, class _ForwardIterator>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
void __sort4(_ForwardIterator __x1, _ForwardIterator __x2, _ForwardIterator __x3, _ForwardIterator __x4,
                 _Compare __c) {
  using _Ops = _IterOps<_AlgPolicy>;
  std::__sort3<_AlgPolicy, _Compare>(__x1, __x2, __x3, __c);
  if (__c(*__x4, *__x3)) {
    _Ops::iter_swap(__x3, __x4);
    if (__c(*__x3, *__x2)) {
      _Ops::iter_swap(__x2, __x3);
      if (__c(*__x2, *__x1)) {
        _Ops::iter_swap(__x1, __x2);
      }
    }
  }
}



template <class _AlgPolicy, class _Comp, class _ForwardIterator>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) void __sort5(_ForwardIterator __x1, _ForwardIterator __x2, _ForwardIterator __x3,
                                   _ForwardIterator __x4, _ForwardIterator __x5, _Comp __comp) {
  using _Ops = _IterOps<_AlgPolicy>;

  std::__sort4<_AlgPolicy, _Comp>(__x1, __x2, __x3, __x4, __comp);
  if (__comp(*__x5, *__x4)) {
    _Ops::iter_swap(__x4, __x5);
    if (__comp(*__x4, *__x3)) {
      _Ops::iter_swap(__x3, __x4);
      if (__comp(*__x3, *__x2)) {
        _Ops::iter_swap(__x2, __x3);
        if (__comp(*__x2, *__x1)) {
          _Ops::iter_swap(__x1, __x2);
        }
      }
    }
  }
}


template <class _Tp>
struct __is_simple_comparator : false_type {};
template <>
struct __is_simple_comparator<__less<>&> : true_type {};
template <class _Tp>
struct __is_simple_comparator<less<_Tp>&> : true_type {};
template <class _Tp>
struct __is_simple_comparator<greater<_Tp>&> : true_type {};

template <>
struct __is_simple_comparator<ranges::less&> : true_type {};
template <>
struct __is_simple_comparator<ranges::greater&> : true_type {};


template <class _Compare, class _Iter, class _Tp = typename iterator_traits<_Iter>::value_type>
using __use_branchless_sort =
    integral_constant<bool, __libcpp_is_contiguous_iterator<_Iter>::value && sizeof(_Tp) <= sizeof(void*) &&
                                is_arithmetic<_Tp>::value && __is_simple_comparator<_Compare>::value>;

namespace __detail {


enum { __block_size = sizeof(uint64_t) * 8 };

}


template <class _Compare, class _RandomAccessIterator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) void __cond_swap(_RandomAccessIterator __x, _RandomAccessIterator __y, _Compare __c) {

  using value_type = typename iterator_traits<_RandomAccessIterator>::value_type;
  bool __r = __c(*__x, *__y);
  value_type __tmp = __r ? *__x : *__y;
  *__y = __r ? *__y : *__x;
  *__x = __tmp;
}



template <class _Compare, class _RandomAccessIterator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) void __partially_sorted_swap(_RandomAccessIterator __x, _RandomAccessIterator __y,
                                                          _RandomAccessIterator __z, _Compare __c) {

  using value_type = typename iterator_traits<_RandomAccessIterator>::value_type;
  bool __r = __c(*__z, *__x);
  value_type __tmp = __r ? *__z : *__x;
  *__z = __r ? *__x : *__z;
  __r = __c(__tmp, *__y);
  *__x = __r ? *__x : *__y;
  *__y = __r ? *__y : __tmp;
}

template <class, class _Compare, class _RandomAccessIterator,
          __enable_if_t<__use_branchless_sort<_Compare, _RandomAccessIterator>::value, int> = 0>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) void
__sort3_maybe_branchless(_RandomAccessIterator __x1, _RandomAccessIterator __x2, _RandomAccessIterator __x3,
                         _Compare __c) {
  std::__cond_swap<_Compare>(__x2, __x3, __c);
  std::__partially_sorted_swap<_Compare>(__x1, __x2, __x3, __c);
}

template <class _AlgPolicy, class _Compare, class _RandomAccessIterator,
          __enable_if_t<!__use_branchless_sort<_Compare, _RandomAccessIterator>::value, int> = 0>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) void
__sort3_maybe_branchless(_RandomAccessIterator __x1, _RandomAccessIterator __x2, _RandomAccessIterator __x3,
                         _Compare __c) {
  std::__sort3<_AlgPolicy, _Compare>(__x1, __x2, __x3, __c);
}

template <class, class _Compare, class _RandomAccessIterator,
          __enable_if_t<__use_branchless_sort<_Compare, _RandomAccessIterator>::value, int> = 0>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) void
__sort4_maybe_branchless(_RandomAccessIterator __x1, _RandomAccessIterator __x2, _RandomAccessIterator __x3,
                         _RandomAccessIterator __x4, _Compare __c) {
  std::__cond_swap<_Compare>(__x1, __x3, __c);
  std::__cond_swap<_Compare>(__x2, __x4, __c);
  std::__cond_swap<_Compare>(__x1, __x2, __c);
  std::__cond_swap<_Compare>(__x3, __x4, __c);
  std::__cond_swap<_Compare>(__x2, __x3, __c);
}

template <class _AlgPolicy, class _Compare, class _RandomAccessIterator,
          __enable_if_t<!__use_branchless_sort<_Compare, _RandomAccessIterator>::value, int> = 0>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) void
__sort4_maybe_branchless(_RandomAccessIterator __x1, _RandomAccessIterator __x2, _RandomAccessIterator __x3,
                         _RandomAccessIterator __x4, _Compare __c) {
  std::__sort4<_AlgPolicy, _Compare>(__x1, __x2, __x3, __x4, __c);
}

template <class _AlgPolicy, class _Compare, class _RandomAccessIterator,
          __enable_if_t<__use_branchless_sort<_Compare, _RandomAccessIterator>::value, int> = 0>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) void
__sort5_maybe_branchless(
    _RandomAccessIterator __x1,
    _RandomAccessIterator __x2,
    _RandomAccessIterator __x3,
    _RandomAccessIterator __x4,
    _RandomAccessIterator __x5,
    _Compare __c) {
  std::__cond_swap<_Compare>(__x1, __x2, __c);
  std::__cond_swap<_Compare>(__x4, __x5, __c);
  std::__partially_sorted_swap<_Compare>(__x3, __x4, __x5, __c);
  std::__cond_swap<_Compare>(__x2, __x5, __c);
  std::__partially_sorted_swap<_Compare>(__x1, __x3, __x4, __c);
  std::__partially_sorted_swap<_Compare>(__x2, __x3, __x4, __c);
}

template <class _AlgPolicy, class _Compare, class _RandomAccessIterator,
          __enable_if_t<!__use_branchless_sort<_Compare, _RandomAccessIterator>::value, int> = 0>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) void
__sort5_maybe_branchless(_RandomAccessIterator __x1, _RandomAccessIterator __x2, _RandomAccessIterator __x3,
                         _RandomAccessIterator __x4, _RandomAccessIterator __x5, _Compare __c) {
  std::__sort5<_AlgPolicy, _Compare, _RandomAccessIterator>(
      std::move(__x1), std::move(__x2), std::move(__x3), std::move(__x4), std::move(__x5), __c);
}


template <class _AlgPolicy, class _Compare, class _BidirectionalIterator>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
constexpr void __selection_sort(_BidirectionalIterator __first, _BidirectionalIterator __last,
                                                    _Compare __comp) {
  _BidirectionalIterator __lm1 = __last;
  for (--__lm1; __first != __lm1; ++__first) {
    _BidirectionalIterator __i = std::__min_element<_Compare>(__first, __last, __comp);
    if (__i != __first)
      _IterOps<_AlgPolicy>::iter_swap(__first, __i);
  }
}



template <class _AlgPolicy, class _Compare, class _BidirectionalIterator>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
void __insertion_sort(_BidirectionalIterator __first, _BidirectionalIterator __last, _Compare __comp) {
  using _Ops = _IterOps<_AlgPolicy>;

  typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;
  if (__first == __last)
    return;
  _BidirectionalIterator __i = __first;
  for (++__i; __i != __last; ++__i) {
    _BidirectionalIterator __j = __i;
    --__j;
    if (__comp(*__i, *__j)) {
      value_type __t(_Ops::__iter_move(__i));
      _BidirectionalIterator __k = __j;
      __j = __i;
      do {
        *__j = _Ops::__iter_move(__k);
        __j = __k;
      } while (__j != __first && __comp(__t, *--__k));
      *__j = std::move(__t);
    }
  }
}






template <class _AlgPolicy, class _Compare, class _RandomAccessIterator>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) void
__insertion_sort_unguarded(_RandomAccessIterator const __first, _RandomAccessIterator __last, _Compare __comp) {
  using _Ops = _IterOps<_AlgPolicy>;
  typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
  typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;
  if (__first == __last)
    return;
  const _RandomAccessIterator __leftmost = __first - difference_type(1); (void)__leftmost;
  for (_RandomAccessIterator __i = __first + difference_type(1); __i != __last; ++__i) {
    _RandomAccessIterator __j = __i - difference_type(1);
    if (__comp(*__i, *__j)) {
      value_type __t(_Ops::__iter_move(__i));
      _RandomAccessIterator __k = __j;
      __j = __i;
      do {
        *__j = _Ops::__iter_move(__k);
        __j = __k;
        ((void)0);


      } while (__comp(__t, *--__k));
      *__j = std::move(__t);
    }
  }
}

template <class _AlgPolicy, class _Comp, class _RandomAccessIterator>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) bool __insertion_sort_incomplete(
    _RandomAccessIterator __first, _RandomAccessIterator __last, _Comp __comp) {
  using _Ops = _IterOps<_AlgPolicy>;

  typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
  switch (__last - __first) {
  case 0:
  case 1:
    return true;
  case 2:
    if (__comp(*--__last, *__first))
      _Ops::iter_swap(__first, __last);
    return true;
  case 3:
    std::__sort3_maybe_branchless<_AlgPolicy, _Comp>(__first, __first + difference_type(1), --__last, __comp);
    return true;
  case 4:
    std::__sort4_maybe_branchless<_AlgPolicy, _Comp>(
        __first, __first + difference_type(1), __first + difference_type(2), --__last, __comp);
    return true;
  case 5:
    std::__sort5_maybe_branchless<_AlgPolicy, _Comp>(
        __first, __first + difference_type(1), __first + difference_type(2), __first + difference_type(3),
        --__last, __comp);
    return true;
  }
  typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;
  _RandomAccessIterator __j = __first + difference_type(2);
  std::__sort3_maybe_branchless<_AlgPolicy, _Comp>(__first, __first + difference_type(1), __j, __comp);
  const unsigned __limit = 8;
  unsigned __count = 0;
  for (_RandomAccessIterator __i = __j + difference_type(1); __i != __last; ++__i) {
    if (__comp(*__i, *__j)) {
      value_type __t(_Ops::__iter_move(__i));
      _RandomAccessIterator __k = __j;
      __j = __i;
      do {
        *__j = _Ops::__iter_move(__k);
        __j = __k;
      } while (__j != __first && __comp(__t, *--__k));
      *__j = std::move(__t);
      if (++__count == __limit)
        return ++__i == __last;
    }
    __j = __i;
  }
  return true;
}

template <class _AlgPolicy, class _RandomAccessIterator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) void __swap_bitmap_pos(
    _RandomAccessIterator __first, _RandomAccessIterator __last, uint64_t& __left_bitset, uint64_t& __right_bitset) {
  using _Ops = _IterOps<_AlgPolicy>;
  typedef typename std::iterator_traits<_RandomAccessIterator>::difference_type difference_type;


  while (__left_bitset != 0 && __right_bitset != 0) {
    difference_type __tz_left = __libcpp_ctz(__left_bitset);
    __left_bitset = __libcpp_blsr(__left_bitset);
    difference_type __tz_right = __libcpp_ctz(__right_bitset);
    __right_bitset = __libcpp_blsr(__right_bitset);
    _Ops::iter_swap(__first + __tz_left, __last - __tz_right);
  }
}

template <class _Compare,
          class _RandomAccessIterator,
          class _ValueType = typename iterator_traits<_RandomAccessIterator>::value_type>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) void
__populate_left_bitset(_RandomAccessIterator __first, _Compare __comp, _ValueType& __pivot, uint64_t& __left_bitset) {


  _RandomAccessIterator __iter = __first;
  for (int __j = 0; __j < __detail::__block_size;) {
    bool __comp_result = !__comp(*__iter, __pivot);
    __left_bitset |= (static_cast<uint64_t>(__comp_result) << __j);
    __j++;
    ++__iter;
  }
}

template <class _Compare,
          class _RandomAccessIterator,
          class _ValueType = typename iterator_traits<_RandomAccessIterator>::value_type>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) void
__populate_right_bitset(_RandomAccessIterator __lm1, _Compare __comp, _ValueType& __pivot, uint64_t& __right_bitset) {


  _RandomAccessIterator __iter = __lm1;
  for (int __j = 0; __j < __detail::__block_size;) {
    bool __comp_result = __comp(*__iter, __pivot);
    __right_bitset |= (static_cast<uint64_t>(__comp_result) << __j);
    __j++;
    --__iter;
  }
}

template <class _AlgPolicy,
          class _Compare,
          class _RandomAccessIterator,
          class _ValueType = typename iterator_traits<_RandomAccessIterator>::value_type>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) void __bitset_partition_partial_blocks(
    _RandomAccessIterator& __first,
    _RandomAccessIterator& __lm1,
    _Compare __comp,
    _ValueType& __pivot,
    uint64_t& __left_bitset,
    uint64_t& __right_bitset) {
  typedef typename std::iterator_traits<_RandomAccessIterator>::difference_type difference_type;
  difference_type __remaining_len = __lm1 - __first + 1;
  difference_type __l_size;
  difference_type __r_size;
  if (__left_bitset == 0 && __right_bitset == 0) {
    __l_size = __remaining_len / 2;
    __r_size = __remaining_len - __l_size;
  } else if (__left_bitset == 0) {

    __l_size = __remaining_len - __detail::__block_size;
    __r_size = __detail::__block_size;
  } else {
    __l_size = __detail::__block_size;
    __r_size = __remaining_len - __detail::__block_size;
  }

  if (__left_bitset == 0) {
    _RandomAccessIterator __iter = __first;
    for (int __j = 0; __j < __l_size; __j++) {
      bool __comp_result = !__comp(*__iter, __pivot);
      __left_bitset |= (static_cast<uint64_t>(__comp_result) << __j);
      ++__iter;
    }
  }


  if (__right_bitset == 0) {
    _RandomAccessIterator __iter = __lm1;
    for (int __j = 0; __j < __r_size; __j++) {
      bool __comp_result = __comp(*__iter, __pivot);
      __right_bitset |= (static_cast<uint64_t>(__comp_result) << __j);
      --__iter;
    }
  }
  std::__swap_bitmap_pos<_AlgPolicy, _RandomAccessIterator>(__first, __lm1, __left_bitset, __right_bitset);
  __first += (__left_bitset == 0) ? __l_size : 0;
  __lm1 -= (__right_bitset == 0) ? __r_size : 0;
}

template <class _AlgPolicy, class _RandomAccessIterator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) void __swap_bitmap_pos_within(
    _RandomAccessIterator& __first, _RandomAccessIterator& __lm1, uint64_t& __left_bitset, uint64_t& __right_bitset) {
  using _Ops = _IterOps<_AlgPolicy>;
  typedef typename std::iterator_traits<_RandomAccessIterator>::difference_type difference_type;
  if (__left_bitset) {


    while (__left_bitset != 0) {
      difference_type __tz_left = __detail::__block_size - 1 - __libcpp_clz(__left_bitset);
      __left_bitset &= (static_cast<uint64_t>(1) << __tz_left) - 1;
      _RandomAccessIterator __it = __first + __tz_left;
      if (__it != __lm1) {
        _Ops::iter_swap(__it, __lm1);
      }
      --__lm1;
    }
    __first = __lm1 + difference_type(1);
  } else if (__right_bitset) {


    while (__right_bitset != 0) {
      difference_type __tz_right = __detail::__block_size - 1 - __libcpp_clz(__right_bitset);
      __right_bitset &= (static_cast<uint64_t>(1) << __tz_right) - 1;
      _RandomAccessIterator __it = __lm1 - __tz_right;
      if (__it != __first) {
        _Ops::iter_swap(__it, __first);
      }
      ++__first;
    }
  }
}
# 503 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/sort.h" 3
template <class _AlgPolicy, class _RandomAccessIterator, class _Compare>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) std::pair<_RandomAccessIterator, bool>
__bitset_partition(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp) {
  using _Ops = _IterOps<_AlgPolicy>;
  typedef typename std::iterator_traits<_RandomAccessIterator>::value_type value_type;
  typedef typename std::iterator_traits<_RandomAccessIterator>::difference_type difference_type;
  ((void)0);
  const _RandomAccessIterator __begin = __first;
  const _RandomAccessIterator __end = __last; (void)__end;

  value_type __pivot(_Ops::__iter_move(__first));

  if (__comp(__pivot, *(__last - difference_type(1)))) {

    do {
      ++__first;
      ((void)0);


    } while (!__comp(__pivot, *__first));
  } else {
    while (++__first < __last && !__comp(__pivot, *__first)) {
    }
  }

  if (__first < __last) {


    do {
      ((void)0);


      --__last;
    } while (__comp(__pivot, *__last));
  }




  bool __already_partitioned = __first >= __last;
  if (!__already_partitioned) {
    _Ops::iter_swap(__first, __last);
    ++__first;
  }



  _RandomAccessIterator __lm1 = __last - difference_type(1);
  uint64_t __left_bitset = 0;
  uint64_t __right_bitset = 0;


  while (__lm1 - __first >= 2 * __detail::__block_size - 1) {


    if (__left_bitset == 0)
      std::__populate_left_bitset<_Compare>(__first, __comp, __pivot, __left_bitset);


    if (__right_bitset == 0)
      std::__populate_right_bitset<_Compare>(__lm1, __comp, __pivot, __right_bitset);


    std::__swap_bitmap_pos<_AlgPolicy, _RandomAccessIterator>(__first, __lm1, __left_bitset, __right_bitset);


    __first += (__left_bitset == 0) ? difference_type(__detail::__block_size) : difference_type(0);
    __lm1 -= (__right_bitset == 0) ? difference_type(__detail::__block_size) : difference_type(0);
  }


  std::__bitset_partition_partial_blocks<_AlgPolicy, _Compare>(
      __first, __lm1, __comp, __pivot, __left_bitset, __right_bitset);


  std::__swap_bitmap_pos_within<_AlgPolicy>(__first, __lm1, __left_bitset, __right_bitset);


  _RandomAccessIterator __pivot_pos = __first - difference_type(1);
  if (__begin != __pivot_pos) {
    *__begin = _Ops::__iter_move(__pivot_pos);
  }
  *__pivot_pos = std::move(__pivot);
  return std::make_pair(__pivot_pos, __already_partitioned);
}






template <class _AlgPolicy, class _RandomAccessIterator, class _Compare>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) std::pair<_RandomAccessIterator, bool>
__partition_with_equals_on_right(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp) {
  using _Ops = _IterOps<_AlgPolicy>;
  typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
  typedef typename std::iterator_traits<_RandomAccessIterator>::value_type value_type;
  ((void)0);
  const _RandomAccessIterator __begin = __first;
  const _RandomAccessIterator __end = __last; (void)__end;
  value_type __pivot(_Ops::__iter_move(__first));



  do {
    ++__first;
    ((void)0);


  } while (__comp(*__first, __pivot));


  if (__begin == __first - difference_type(1)) {
    while (__first < __last && !__comp(*--__last, __pivot))
      ;
  } else {

    do {
      ((void)0);


      --__last;
    } while (!__comp(*__last, __pivot));
  }




  bool __already_partitioned = __first >= __last;



  while (__first < __last) {
    _Ops::iter_swap(__first, __last);
    do {
      ++__first;
      ((void)0);


    } while (__comp(*__first, __pivot));
    do {
      ((void)0);


      --__last;
    } while (!__comp(*__last, __pivot));
  }

  _RandomAccessIterator __pivot_pos = __first - difference_type(1);
  if (__begin != __pivot_pos) {
    *__begin = _Ops::__iter_move(__pivot_pos);
  }
  *__pivot_pos = std::move(__pivot);
  return std::make_pair(__pivot_pos, __already_partitioned);
}



template <class _AlgPolicy, class _RandomAccessIterator, class _Compare>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) _RandomAccessIterator
__partition_with_equals_on_left(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp) {
  using _Ops = _IterOps<_AlgPolicy>;
  typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
  typedef typename std::iterator_traits<_RandomAccessIterator>::value_type value_type;

  _RandomAccessIterator __begin = __first;
  const _RandomAccessIterator __end = __last; (void)__end;
  value_type __pivot(_Ops::__iter_move(__first));
  if (__comp(__pivot, *(__last - difference_type(1)))) {

    do {
      ++__first;
      ((void)0);


    } while (!__comp(__pivot, *__first));
  } else {
    while (++__first < __last && !__comp(__pivot, *__first)) {
    }
  }

  if (__first < __last) {


    do {
      ((void)0);


      --__last;
    } while (__comp(__pivot, *__last));
  }
  while (__first < __last) {
    _Ops::iter_swap(__first, __last);
    do {
      ++__first;
      ((void)0);


    } while (!__comp(__pivot, *__first));
    do {
      ((void)0);


      --__last;
    } while (__comp(__pivot, *__last));
  }
  _RandomAccessIterator __pivot_pos = __first - difference_type(1);
  if (__begin != __pivot_pos) {
    *__begin = _Ops::__iter_move(__pivot_pos);
  }
  *__pivot_pos = std::move(__pivot);
  return __first;
}
# 724 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/sort.h" 3
template <class _AlgPolicy, class _Compare, class _RandomAccessIterator, bool _UseBitSetPartition>
void __introsort(_RandomAccessIterator __first,
                 _RandomAccessIterator __last,
                 _Compare __comp,
                 typename iterator_traits<_RandomAccessIterator>::difference_type __depth,
                 bool __leftmost = true) {
  using _Ops = _IterOps<_AlgPolicy>;
  typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
  using _Comp_ref = __comp_ref_type<_Compare>;

  constexpr difference_type __limit = 24;

  constexpr difference_type __ninther_threshold = 128;
  while (true) {
    difference_type __len = __last - __first;
    switch (__len) {
    case 0:
    case 1:
      return;
    case 2:
      if (__comp(*--__last, *__first))
        _Ops::iter_swap(__first, __last);
      return;
    case 3:
      std::__sort3_maybe_branchless<_AlgPolicy, _Compare>(__first, __first + difference_type(1), --__last, __comp);
      return;
    case 4:
      std::__sort4_maybe_branchless<_AlgPolicy, _Compare>(
          __first, __first + difference_type(1), __first + difference_type(2), --__last, __comp);
      return;
    case 5:
      std::__sort5_maybe_branchless<_AlgPolicy, _Compare>(
          __first, __first + difference_type(1), __first + difference_type(2), __first + difference_type(3),
          --__last, __comp);
      return;
    }

    if (__len < __limit) {
      if (__leftmost) {
        std::__insertion_sort<_AlgPolicy, _Compare>(__first, __last, __comp);
      } else {
        std::__insertion_sort_unguarded<_AlgPolicy, _Compare>(__first, __last, __comp);
      }
      return;
    }
    if (__depth == 0) {

      std::__partial_sort<_AlgPolicy, _Compare>(__first, __last, __last, __comp);
      return;
    }
    --__depth;
    {
      difference_type __half_len = __len / 2;


      if (__len > __ninther_threshold) {
        std::__sort3<_AlgPolicy, _Compare>(__first, __first + __half_len, __last - difference_type(1), __comp);
        std::__sort3<_AlgPolicy, _Compare>(
            __first + difference_type(1), __first + (__half_len - 1), __last - difference_type(2), __comp);
        std::__sort3<_AlgPolicy, _Compare>(
            __first + difference_type(2), __first + (__half_len + 1), __last - difference_type(3), __comp);
        std::__sort3<_AlgPolicy, _Compare>(
            __first + (__half_len - 1), __first + __half_len, __first + (__half_len + 1), __comp);
        _Ops::iter_swap(__first, __first + __half_len);
      } else {
        std::__sort3<_AlgPolicy, _Compare>(__first + __half_len, __first, __last - difference_type(1), __comp);
      }
    }
# 800 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/sort.h" 3
    if (!__leftmost && !__comp(*(__first - difference_type(1)), *__first)) {
      __first = std::__partition_with_equals_on_left<_AlgPolicy, _RandomAccessIterator, _Comp_ref>(
          __first, __last, _Comp_ref(__comp));
      continue;
    }

    auto __ret =
        _UseBitSetPartition
            ? std::__bitset_partition<_AlgPolicy, _RandomAccessIterator, _Compare>(__first, __last, __comp)
            : std::__partition_with_equals_on_right<_AlgPolicy, _RandomAccessIterator, _Compare>(__first, __last, __comp);
    _RandomAccessIterator __i = __ret.first;


    if (__ret.second) {
      bool __fs = std::__insertion_sort_incomplete<_AlgPolicy, _Compare>(__first, __i, __comp);
      if (std::__insertion_sort_incomplete<_AlgPolicy, _Compare>(__i + difference_type(1), __last, __comp)) {
        if (__fs)
          return;
        __last = __i;
        continue;
      } else {
        if (__fs) {
          __first = ++__i;
          continue;
        }
      }
    }

    std::__introsort<_AlgPolicy, _Compare, _RandomAccessIterator, _UseBitSetPartition>(
        __first, __i, __comp, __depth, __leftmost);
    __leftmost = false;
    __first = ++__i;
  }
}

template <typename _Number>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) _Number __log2i(_Number __n) {
  if (__n == 0)
    return 0;
  if (sizeof(__n) <= sizeof(unsigned))
    return sizeof(unsigned) * 8 - 1 - __libcpp_clz(static_cast<unsigned>(__n));
  if (sizeof(__n) <= sizeof(unsigned long))
    return sizeof(unsigned long) * 8 - 1 - __libcpp_clz(static_cast<unsigned long>(__n));
  if (sizeof(__n) <= sizeof(unsigned long long))
    return sizeof(unsigned long long) * 8 - 1 - __libcpp_clz(static_cast<unsigned long long>(__n));

  _Number __log2 = 0;
  while (__n > 1) {
    __log2++;
    __n >>= 1;
  }
  return __log2;
}

template <class _Comp, class _RandomAccessIterator>
void __sort(_RandomAccessIterator, _RandomAccessIterator, _Comp);

extern template __attribute__((__visibility__("default"))) void __sort<__less<char>&, char*>(char*, char*, __less<char>&);

extern template __attribute__((__visibility__("default"))) void __sort<__less<wchar_t>&, wchar_t*>(wchar_t*, wchar_t*, __less<wchar_t>&);

extern template __attribute__((__visibility__("default"))) void __sort<__less<signed char>&, signed char*>(signed char*, signed char*, __less<signed char>&);
extern template __attribute__((__visibility__("default"))) void __sort<__less<unsigned char>&, unsigned char*>(unsigned char*, unsigned char*, __less<unsigned char>&);
extern template __attribute__((__visibility__("default"))) void __sort<__less<short>&, short*>(short*, short*, __less<short>&);
extern template __attribute__((__visibility__("default"))) void __sort<__less<unsigned short>&, unsigned short*>(unsigned short*, unsigned short*, __less<unsigned short>&);
extern template __attribute__((__visibility__("default"))) void __sort<__less<int>&, int*>(int*, int*, __less<int>&);
extern template __attribute__((__visibility__("default"))) void __sort<__less<unsigned>&, unsigned*>(unsigned*, unsigned*, __less<unsigned>&);
extern template __attribute__((__visibility__("default"))) void __sort<__less<long>&, long*>(long*, long*, __less<long>&);
extern template __attribute__((__visibility__("default"))) void __sort<__less<unsigned long>&, unsigned long*>(unsigned long*, unsigned long*, __less<unsigned long>&);
extern template __attribute__((__visibility__("default"))) void __sort<__less<long long>&, long long*>(long long*, long long*, __less<long long>&);
extern template __attribute__((__visibility__("default"))) void __sort<__less<unsigned long long>&, unsigned long long*>(unsigned long long*, unsigned long long*, __less<unsigned long long>&);
extern template __attribute__((__visibility__("default"))) void __sort<__less<float>&, float*>(float*, float*, __less<float>&);
extern template __attribute__((__visibility__("default"))) void __sort<__less<double>&, double*>(double*, double*, __less<double>&);
extern template __attribute__((__visibility__("default"))) void __sort<__less<long double>&, long double*>(long double*, long double*, __less<long double>&);

template <class _AlgPolicy, class _RandomAccessIterator, class _Comp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr void
__sort_dispatch(_RandomAccessIterator __first, _RandomAccessIterator __last, _Comp& __comp) {
  typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
  difference_type __depth_limit = 2 * std::__log2i(__last - __first);




  std::__introsort<_AlgPolicy,
                   _Comp&,
                   _RandomAccessIterator,
                   __use_branchless_sort<_Comp, _RandomAccessIterator>::value>(
      __first, __last, __comp, __depth_limit);
}

template <class _Type, class... _Options>
using __is_any_of = _Or<is_same<_Type, _Options>...>;

template <class _Type>
using __sort_is_specialized_in_library = __is_any_of<
    _Type,
    char,

    wchar_t,

    signed char,
    unsigned char,
    short,
    unsigned short,
    int,
    unsigned int,
    long,
    unsigned long,
    long long,
    unsigned long long,
    float,
    double,
    long double>;

template <class _AlgPolicy, class _Type, __enable_if_t<__sort_is_specialized_in_library<_Type>::value, int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) void __sort_dispatch(_Type* __first, _Type* __last, __less<>&) {
  __less<_Type> __comp;
  std::__sort<__less<_Type>&, _Type*>(__first, __last, __comp);
}

template <class _AlgPolicy, class _Type, __enable_if_t<__sort_is_specialized_in_library<_Type>::value, int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) void __sort_dispatch(_Type* __first, _Type* __last, less<_Type>&) {
  __less<_Type> __comp;
  std::__sort<__less<_Type>&, _Type*>(__first, __last, __comp);
}


template <class _AlgPolicy, class _Type, __enable_if_t<__sort_is_specialized_in_library<_Type>::value, int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) void __sort_dispatch(_Type* __first, _Type* __last, less<>&) {
  __less<_Type> __comp;
  std::__sort<__less<_Type>&, _Type*>(__first, __last, __comp);
}



template <class _AlgPolicy, class _Type, __enable_if_t<__sort_is_specialized_in_library<_Type>::value, int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) void __sort_dispatch(_Type* __first, _Type* __last, ranges::less&) {
  __less<_Type> __comp;
  std::__sort<__less<_Type>&, _Type*>(__first, __last, __comp);
}


template <class _AlgPolicy, class _RandomAccessIterator, class _Comp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
void __sort_impl(_RandomAccessIterator __first, _RandomAccessIterator __last, _Comp& __comp) {
  std::__debug_randomize_range<_AlgPolicy>(__first, __last);

  if (__libcpp_is_constant_evaluated()) {
    std::__partial_sort<_AlgPolicy>(
        std::__unwrap_iter(__first), std::__unwrap_iter(__last), std::__unwrap_iter(__last), __comp);
  } else {
    std::__sort_dispatch<_AlgPolicy>(std::__unwrap_iter(__first), std::__unwrap_iter(__last), __comp);
  }
  std::__check_strict_weak_ordering_sorted(std::__unwrap_iter(__first), std::__unwrap_iter(__last), __comp);
}

template <class _RandomAccessIterator, class _Comp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
void sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Comp __comp) {
  std::__sort_impl<_ClassicAlgPolicy>(std::move(__first), std::move(__last), __comp);
}

template <class _RandomAccessIterator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
void sort(_RandomAccessIterator __first, _RandomAccessIterator __last) {
  std::sort(__first, __last, __less<>());
}

}}
# 16 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/nth_element.h" 2 3
# 23 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/nth_element.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template<class _Compare, class _RandomAccessIterator>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr bool
__nth_element_find_guard(_RandomAccessIterator& __i, _RandomAccessIterator& __j,
                         _RandomAccessIterator __m, _Compare __comp)
{

    while (true) {
        if (__i == --__j) {
            return false;
        }
        if (__comp(*__j, *__m)) {
            return true;
        }
    }
}

template <class _AlgPolicy, class _Compare, class _RandomAccessIterator>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr void
__nth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth, _RandomAccessIterator __last, _Compare __comp)
{
    using _Ops = _IterOps<_AlgPolicy>;


    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
    const difference_type __limit = 7;
    while (true)
    {
        if (__nth == __last)
            return;
        difference_type __len = __last - __first;
        switch (__len)
        {
        case 0:
        case 1:
            return;
        case 2:
            if (__comp(*--__last, *__first))
                _Ops::iter_swap(__first, __last);
            return;
        case 3:
            {
            _RandomAccessIterator __m = __first;
            std::__sort3<_AlgPolicy, _Compare>(__first, ++__m, --__last, __comp);
            return;
            }
        }
        if (__len <= __limit)
        {
            std::__selection_sort<_AlgPolicy, _Compare>(__first, __last, __comp);
            return;
        }

        _RandomAccessIterator __m = __first + __len/2;
        _RandomAccessIterator __lm1 = __last;
        unsigned __n_swaps = std::__sort3<_AlgPolicy, _Compare>(__first, __m, --__lm1, __comp);



        _RandomAccessIterator __i = __first;
        _RandomAccessIterator __j = __lm1;



        if (!__comp(*__i, *__m))
        {

            if (std::__nth_element_find_guard<_Compare>(__i, __j, __m, __comp)) {
                _Ops::iter_swap(__i, __j);
                ++__n_swaps;
            } else {


                ++__i;
                __j = __last;
                if (!__comp(*__first, *--__j)) {
                    while (true) {
                        if (__i == __j) {
                            return;
                        } else if (__comp(*__first, *__i)) {
                            _Ops::iter_swap(__i, __j);
                            ++__n_swaps;
                            ++__i;
                            break;
                        }
                        ++__i;
                    }
                }

                if (__i == __j) {
                    return;
                }
                while (true) {
                    while (!__comp(*__first, *__i))
                        ++__i;
                    while (__comp(*__first, *--__j))
                        ;
                    if (__i >= __j)
                        break;
                    _Ops::iter_swap(__i, __j);
                    ++__n_swaps;
                    ++__i;
                }


                if (__nth < __i) {
                    return;
                }


                __first = __i;
                continue;
            }
        }
        ++__i;


        if (__i < __j)
        {

            while (true)
            {

                while (__comp(*__i, *__m))
                    ++__i;

                while (!__comp(*--__j, *__m))
                    ;
                if (__i >= __j)
                    break;
                _Ops::iter_swap(__i, __j);
                ++__n_swaps;


                if (__m == __i)
                    __m = __j;
                ++__i;
            }
        }

        if (__i != __m && __comp(*__m, *__i))
        {
            _Ops::iter_swap(__i, __m);
            ++__n_swaps;
        }

        if (__nth == __i)
            return;
        if (__n_swaps == 0)
        {

            if (__nth < __i)
            {

                __j = __m = __first;
                while (true) {
                    if (++__j == __i) {

                        return;
                    }
                    if (__comp(*__j, *__m)) {

                        break;
                    }
                    __m = __j;
                }
            }
            else
            {

                __j = __m = __i;
                while (true) {
                    if (++__j == __last) {

                        return;
                    }
                    if (__comp(*__j, *__m)) {

                        break;
                    }
                    __m = __j;
                }
            }
        }

        if (__nth < __i)
        {

            __last = __i;
        }
        else
        {

            __first = ++__i;
        }
    }
}

template <class _AlgPolicy, class _RandomAccessIterator, class _Compare>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
void __nth_element_impl(_RandomAccessIterator __first, _RandomAccessIterator __nth, _RandomAccessIterator __last,
                        _Compare& __comp) {
  if (__nth == __last)
    return;

  std::__debug_randomize_range<_AlgPolicy>(__first, __last);

  std::__nth_element<_AlgPolicy, __comp_ref_type<_Compare> >(__first, __nth, __last, __comp);

  std::__debug_randomize_range<_AlgPolicy>(__first, __nth);
  if (__nth != __last) {
    std::__debug_randomize_range<_AlgPolicy>(++__nth, __last);
  }
}

template <class _RandomAccessIterator, class _Compare>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
void nth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth, _RandomAccessIterator __last,
                 _Compare __comp) {
  std::__nth_element_impl<_ClassicAlgPolicy>(std::move(__first), std::move(__nth), std::move(__last), __comp);
}

template <class _RandomAccessIterator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
void nth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth, _RandomAccessIterator __last) {
  std::nth_element(std::move(__first), std::move(__nth), std::move(__last), __less<>());
}

}}
# 1820 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/algorithm" 2 3

# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/partial_sort_copy.h" 1 3
# 16 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/partial_sort_copy.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/make_projected.h" 1 3
# 26 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/make_projected.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Pred, class _Proj>
struct _ProjectedPred {
  _Pred& __pred;
  _Proj& __proj;

  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) _ProjectedPred(_Pred& __pred_arg, _Proj& __proj_arg)
      : __pred(__pred_arg), __proj(__proj_arg) {}

  template <class _Tp>
  typename __invoke_of<_Pred&,
                       decltype(std::__invoke(std::declval<_Proj&>(), std::declval<_Tp>()))
  >::type
  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) operator()(_Tp&& __v) const {
    return std::__invoke(__pred, std::__invoke(__proj, std::forward<_Tp>(__v)));
  }

  template <class _T1, class _T2>
  typename __invoke_of<_Pred&,
                       decltype(std::__invoke(std::declval<_Proj&>(), std::declval<_T1>())),
                       decltype(std::__invoke(std::declval<_Proj&>(), std::declval<_T2>()))
  >::type
  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) operator()(_T1&& __lhs, _T2&& __rhs) const {
    return std::__invoke(__pred,
                      std::__invoke(__proj, std::forward<_T1>(__lhs)),
                      std::__invoke(__proj, std::forward<_T2>(__rhs)));
  }

};

template <class _Pred,
          class _Proj,
          __enable_if_t<!(!is_member_pointer<__decay_t<_Pred> >::value &&
                            __is_identity<__decay_t<_Proj> >::value),
                        int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr _ProjectedPred<_Pred, _Proj>
__make_projected(_Pred& __pred, _Proj& __proj) {
  return _ProjectedPred<_Pred, _Proj>(__pred, __proj);
}




template <class _Pred,
          class _Proj,
          __enable_if_t<!is_member_pointer<__decay_t<_Pred> >::value &&
                          __is_identity<__decay_t<_Proj> >::value,
                        int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr _Pred& __make_projected(_Pred& __pred, _Proj&) {
  return __pred;
}

}}



namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

namespace ranges {

template <class _Comp, class _Proj1, class _Proj2>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
decltype(auto) __make_projected_comp(_Comp& __comp, _Proj1& __proj1, _Proj2& __proj2) {
  if constexpr (__is_identity<decay_t<_Proj1>>::value && __is_identity<decay_t<_Proj2>>::value &&
                !is_member_pointer_v<decay_t<_Comp>>) {


    return __comp;

  } else {
    return [&](auto&& __lhs, auto&& __rhs) {
      return std::invoke(__comp,
                        std::invoke(__proj1, std::forward<decltype(__lhs)>(__lhs)),
                        std::invoke(__proj2, std::forward<decltype(__rhs)>(__rhs)));
    };
  }
}

}

}}
# 17 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/partial_sort_copy.h" 2 3
# 29 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/partial_sort_copy.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _AlgPolicy, class _Compare,
          class _InputIterator, class _Sentinel1, class _RandomAccessIterator, class _Sentinel2,
          class _Proj1, class _Proj2>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr pair<_InputIterator, _RandomAccessIterator>
__partial_sort_copy(_InputIterator __first, _Sentinel1 __last,
                    _RandomAccessIterator __result_first, _Sentinel2 __result_last,
                    _Compare&& __comp, _Proj1&& __proj1, _Proj2&& __proj2)
{
    _RandomAccessIterator __r = __result_first;
    auto&& __projected_comp = std::__make_projected(__comp, __proj2);

    if (__r != __result_last)
    {
        for (; __first != __last && __r != __result_last; ++__first, (void) ++__r)
            *__r = *__first;
        std::__make_heap<_AlgPolicy>(__result_first, __r, __projected_comp);
        typename iterator_traits<_RandomAccessIterator>::difference_type __len = __r - __result_first;
        for (; __first != __last; ++__first)
            if (std::__invoke(__comp, std::__invoke(__proj1, *__first), std::__invoke(__proj2, *__result_first))) {
                *__result_first = *__first;
                std::__sift_down<_AlgPolicy>(__result_first, __projected_comp, __len, __result_first);
            }
        std::__sort_heap<_AlgPolicy>(__result_first, __r, __projected_comp);
    }

    return pair<_InputIterator, _RandomAccessIterator>(
        _IterOps<_AlgPolicy>::next(std::move(__first), std::move(__last)), std::move(__r));
}

template <class _InputIterator, class _RandomAccessIterator, class _Compare>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
_RandomAccessIterator
partial_sort_copy(_InputIterator __first, _InputIterator __last,
                  _RandomAccessIterator __result_first, _RandomAccessIterator __result_last, _Compare __comp)
{
  static_assert(__is_callable<_Compare, decltype(*__first), decltype(*__result_first)>::value,
                "Comparator has to be callable");

  auto __result = std::__partial_sort_copy<_ClassicAlgPolicy>(__first, __last, __result_first, __result_last,
      static_cast<__comp_ref_type<_Compare> >(__comp), __identity(), __identity());
  return __result.second;
}

template <class _InputIterator, class _RandomAccessIterator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
_RandomAccessIterator
partial_sort_copy(_InputIterator __first, _InputIterator __last,
                  _RandomAccessIterator __result_first, _RandomAccessIterator __result_last)
{
    return std::partial_sort_copy(__first, __last, __result_first, __result_last, __less<>());
}

}}
# 1822 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/algorithm" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/partition.h" 1 3
# 20 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/partition.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Predicate, class _AlgPolicy, class _ForwardIterator, class _Sentinel>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr pair<_ForwardIterator, _ForwardIterator>
__partition_impl(_ForwardIterator __first, _Sentinel __last, _Predicate __pred, forward_iterator_tag)
{
    while (true)
    {
        if (__first == __last)
            return std::make_pair(std::move(__first), std::move(__first));
        if (!__pred(*__first))
            break;
        ++__first;
    }

    _ForwardIterator __p = __first;
    while (++__p != __last)
    {
        if (__pred(*__p))
        {
            _IterOps<_AlgPolicy>::iter_swap(__first, __p);
            ++__first;
        }
    }
    return std::make_pair(std::move(__first), std::move(__p));
}

template <class _Predicate, class _AlgPolicy, class _BidirectionalIterator, class _Sentinel>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr pair<_BidirectionalIterator, _BidirectionalIterator>
__partition_impl(_BidirectionalIterator __first, _Sentinel __sentinel, _Predicate __pred,
            bidirectional_iterator_tag)
{
    _BidirectionalIterator __original_last = _IterOps<_AlgPolicy>::next(__first, __sentinel);
    _BidirectionalIterator __last = __original_last;

    while (true)
    {
        while (true)
        {
            if (__first == __last)
                return std::make_pair(std::move(__first), std::move(__original_last));
            if (!__pred(*__first))
                break;
            ++__first;
        }
        do
        {
            if (__first == --__last)
                return std::make_pair(std::move(__first), std::move(__original_last));
        } while (!__pred(*__last));
        _IterOps<_AlgPolicy>::iter_swap(__first, __last);
        ++__first;
    }
}

template <class _AlgPolicy, class _ForwardIterator, class _Sentinel, class _Predicate, class _IterCategory>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
pair<_ForwardIterator, _ForwardIterator> __partition(
    _ForwardIterator __first, _Sentinel __last, _Predicate&& __pred, _IterCategory __iter_category) {
  return std::__partition_impl<__remove_cvref_t<_Predicate>&, _AlgPolicy>(
      std::move(__first), std::move(__last), __pred, __iter_category);
}

template <class _ForwardIterator, class _Predicate>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
_ForwardIterator
partition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred)
{
  using _IterCategory = typename iterator_traits<_ForwardIterator>::iterator_category;
  auto __result = std::__partition<_ClassicAlgPolicy>(std::move(__first), std::move(__last), __pred, _IterCategory());
  return __result.first;
}

}}
# 1823 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/algorithm" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/partition_copy.h" 1 3
# 18 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/partition_copy.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _InputIterator, class _OutputIterator1,
          class _OutputIterator2, class _Predicate>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr pair<_OutputIterator1, _OutputIterator2>
partition_copy(_InputIterator __first, _InputIterator __last,
               _OutputIterator1 __out_true, _OutputIterator2 __out_false,
               _Predicate __pred)
{
    for (; __first != __last; ++__first)
    {
        if (__pred(*__first))
        {
            *__out_true = *__first;
            ++__out_true;
        }
        else
        {
            *__out_false = *__first;
            ++__out_false;
        }
    }
    return pair<_OutputIterator1, _OutputIterator2>(__out_true, __out_false);
}

}}
# 1824 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/algorithm" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/partition_point.h" 1 3
# 20 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/partition_point.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template<class _ForwardIterator, class _Predicate>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr _ForwardIterator
partition_point(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred)
{
    typedef typename iterator_traits<_ForwardIterator>::difference_type difference_type;
    difference_type __len = std::distance(__first, __last);
    while (__len != 0)
    {
        difference_type __l2 = std::__half_positive(__len);
        _ForwardIterator __m = __first;
        std::advance(__m, __l2);
        if (__pred(*__m))
        {
            __first = ++__m;
            __len -= __l2 + 1;
        }
        else
            __len = __l2;
    }
    return __first;
}

}}
# 1825 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/algorithm" 2 3

# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/prev_permutation.h" 1 3
# 23 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/prev_permutation.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _AlgPolicy, class _Compare, class _BidirectionalIterator, class _Sentinel>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
pair<_BidirectionalIterator, bool>
__prev_permutation(_BidirectionalIterator __first, _Sentinel __last, _Compare&& __comp)
{
    using _Result = pair<_BidirectionalIterator, bool>;

    _BidirectionalIterator __last_iter = _IterOps<_AlgPolicy>::next(__first, __last);
    _BidirectionalIterator __i = __last_iter;
    if (__first == __last || __first == --__i)
        return _Result(std::move(__last_iter), false);

    while (true)
    {
        _BidirectionalIterator __ip1 = __i;
        if (__comp(*__ip1, *--__i))
        {
            _BidirectionalIterator __j = __last_iter;
            while (!__comp(*--__j, *__i))
                ;
            _IterOps<_AlgPolicy>::iter_swap(__i, __j);
            std::__reverse<_AlgPolicy>(__ip1, __last_iter);
            return _Result(std::move(__last_iter), true);
        }
        if (__i == __first)
        {
            std::__reverse<_AlgPolicy>(__first, __last_iter);
            return _Result(std::move(__last_iter), false);
        }
    }
}

template <class _BidirectionalIterator, class _Compare>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
bool
prev_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last, _Compare __comp)
{
  return std::__prev_permutation<_ClassicAlgPolicy>(
      std::move(__first), std::move(__last), static_cast<__comp_ref_type<_Compare> >(__comp)).second;
}

template <class _BidirectionalIterator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
bool
prev_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last)
{
    return std::prev_permutation(__first, __last, __less<>());
}

}}
# 1827 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/algorithm" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_any_all_none_of.h" 1 3
# 12 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_any_all_none_of.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_find.h" 1 3
# 14 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_find.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backend.h" 1 3
# 12 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backend.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/cpu_backend.h" 1 3
# 49 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/cpu_backend.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/cpu_backends/any_of.h" 1 3
# 14 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/cpu_backends/any_of.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/cpu_backends/backend.h" 1 3
# 18 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/cpu_backends/backend.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/cpu_backends/thread.h" 1 3
# 19 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/cpu_backends/thread.h" 3



# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__undef_macros" 1 3
# 23 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/cpu_backends/thread.h" 2 3






namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

namespace __par_backend {
inline namespace __thread_cpu_backend {

template <class _RandomAccessIterator, class _Fp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) void __parallel_for(_RandomAccessIterator __first, _RandomAccessIterator __last, _Fp __f) {
  __f(__first, __last);
}

template <class _Index, class _UnaryOp, class _Tp, class _BinaryOp, class _Reduce>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) _Tp
__parallel_transform_reduce(_Index __first, _Index __last, _UnaryOp, _Tp __init, _BinaryOp, _Reduce __reduce) {
  return __reduce(std::move(__first), std::move(__last), std::move(__init));
}

template <class _RandomAccessIterator, class _Compare, class _LeafSort>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) void __parallel_stable_sort(
    _RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp, _LeafSort __leaf_sort) {
  __leaf_sort(__first, __last, __comp);
}

__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) inline void __cancel_execution() {}

template <class _RandomAccessIterator1,
          class _RandomAccessIterator2,
          class _RandomAccessIterator3,
          class _Compare,
          class _LeafMerge>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) void __parallel_merge(
    _RandomAccessIterator1 __first1,
    _RandomAccessIterator1 __last1,
    _RandomAccessIterator2 __first2,
    _RandomAccessIterator2 __last2,
    _RandomAccessIterator3 __outit,
    _Compare __comp,
    _LeafMerge __leaf_merge) {
  __leaf_merge(__first1, __last1, __first2, __last2, __outit, __comp);
}

}
}

}}
# 19 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/cpu_backends/backend.h" 2 3
# 27 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/cpu_backends/backend.h" 3




namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

struct __cpu_backend_tag {};

inline constexpr size_t __lane_size = 64;

}}
# 15 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/cpu_backends/any_of.h" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__atomic/atomic.h" 1 3
# 12 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__atomic/atomic.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__atomic/atomic_base.h" 1 3
# 12 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__atomic/atomic_base.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__atomic/atomic_sync.h" 1 3
# 12 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__atomic/atomic_sync.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__atomic/contention_t.h" 1 3
# 12 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__atomic/contention_t.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__atomic/cxx_atomic_impl.h" 1 3
# 12 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__atomic/cxx_atomic_impl.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__atomic/is_always_lock_free.h" 1 3
# 16 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__atomic/is_always_lock_free.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Tp>
struct __libcpp_is_always_lock_free {

  static const bool __value = __atomic_always_lock_free(sizeof(_Tp), 0);
};

}}
# 13 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__atomic/cxx_atomic_impl.h" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__atomic/memory_order.h" 1 3
# 18 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__atomic/memory_order.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {




enum __legacy_memory_order {
    __mo_relaxed,
    __mo_consume,
    __mo_acquire,
    __mo_release,
    __mo_acq_rel,
    __mo_seq_cst
};

using __memory_order_underlying_t = underlying_type<__legacy_memory_order>::type;



enum class memory_order : __memory_order_underlying_t {
  relaxed = __mo_relaxed,
  consume = __mo_consume,
  acquire = __mo_acquire,
  release = __mo_release,
  acq_rel = __mo_acq_rel,
  seq_cst = __mo_seq_cst
};

static_assert((is_same<underlying_type<memory_order>::type, __memory_order_underlying_t>::value),
  "unexpected underlying type for std::memory_order");

inline constexpr auto memory_order_relaxed = memory_order::relaxed;
inline constexpr auto memory_order_consume = memory_order::consume;
inline constexpr auto memory_order_acquire = memory_order::acquire;
inline constexpr auto memory_order_release = memory_order::release;
inline constexpr auto memory_order_acq_rel = memory_order::acq_rel;
inline constexpr auto memory_order_seq_cst = memory_order::seq_cst;
# 70 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__atomic/memory_order.h" 3
}}
# 14 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__atomic/cxx_atomic_impl.h" 2 3
# 25 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__atomic/cxx_atomic_impl.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 302 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__atomic/cxx_atomic_impl.h" 3
template <typename _Tp>
struct __cxx_atomic_base_impl {

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))

    __cxx_atomic_base_impl() noexcept = default;



  constexpr explicit __cxx_atomic_base_impl(_Tp __value) noexcept
    : __a_value(__value) {}
  __extension__ _Atomic(_Tp) __a_value;
};



__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) inline
void __cxx_atomic_thread_fence(memory_order __order) noexcept {
    __c11_atomic_thread_fence(static_cast<__memory_order_underlying_t>(__order));
}

__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) inline
void __cxx_atomic_signal_fence(memory_order __order) noexcept {
    __c11_atomic_signal_fence(static_cast<__memory_order_underlying_t>(__order));
}

template<class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
void __cxx_atomic_init(__cxx_atomic_base_impl<_Tp> volatile* __a, _Tp __val) noexcept {
    __c11_atomic_init(std::addressof(__a->__a_value), __val);
}
template<class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
void __cxx_atomic_init(__cxx_atomic_base_impl<_Tp> * __a, _Tp __val) noexcept {
    __c11_atomic_init(std::addressof(__a->__a_value), __val);
}

template<class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
void __cxx_atomic_store(__cxx_atomic_base_impl<_Tp> volatile* __a, _Tp __val, memory_order __order) noexcept {
    __c11_atomic_store(std::addressof(__a->__a_value), __val, static_cast<__memory_order_underlying_t>(__order));
}
template<class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
void __cxx_atomic_store(__cxx_atomic_base_impl<_Tp> * __a, _Tp __val, memory_order __order) noexcept {
    __c11_atomic_store(std::addressof(__a->__a_value), __val, static_cast<__memory_order_underlying_t>(__order));
}

template<class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
_Tp __cxx_atomic_load(__cxx_atomic_base_impl<_Tp> const volatile* __a, memory_order __order) noexcept {
    using __ptr_type = __remove_const_t<decltype(__a->__a_value)>*;
    return __c11_atomic_load(
        const_cast<__ptr_type>(std::addressof(__a->__a_value)), static_cast<__memory_order_underlying_t>(__order));
}
template<class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
_Tp __cxx_atomic_load(__cxx_atomic_base_impl<_Tp> const* __a, memory_order __order) noexcept {
    using __ptr_type = __remove_const_t<decltype(__a->__a_value)>*;
    return __c11_atomic_load(
        const_cast<__ptr_type>(std::addressof(__a->__a_value)), static_cast<__memory_order_underlying_t>(__order));
}

template<class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
_Tp __cxx_atomic_exchange(__cxx_atomic_base_impl<_Tp> volatile* __a, _Tp __value, memory_order __order) noexcept {
    return __c11_atomic_exchange(
        std::addressof(__a->__a_value), __value, static_cast<__memory_order_underlying_t>(__order));
}
template<class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
_Tp __cxx_atomic_exchange(__cxx_atomic_base_impl<_Tp> * __a, _Tp __value, memory_order __order) noexcept {
    return __c11_atomic_exchange(
        std::addressof(__a->__a_value), __value, static_cast<__memory_order_underlying_t>(__order));
}

__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) inline constexpr memory_order __to_failure_order(memory_order __order) {

  return __order == memory_order_release ? memory_order_relaxed:
         (__order == memory_order_acq_rel ? memory_order_acquire:
             __order);
}

template<class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
bool __cxx_atomic_compare_exchange_strong(__cxx_atomic_base_impl<_Tp> volatile* __a, _Tp* __expected, _Tp __value, memory_order __success, memory_order __failure) noexcept {
  return __c11_atomic_compare_exchange_strong(
      std::addressof(__a->__a_value),
      __expected,
      __value,
      static_cast<__memory_order_underlying_t>(__success),
      static_cast<__memory_order_underlying_t>(__to_failure_order(__failure)));
}
template<class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
bool __cxx_atomic_compare_exchange_strong(__cxx_atomic_base_impl<_Tp> * __a, _Tp* __expected, _Tp __value, memory_order __success, memory_order __failure) noexcept {
  return __c11_atomic_compare_exchange_strong(
      std::addressof(__a->__a_value),
      __expected,
      __value,
      static_cast<__memory_order_underlying_t>(__success),
      static_cast<__memory_order_underlying_t>(__to_failure_order(__failure)));
}

template<class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
bool __cxx_atomic_compare_exchange_weak(__cxx_atomic_base_impl<_Tp> volatile* __a, _Tp* __expected, _Tp __value, memory_order __success, memory_order __failure) noexcept {
  return __c11_atomic_compare_exchange_weak(
      std::addressof(__a->__a_value),
      __expected,
      __value,
      static_cast<__memory_order_underlying_t>(__success),
      static_cast<__memory_order_underlying_t>(__to_failure_order(__failure)));
}
template<class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
bool __cxx_atomic_compare_exchange_weak(__cxx_atomic_base_impl<_Tp> * __a, _Tp* __expected, _Tp __value, memory_order __success, memory_order __failure) noexcept {
  return __c11_atomic_compare_exchange_weak(
      std::addressof(__a->__a_value),
      __expected,
      __value,
      static_cast<__memory_order_underlying_t>(__success),
      static_cast<__memory_order_underlying_t>(__to_failure_order(__failure)));
}

template<class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
_Tp __cxx_atomic_fetch_add(__cxx_atomic_base_impl<_Tp> volatile* __a, _Tp __delta, memory_order __order) noexcept {
  return __c11_atomic_fetch_add(
      std::addressof(__a->__a_value), __delta, static_cast<__memory_order_underlying_t>(__order));
}
template<class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
_Tp __cxx_atomic_fetch_add(__cxx_atomic_base_impl<_Tp> * __a, _Tp __delta, memory_order __order) noexcept {
  return __c11_atomic_fetch_add(
      std::addressof(__a->__a_value), __delta, static_cast<__memory_order_underlying_t>(__order));
}

template<class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
_Tp* __cxx_atomic_fetch_add(__cxx_atomic_base_impl<_Tp*> volatile* __a, ptrdiff_t __delta, memory_order __order) noexcept {
  return __c11_atomic_fetch_add(
      std::addressof(__a->__a_value), __delta, static_cast<__memory_order_underlying_t>(__order));
}
template<class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
_Tp* __cxx_atomic_fetch_add(__cxx_atomic_base_impl<_Tp*> * __a, ptrdiff_t __delta, memory_order __order) noexcept {
  return __c11_atomic_fetch_add(
      std::addressof(__a->__a_value), __delta, static_cast<__memory_order_underlying_t>(__order));
}

template<class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
_Tp __cxx_atomic_fetch_sub(__cxx_atomic_base_impl<_Tp> volatile* __a, _Tp __delta, memory_order __order) noexcept {
  return __c11_atomic_fetch_sub(
      std::addressof(__a->__a_value), __delta, static_cast<__memory_order_underlying_t>(__order));
}
template<class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
_Tp __cxx_atomic_fetch_sub(__cxx_atomic_base_impl<_Tp> * __a, _Tp __delta, memory_order __order) noexcept {
  return __c11_atomic_fetch_sub(
      std::addressof(__a->__a_value), __delta, static_cast<__memory_order_underlying_t>(__order));
}
template<class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
_Tp* __cxx_atomic_fetch_sub(__cxx_atomic_base_impl<_Tp*> volatile* __a, ptrdiff_t __delta, memory_order __order) noexcept {
  return __c11_atomic_fetch_sub(
      std::addressof(__a->__a_value), __delta, static_cast<__memory_order_underlying_t>(__order));
}
template<class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
_Tp* __cxx_atomic_fetch_sub(__cxx_atomic_base_impl<_Tp*> * __a, ptrdiff_t __delta, memory_order __order) noexcept {
  return __c11_atomic_fetch_sub(
      std::addressof(__a->__a_value), __delta, static_cast<__memory_order_underlying_t>(__order));
}

template<class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
_Tp __cxx_atomic_fetch_and(__cxx_atomic_base_impl<_Tp> volatile* __a, _Tp __pattern, memory_order __order) noexcept {
  return __c11_atomic_fetch_and(
      std::addressof(__a->__a_value), __pattern, static_cast<__memory_order_underlying_t>(__order));
}
template<class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
_Tp __cxx_atomic_fetch_and(__cxx_atomic_base_impl<_Tp> * __a, _Tp __pattern, memory_order __order) noexcept {
  return __c11_atomic_fetch_and(
      std::addressof(__a->__a_value), __pattern, static_cast<__memory_order_underlying_t>(__order));
}

template<class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
_Tp __cxx_atomic_fetch_or(__cxx_atomic_base_impl<_Tp> volatile* __a, _Tp __pattern, memory_order __order) noexcept {
  return __c11_atomic_fetch_or(
      std::addressof(__a->__a_value), __pattern, static_cast<__memory_order_underlying_t>(__order));
}
template<class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
_Tp __cxx_atomic_fetch_or(__cxx_atomic_base_impl<_Tp> * __a, _Tp __pattern, memory_order __order) noexcept {
  return __c11_atomic_fetch_or(
      std::addressof(__a->__a_value), __pattern, static_cast<__memory_order_underlying_t>(__order));
}

template<class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
_Tp __cxx_atomic_fetch_xor(__cxx_atomic_base_impl<_Tp> volatile* __a, _Tp __pattern, memory_order __order) noexcept {
  return __c11_atomic_fetch_xor(
      std::addressof(__a->__a_value), __pattern, static_cast<__memory_order_underlying_t>(__order));
}
template<class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
_Tp __cxx_atomic_fetch_xor(__cxx_atomic_base_impl<_Tp> * __a, _Tp __pattern, memory_order __order) noexcept {
  return __c11_atomic_fetch_xor(
      std::addressof(__a->__a_value), __pattern, static_cast<__memory_order_underlying_t>(__order));
}
# 815 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__atomic/cxx_atomic_impl.h" 3
template <typename _Tp,
          typename _Base = __cxx_atomic_base_impl<_Tp> >

struct __cxx_atomic_impl : public _Base {
    static_assert(is_trivially_copyable<_Tp>::value,
      "std::atomic<T> requires that 'T' be a trivially copyable type");

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) __cxx_atomic_impl() noexcept = default;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr explicit __cxx_atomic_impl(_Tp __value) noexcept
    : _Base(__value) {}
};

}}
# 13 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__atomic/contention_t.h" 2 3
# 18 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__atomic/contention_t.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {


    using __cxx_contention_t = int32_t;




using __cxx_atomic_contention_t = __cxx_atomic_impl<__cxx_contention_t>;

}}
# 13 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__atomic/atomic_sync.h" 2 3



# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__chrono/duration.h" 1 3
# 21 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__chrono/duration.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/ratio" 1 3
# 93 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/ratio" 3



# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__undef_macros" 1 3
# 97 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/ratio" 2 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {



template <intmax_t _Xp, intmax_t _Yp>
struct __static_gcd
{
    static const intmax_t value = __static_gcd<_Yp, _Xp % _Yp>::value;
};

template <intmax_t _Xp>
struct __static_gcd<_Xp, 0>
{
    static const intmax_t value = _Xp;
};

template <>
struct __static_gcd<0, 0>
{
    static const intmax_t value = 1;
};



template <intmax_t _Xp, intmax_t _Yp>
struct __static_lcm
{
    static const intmax_t value = _Xp / __static_gcd<_Xp, _Yp>::value * _Yp;
};

template <intmax_t _Xp>
struct __static_abs
{
    static const intmax_t value = _Xp < 0 ? -_Xp : _Xp;
};

template <intmax_t _Xp>
struct __static_sign
{
    static const intmax_t value = _Xp == 0 ? 0 : (_Xp < 0 ? -1 : 1);
};

template <intmax_t _Xp, intmax_t _Yp, intmax_t = __static_sign<_Yp>::value>
class __ll_add;

template <intmax_t _Xp, intmax_t _Yp>
class __ll_add<_Xp, _Yp, 1>
{
    static const intmax_t min = (1LL << (sizeof(intmax_t) * 8 - 1)) + 1;
    static const intmax_t max = -min;

    static_assert(_Xp <= max - _Yp, "overflow in __ll_add");
public:
    static const intmax_t value = _Xp + _Yp;
};

template <intmax_t _Xp, intmax_t _Yp>
class __ll_add<_Xp, _Yp, 0>
{
public:
    static const intmax_t value = _Xp;
};

template <intmax_t _Xp, intmax_t _Yp>
class __ll_add<_Xp, _Yp, -1>
{
    static const intmax_t min = (1LL << (sizeof(intmax_t) * 8 - 1)) + 1;
    static const intmax_t max = -min;

    static_assert(min - _Yp <= _Xp, "overflow in __ll_add");
public:
    static const intmax_t value = _Xp + _Yp;
};

template <intmax_t _Xp, intmax_t _Yp, intmax_t = __static_sign<_Yp>::value>
class __ll_sub;

template <intmax_t _Xp, intmax_t _Yp>
class __ll_sub<_Xp, _Yp, 1>
{
    static const intmax_t min = (1LL << (sizeof(intmax_t) * 8 - 1)) + 1;
    static const intmax_t max = -min;

    static_assert(min + _Yp <= _Xp, "overflow in __ll_sub");
public:
    static const intmax_t value = _Xp - _Yp;
};

template <intmax_t _Xp, intmax_t _Yp>
class __ll_sub<_Xp, _Yp, 0>
{
public:
    static const intmax_t value = _Xp;
};

template <intmax_t _Xp, intmax_t _Yp>
class __ll_sub<_Xp, _Yp, -1>
{
    static const intmax_t min = (1LL << (sizeof(intmax_t) * 8 - 1)) + 1;
    static const intmax_t max = -min;

    static_assert(_Xp <= max + _Yp, "overflow in __ll_sub");
public:
    static const intmax_t value = _Xp - _Yp;
};

template <intmax_t _Xp, intmax_t _Yp>
class __ll_mul
{
    static const intmax_t nan = (1LL << (sizeof(intmax_t) * 8 - 1));
    static const intmax_t min = nan + 1;
    static const intmax_t max = -min;
    static const intmax_t __a_x = __static_abs<_Xp>::value;
    static const intmax_t __a_y = __static_abs<_Yp>::value;

    static_assert(_Xp != nan && _Yp != nan && __a_x <= max / __a_y, "overflow in __ll_mul");
public:
    static const intmax_t value = _Xp * _Yp;
};

template <intmax_t _Yp>
class __ll_mul<0, _Yp>
{
public:
    static const intmax_t value = 0;
};

template <intmax_t _Xp>
class __ll_mul<_Xp, 0>
{
public:
    static const intmax_t value = 0;
};

template <>
class __ll_mul<0, 0>
{
public:
    static const intmax_t value = 0;
};


template <intmax_t _Xp, intmax_t _Yp>
class __ll_div
{
    static const intmax_t nan = (1LL << (sizeof(intmax_t) * 8 - 1));
    static const intmax_t min = nan + 1;
    static const intmax_t max = -min;

    static_assert(_Xp != nan && _Yp != nan && _Yp != 0, "overflow in __ll_div");
public:
    static const intmax_t value = _Xp / _Yp;
};

template <intmax_t _Num, intmax_t _Den = 1>
class ratio
{
    static_assert(__static_abs<_Num>::value >= 0, "ratio numerator is out of range");
    static_assert(_Den != 0, "ratio divide by 0");
    static_assert(__static_abs<_Den>::value > 0, "ratio denominator is out of range");
    static constexpr const intmax_t __na = __static_abs<_Num>::value;
    static constexpr const intmax_t __da = __static_abs<_Den>::value;
    static constexpr const intmax_t __s = __static_sign<_Num>::value * __static_sign<_Den>::value;
    static constexpr const intmax_t __gcd = __static_gcd<__na, __da>::value;
public:
    static constexpr const intmax_t num = __s * __na / __gcd;
    static constexpr const intmax_t den = __da / __gcd;

    typedef ratio<num, den> type;
};

template <intmax_t _Num, intmax_t _Den>
constexpr const intmax_t ratio<_Num, _Den>::num;

template <intmax_t _Num, intmax_t _Den>
constexpr const intmax_t ratio<_Num, _Den>::den;

template <class _Tp> struct __is_ratio : false_type {};
template <intmax_t _Num, intmax_t _Den> struct __is_ratio<ratio<_Num, _Den> > : true_type {};

typedef ratio<1LL, 1000000000000000000LL> atto;
typedef ratio<1LL, 1000000000000000LL> femto;
typedef ratio<1LL, 1000000000000LL> pico;
typedef ratio<1LL, 1000000000LL> nano;
typedef ratio<1LL, 1000000LL> micro;
typedef ratio<1LL, 1000LL> milli;
typedef ratio<1LL, 100LL> centi;
typedef ratio<1LL, 10LL> deci;
typedef ratio< 10LL, 1LL> deca;
typedef ratio< 100LL, 1LL> hecto;
typedef ratio< 1000LL, 1LL> kilo;
typedef ratio< 1000000LL, 1LL> mega;
typedef ratio< 1000000000LL, 1LL> giga;
typedef ratio< 1000000000000LL, 1LL> tera;
typedef ratio< 1000000000000000LL, 1LL> peta;
typedef ratio<1000000000000000000LL, 1LL> exa;

template <class _R1, class _R2>
struct __ratio_multiply
{
private:
    static const intmax_t __gcd_n1_d2 = __static_gcd<_R1::num, _R2::den>::value;
    static const intmax_t __gcd_d1_n2 = __static_gcd<_R1::den, _R2::num>::value;
public:
    typedef typename ratio
        <
            __ll_mul<_R1::num / __gcd_n1_d2, _R2::num / __gcd_d1_n2>::value,
            __ll_mul<_R2::den / __gcd_n1_d2, _R1::den / __gcd_d1_n2>::value
        >::type type;
};



template <class _R1, class _R2> using ratio_multiply
                                    = typename __ratio_multiply<_R1, _R2>::type;
# 323 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/ratio" 3
template <class _R1, class _R2>
struct __ratio_divide
{
private:
    static const intmax_t __gcd_n1_n2 = __static_gcd<_R1::num, _R2::num>::value;
    static const intmax_t __gcd_d1_d2 = __static_gcd<_R1::den, _R2::den>::value;
public:
    typedef typename ratio
        <
            __ll_mul<_R1::num / __gcd_n1_n2, _R2::den / __gcd_d1_d2>::value,
            __ll_mul<_R2::num / __gcd_n1_n2, _R1::den / __gcd_d1_d2>::value
        >::type type;
};



template <class _R1, class _R2> using ratio_divide
                                      = typename __ratio_divide<_R1, _R2>::type;
# 350 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/ratio" 3
template <class _R1, class _R2>
struct __ratio_add
{
private:
    static const intmax_t __gcd_n1_n2 = __static_gcd<_R1::num, _R2::num>::value;
    static const intmax_t __gcd_d1_d2 = __static_gcd<_R1::den, _R2::den>::value;
public:
    typedef typename ratio_multiply
        <
            ratio<__gcd_n1_n2, _R1::den / __gcd_d1_d2>,
            ratio
            <
                __ll_add
                <
                    __ll_mul<_R1::num / __gcd_n1_n2, _R2::den / __gcd_d1_d2>::value,
                    __ll_mul<_R2::num / __gcd_n1_n2, _R1::den / __gcd_d1_d2>::value
                >::value,
                _R2::den
            >
        >::type type;
};



template <class _R1, class _R2> using ratio_add
                                         = typename __ratio_add<_R1, _R2>::type;
# 385 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/ratio" 3
template <class _R1, class _R2>
struct __ratio_subtract
{
private:
    static const intmax_t __gcd_n1_n2 = __static_gcd<_R1::num, _R2::num>::value;
    static const intmax_t __gcd_d1_d2 = __static_gcd<_R1::den, _R2::den>::value;
public:
    typedef typename ratio_multiply
        <
            ratio<__gcd_n1_n2, _R1::den / __gcd_d1_d2>,
            ratio
            <
                __ll_sub
                <
                    __ll_mul<_R1::num / __gcd_n1_n2, _R2::den / __gcd_d1_d2>::value,
                    __ll_mul<_R2::num / __gcd_n1_n2, _R1::den / __gcd_d1_d2>::value
                >::value,
                _R2::den
            >
        >::type type;
};



template <class _R1, class _R2> using ratio_subtract
                                    = typename __ratio_subtract<_R1, _R2>::type;
# 422 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/ratio" 3
template <class _R1, class _R2>
struct ratio_equal
    : _BoolConstant<(_R1::num == _R2::num && _R1::den == _R2::den)> {};

template <class _R1, class _R2>
struct ratio_not_equal
    : _BoolConstant<!ratio_equal<_R1, _R2>::value> {};



template <class _R1, class _R2, bool _Odd = false,
          intmax_t _Q1 = _R1::num / _R1::den, intmax_t _M1 = _R1::num % _R1::den,
          intmax_t _Q2 = _R2::num / _R2::den, intmax_t _M2 = _R2::num % _R2::den>
struct __ratio_less1
{
    static const bool value = _Odd ? _Q2 < _Q1 : _Q1 < _Q2;
};

template <class _R1, class _R2, bool _Odd, intmax_t _Qp>
struct __ratio_less1<_R1, _R2, _Odd, _Qp, 0, _Qp, 0>
{
    static const bool value = false;
};

template <class _R1, class _R2, bool _Odd, intmax_t _Qp, intmax_t _M2>
struct __ratio_less1<_R1, _R2, _Odd, _Qp, 0, _Qp, _M2>
{
    static const bool value = !_Odd;
};

template <class _R1, class _R2, bool _Odd, intmax_t _Qp, intmax_t _M1>
struct __ratio_less1<_R1, _R2, _Odd, _Qp, _M1, _Qp, 0>
{
    static const bool value = _Odd;
};

template <class _R1, class _R2, bool _Odd, intmax_t _Qp, intmax_t _M1,
                                                        intmax_t _M2>
struct __ratio_less1<_R1, _R2, _Odd, _Qp, _M1, _Qp, _M2>
{
    static const bool value = __ratio_less1<ratio<_R1::den, _M1>,
                                            ratio<_R2::den, _M2>, !_Odd>::value;
};

template <class _R1, class _R2, intmax_t _S1 = __static_sign<_R1::num>::value,
                                intmax_t _S2 = __static_sign<_R2::num>::value>
struct __ratio_less
{
    static const bool value = _S1 < _S2;
};

template <class _R1, class _R2>
struct __ratio_less<_R1, _R2, 1LL, 1LL>
{
    static const bool value = __ratio_less1<_R1, _R2>::value;
};

template <class _R1, class _R2>
struct __ratio_less<_R1, _R2, -1LL, -1LL>
{
    static const bool value = __ratio_less1<ratio<-_R2::num, _R2::den>, ratio<-_R1::num, _R1::den> >::value;
};

template <class _R1, class _R2>
struct ratio_less
    : _BoolConstant<__ratio_less<_R1, _R2>::value> {};

template <class _R1, class _R2>
struct ratio_less_equal
    : _BoolConstant<!ratio_less<_R2, _R1>::value> {};

template <class _R1, class _R2>
struct ratio_greater
    : _BoolConstant<ratio_less<_R2, _R1>::value> {};

template <class _R1, class _R2>
struct ratio_greater_equal
    : _BoolConstant<!ratio_less<_R1, _R2>::value> {};

template <class _R1, class _R2>
struct __ratio_gcd
{
    typedef ratio<__static_gcd<_R1::num, _R2::num>::value,
                  __static_lcm<_R1::den, _R2::den>::value> type;
};


template <class _R1, class _R2>
inline constexpr bool ratio_equal_v = ratio_equal<_R1, _R2>::value;

template <class _R1, class _R2>
inline constexpr bool ratio_not_equal_v = ratio_not_equal<_R1, _R2>::value;

template <class _R1, class _R2>
inline constexpr bool ratio_less_v = ratio_less<_R1, _R2>::value;

template <class _R1, class _R2>
inline constexpr bool ratio_less_equal_v = ratio_less_equal<_R1, _R2>::value;

template <class _R1, class _R2>
inline constexpr bool ratio_greater_v = ratio_greater<_R1, _R2>::value;

template <class _R1, class _R2>
inline constexpr bool ratio_greater_equal_v = ratio_greater_equal<_R1, _R2>::value;


}}
# 22 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__chrono/duration.h" 2 3
# 25 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__chrono/duration.h" 3



# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__undef_macros" 1 3
# 29 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__chrono/duration.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

namespace chrono
{

template <class _Rep, class _Period = ratio<1> > class duration;

template <class _Tp>
struct __is_duration : false_type {};

template <class _Rep, class _Period>
struct __is_duration<duration<_Rep, _Period> > : true_type {};

template <class _Rep, class _Period>
struct __is_duration<const duration<_Rep, _Period> > : true_type {};

template <class _Rep, class _Period>
struct __is_duration<volatile duration<_Rep, _Period> > : true_type {};

template <class _Rep, class _Period>
struct __is_duration<const volatile duration<_Rep, _Period> > : true_type {};

}

template <class _Rep1, class _Period1, class _Rep2, class _Period2>
struct common_type<chrono::duration<_Rep1, _Period1>,
                                         chrono::duration<_Rep2, _Period2> >
{
    typedef chrono::duration<typename common_type<_Rep1, _Rep2>::type,
                             typename __ratio_gcd<_Period1, _Period2>::type> type;
};

namespace chrono {



template <class _FromDuration, class _ToDuration,
          class _Period = typename ratio_divide<typename _FromDuration::period, typename _ToDuration::period>::type,
          bool = _Period::num == 1,
          bool = _Period::den == 1>
struct __duration_cast;

template <class _FromDuration, class _ToDuration, class _Period>
struct __duration_cast<_FromDuration, _ToDuration, _Period, true, true>
{
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    _ToDuration operator()(const _FromDuration& __fd) const
    {
        return _ToDuration(static_cast<typename _ToDuration::rep>(__fd.count()));
    }
};

template <class _FromDuration, class _ToDuration, class _Period>
struct __duration_cast<_FromDuration, _ToDuration, _Period, true, false>
{
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    _ToDuration operator()(const _FromDuration& __fd) const
    {
        typedef typename common_type<typename _ToDuration::rep, typename _FromDuration::rep, intmax_t>::type _Ct;
        return _ToDuration(static_cast<typename _ToDuration::rep>(
                           static_cast<_Ct>(__fd.count()) / static_cast<_Ct>(_Period::den)));
    }
};

template <class _FromDuration, class _ToDuration, class _Period>
struct __duration_cast<_FromDuration, _ToDuration, _Period, false, true>
{
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    _ToDuration operator()(const _FromDuration& __fd) const
    {
        typedef typename common_type<typename _ToDuration::rep, typename _FromDuration::rep, intmax_t>::type _Ct;
        return _ToDuration(static_cast<typename _ToDuration::rep>(
                           static_cast<_Ct>(__fd.count()) * static_cast<_Ct>(_Period::num)));
    }
};

template <class _FromDuration, class _ToDuration, class _Period>
struct __duration_cast<_FromDuration, _ToDuration, _Period, false, false>
{
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    _ToDuration operator()(const _FromDuration& __fd) const
    {
        typedef typename common_type<typename _ToDuration::rep, typename _FromDuration::rep, intmax_t>::type _Ct;
        return _ToDuration(static_cast<typename _ToDuration::rep>(
                           static_cast<_Ct>(__fd.count()) * static_cast<_Ct>(_Period::num)
                                                          / static_cast<_Ct>(_Period::den)));
    }
};

template <class _ToDuration, class _Rep, class _Period, __enable_if_t<__is_duration<_ToDuration>::value, int> = 0>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
constexpr
_ToDuration
duration_cast(const duration<_Rep, _Period>& __fd)
{
    return __duration_cast<duration<_Rep, _Period>, _ToDuration>()(__fd);
}

template <class _Rep>
struct treat_as_floating_point : is_floating_point<_Rep> {};


template <class _Rep>
inline constexpr bool treat_as_floating_point_v = treat_as_floating_point<_Rep>::value;


template <class _Rep>
struct duration_values
{
public:
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) static constexpr _Rep zero() noexcept {return _Rep(0);}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) static constexpr _Rep max() noexcept {return numeric_limits<_Rep>::max();}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) static constexpr _Rep min() noexcept {return numeric_limits<_Rep>::lowest();}
};


template <class _ToDuration, class _Rep, class _Period, enable_if_t<__is_duration<_ToDuration>::value, int> = 0>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
_ToDuration
floor(const duration<_Rep, _Period>& __d)
{
    _ToDuration __t = chrono::duration_cast<_ToDuration>(__d);
    if (__t > __d)
        __t = __t - _ToDuration{1};
    return __t;
}

template <class _ToDuration, class _Rep, class _Period, enable_if_t<__is_duration<_ToDuration>::value, int> = 0>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
_ToDuration
ceil(const duration<_Rep, _Period>& __d)
{
    _ToDuration __t = chrono::duration_cast<_ToDuration>(__d);
    if (__t < __d)
        __t = __t + _ToDuration{1};
    return __t;
}

template <class _ToDuration, class _Rep, class _Period, enable_if_t<__is_duration<_ToDuration>::value, int> = 0>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
_ToDuration
round(const duration<_Rep, _Period>& __d)
{
    _ToDuration __lower = chrono::floor<_ToDuration>(__d);
    _ToDuration __upper = __lower + _ToDuration{1};
    auto __lower_diff = __d - __lower;
    auto __upper_diff = __upper - __d;
    if (__lower_diff < __upper_diff)
        return __lower;
    if (__lower_diff > __upper_diff)
        return __upper;
    return __lower.count() & 1 ? __upper : __lower;
}




template <class _Rep, class _Period>
class duration
{
    static_assert(!__is_duration<_Rep>::value, "A duration representation can not be a duration");
    static_assert(__is_ratio<_Period>::value, "Second template parameter of duration must be a std::ratio");
    static_assert(_Period::num > 0, "duration period must be positive");

    template <class _R1, class _R2>
    struct __no_overflow
    {
    private:
        static const intmax_t __gcd_n1_n2 = __static_gcd<_R1::num, _R2::num>::value;
        static const intmax_t __gcd_d1_d2 = __static_gcd<_R1::den, _R2::den>::value;
        static const intmax_t __n1 = _R1::num / __gcd_n1_n2;
        static const intmax_t __d1 = _R1::den / __gcd_d1_d2;
        static const intmax_t __n2 = _R2::num / __gcd_n1_n2;
        static const intmax_t __d2 = _R2::den / __gcd_d1_d2;
        static const intmax_t max = -((intmax_t(1) << (sizeof(intmax_t) * 8 - 1)) + 1);

        template <intmax_t _Xp, intmax_t _Yp, bool __overflow>
        struct __mul
        {
            static const intmax_t value = _Xp * _Yp;
        };

        template <intmax_t _Xp, intmax_t _Yp>
        struct __mul<_Xp, _Yp, true>
        {
            static const intmax_t value = 1;
        };

    public:
        static const bool value = (__n1 <= max / __d2) && (__n2 <= max / __d1);
        typedef ratio<__mul<__n1, __d2, !value>::value,
                      __mul<__n2, __d1, !value>::value> type;
    };

public:
    typedef _Rep rep;
    typedef typename _Period::type period;
private:
    rep __rep_;
public:


        constexpr duration() = default;




    template <class _Rep2, __enable_if_t<is_convertible<const _Rep2&, rep>::value &&
                                         (treat_as_floating_point<rep>::value ||
                                          !treat_as_floating_point<_Rep2>::value), int> = 0>
        __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
        explicit duration(const _Rep2& __r)
                : __rep_(__r) {}


    template <class _Rep2, class _Period2, __enable_if_t<__no_overflow<_Period2, period>::value && (
                                                            treat_as_floating_point<rep>::value ||
                                                            (__no_overflow<_Period2, period>::type::den == 1 &&
                                                             !treat_as_floating_point<_Rep2>::value)), int> = 0>
        __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
        duration(const duration<_Rep2, _Period2>& __d)
                : __rep_(chrono::duration_cast<duration>(__d).count()) {}



    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr rep count() const {return __rep_;}



    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr typename common_type<duration>::type operator+() const {return typename common_type<duration>::type(*this);}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr typename common_type<duration>::type operator-() const {return typename common_type<duration>::type(-__rep_);}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr duration& operator++() {++__rep_; return *this;}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr duration operator++(int) {return duration(__rep_++);}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr duration& operator--() {--__rep_; return *this;}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr duration operator--(int) {return duration(__rep_--);}

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr duration& operator+=(const duration& __d) {__rep_ += __d.count(); return *this;}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr duration& operator-=(const duration& __d) {__rep_ -= __d.count(); return *this;}

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr duration& operator*=(const rep& __rhs) {__rep_ *= __rhs; return *this;}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr duration& operator/=(const rep& __rhs) {__rep_ /= __rhs; return *this;}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr duration& operator%=(const rep& __rhs) {__rep_ %= __rhs; return *this;}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr duration& operator%=(const duration& __rhs) {__rep_ %= __rhs.count(); return *this;}



    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) static constexpr duration zero() noexcept {return duration(duration_values<rep>::zero());}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) static constexpr duration min() noexcept {return duration(duration_values<rep>::min());}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) static constexpr duration max() noexcept {return duration(duration_values<rep>::max());}
};

typedef duration<long long, nano> nanoseconds;
typedef duration<long long, micro> microseconds;
typedef duration<long long, milli> milliseconds;
typedef duration<long long > seconds;
typedef duration< long, ratio< 60> > minutes;
typedef duration< long, ratio<3600> > hours;

typedef duration< int, ratio_multiply<ratio<24>, hours::period>> days;
typedef duration< int, ratio_multiply<ratio<7>, days::period>> weeks;
typedef duration< int, ratio_multiply<ratio<146097, 400>, days::period>> years;
typedef duration< int, ratio_divide<years::period, ratio<12>>> months;



template <class _LhsDuration, class _RhsDuration>
struct __duration_eq
{
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    bool operator()(const _LhsDuration& __lhs, const _RhsDuration& __rhs) const
        {
            typedef typename common_type<_LhsDuration, _RhsDuration>::type _Ct;
            return _Ct(__lhs).count() == _Ct(__rhs).count();
        }
};

template <class _LhsDuration>
struct __duration_eq<_LhsDuration, _LhsDuration>
{
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    bool operator()(const _LhsDuration& __lhs, const _LhsDuration& __rhs) const
        {return __lhs.count() == __rhs.count();}
};

template <class _Rep1, class _Period1, class _Rep2, class _Period2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
constexpr
bool
operator==(const duration<_Rep1, _Period1>& __lhs, const duration<_Rep2, _Period2>& __rhs)
{
    return __duration_eq<duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >()(__lhs, __rhs);
}
# 340 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__chrono/duration.h" 3
template <class _LhsDuration, class _RhsDuration>
struct __duration_lt
{
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    bool operator()(const _LhsDuration& __lhs, const _RhsDuration& __rhs) const
        {
            typedef typename common_type<_LhsDuration, _RhsDuration>::type _Ct;
            return _Ct(__lhs).count() < _Ct(__rhs).count();
        }
};

template <class _LhsDuration>
struct __duration_lt<_LhsDuration, _LhsDuration>
{
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    bool operator()(const _LhsDuration& __lhs, const _LhsDuration& __rhs) const
        {return __lhs.count() < __rhs.count();}
};

template <class _Rep1, class _Period1, class _Rep2, class _Period2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
constexpr
bool
operator< (const duration<_Rep1, _Period1>& __lhs, const duration<_Rep2, _Period2>& __rhs)
{
    return __duration_lt<duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >()(__lhs, __rhs);
}



template <class _Rep1, class _Period1, class _Rep2, class _Period2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
constexpr
bool
operator> (const duration<_Rep1, _Period1>& __lhs, const duration<_Rep2, _Period2>& __rhs)
{
    return __rhs < __lhs;
}



template <class _Rep1, class _Period1, class _Rep2, class _Period2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
constexpr
bool
operator<=(const duration<_Rep1, _Period1>& __lhs, const duration<_Rep2, _Period2>& __rhs)
{
    return !(__rhs < __lhs);
}



template <class _Rep1, class _Period1, class _Rep2, class _Period2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
constexpr
bool
operator>=(const duration<_Rep1, _Period1>& __lhs, const duration<_Rep2, _Period2>& __rhs)
{
    return !(__lhs < __rhs);
}



template<class _Rep1, class _Period1, class _Rep2, class _Period2>
  requires three_way_comparable<common_type_t<_Rep1, _Rep2>>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
constexpr auto operator<=>(const duration<_Rep1, _Period1>& __lhs,
                           const duration<_Rep2, _Period2>& __rhs)
{
    using _Ct = common_type_t<duration<_Rep1, _Period1>, duration<_Rep2, _Period2>>;
    return _Ct(__lhs).count() <=> _Ct(__rhs).count();
}





template <class _Rep1, class _Period1, class _Rep2, class _Period2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
constexpr
typename common_type<duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type
operator+(const duration<_Rep1, _Period1>& __lhs, const duration<_Rep2, _Period2>& __rhs)
{
    typedef typename common_type<duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _Cd;
    return _Cd(_Cd(__lhs).count() + _Cd(__rhs).count());
}



template <class _Rep1, class _Period1, class _Rep2, class _Period2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
constexpr
typename common_type<duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type
operator-(const duration<_Rep1, _Period1>& __lhs, const duration<_Rep2, _Period2>& __rhs)
{
    typedef typename common_type<duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _Cd;
    return _Cd(_Cd(__lhs).count() - _Cd(__rhs).count());
}



template <class _Rep1, class _Period, class _Rep2,
          __enable_if_t<is_convertible<_Rep2, typename common_type<_Rep1, _Rep2>::type>::value, int> = 0>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
constexpr
duration<typename common_type<_Rep1, _Rep2>::type, _Period>
operator*(const duration<_Rep1, _Period>& __d, const _Rep2& __s)
{
    typedef typename common_type<_Rep1, _Rep2>::type _Cr;
    typedef duration<_Cr, _Period> _Cd;
    return _Cd(_Cd(__d).count() * static_cast<_Cr>(__s));
}

template <class _Rep1, class _Period, class _Rep2,
          __enable_if_t<is_convertible<_Rep1, typename common_type<_Rep1, _Rep2>::type>::value, int> = 0>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
constexpr
duration<typename common_type<_Rep1, _Rep2>::type, _Period>
operator*(const _Rep1& __s, const duration<_Rep2, _Period>& __d)
{
    return __d * __s;
}



template <class _Rep1, class _Period, class _Rep2,
          __enable_if_t<!__is_duration<_Rep2>::value && is_convertible<_Rep2, typename common_type<_Rep1, _Rep2>::type>::value, int> = 0>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
constexpr
duration<typename common_type<_Rep1, _Rep2>::type, _Period>
operator/(const duration<_Rep1, _Period>& __d, const _Rep2& __s)
{
    typedef typename common_type<_Rep1, _Rep2>::type _Cr;
    typedef duration<_Cr, _Period> _Cd;
    return _Cd(_Cd(__d).count() / static_cast<_Cr>(__s));
}

template <class _Rep1, class _Period1, class _Rep2, class _Period2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
constexpr
typename common_type<_Rep1, _Rep2>::type
operator/(const duration<_Rep1, _Period1>& __lhs, const duration<_Rep2, _Period2>& __rhs)
{
    typedef typename common_type<duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _Ct;
    return _Ct(__lhs).count() / _Ct(__rhs).count();
}



template <class _Rep1, class _Period, class _Rep2,
          __enable_if_t<!__is_duration<_Rep2>::value && is_convertible<_Rep2, typename common_type<_Rep1, _Rep2>::type>::value, int> = 0>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
constexpr
duration<typename common_type<_Rep1, _Rep2>::type, _Period>
operator%(const duration<_Rep1, _Period>& __d, const _Rep2& __s)
{
    typedef typename common_type<_Rep1, _Rep2>::type _Cr;
    typedef duration<_Cr, _Period> _Cd;
    return _Cd(_Cd(__d).count() % static_cast<_Cr>(__s));
}

template <class _Rep1, class _Period1, class _Rep2, class _Period2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
constexpr
typename common_type<duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type
operator%(const duration<_Rep1, _Period1>& __lhs, const duration<_Rep2, _Period2>& __rhs)
{
    typedef typename common_type<_Rep1, _Rep2>::type _Cr;
    typedef typename common_type<duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _Cd;
    return _Cd(static_cast<_Cr>(_Cd(__lhs).count()) % static_cast<_Cr>(_Cd(__rhs).count()));
}

}



inline namespace literals
{
  inline namespace chrono_literals
  {

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr chrono::hours operator""h(unsigned long long __h)
    {
        return chrono::hours(static_cast<chrono::hours::rep>(__h));
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr chrono::duration<long double, ratio<3600,1>> operator""h(long double __h)
    {
        return chrono::duration<long double, ratio<3600,1>>(__h);
    }


    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr chrono::minutes operator""min(unsigned long long __m)
    {
        return chrono::minutes(static_cast<chrono::minutes::rep>(__m));
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr chrono::duration<long double, ratio<60,1>> operator""min(long double __m)
    {
        return chrono::duration<long double, ratio<60,1>> (__m);
    }


    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr chrono::seconds operator""s(unsigned long long __s)
    {
        return chrono::seconds(static_cast<chrono::seconds::rep>(__s));
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr chrono::duration<long double> operator""s(long double __s)
    {
        return chrono::duration<long double> (__s);
    }


    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr chrono::milliseconds operator""ms(unsigned long long __ms)
    {
        return chrono::milliseconds(static_cast<chrono::milliseconds::rep>(__ms));
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr chrono::duration<long double, milli> operator""ms(long double __ms)
    {
        return chrono::duration<long double, milli>(__ms);
    }


    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr chrono::microseconds operator""us(unsigned long long __us)
    {
        return chrono::microseconds(static_cast<chrono::microseconds::rep>(__us));
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr chrono::duration<long double, micro> operator""us(long double __us)
    {
        return chrono::duration<long double, micro> (__us);
    }


    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr chrono::nanoseconds operator""ns(unsigned long long __ns)
    {
        return chrono::nanoseconds(static_cast<chrono::nanoseconds::rep>(__ns));
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr chrono::duration<long double, nano> operator""ns(long double __ns)
    {
        return chrono::duration<long double, nano> (__ns);
    }

}
}

namespace chrono {
   using namespace literals::chrono_literals;
}



}}
# 17 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__atomic/atomic_sync.h" 2 3


# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__thread/poll_with_backoff.h" 1 3
# 15 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__thread/poll_with_backoff.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__chrono/high_resolution_clock.h" 1 3
# 13 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__chrono/high_resolution_clock.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__chrono/steady_clock.h" 1 3
# 14 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__chrono/steady_clock.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__chrono/time_point.h" 1 3
# 24 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__chrono/time_point.h" 3



# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__undef_macros" 1 3
# 28 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__chrono/time_point.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

namespace chrono
{

template <class _Clock, class _Duration = typename _Clock::duration>
class time_point
{
    static_assert(__is_duration<_Duration>::value,
                  "Second template parameter of time_point must be a std::chrono::duration");
public:
    typedef _Clock clock;
    typedef _Duration duration;
    typedef typename duration::rep rep;
    typedef typename duration::period period;
private:
    duration __d_;

public:
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr time_point() : __d_(duration::zero()) {}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr explicit time_point(const duration& __d) : __d_(__d) {}


    template <class _Duration2, __enable_if_t<is_convertible<_Duration2, duration>::value, int> = 0>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    time_point(const time_point<clock, _Duration2>& __t)
            : __d_(__t.time_since_epoch()) {}



    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr duration time_since_epoch() const {return __d_;}



    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr time_point& operator+=(const duration& __d) {__d_ += __d; return *this;}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr time_point& operator-=(const duration& __d) {__d_ -= __d; return *this;}



    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) static constexpr time_point min() noexcept {return time_point(duration::min());}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) static constexpr time_point max() noexcept {return time_point(duration::max());}
};

}

template <class _Clock, class _Duration1, class _Duration2>
struct common_type<chrono::time_point<_Clock, _Duration1>,
                                         chrono::time_point<_Clock, _Duration2> >
{
    typedef chrono::time_point<_Clock, typename common_type<_Duration1, _Duration2>::type> type;
};

namespace chrono {

template <class _ToDuration, class _Clock, class _Duration>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
time_point<_Clock, _ToDuration>
time_point_cast(const time_point<_Clock, _Duration>& __t)
{
    return time_point<_Clock, _ToDuration>(chrono::duration_cast<_ToDuration>(__t.time_since_epoch()));
}


template <class _ToDuration, class _Clock, class _Duration, enable_if_t<__is_duration<_ToDuration>::value, int> = 0>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
time_point<_Clock, _ToDuration>
floor(const time_point<_Clock, _Duration>& __t)
{
    return time_point<_Clock, _ToDuration>{chrono::floor<_ToDuration>(__t.time_since_epoch())};
}

template <class _ToDuration, class _Clock, class _Duration, enable_if_t<__is_duration<_ToDuration>::value, int> = 0>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
time_point<_Clock, _ToDuration>
ceil(const time_point<_Clock, _Duration>& __t)
{
    return time_point<_Clock, _ToDuration>{chrono::ceil<_ToDuration>(__t.time_since_epoch())};
}

template <class _ToDuration, class _Clock, class _Duration, enable_if_t<__is_duration<_ToDuration>::value, int> = 0>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
time_point<_Clock, _ToDuration>
round(const time_point<_Clock, _Duration>& __t)
{
    return time_point<_Clock, _ToDuration>{chrono::round<_ToDuration>(__t.time_since_epoch())};
}

template <class _Rep, class _Period, enable_if_t<numeric_limits<_Rep>::is_signed, int> = 0>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
duration<_Rep, _Period>
abs(duration<_Rep, _Period> __d)
{
    return __d >= __d.zero() ? +__d : -__d;
}




template <class _Clock, class _Duration1, class _Duration2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
bool
operator==(const time_point<_Clock, _Duration1>& __lhs, const time_point<_Clock, _Duration2>& __rhs)
{
    return __lhs.time_since_epoch() == __rhs.time_since_epoch();
}
# 151 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__chrono/time_point.h" 3
template <class _Clock, class _Duration1, class _Duration2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
bool
operator<(const time_point<_Clock, _Duration1>& __lhs, const time_point<_Clock, _Duration2>& __rhs)
{
    return __lhs.time_since_epoch() < __rhs.time_since_epoch();
}



template <class _Clock, class _Duration1, class _Duration2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
bool
operator>(const time_point<_Clock, _Duration1>& __lhs, const time_point<_Clock, _Duration2>& __rhs)
{
    return __rhs < __lhs;
}



template <class _Clock, class _Duration1, class _Duration2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
bool
operator<=(const time_point<_Clock, _Duration1>& __lhs, const time_point<_Clock, _Duration2>& __rhs)
{
    return !(__rhs < __lhs);
}



template <class _Clock, class _Duration1, class _Duration2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
bool
operator>=(const time_point<_Clock, _Duration1>& __lhs, const time_point<_Clock, _Duration2>& __rhs)
{
    return !(__lhs < __rhs);
}



template <class _Clock, class _Duration1, three_way_comparable_with<_Duration1> _Duration2>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr auto
operator<=>(const time_point<_Clock, _Duration1>& __lhs, const time_point<_Clock, _Duration2>& __rhs) {
    return __lhs.time_since_epoch() <=> __rhs.time_since_epoch();
}





template <class _Clock, class _Duration1, class _Rep2, class _Period2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
time_point<_Clock, typename common_type<_Duration1, duration<_Rep2, _Period2> >::type>
operator+(const time_point<_Clock, _Duration1>& __lhs, const duration<_Rep2, _Period2>& __rhs)
{
    typedef time_point<_Clock, typename common_type<_Duration1, duration<_Rep2, _Period2> >::type> _Tr;
    return _Tr (__lhs.time_since_epoch() + __rhs);
}



template <class _Rep1, class _Period1, class _Clock, class _Duration2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
time_point<_Clock, typename common_type<duration<_Rep1, _Period1>, _Duration2>::type>
operator+(const duration<_Rep1, _Period1>& __lhs, const time_point<_Clock, _Duration2>& __rhs)
{
    return __rhs + __lhs;
}



template <class _Clock, class _Duration1, class _Rep2, class _Period2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
time_point<_Clock, typename common_type<_Duration1, duration<_Rep2, _Period2> >::type>
operator-(const time_point<_Clock, _Duration1>& __lhs, const duration<_Rep2, _Period2>& __rhs)
{
    typedef time_point<_Clock, typename common_type<_Duration1, duration<_Rep2, _Period2> >::type> _Ret;
    return _Ret(__lhs.time_since_epoch() -__rhs);
}



template <class _Clock, class _Duration1, class _Duration2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
typename common_type<_Duration1, _Duration2>::type
operator-(const time_point<_Clock, _Duration1>& __lhs, const time_point<_Clock, _Duration2>& __rhs)
{
    return __lhs.time_since_epoch() - __rhs.time_since_epoch();
}

}

}}
# 15 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__chrono/steady_clock.h" 2 3
# 19 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__chrono/steady_clock.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

namespace chrono
{


class __attribute__((__visibility__("default"))) steady_clock
{
public:
    typedef nanoseconds duration;
    typedef duration::rep rep;
    typedef duration::period period;
    typedef chrono::time_point<steady_clock, duration> time_point;
    static constexpr const bool is_steady = true;

    static time_point now() noexcept;
};


}

}}
# 14 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__chrono/high_resolution_clock.h" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__chrono/system_clock.h" 1 3
# 16 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__chrono/system_clock.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/ctime" 1 3
# 53 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/ctime" 3
# 1 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/llvm_libc_wrappers/time.h" 1 3
# 16 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/llvm_libc_wrappers/time.h" 3
# 1 "/usr/include/time.h" 1 3 4
# 29 "/usr/include/time.h" 3 4
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/stddef.h" 1 3 4
# 15 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/stddef.h" 3


# 1 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/stddef.h" 1 3
# 59 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/stddef.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/__stddef_size_t.h" 1 3
# 15 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/__stddef_size_t.h" 3
typedef long unsigned int size_t;
# 60 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/stddef.h" 2 3
# 74 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/stddef.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/__stddef_null.h" 1 3
# 75 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/stddef.h" 2 3
# 18 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/stddef.h" 2 3
# 30 "/usr/include/time.h" 2 3 4



# 1 "/usr/include/bits/time.h" 1 3 4
# 73 "/usr/include/bits/time.h" 3 4
# 1 "/usr/include/bits/timex.h" 1 3 4
# 26 "/usr/include/bits/timex.h" 3 4
struct timex
{
  unsigned int modes;
  __syscall_slong_t offset;
  __syscall_slong_t freq;
  __syscall_slong_t maxerror;
  __syscall_slong_t esterror;
  int status;
  __syscall_slong_t constant;
  __syscall_slong_t precision;
  __syscall_slong_t tolerance;
  struct timeval time;
  __syscall_slong_t tick;
  __syscall_slong_t ppsfreq;
  __syscall_slong_t jitter;
  int shift;
  __syscall_slong_t stabil;
  __syscall_slong_t jitcnt;
  __syscall_slong_t calcnt;
  __syscall_slong_t errcnt;
  __syscall_slong_t stbcnt;

  int tai;


  int :32; int :32; int :32; int :32;
  int :32; int :32; int :32; int :32;
  int :32; int :32; int :32;
};
# 74 "/usr/include/bits/time.h" 2 3 4

extern "C" {


extern int clock_adjtime (__clockid_t __clock_id, struct timex *__utx) throw ();

}
# 34 "/usr/include/time.h" 2 3 4





# 1 "/usr/include/bits/types/struct_tm.h" 1 3 4






struct tm
{
  int tm_sec;
  int tm_min;
  int tm_hour;
  int tm_mday;
  int tm_mon;
  int tm_year;
  int tm_wday;
  int tm_yday;
  int tm_isdst;


  long int tm_gmtoff;
  const char *tm_zone;




};
# 40 "/usr/include/time.h" 2 3 4








# 1 "/usr/include/bits/types/struct_itimerspec.h" 1 3 4







struct itimerspec
  {
    struct timespec it_interval;
    struct timespec it_value;
  };
# 49 "/usr/include/time.h" 2 3 4
struct sigevent;
# 68 "/usr/include/time.h" 3 4
extern "C" {



extern clock_t clock (void) throw ();


extern time_t time (time_t *__timer) throw ();


extern double difftime (time_t __time1, time_t __time0)
     throw () __attribute__ ((__const__));


extern time_t mktime (struct tm *__tp) throw ();





extern size_t strftime (char *__restrict __s, size_t __maxsize,
   const char *__restrict __format,
   const struct tm *__restrict __tp) throw ();




extern char *strptime (const char *__restrict __s,
         const char *__restrict __fmt, struct tm *__tp)
     throw ();






extern size_t strftime_l (char *__restrict __s, size_t __maxsize,
     const char *__restrict __format,
     const struct tm *__restrict __tp,
     locale_t __loc) throw ();



extern char *strptime_l (const char *__restrict __s,
    const char *__restrict __fmt, struct tm *__tp,
    locale_t __loc) throw ();





extern struct tm *gmtime (const time_t *__timer) throw ();



extern struct tm *localtime (const time_t *__timer) throw ();




extern struct tm *gmtime_r (const time_t *__restrict __timer,
       struct tm *__restrict __tp) throw ();



extern struct tm *localtime_r (const time_t *__restrict __timer,
          struct tm *__restrict __tp) throw ();




extern char *asctime (const struct tm *__tp) throw ();


extern char *ctime (const time_t *__timer) throw ();






extern char *asctime_r (const struct tm *__restrict __tp,
   char *__restrict __buf) throw ();


extern char *ctime_r (const time_t *__restrict __timer,
        char *__restrict __buf) throw ();




extern char *__tzname[2];
extern int __daylight;
extern long int __timezone;




extern char *tzname[2];



extern void tzset (void) throw ();



extern int daylight;
extern long int timezone;





extern int stime (const time_t *__when) throw ();
# 196 "/usr/include/time.h" 3 4
extern time_t timegm (struct tm *__tp) throw ();


extern time_t timelocal (struct tm *__tp) throw ();


extern int dysize (int __year) throw () __attribute__ ((__const__));
# 211 "/usr/include/time.h" 3 4
extern int nanosleep (const struct timespec *__requested_time,
        struct timespec *__remaining);



extern int clock_getres (clockid_t __clock_id, struct timespec *__res) throw ();


extern int clock_gettime (clockid_t __clock_id, struct timespec *__tp) throw ();


extern int clock_settime (clockid_t __clock_id, const struct timespec *__tp)
     throw ();






extern int clock_nanosleep (clockid_t __clock_id, int __flags,
       const struct timespec *__req,
       struct timespec *__rem);


extern int clock_getcpuclockid (pid_t __pid, clockid_t *__clock_id) throw ();




extern int timer_create (clockid_t __clock_id,
    struct sigevent *__restrict __evp,
    timer_t *__restrict __timerid) throw ();


extern int timer_delete (timer_t __timerid) throw ();


extern int timer_settime (timer_t __timerid, int __flags,
     const struct itimerspec *__restrict __value,
     struct itimerspec *__restrict __ovalue) throw ();


extern int timer_gettime (timer_t __timerid, struct itimerspec *__value)
     throw ();


extern int timer_getoverrun (timer_t __timerid) throw ();





extern int timespec_get (struct timespec *__ts, int __base)
     throw () __attribute__ ((__nonnull__ (1)));
# 280 "/usr/include/time.h" 3 4
extern int getdate_err;
# 289 "/usr/include/time.h" 3 4
extern struct tm *getdate (const char *__string);
# 303 "/usr/include/time.h" 3 4
extern int getdate_r (const char *__restrict __string,
        struct tm *__restrict __resbufp);


}
# 17 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/llvm_libc_wrappers/time.h" 2 3
# 54 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/ctime" 2 3
# 61 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/ctime" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

using ::clock_t __attribute__((__using_if_exists__));
using ::size_t __attribute__((__using_if_exists__));
using ::time_t __attribute__((__using_if_exists__));
using ::tm __attribute__((__using_if_exists__));

using ::timespec __attribute__((__using_if_exists__));

using ::clock __attribute__((__using_if_exists__));
using ::difftime __attribute__((__using_if_exists__));
using ::mktime __attribute__((__using_if_exists__));
using ::time __attribute__((__using_if_exists__));
using ::asctime __attribute__((__using_if_exists__));
using ::ctime __attribute__((__using_if_exists__));
using ::gmtime __attribute__((__using_if_exists__));
using ::localtime __attribute__((__using_if_exists__));
using ::strftime __attribute__((__using_if_exists__));

using ::timespec_get __attribute__((__using_if_exists__));


}}
# 17 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__chrono/system_clock.h" 2 3
# 20 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__chrono/system_clock.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

namespace chrono
{

class __attribute__((__visibility__("default"))) system_clock
{
public:
    typedef microseconds duration;
    typedef duration::rep rep;
    typedef duration::period period;
    typedef chrono::time_point<system_clock> time_point;
    static constexpr const bool is_steady = false;

    static time_point now() noexcept;
    static time_t to_time_t (const time_point& __t) noexcept;
    static time_point from_time_t(time_t __t) noexcept;
};



template <class _Duration>
using sys_time = time_point<system_clock, _Duration>;
using sys_seconds = sys_time<seconds>;
using sys_days = sys_time<days>;



}

}}
# 15 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__chrono/high_resolution_clock.h" 2 3
# 19 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__chrono/high_resolution_clock.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

namespace chrono
{


typedef steady_clock high_resolution_clock;




}

}}
# 16 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__thread/poll_with_backoff.h" 2 3
# 20 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__thread/poll_with_backoff.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

static constexpr const int __libcpp_polling_count = 64;
# 37 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__thread/poll_with_backoff.h" 3
template<class _Fn, class _BFn>
                          __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
bool __libcpp_thread_poll_with_backoff(_Fn&& __f, _BFn&& __bf, chrono::nanoseconds __max_elapsed = chrono::nanoseconds::zero()) {
    auto const __start = chrono::high_resolution_clock::now();
    for (int __count = 0;;) {
      if (__f())
        return true;
      if (__count < __libcpp_polling_count) {
        __count += 1;
        continue;
      }
      chrono::nanoseconds const __elapsed = chrono::high_resolution_clock::now() - __start;
      if (__max_elapsed != chrono::nanoseconds::zero() && __max_elapsed < __elapsed)
          return false;
      if (__bf(__elapsed))
        return false;
    }
}







struct __spinning_backoff_policy {
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
  bool operator()(chrono::nanoseconds const&) const {
      return false;
  }
};

}}
# 20 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__atomic/atomic_sync.h" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__threading_support" 1 3
# 14 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__threading_support" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__chrono/convert_to_timespec.h" 1 3
# 19 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__chrono/convert_to_timespec.h" 3



# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__undef_macros" 1 3
# 23 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__chrono/convert_to_timespec.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {



template <class _TimeSpec>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) inline
_TimeSpec __convert_to_timespec(const chrono::nanoseconds& __ns)
{
  using namespace chrono;
  seconds __s = duration_cast<seconds>(__ns);
  _TimeSpec __ts;
  typedef decltype(__ts.tv_sec) __ts_sec;
  const __ts_sec __ts_sec_max = numeric_limits<__ts_sec>::max();

  if (__s.count() < __ts_sec_max)
  {
    __ts.tv_sec = static_cast<__ts_sec>(__s.count());
    __ts.tv_nsec = static_cast<decltype(__ts.tv_nsec)>((__ns - __s).count());
  }
  else
  {
    __ts.tv_sec = __ts_sec_max;
    __ts.tv_nsec = 999999999;
  }

  return __ts;
}

}}
# 15 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__threading_support" 2 3




# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/errno.h" 1 3
# 29 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/errno.h" 3



# 1 "/usr/include/errno.h" 1 3 4
# 28 "/usr/include/errno.h" 3 4
# 1 "/usr/include/bits/errno.h" 1 3 4
# 26 "/usr/include/bits/errno.h" 3 4
# 1 "/usr/include/linux/errno.h" 1 3 4
# 1 "/usr/include/asm/errno.h" 1 3 4
# 1 "/usr/include/asm-generic/errno.h" 1 3 4




# 1 "/usr/include/asm-generic/errno-base.h" 1 3 4
# 6 "/usr/include/asm-generic/errno.h" 2 3 4
# 2 "/usr/include/asm/errno.h" 2 3 4
# 2 "/usr/include/linux/errno.h" 2 3 4
# 27 "/usr/include/bits/errno.h" 2 3 4
# 29 "/usr/include/errno.h" 2 3 4





extern "C" {


extern int *__errno_location (void) throw () __attribute__ ((__const__));







extern char *program_invocation_name;
extern char *program_invocation_short_name;

# 1 "/usr/include/bits/types/error_t.h" 1 3 4
# 22 "/usr/include/bits/types/error_t.h" 3 4
typedef int error_t;
# 49 "/usr/include/errno.h" 2 3 4



}
# 33 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/errno.h" 2 3
# 20 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__threading_support" 2 3
# 27 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__threading_support" 3
# 40 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__threading_support" 3
# 1 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/openmp_wrappers/math.h" 1 3
# 20 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/openmp_wrappers/math.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/openmp_wrappers/cmath" 1 3
# 17 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/openmp_wrappers/cmath" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/cmath" 1 3
# 314 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/cmath" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/promote.h" 1 3
# 19 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/promote.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Tp>
struct __numeric_type {
  static void __test(...);
  static float __test(float);
  static double __test(char);
  static double __test(int);
  static double __test(unsigned);
  static double __test(long);
  static double __test(unsigned long);
  static double __test(long long);
  static double __test(unsigned long long);

  static double __test(__int128_t);
  static double __test(__uint128_t);

  static double __test(double);
  static long double __test(long double);

  typedef decltype(__test(std::declval<_Tp>())) type;
  static const bool value = _IsNotSame<type, void>::value;
};

template <>
struct __numeric_type<void> {
  static const bool value = true;
};

template <class _A1,
          class _A2 = void,
          class _A3 = void,
          bool = __numeric_type<_A1>::value&& __numeric_type<_A2>::value&& __numeric_type<_A3>::value>
class __promote_imp {
public:
  static const bool value = false;
};

template <class _A1, class _A2, class _A3>
class __promote_imp<_A1, _A2, _A3, true> {
private:
  typedef typename __promote_imp<_A1>::type __type1;
  typedef typename __promote_imp<_A2>::type __type2;
  typedef typename __promote_imp<_A3>::type __type3;

public:
  typedef decltype(__type1() + __type2() + __type3()) type;
  static const bool value = true;
};

template <class _A1, class _A2>
class __promote_imp<_A1, _A2, void, true> {
private:
  typedef typename __promote_imp<_A1>::type __type1;
  typedef typename __promote_imp<_A2>::type __type2;

public:
  typedef decltype(__type1() + __type2()) type;
  static const bool value = true;
};

template <class _A1>
class __promote_imp<_A1, void, void, true> {
public:
  typedef typename __numeric_type<_A1>::type type;
  static const bool value = true;
};

template <class _A1, class _A2 = void, class _A3 = void>
class __promote : public __promote_imp<_A1, _A2, _A3> {};

}}
# 315 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/cmath" 2 3




# 1 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/openmp_wrappers/math.h" 1 3
# 20 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/openmp_wrappers/math.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/openmp_wrappers/cmath" 1 3
# 21 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/openmp_wrappers/math.h" 2 3
# 30 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/openmp_wrappers/math.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/math.h" 1 3
# 298 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/math.h" 3



# 1 "/usr/include/math.h" 1 3 4
# 27 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/libc-header-start.h" 1 3 4
# 28 "/usr/include/math.h" 2 3 4






extern "C" {





# 1 "/usr/include/bits/math-vector.h" 1 3 4
# 25 "/usr/include/bits/math-vector.h" 3 4
# 1 "/usr/include/bits/libm-simd-decl-stubs.h" 1 3 4
# 26 "/usr/include/bits/math-vector.h" 2 3 4
# 41 "/usr/include/math.h" 2 3 4
# 138 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/flt-eval-method.h" 1 3 4
# 139 "/usr/include/math.h" 2 3 4
# 149 "/usr/include/math.h" 3 4
typedef float float_t;
typedef double double_t;
# 190 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/fp-logb.h" 1 3 4
# 191 "/usr/include/math.h" 2 3 4
# 233 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/fp-fast.h" 1 3 4
# 234 "/usr/include/math.h" 2 3 4



enum
  {
    FP_INT_UPWARD =

      0,
    FP_INT_DOWNWARD =

      1,
    FP_INT_TOWARDZERO =

      2,
    FP_INT_TONEARESTFROMZERO =

      3,
    FP_INT_TONEAREST =

      4,
  };
# 289 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathcalls-helper-functions.h" 1 3 4
# 21 "/usr/include/bits/mathcalls-helper-functions.h" 3 4
extern int __fpclassify (double __value) throw ()
     __attribute__ ((__const__));


extern int __signbit (double __value) throw ()
     __attribute__ ((__const__));



extern int __isinf (double __value) throw () __attribute__ ((__const__));


extern int __finite (double __value) throw () __attribute__ ((__const__));


extern int __isnan (double __value) throw () __attribute__ ((__const__));


extern int __iseqsig (double __x, double __y) throw ();


extern int __issignaling (double __value) throw ()
     __attribute__ ((__const__));
# 290 "/usr/include/math.h" 2 3 4
# 1 "/usr/include/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/bits/mathcalls.h" 3 4
extern double acos (double __x) throw (); extern double __acos (double __x) throw ();

extern double asin (double __x) throw (); extern double __asin (double __x) throw ();

extern double atan (double __x) throw (); extern double __atan (double __x) throw ();

extern double atan2 (double __y, double __x) throw (); extern double __atan2 (double __y, double __x) throw ();


 extern double cos (double __x) throw (); extern double __cos (double __x) throw ();

 extern double sin (double __x) throw (); extern double __sin (double __x) throw ();

extern double tan (double __x) throw (); extern double __tan (double __x) throw ();




extern double cosh (double __x) throw (); extern double __cosh (double __x) throw ();

extern double sinh (double __x) throw (); extern double __sinh (double __x) throw ();

extern double tanh (double __x) throw (); extern double __tanh (double __x) throw ();



 extern void sincos (double __x, double *__sinx, double *__cosx) throw (); extern void __sincos (double __x, double *__sinx, double *__cosx) throw ();





extern double acosh (double __x) throw (); extern double __acosh (double __x) throw ();

extern double asinh (double __x) throw (); extern double __asinh (double __x) throw ();

extern double atanh (double __x) throw (); extern double __atanh (double __x) throw ();





 extern double exp (double __x) throw (); extern double __exp (double __x) throw ();


extern double frexp (double __x, int *__exponent) throw (); extern double __frexp (double __x, int *__exponent) throw ();


extern double ldexp (double __x, int __exponent) throw (); extern double __ldexp (double __x, int __exponent) throw ();


 extern double log (double __x) throw (); extern double __log (double __x) throw ();


extern double log10 (double __x) throw (); extern double __log10 (double __x) throw ();


extern double modf (double __x, double *__iptr) throw (); extern double __modf (double __x, double *__iptr) throw () __attribute__ ((__nonnull__ (2)));



extern double exp10 (double __x) throw (); extern double __exp10 (double __x) throw ();




extern double expm1 (double __x) throw (); extern double __expm1 (double __x) throw ();


extern double log1p (double __x) throw (); extern double __log1p (double __x) throw ();


extern double logb (double __x) throw (); extern double __logb (double __x) throw ();




extern double exp2 (double __x) throw (); extern double __exp2 (double __x) throw ();


extern double log2 (double __x) throw (); extern double __log2 (double __x) throw ();






 extern double pow (double __x, double __y) throw (); extern double __pow (double __x, double __y) throw ();


extern double sqrt (double __x) throw (); extern double __sqrt (double __x) throw ();



extern double hypot (double __x, double __y) throw (); extern double __hypot (double __x, double __y) throw ();




extern double cbrt (double __x) throw (); extern double __cbrt (double __x) throw ();






extern double ceil (double __x) throw () __attribute__ ((__const__)); extern double __ceil (double __x) throw () __attribute__ ((__const__));


extern double fabs (double __x) throw () __attribute__ ((__const__)); extern double __fabs (double __x) throw () __attribute__ ((__const__));


extern double floor (double __x) throw () __attribute__ ((__const__)); extern double __floor (double __x) throw () __attribute__ ((__const__));


extern double fmod (double __x, double __y) throw (); extern double __fmod (double __x, double __y) throw ();
# 182 "/usr/include/bits/mathcalls.h" 3 4
extern int finite (double __value) throw () __attribute__ ((__const__));


extern double drem (double __x, double __y) throw (); extern double __drem (double __x, double __y) throw ();



extern double significand (double __x) throw (); extern double __significand (double __x) throw ();






extern double copysign (double __x, double __y) throw () __attribute__ ((__const__)); extern double __copysign (double __x, double __y) throw () __attribute__ ((__const__));




extern double nan (const char *__tagb) throw (); extern double __nan (const char *__tagb) throw ();
# 217 "/usr/include/bits/mathcalls.h" 3 4
extern double j0 (double) throw (); extern double __j0 (double) throw ();
extern double j1 (double) throw (); extern double __j1 (double) throw ();
extern double jn (int, double) throw (); extern double __jn (int, double) throw ();
extern double y0 (double) throw (); extern double __y0 (double) throw ();
extern double y1 (double) throw (); extern double __y1 (double) throw ();
extern double yn (int, double) throw (); extern double __yn (int, double) throw ();





extern double erf (double) throw (); extern double __erf (double) throw ();
extern double erfc (double) throw (); extern double __erfc (double) throw ();
extern double lgamma (double) throw (); extern double __lgamma (double) throw ();




extern double tgamma (double) throw (); extern double __tgamma (double) throw ();





extern double gamma (double) throw (); extern double __gamma (double) throw ();







extern double lgamma_r (double, int *__signgamp) throw (); extern double __lgamma_r (double, int *__signgamp) throw ();






extern double rint (double __x) throw (); extern double __rint (double __x) throw ();


extern double nextafter (double __x, double __y) throw (); extern double __nextafter (double __x, double __y) throw ();

extern double nexttoward (double __x, long double __y) throw (); extern double __nexttoward (double __x, long double __y) throw ();




extern double nextdown (double __x) throw (); extern double __nextdown (double __x) throw ();

extern double nextup (double __x) throw (); extern double __nextup (double __x) throw ();



extern double remainder (double __x, double __y) throw (); extern double __remainder (double __x, double __y) throw ();



extern double scalbn (double __x, int __n) throw (); extern double __scalbn (double __x, int __n) throw ();



extern int ilogb (double __x) throw (); extern int __ilogb (double __x) throw ();




extern long int llogb (double __x) throw (); extern long int __llogb (double __x) throw ();




extern double scalbln (double __x, long int __n) throw (); extern double __scalbln (double __x, long int __n) throw ();



extern double nearbyint (double __x) throw (); extern double __nearbyint (double __x) throw ();



extern double round (double __x) throw () __attribute__ ((__const__)); extern double __round (double __x) throw () __attribute__ ((__const__));



extern double trunc (double __x) throw () __attribute__ ((__const__)); extern double __trunc (double __x) throw () __attribute__ ((__const__));




extern double remquo (double __x, double __y, int *__quo) throw (); extern double __remquo (double __x, double __y, int *__quo) throw ();






extern long int lrint (double __x) throw (); extern long int __lrint (double __x) throw ();
__extension__
extern long long int llrint (double __x) throw (); extern long long int __llrint (double __x) throw ();



extern long int lround (double __x) throw (); extern long int __lround (double __x) throw ();
__extension__
extern long long int llround (double __x) throw (); extern long long int __llround (double __x) throw ();



extern double fdim (double __x, double __y) throw (); extern double __fdim (double __x, double __y) throw ();


extern double fmax (double __x, double __y) throw () __attribute__ ((__const__)); extern double __fmax (double __x, double __y) throw () __attribute__ ((__const__));


extern double fmin (double __x, double __y) throw () __attribute__ ((__const__)); extern double __fmin (double __x, double __y) throw () __attribute__ ((__const__));


extern double fma (double __x, double __y, double __z) throw (); extern double __fma (double __x, double __y, double __z) throw ();




extern double roundeven (double __x) throw () __attribute__ ((__const__)); extern double __roundeven (double __x) throw () __attribute__ ((__const__));



extern __intmax_t fromfp (double __x, int __round, unsigned int __width) throw (); extern __intmax_t __fromfp (double __x, int __round, unsigned int __width) throw ();




extern __uintmax_t ufromfp (double __x, int __round, unsigned int __width) throw (); extern __uintmax_t __ufromfp (double __x, int __round, unsigned int __width) throw ();





extern __intmax_t fromfpx (double __x, int __round, unsigned int __width) throw (); extern __intmax_t __fromfpx (double __x, int __round, unsigned int __width) throw ();





extern __uintmax_t ufromfpx (double __x, int __round, unsigned int __width) throw (); extern __uintmax_t __ufromfpx (double __x, int __round, unsigned int __width) throw ();



extern double fmaxmag (double __x, double __y) throw () __attribute__ ((__const__)); extern double __fmaxmag (double __x, double __y) throw () __attribute__ ((__const__));


extern double fminmag (double __x, double __y) throw () __attribute__ ((__const__)); extern double __fminmag (double __x, double __y) throw () __attribute__ ((__const__));


extern int totalorder (double __x, double __y) throw ()
     __attribute__ ((__const__));


extern int totalordermag (double __x, double __y) throw ()
     __attribute__ ((__const__));


extern int canonicalize (double *__cx, const double *__x) throw ();


extern double getpayload (const double *__x) throw (); extern double __getpayload (const double *__x) throw ();


extern int setpayload (double *__x, double __payload) throw ();


extern int setpayloadsig (double *__x, double __payload) throw ();







extern double scalb (double __x, double __n) throw (); extern double __scalb (double __x, double __n) throw ();
# 291 "/usr/include/math.h" 2 3 4
# 306 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathcalls-helper-functions.h" 1 3 4
# 21 "/usr/include/bits/mathcalls-helper-functions.h" 3 4
extern int __fpclassifyf (float __value) throw ()
     __attribute__ ((__const__));


extern int __signbitf (float __value) throw ()
     __attribute__ ((__const__));



extern int __isinff (float __value) throw () __attribute__ ((__const__));


extern int __finitef (float __value) throw () __attribute__ ((__const__));


extern int __isnanf (float __value) throw () __attribute__ ((__const__));


extern int __iseqsigf (float __x, float __y) throw ();


extern int __issignalingf (float __value) throw ()
     __attribute__ ((__const__));
# 307 "/usr/include/math.h" 2 3 4
# 1 "/usr/include/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/bits/mathcalls.h" 3 4
extern float acosf (float __x) throw (); extern float __acosf (float __x) throw ();

extern float asinf (float __x) throw (); extern float __asinf (float __x) throw ();

extern float atanf (float __x) throw (); extern float __atanf (float __x) throw ();

extern float atan2f (float __y, float __x) throw (); extern float __atan2f (float __y, float __x) throw ();


 extern float cosf (float __x) throw (); extern float __cosf (float __x) throw ();

 extern float sinf (float __x) throw (); extern float __sinf (float __x) throw ();

extern float tanf (float __x) throw (); extern float __tanf (float __x) throw ();




extern float coshf (float __x) throw (); extern float __coshf (float __x) throw ();

extern float sinhf (float __x) throw (); extern float __sinhf (float __x) throw ();

extern float tanhf (float __x) throw (); extern float __tanhf (float __x) throw ();



 extern void sincosf (float __x, float *__sinx, float *__cosx) throw (); extern void __sincosf (float __x, float *__sinx, float *__cosx) throw ();





extern float acoshf (float __x) throw (); extern float __acoshf (float __x) throw ();

extern float asinhf (float __x) throw (); extern float __asinhf (float __x) throw ();

extern float atanhf (float __x) throw (); extern float __atanhf (float __x) throw ();





 extern float expf (float __x) throw (); extern float __expf (float __x) throw ();


extern float frexpf (float __x, int *__exponent) throw (); extern float __frexpf (float __x, int *__exponent) throw ();


extern float ldexpf (float __x, int __exponent) throw (); extern float __ldexpf (float __x, int __exponent) throw ();


 extern float logf (float __x) throw (); extern float __logf (float __x) throw ();


extern float log10f (float __x) throw (); extern float __log10f (float __x) throw ();


extern float modff (float __x, float *__iptr) throw (); extern float __modff (float __x, float *__iptr) throw () __attribute__ ((__nonnull__ (2)));



extern float exp10f (float __x) throw (); extern float __exp10f (float __x) throw ();




extern float expm1f (float __x) throw (); extern float __expm1f (float __x) throw ();


extern float log1pf (float __x) throw (); extern float __log1pf (float __x) throw ();


extern float logbf (float __x) throw (); extern float __logbf (float __x) throw ();




extern float exp2f (float __x) throw (); extern float __exp2f (float __x) throw ();


extern float log2f (float __x) throw (); extern float __log2f (float __x) throw ();






 extern float powf (float __x, float __y) throw (); extern float __powf (float __x, float __y) throw ();


extern float sqrtf (float __x) throw (); extern float __sqrtf (float __x) throw ();



extern float hypotf (float __x, float __y) throw (); extern float __hypotf (float __x, float __y) throw ();




extern float cbrtf (float __x) throw (); extern float __cbrtf (float __x) throw ();






extern float ceilf (float __x) throw () __attribute__ ((__const__)); extern float __ceilf (float __x) throw () __attribute__ ((__const__));


extern float fabsf (float __x) throw () __attribute__ ((__const__)); extern float __fabsf (float __x) throw () __attribute__ ((__const__));


extern float floorf (float __x) throw () __attribute__ ((__const__)); extern float __floorf (float __x) throw () __attribute__ ((__const__));


extern float fmodf (float __x, float __y) throw (); extern float __fmodf (float __x, float __y) throw ();
# 177 "/usr/include/bits/mathcalls.h" 3 4
extern int isinff (float __value) throw () __attribute__ ((__const__));




extern int finitef (float __value) throw () __attribute__ ((__const__));


extern float dremf (float __x, float __y) throw (); extern float __dremf (float __x, float __y) throw ();



extern float significandf (float __x) throw (); extern float __significandf (float __x) throw ();






extern float copysignf (float __x, float __y) throw () __attribute__ ((__const__)); extern float __copysignf (float __x, float __y) throw () __attribute__ ((__const__));




extern float nanf (const char *__tagb) throw (); extern float __nanf (const char *__tagb) throw ();
# 211 "/usr/include/bits/mathcalls.h" 3 4
extern int isnanf (float __value) throw () __attribute__ ((__const__));





extern float j0f (float) throw (); extern float __j0f (float) throw ();
extern float j1f (float) throw (); extern float __j1f (float) throw ();
extern float jnf (int, float) throw (); extern float __jnf (int, float) throw ();
extern float y0f (float) throw (); extern float __y0f (float) throw ();
extern float y1f (float) throw (); extern float __y1f (float) throw ();
extern float ynf (int, float) throw (); extern float __ynf (int, float) throw ();





extern float erff (float) throw (); extern float __erff (float) throw ();
extern float erfcf (float) throw (); extern float __erfcf (float) throw ();
extern float lgammaf (float) throw (); extern float __lgammaf (float) throw ();




extern float tgammaf (float) throw (); extern float __tgammaf (float) throw ();





extern float gammaf (float) throw (); extern float __gammaf (float) throw ();







extern float lgammaf_r (float, int *__signgamp) throw (); extern float __lgammaf_r (float, int *__signgamp) throw ();






extern float rintf (float __x) throw (); extern float __rintf (float __x) throw ();


extern float nextafterf (float __x, float __y) throw (); extern float __nextafterf (float __x, float __y) throw ();

extern float nexttowardf (float __x, long double __y) throw (); extern float __nexttowardf (float __x, long double __y) throw ();




extern float nextdownf (float __x) throw (); extern float __nextdownf (float __x) throw ();

extern float nextupf (float __x) throw (); extern float __nextupf (float __x) throw ();



extern float remainderf (float __x, float __y) throw (); extern float __remainderf (float __x, float __y) throw ();



extern float scalbnf (float __x, int __n) throw (); extern float __scalbnf (float __x, int __n) throw ();



extern int ilogbf (float __x) throw (); extern int __ilogbf (float __x) throw ();




extern long int llogbf (float __x) throw (); extern long int __llogbf (float __x) throw ();




extern float scalblnf (float __x, long int __n) throw (); extern float __scalblnf (float __x, long int __n) throw ();



extern float nearbyintf (float __x) throw (); extern float __nearbyintf (float __x) throw ();



extern float roundf (float __x) throw () __attribute__ ((__const__)); extern float __roundf (float __x) throw () __attribute__ ((__const__));



extern float truncf (float __x) throw () __attribute__ ((__const__)); extern float __truncf (float __x) throw () __attribute__ ((__const__));




extern float remquof (float __x, float __y, int *__quo) throw (); extern float __remquof (float __x, float __y, int *__quo) throw ();






extern long int lrintf (float __x) throw (); extern long int __lrintf (float __x) throw ();
__extension__
extern long long int llrintf (float __x) throw (); extern long long int __llrintf (float __x) throw ();



extern long int lroundf (float __x) throw (); extern long int __lroundf (float __x) throw ();
__extension__
extern long long int llroundf (float __x) throw (); extern long long int __llroundf (float __x) throw ();



extern float fdimf (float __x, float __y) throw (); extern float __fdimf (float __x, float __y) throw ();


extern float fmaxf (float __x, float __y) throw () __attribute__ ((__const__)); extern float __fmaxf (float __x, float __y) throw () __attribute__ ((__const__));


extern float fminf (float __x, float __y) throw () __attribute__ ((__const__)); extern float __fminf (float __x, float __y) throw () __attribute__ ((__const__));


extern float fmaf (float __x, float __y, float __z) throw (); extern float __fmaf (float __x, float __y, float __z) throw ();




extern float roundevenf (float __x) throw () __attribute__ ((__const__)); extern float __roundevenf (float __x) throw () __attribute__ ((__const__));



extern __intmax_t fromfpf (float __x, int __round, unsigned int __width) throw (); extern __intmax_t __fromfpf (float __x, int __round, unsigned int __width) throw ();




extern __uintmax_t ufromfpf (float __x, int __round, unsigned int __width) throw (); extern __uintmax_t __ufromfpf (float __x, int __round, unsigned int __width) throw ();





extern __intmax_t fromfpxf (float __x, int __round, unsigned int __width) throw (); extern __intmax_t __fromfpxf (float __x, int __round, unsigned int __width) throw ();





extern __uintmax_t ufromfpxf (float __x, int __round, unsigned int __width) throw (); extern __uintmax_t __ufromfpxf (float __x, int __round, unsigned int __width) throw ();



extern float fmaxmagf (float __x, float __y) throw () __attribute__ ((__const__)); extern float __fmaxmagf (float __x, float __y) throw () __attribute__ ((__const__));


extern float fminmagf (float __x, float __y) throw () __attribute__ ((__const__)); extern float __fminmagf (float __x, float __y) throw () __attribute__ ((__const__));


extern int totalorderf (float __x, float __y) throw ()
     __attribute__ ((__const__));


extern int totalordermagf (float __x, float __y) throw ()
     __attribute__ ((__const__));


extern int canonicalizef (float *__cx, const float *__x) throw ();


extern float getpayloadf (const float *__x) throw (); extern float __getpayloadf (const float *__x) throw ();


extern int setpayloadf (float *__x, float __payload) throw ();


extern int setpayloadsigf (float *__x, float __payload) throw ();







extern float scalbf (float __x, float __n) throw (); extern float __scalbf (float __x, float __n) throw ();
# 308 "/usr/include/math.h" 2 3 4
# 349 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathcalls-helper-functions.h" 1 3 4
# 21 "/usr/include/bits/mathcalls-helper-functions.h" 3 4
extern int __fpclassifyl (long double __value) throw ()
     __attribute__ ((__const__));


extern int __signbitl (long double __value) throw ()
     __attribute__ ((__const__));



extern int __isinfl (long double __value) throw () __attribute__ ((__const__));


extern int __finitel (long double __value) throw () __attribute__ ((__const__));


extern int __isnanl (long double __value) throw () __attribute__ ((__const__));


extern int __iseqsigl (long double __x, long double __y) throw ();


extern int __issignalingl (long double __value) throw ()
     __attribute__ ((__const__));
# 350 "/usr/include/math.h" 2 3 4
# 1 "/usr/include/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/bits/mathcalls.h" 3 4
extern long double acosl (long double __x) throw (); extern long double __acosl (long double __x) throw ();

extern long double asinl (long double __x) throw (); extern long double __asinl (long double __x) throw ();

extern long double atanl (long double __x) throw (); extern long double __atanl (long double __x) throw ();

extern long double atan2l (long double __y, long double __x) throw (); extern long double __atan2l (long double __y, long double __x) throw ();


 extern long double cosl (long double __x) throw (); extern long double __cosl (long double __x) throw ();

 extern long double sinl (long double __x) throw (); extern long double __sinl (long double __x) throw ();

extern long double tanl (long double __x) throw (); extern long double __tanl (long double __x) throw ();




extern long double coshl (long double __x) throw (); extern long double __coshl (long double __x) throw ();

extern long double sinhl (long double __x) throw (); extern long double __sinhl (long double __x) throw ();

extern long double tanhl (long double __x) throw (); extern long double __tanhl (long double __x) throw ();



 extern void sincosl (long double __x, long double *__sinx, long double *__cosx) throw (); extern void __sincosl (long double __x, long double *__sinx, long double *__cosx) throw ();





extern long double acoshl (long double __x) throw (); extern long double __acoshl (long double __x) throw ();

extern long double asinhl (long double __x) throw (); extern long double __asinhl (long double __x) throw ();

extern long double atanhl (long double __x) throw (); extern long double __atanhl (long double __x) throw ();





 extern long double expl (long double __x) throw (); extern long double __expl (long double __x) throw ();


extern long double frexpl (long double __x, int *__exponent) throw (); extern long double __frexpl (long double __x, int *__exponent) throw ();


extern long double ldexpl (long double __x, int __exponent) throw (); extern long double __ldexpl (long double __x, int __exponent) throw ();


 extern long double logl (long double __x) throw (); extern long double __logl (long double __x) throw ();


extern long double log10l (long double __x) throw (); extern long double __log10l (long double __x) throw ();


extern long double modfl (long double __x, long double *__iptr) throw (); extern long double __modfl (long double __x, long double *__iptr) throw () __attribute__ ((__nonnull__ (2)));



extern long double exp10l (long double __x) throw (); extern long double __exp10l (long double __x) throw ();




extern long double expm1l (long double __x) throw (); extern long double __expm1l (long double __x) throw ();


extern long double log1pl (long double __x) throw (); extern long double __log1pl (long double __x) throw ();


extern long double logbl (long double __x) throw (); extern long double __logbl (long double __x) throw ();




extern long double exp2l (long double __x) throw (); extern long double __exp2l (long double __x) throw ();


extern long double log2l (long double __x) throw (); extern long double __log2l (long double __x) throw ();






 extern long double powl (long double __x, long double __y) throw (); extern long double __powl (long double __x, long double __y) throw ();


extern long double sqrtl (long double __x) throw (); extern long double __sqrtl (long double __x) throw ();



extern long double hypotl (long double __x, long double __y) throw (); extern long double __hypotl (long double __x, long double __y) throw ();




extern long double cbrtl (long double __x) throw (); extern long double __cbrtl (long double __x) throw ();






extern long double ceill (long double __x) throw () __attribute__ ((__const__)); extern long double __ceill (long double __x) throw () __attribute__ ((__const__));


extern long double fabsl (long double __x) throw () __attribute__ ((__const__)); extern long double __fabsl (long double __x) throw () __attribute__ ((__const__));


extern long double floorl (long double __x) throw () __attribute__ ((__const__)); extern long double __floorl (long double __x) throw () __attribute__ ((__const__));


extern long double fmodl (long double __x, long double __y) throw (); extern long double __fmodl (long double __x, long double __y) throw ();
# 177 "/usr/include/bits/mathcalls.h" 3 4
extern int isinfl (long double __value) throw () __attribute__ ((__const__));




extern int finitel (long double __value) throw () __attribute__ ((__const__));


extern long double dreml (long double __x, long double __y) throw (); extern long double __dreml (long double __x, long double __y) throw ();



extern long double significandl (long double __x) throw (); extern long double __significandl (long double __x) throw ();






extern long double copysignl (long double __x, long double __y) throw () __attribute__ ((__const__)); extern long double __copysignl (long double __x, long double __y) throw () __attribute__ ((__const__));




extern long double nanl (const char *__tagb) throw (); extern long double __nanl (const char *__tagb) throw ();
# 211 "/usr/include/bits/mathcalls.h" 3 4
extern int isnanl (long double __value) throw () __attribute__ ((__const__));





extern long double j0l (long double) throw (); extern long double __j0l (long double) throw ();
extern long double j1l (long double) throw (); extern long double __j1l (long double) throw ();
extern long double jnl (int, long double) throw (); extern long double __jnl (int, long double) throw ();
extern long double y0l (long double) throw (); extern long double __y0l (long double) throw ();
extern long double y1l (long double) throw (); extern long double __y1l (long double) throw ();
extern long double ynl (int, long double) throw (); extern long double __ynl (int, long double) throw ();





extern long double erfl (long double) throw (); extern long double __erfl (long double) throw ();
extern long double erfcl (long double) throw (); extern long double __erfcl (long double) throw ();
extern long double lgammal (long double) throw (); extern long double __lgammal (long double) throw ();




extern long double tgammal (long double) throw (); extern long double __tgammal (long double) throw ();





extern long double gammal (long double) throw (); extern long double __gammal (long double) throw ();







extern long double lgammal_r (long double, int *__signgamp) throw (); extern long double __lgammal_r (long double, int *__signgamp) throw ();






extern long double rintl (long double __x) throw (); extern long double __rintl (long double __x) throw ();


extern long double nextafterl (long double __x, long double __y) throw (); extern long double __nextafterl (long double __x, long double __y) throw ();

extern long double nexttowardl (long double __x, long double __y) throw (); extern long double __nexttowardl (long double __x, long double __y) throw ();




extern long double nextdownl (long double __x) throw (); extern long double __nextdownl (long double __x) throw ();

extern long double nextupl (long double __x) throw (); extern long double __nextupl (long double __x) throw ();



extern long double remainderl (long double __x, long double __y) throw (); extern long double __remainderl (long double __x, long double __y) throw ();



extern long double scalbnl (long double __x, int __n) throw (); extern long double __scalbnl (long double __x, int __n) throw ();



extern int ilogbl (long double __x) throw (); extern int __ilogbl (long double __x) throw ();




extern long int llogbl (long double __x) throw (); extern long int __llogbl (long double __x) throw ();




extern long double scalblnl (long double __x, long int __n) throw (); extern long double __scalblnl (long double __x, long int __n) throw ();



extern long double nearbyintl (long double __x) throw (); extern long double __nearbyintl (long double __x) throw ();



extern long double roundl (long double __x) throw () __attribute__ ((__const__)); extern long double __roundl (long double __x) throw () __attribute__ ((__const__));



extern long double truncl (long double __x) throw () __attribute__ ((__const__)); extern long double __truncl (long double __x) throw () __attribute__ ((__const__));




extern long double remquol (long double __x, long double __y, int *__quo) throw (); extern long double __remquol (long double __x, long double __y, int *__quo) throw ();






extern long int lrintl (long double __x) throw (); extern long int __lrintl (long double __x) throw ();
__extension__
extern long long int llrintl (long double __x) throw (); extern long long int __llrintl (long double __x) throw ();



extern long int lroundl (long double __x) throw (); extern long int __lroundl (long double __x) throw ();
__extension__
extern long long int llroundl (long double __x) throw (); extern long long int __llroundl (long double __x) throw ();



extern long double fdiml (long double __x, long double __y) throw (); extern long double __fdiml (long double __x, long double __y) throw ();


extern long double fmaxl (long double __x, long double __y) throw () __attribute__ ((__const__)); extern long double __fmaxl (long double __x, long double __y) throw () __attribute__ ((__const__));


extern long double fminl (long double __x, long double __y) throw () __attribute__ ((__const__)); extern long double __fminl (long double __x, long double __y) throw () __attribute__ ((__const__));


extern long double fmal (long double __x, long double __y, long double __z) throw (); extern long double __fmal (long double __x, long double __y, long double __z) throw ();




extern long double roundevenl (long double __x) throw () __attribute__ ((__const__)); extern long double __roundevenl (long double __x) throw () __attribute__ ((__const__));



extern __intmax_t fromfpl (long double __x, int __round, unsigned int __width) throw (); extern __intmax_t __fromfpl (long double __x, int __round, unsigned int __width) throw ();




extern __uintmax_t ufromfpl (long double __x, int __round, unsigned int __width) throw (); extern __uintmax_t __ufromfpl (long double __x, int __round, unsigned int __width) throw ();





extern __intmax_t fromfpxl (long double __x, int __round, unsigned int __width) throw (); extern __intmax_t __fromfpxl (long double __x, int __round, unsigned int __width) throw ();





extern __uintmax_t ufromfpxl (long double __x, int __round, unsigned int __width) throw (); extern __uintmax_t __ufromfpxl (long double __x, int __round, unsigned int __width) throw ();



extern long double fmaxmagl (long double __x, long double __y) throw () __attribute__ ((__const__)); extern long double __fmaxmagl (long double __x, long double __y) throw () __attribute__ ((__const__));


extern long double fminmagl (long double __x, long double __y) throw () __attribute__ ((__const__)); extern long double __fminmagl (long double __x, long double __y) throw () __attribute__ ((__const__));


extern int totalorderl (long double __x, long double __y) throw ()
     __attribute__ ((__const__));


extern int totalordermagl (long double __x, long double __y) throw ()
     __attribute__ ((__const__));


extern int canonicalizel (long double *__cx, const long double *__x) throw ();


extern long double getpayloadl (const long double *__x) throw (); extern long double __getpayloadl (const long double *__x) throw ();


extern int setpayloadl (long double *__x, long double __payload) throw ();


extern int setpayloadsigl (long double *__x, long double __payload) throw ();







extern long double scalbl (long double __x, long double __n) throw (); extern long double __scalbl (long double __x, long double __n) throw ();
# 351 "/usr/include/math.h" 2 3 4
# 389 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/bits/mathcalls.h" 3 4
extern _Float32 acosf32 (_Float32 __x) throw (); extern _Float32 __acosf32 (_Float32 __x) throw ();

extern _Float32 asinf32 (_Float32 __x) throw (); extern _Float32 __asinf32 (_Float32 __x) throw ();

extern _Float32 atanf32 (_Float32 __x) throw (); extern _Float32 __atanf32 (_Float32 __x) throw ();

extern _Float32 atan2f32 (_Float32 __y, _Float32 __x) throw (); extern _Float32 __atan2f32 (_Float32 __y, _Float32 __x) throw ();


 extern _Float32 cosf32 (_Float32 __x) throw (); extern _Float32 __cosf32 (_Float32 __x) throw ();

 extern _Float32 sinf32 (_Float32 __x) throw (); extern _Float32 __sinf32 (_Float32 __x) throw ();

extern _Float32 tanf32 (_Float32 __x) throw (); extern _Float32 __tanf32 (_Float32 __x) throw ();




extern _Float32 coshf32 (_Float32 __x) throw (); extern _Float32 __coshf32 (_Float32 __x) throw ();

extern _Float32 sinhf32 (_Float32 __x) throw (); extern _Float32 __sinhf32 (_Float32 __x) throw ();

extern _Float32 tanhf32 (_Float32 __x) throw (); extern _Float32 __tanhf32 (_Float32 __x) throw ();



 extern void sincosf32 (_Float32 __x, _Float32 *__sinx, _Float32 *__cosx) throw (); extern void __sincosf32 (_Float32 __x, _Float32 *__sinx, _Float32 *__cosx) throw ();





extern _Float32 acoshf32 (_Float32 __x) throw (); extern _Float32 __acoshf32 (_Float32 __x) throw ();

extern _Float32 asinhf32 (_Float32 __x) throw (); extern _Float32 __asinhf32 (_Float32 __x) throw ();

extern _Float32 atanhf32 (_Float32 __x) throw (); extern _Float32 __atanhf32 (_Float32 __x) throw ();





 extern _Float32 expf32 (_Float32 __x) throw (); extern _Float32 __expf32 (_Float32 __x) throw ();


extern _Float32 frexpf32 (_Float32 __x, int *__exponent) throw (); extern _Float32 __frexpf32 (_Float32 __x, int *__exponent) throw ();


extern _Float32 ldexpf32 (_Float32 __x, int __exponent) throw (); extern _Float32 __ldexpf32 (_Float32 __x, int __exponent) throw ();


 extern _Float32 logf32 (_Float32 __x) throw (); extern _Float32 __logf32 (_Float32 __x) throw ();


extern _Float32 log10f32 (_Float32 __x) throw (); extern _Float32 __log10f32 (_Float32 __x) throw ();


extern _Float32 modff32 (_Float32 __x, _Float32 *__iptr) throw (); extern _Float32 __modff32 (_Float32 __x, _Float32 *__iptr) throw () __attribute__ ((__nonnull__ (2)));



extern _Float32 exp10f32 (_Float32 __x) throw (); extern _Float32 __exp10f32 (_Float32 __x) throw ();




extern _Float32 expm1f32 (_Float32 __x) throw (); extern _Float32 __expm1f32 (_Float32 __x) throw ();


extern _Float32 log1pf32 (_Float32 __x) throw (); extern _Float32 __log1pf32 (_Float32 __x) throw ();


extern _Float32 logbf32 (_Float32 __x) throw (); extern _Float32 __logbf32 (_Float32 __x) throw ();




extern _Float32 exp2f32 (_Float32 __x) throw (); extern _Float32 __exp2f32 (_Float32 __x) throw ();


extern _Float32 log2f32 (_Float32 __x) throw (); extern _Float32 __log2f32 (_Float32 __x) throw ();






 extern _Float32 powf32 (_Float32 __x, _Float32 __y) throw (); extern _Float32 __powf32 (_Float32 __x, _Float32 __y) throw ();


extern _Float32 sqrtf32 (_Float32 __x) throw (); extern _Float32 __sqrtf32 (_Float32 __x) throw ();



extern _Float32 hypotf32 (_Float32 __x, _Float32 __y) throw (); extern _Float32 __hypotf32 (_Float32 __x, _Float32 __y) throw ();




extern _Float32 cbrtf32 (_Float32 __x) throw (); extern _Float32 __cbrtf32 (_Float32 __x) throw ();






extern _Float32 ceilf32 (_Float32 __x) throw () __attribute__ ((__const__)); extern _Float32 __ceilf32 (_Float32 __x) throw () __attribute__ ((__const__));


extern _Float32 fabsf32 (_Float32 __x) throw () __attribute__ ((__const__)); extern _Float32 __fabsf32 (_Float32 __x) throw () __attribute__ ((__const__));


extern _Float32 floorf32 (_Float32 __x) throw () __attribute__ ((__const__)); extern _Float32 __floorf32 (_Float32 __x) throw () __attribute__ ((__const__));


extern _Float32 fmodf32 (_Float32 __x, _Float32 __y) throw (); extern _Float32 __fmodf32 (_Float32 __x, _Float32 __y) throw ();
# 196 "/usr/include/bits/mathcalls.h" 3 4
extern _Float32 copysignf32 (_Float32 __x, _Float32 __y) throw () __attribute__ ((__const__)); extern _Float32 __copysignf32 (_Float32 __x, _Float32 __y) throw () __attribute__ ((__const__));




extern _Float32 nanf32 (const char *__tagb) throw (); extern _Float32 __nanf32 (const char *__tagb) throw ();
# 217 "/usr/include/bits/mathcalls.h" 3 4
extern _Float32 j0f32 (_Float32) throw (); extern _Float32 __j0f32 (_Float32) throw ();
extern _Float32 j1f32 (_Float32) throw (); extern _Float32 __j1f32 (_Float32) throw ();
extern _Float32 jnf32 (int, _Float32) throw (); extern _Float32 __jnf32 (int, _Float32) throw ();
extern _Float32 y0f32 (_Float32) throw (); extern _Float32 __y0f32 (_Float32) throw ();
extern _Float32 y1f32 (_Float32) throw (); extern _Float32 __y1f32 (_Float32) throw ();
extern _Float32 ynf32 (int, _Float32) throw (); extern _Float32 __ynf32 (int, _Float32) throw ();





extern _Float32 erff32 (_Float32) throw (); extern _Float32 __erff32 (_Float32) throw ();
extern _Float32 erfcf32 (_Float32) throw (); extern _Float32 __erfcf32 (_Float32) throw ();
extern _Float32 lgammaf32 (_Float32) throw (); extern _Float32 __lgammaf32 (_Float32) throw ();




extern _Float32 tgammaf32 (_Float32) throw (); extern _Float32 __tgammaf32 (_Float32) throw ();
# 249 "/usr/include/bits/mathcalls.h" 3 4
extern _Float32 lgammaf32_r (_Float32, int *__signgamp) throw (); extern _Float32 __lgammaf32_r (_Float32, int *__signgamp) throw ();






extern _Float32 rintf32 (_Float32 __x) throw (); extern _Float32 __rintf32 (_Float32 __x) throw ();


extern _Float32 nextafterf32 (_Float32 __x, _Float32 __y) throw (); extern _Float32 __nextafterf32 (_Float32 __x, _Float32 __y) throw ();






extern _Float32 nextdownf32 (_Float32 __x) throw (); extern _Float32 __nextdownf32 (_Float32 __x) throw ();

extern _Float32 nextupf32 (_Float32 __x) throw (); extern _Float32 __nextupf32 (_Float32 __x) throw ();



extern _Float32 remainderf32 (_Float32 __x, _Float32 __y) throw (); extern _Float32 __remainderf32 (_Float32 __x, _Float32 __y) throw ();



extern _Float32 scalbnf32 (_Float32 __x, int __n) throw (); extern _Float32 __scalbnf32 (_Float32 __x, int __n) throw ();



extern int ilogbf32 (_Float32 __x) throw (); extern int __ilogbf32 (_Float32 __x) throw ();




extern long int llogbf32 (_Float32 __x) throw (); extern long int __llogbf32 (_Float32 __x) throw ();




extern _Float32 scalblnf32 (_Float32 __x, long int __n) throw (); extern _Float32 __scalblnf32 (_Float32 __x, long int __n) throw ();



extern _Float32 nearbyintf32 (_Float32 __x) throw (); extern _Float32 __nearbyintf32 (_Float32 __x) throw ();



extern _Float32 roundf32 (_Float32 __x) throw () __attribute__ ((__const__)); extern _Float32 __roundf32 (_Float32 __x) throw () __attribute__ ((__const__));



extern _Float32 truncf32 (_Float32 __x) throw () __attribute__ ((__const__)); extern _Float32 __truncf32 (_Float32 __x) throw () __attribute__ ((__const__));




extern _Float32 remquof32 (_Float32 __x, _Float32 __y, int *__quo) throw (); extern _Float32 __remquof32 (_Float32 __x, _Float32 __y, int *__quo) throw ();






extern long int lrintf32 (_Float32 __x) throw (); extern long int __lrintf32 (_Float32 __x) throw ();
__extension__
extern long long int llrintf32 (_Float32 __x) throw (); extern long long int __llrintf32 (_Float32 __x) throw ();



extern long int lroundf32 (_Float32 __x) throw (); extern long int __lroundf32 (_Float32 __x) throw ();
__extension__
extern long long int llroundf32 (_Float32 __x) throw (); extern long long int __llroundf32 (_Float32 __x) throw ();



extern _Float32 fdimf32 (_Float32 __x, _Float32 __y) throw (); extern _Float32 __fdimf32 (_Float32 __x, _Float32 __y) throw ();


extern _Float32 fmaxf32 (_Float32 __x, _Float32 __y) throw () __attribute__ ((__const__)); extern _Float32 __fmaxf32 (_Float32 __x, _Float32 __y) throw () __attribute__ ((__const__));


extern _Float32 fminf32 (_Float32 __x, _Float32 __y) throw () __attribute__ ((__const__)); extern _Float32 __fminf32 (_Float32 __x, _Float32 __y) throw () __attribute__ ((__const__));


extern _Float32 fmaf32 (_Float32 __x, _Float32 __y, _Float32 __z) throw (); extern _Float32 __fmaf32 (_Float32 __x, _Float32 __y, _Float32 __z) throw ();




extern _Float32 roundevenf32 (_Float32 __x) throw () __attribute__ ((__const__)); extern _Float32 __roundevenf32 (_Float32 __x) throw () __attribute__ ((__const__));



extern __intmax_t fromfpf32 (_Float32 __x, int __round, unsigned int __width) throw (); extern __intmax_t __fromfpf32 (_Float32 __x, int __round, unsigned int __width) throw ();




extern __uintmax_t ufromfpf32 (_Float32 __x, int __round, unsigned int __width) throw (); extern __uintmax_t __ufromfpf32 (_Float32 __x, int __round, unsigned int __width) throw ();





extern __intmax_t fromfpxf32 (_Float32 __x, int __round, unsigned int __width) throw (); extern __intmax_t __fromfpxf32 (_Float32 __x, int __round, unsigned int __width) throw ();





extern __uintmax_t ufromfpxf32 (_Float32 __x, int __round, unsigned int __width) throw (); extern __uintmax_t __ufromfpxf32 (_Float32 __x, int __round, unsigned int __width) throw ();



extern _Float32 fmaxmagf32 (_Float32 __x, _Float32 __y) throw () __attribute__ ((__const__)); extern _Float32 __fmaxmagf32 (_Float32 __x, _Float32 __y) throw () __attribute__ ((__const__));


extern _Float32 fminmagf32 (_Float32 __x, _Float32 __y) throw () __attribute__ ((__const__)); extern _Float32 __fminmagf32 (_Float32 __x, _Float32 __y) throw () __attribute__ ((__const__));


extern int totalorderf32 (_Float32 __x, _Float32 __y) throw ()
     __attribute__ ((__const__));


extern int totalordermagf32 (_Float32 __x, _Float32 __y) throw ()
     __attribute__ ((__const__));


extern int canonicalizef32 (_Float32 *__cx, const _Float32 *__x) throw ();


extern _Float32 getpayloadf32 (const _Float32 *__x) throw (); extern _Float32 __getpayloadf32 (const _Float32 *__x) throw ();


extern int setpayloadf32 (_Float32 *__x, _Float32 __payload) throw ();


extern int setpayloadsigf32 (_Float32 *__x, _Float32 __payload) throw ();
# 390 "/usr/include/math.h" 2 3 4
# 406 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/bits/mathcalls.h" 3 4
extern _Float64 acosf64 (_Float64 __x) throw (); extern _Float64 __acosf64 (_Float64 __x) throw ();

extern _Float64 asinf64 (_Float64 __x) throw (); extern _Float64 __asinf64 (_Float64 __x) throw ();

extern _Float64 atanf64 (_Float64 __x) throw (); extern _Float64 __atanf64 (_Float64 __x) throw ();

extern _Float64 atan2f64 (_Float64 __y, _Float64 __x) throw (); extern _Float64 __atan2f64 (_Float64 __y, _Float64 __x) throw ();


 extern _Float64 cosf64 (_Float64 __x) throw (); extern _Float64 __cosf64 (_Float64 __x) throw ();

 extern _Float64 sinf64 (_Float64 __x) throw (); extern _Float64 __sinf64 (_Float64 __x) throw ();

extern _Float64 tanf64 (_Float64 __x) throw (); extern _Float64 __tanf64 (_Float64 __x) throw ();




extern _Float64 coshf64 (_Float64 __x) throw (); extern _Float64 __coshf64 (_Float64 __x) throw ();

extern _Float64 sinhf64 (_Float64 __x) throw (); extern _Float64 __sinhf64 (_Float64 __x) throw ();

extern _Float64 tanhf64 (_Float64 __x) throw (); extern _Float64 __tanhf64 (_Float64 __x) throw ();



 extern void sincosf64 (_Float64 __x, _Float64 *__sinx, _Float64 *__cosx) throw (); extern void __sincosf64 (_Float64 __x, _Float64 *__sinx, _Float64 *__cosx) throw ();





extern _Float64 acoshf64 (_Float64 __x) throw (); extern _Float64 __acoshf64 (_Float64 __x) throw ();

extern _Float64 asinhf64 (_Float64 __x) throw (); extern _Float64 __asinhf64 (_Float64 __x) throw ();

extern _Float64 atanhf64 (_Float64 __x) throw (); extern _Float64 __atanhf64 (_Float64 __x) throw ();





 extern _Float64 expf64 (_Float64 __x) throw (); extern _Float64 __expf64 (_Float64 __x) throw ();


extern _Float64 frexpf64 (_Float64 __x, int *__exponent) throw (); extern _Float64 __frexpf64 (_Float64 __x, int *__exponent) throw ();


extern _Float64 ldexpf64 (_Float64 __x, int __exponent) throw (); extern _Float64 __ldexpf64 (_Float64 __x, int __exponent) throw ();


 extern _Float64 logf64 (_Float64 __x) throw (); extern _Float64 __logf64 (_Float64 __x) throw ();


extern _Float64 log10f64 (_Float64 __x) throw (); extern _Float64 __log10f64 (_Float64 __x) throw ();


extern _Float64 modff64 (_Float64 __x, _Float64 *__iptr) throw (); extern _Float64 __modff64 (_Float64 __x, _Float64 *__iptr) throw () __attribute__ ((__nonnull__ (2)));



extern _Float64 exp10f64 (_Float64 __x) throw (); extern _Float64 __exp10f64 (_Float64 __x) throw ();




extern _Float64 expm1f64 (_Float64 __x) throw (); extern _Float64 __expm1f64 (_Float64 __x) throw ();


extern _Float64 log1pf64 (_Float64 __x) throw (); extern _Float64 __log1pf64 (_Float64 __x) throw ();


extern _Float64 logbf64 (_Float64 __x) throw (); extern _Float64 __logbf64 (_Float64 __x) throw ();




extern _Float64 exp2f64 (_Float64 __x) throw (); extern _Float64 __exp2f64 (_Float64 __x) throw ();


extern _Float64 log2f64 (_Float64 __x) throw (); extern _Float64 __log2f64 (_Float64 __x) throw ();






 extern _Float64 powf64 (_Float64 __x, _Float64 __y) throw (); extern _Float64 __powf64 (_Float64 __x, _Float64 __y) throw ();


extern _Float64 sqrtf64 (_Float64 __x) throw (); extern _Float64 __sqrtf64 (_Float64 __x) throw ();



extern _Float64 hypotf64 (_Float64 __x, _Float64 __y) throw (); extern _Float64 __hypotf64 (_Float64 __x, _Float64 __y) throw ();




extern _Float64 cbrtf64 (_Float64 __x) throw (); extern _Float64 __cbrtf64 (_Float64 __x) throw ();






extern _Float64 ceilf64 (_Float64 __x) throw () __attribute__ ((__const__)); extern _Float64 __ceilf64 (_Float64 __x) throw () __attribute__ ((__const__));


extern _Float64 fabsf64 (_Float64 __x) throw () __attribute__ ((__const__)); extern _Float64 __fabsf64 (_Float64 __x) throw () __attribute__ ((__const__));


extern _Float64 floorf64 (_Float64 __x) throw () __attribute__ ((__const__)); extern _Float64 __floorf64 (_Float64 __x) throw () __attribute__ ((__const__));


extern _Float64 fmodf64 (_Float64 __x, _Float64 __y) throw (); extern _Float64 __fmodf64 (_Float64 __x, _Float64 __y) throw ();
# 196 "/usr/include/bits/mathcalls.h" 3 4
extern _Float64 copysignf64 (_Float64 __x, _Float64 __y) throw () __attribute__ ((__const__)); extern _Float64 __copysignf64 (_Float64 __x, _Float64 __y) throw () __attribute__ ((__const__));




extern _Float64 nanf64 (const char *__tagb) throw (); extern _Float64 __nanf64 (const char *__tagb) throw ();
# 217 "/usr/include/bits/mathcalls.h" 3 4
extern _Float64 j0f64 (_Float64) throw (); extern _Float64 __j0f64 (_Float64) throw ();
extern _Float64 j1f64 (_Float64) throw (); extern _Float64 __j1f64 (_Float64) throw ();
extern _Float64 jnf64 (int, _Float64) throw (); extern _Float64 __jnf64 (int, _Float64) throw ();
extern _Float64 y0f64 (_Float64) throw (); extern _Float64 __y0f64 (_Float64) throw ();
extern _Float64 y1f64 (_Float64) throw (); extern _Float64 __y1f64 (_Float64) throw ();
extern _Float64 ynf64 (int, _Float64) throw (); extern _Float64 __ynf64 (int, _Float64) throw ();





extern _Float64 erff64 (_Float64) throw (); extern _Float64 __erff64 (_Float64) throw ();
extern _Float64 erfcf64 (_Float64) throw (); extern _Float64 __erfcf64 (_Float64) throw ();
extern _Float64 lgammaf64 (_Float64) throw (); extern _Float64 __lgammaf64 (_Float64) throw ();




extern _Float64 tgammaf64 (_Float64) throw (); extern _Float64 __tgammaf64 (_Float64) throw ();
# 249 "/usr/include/bits/mathcalls.h" 3 4
extern _Float64 lgammaf64_r (_Float64, int *__signgamp) throw (); extern _Float64 __lgammaf64_r (_Float64, int *__signgamp) throw ();






extern _Float64 rintf64 (_Float64 __x) throw (); extern _Float64 __rintf64 (_Float64 __x) throw ();


extern _Float64 nextafterf64 (_Float64 __x, _Float64 __y) throw (); extern _Float64 __nextafterf64 (_Float64 __x, _Float64 __y) throw ();






extern _Float64 nextdownf64 (_Float64 __x) throw (); extern _Float64 __nextdownf64 (_Float64 __x) throw ();

extern _Float64 nextupf64 (_Float64 __x) throw (); extern _Float64 __nextupf64 (_Float64 __x) throw ();



extern _Float64 remainderf64 (_Float64 __x, _Float64 __y) throw (); extern _Float64 __remainderf64 (_Float64 __x, _Float64 __y) throw ();



extern _Float64 scalbnf64 (_Float64 __x, int __n) throw (); extern _Float64 __scalbnf64 (_Float64 __x, int __n) throw ();



extern int ilogbf64 (_Float64 __x) throw (); extern int __ilogbf64 (_Float64 __x) throw ();




extern long int llogbf64 (_Float64 __x) throw (); extern long int __llogbf64 (_Float64 __x) throw ();




extern _Float64 scalblnf64 (_Float64 __x, long int __n) throw (); extern _Float64 __scalblnf64 (_Float64 __x, long int __n) throw ();



extern _Float64 nearbyintf64 (_Float64 __x) throw (); extern _Float64 __nearbyintf64 (_Float64 __x) throw ();



extern _Float64 roundf64 (_Float64 __x) throw () __attribute__ ((__const__)); extern _Float64 __roundf64 (_Float64 __x) throw () __attribute__ ((__const__));



extern _Float64 truncf64 (_Float64 __x) throw () __attribute__ ((__const__)); extern _Float64 __truncf64 (_Float64 __x) throw () __attribute__ ((__const__));




extern _Float64 remquof64 (_Float64 __x, _Float64 __y, int *__quo) throw (); extern _Float64 __remquof64 (_Float64 __x, _Float64 __y, int *__quo) throw ();






extern long int lrintf64 (_Float64 __x) throw (); extern long int __lrintf64 (_Float64 __x) throw ();
__extension__
extern long long int llrintf64 (_Float64 __x) throw (); extern long long int __llrintf64 (_Float64 __x) throw ();



extern long int lroundf64 (_Float64 __x) throw (); extern long int __lroundf64 (_Float64 __x) throw ();
__extension__
extern long long int llroundf64 (_Float64 __x) throw (); extern long long int __llroundf64 (_Float64 __x) throw ();



extern _Float64 fdimf64 (_Float64 __x, _Float64 __y) throw (); extern _Float64 __fdimf64 (_Float64 __x, _Float64 __y) throw ();


extern _Float64 fmaxf64 (_Float64 __x, _Float64 __y) throw () __attribute__ ((__const__)); extern _Float64 __fmaxf64 (_Float64 __x, _Float64 __y) throw () __attribute__ ((__const__));


extern _Float64 fminf64 (_Float64 __x, _Float64 __y) throw () __attribute__ ((__const__)); extern _Float64 __fminf64 (_Float64 __x, _Float64 __y) throw () __attribute__ ((__const__));


extern _Float64 fmaf64 (_Float64 __x, _Float64 __y, _Float64 __z) throw (); extern _Float64 __fmaf64 (_Float64 __x, _Float64 __y, _Float64 __z) throw ();




extern _Float64 roundevenf64 (_Float64 __x) throw () __attribute__ ((__const__)); extern _Float64 __roundevenf64 (_Float64 __x) throw () __attribute__ ((__const__));



extern __intmax_t fromfpf64 (_Float64 __x, int __round, unsigned int __width) throw (); extern __intmax_t __fromfpf64 (_Float64 __x, int __round, unsigned int __width) throw ();




extern __uintmax_t ufromfpf64 (_Float64 __x, int __round, unsigned int __width) throw (); extern __uintmax_t __ufromfpf64 (_Float64 __x, int __round, unsigned int __width) throw ();





extern __intmax_t fromfpxf64 (_Float64 __x, int __round, unsigned int __width) throw (); extern __intmax_t __fromfpxf64 (_Float64 __x, int __round, unsigned int __width) throw ();





extern __uintmax_t ufromfpxf64 (_Float64 __x, int __round, unsigned int __width) throw (); extern __uintmax_t __ufromfpxf64 (_Float64 __x, int __round, unsigned int __width) throw ();



extern _Float64 fmaxmagf64 (_Float64 __x, _Float64 __y) throw () __attribute__ ((__const__)); extern _Float64 __fmaxmagf64 (_Float64 __x, _Float64 __y) throw () __attribute__ ((__const__));


extern _Float64 fminmagf64 (_Float64 __x, _Float64 __y) throw () __attribute__ ((__const__)); extern _Float64 __fminmagf64 (_Float64 __x, _Float64 __y) throw () __attribute__ ((__const__));


extern int totalorderf64 (_Float64 __x, _Float64 __y) throw ()
     __attribute__ ((__const__));


extern int totalordermagf64 (_Float64 __x, _Float64 __y) throw ()
     __attribute__ ((__const__));


extern int canonicalizef64 (_Float64 *__cx, const _Float64 *__x) throw ();


extern _Float64 getpayloadf64 (const _Float64 *__x) throw (); extern _Float64 __getpayloadf64 (const _Float64 *__x) throw ();


extern int setpayloadf64 (_Float64 *__x, _Float64 __payload) throw ();


extern int setpayloadsigf64 (_Float64 *__x, _Float64 __payload) throw ();
# 407 "/usr/include/math.h" 2 3 4
# 440 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/bits/mathcalls.h" 3 4
extern _Float32x acosf32x (_Float32x __x) throw (); extern _Float32x __acosf32x (_Float32x __x) throw ();

extern _Float32x asinf32x (_Float32x __x) throw (); extern _Float32x __asinf32x (_Float32x __x) throw ();

extern _Float32x atanf32x (_Float32x __x) throw (); extern _Float32x __atanf32x (_Float32x __x) throw ();

extern _Float32x atan2f32x (_Float32x __y, _Float32x __x) throw (); extern _Float32x __atan2f32x (_Float32x __y, _Float32x __x) throw ();


 extern _Float32x cosf32x (_Float32x __x) throw (); extern _Float32x __cosf32x (_Float32x __x) throw ();

 extern _Float32x sinf32x (_Float32x __x) throw (); extern _Float32x __sinf32x (_Float32x __x) throw ();

extern _Float32x tanf32x (_Float32x __x) throw (); extern _Float32x __tanf32x (_Float32x __x) throw ();




extern _Float32x coshf32x (_Float32x __x) throw (); extern _Float32x __coshf32x (_Float32x __x) throw ();

extern _Float32x sinhf32x (_Float32x __x) throw (); extern _Float32x __sinhf32x (_Float32x __x) throw ();

extern _Float32x tanhf32x (_Float32x __x) throw (); extern _Float32x __tanhf32x (_Float32x __x) throw ();



 extern void sincosf32x (_Float32x __x, _Float32x *__sinx, _Float32x *__cosx) throw (); extern void __sincosf32x (_Float32x __x, _Float32x *__sinx, _Float32x *__cosx) throw ();





extern _Float32x acoshf32x (_Float32x __x) throw (); extern _Float32x __acoshf32x (_Float32x __x) throw ();

extern _Float32x asinhf32x (_Float32x __x) throw (); extern _Float32x __asinhf32x (_Float32x __x) throw ();

extern _Float32x atanhf32x (_Float32x __x) throw (); extern _Float32x __atanhf32x (_Float32x __x) throw ();





 extern _Float32x expf32x (_Float32x __x) throw (); extern _Float32x __expf32x (_Float32x __x) throw ();


extern _Float32x frexpf32x (_Float32x __x, int *__exponent) throw (); extern _Float32x __frexpf32x (_Float32x __x, int *__exponent) throw ();


extern _Float32x ldexpf32x (_Float32x __x, int __exponent) throw (); extern _Float32x __ldexpf32x (_Float32x __x, int __exponent) throw ();


 extern _Float32x logf32x (_Float32x __x) throw (); extern _Float32x __logf32x (_Float32x __x) throw ();


extern _Float32x log10f32x (_Float32x __x) throw (); extern _Float32x __log10f32x (_Float32x __x) throw ();


extern _Float32x modff32x (_Float32x __x, _Float32x *__iptr) throw (); extern _Float32x __modff32x (_Float32x __x, _Float32x *__iptr) throw () __attribute__ ((__nonnull__ (2)));



extern _Float32x exp10f32x (_Float32x __x) throw (); extern _Float32x __exp10f32x (_Float32x __x) throw ();




extern _Float32x expm1f32x (_Float32x __x) throw (); extern _Float32x __expm1f32x (_Float32x __x) throw ();


extern _Float32x log1pf32x (_Float32x __x) throw (); extern _Float32x __log1pf32x (_Float32x __x) throw ();


extern _Float32x logbf32x (_Float32x __x) throw (); extern _Float32x __logbf32x (_Float32x __x) throw ();




extern _Float32x exp2f32x (_Float32x __x) throw (); extern _Float32x __exp2f32x (_Float32x __x) throw ();


extern _Float32x log2f32x (_Float32x __x) throw (); extern _Float32x __log2f32x (_Float32x __x) throw ();






 extern _Float32x powf32x (_Float32x __x, _Float32x __y) throw (); extern _Float32x __powf32x (_Float32x __x, _Float32x __y) throw ();


extern _Float32x sqrtf32x (_Float32x __x) throw (); extern _Float32x __sqrtf32x (_Float32x __x) throw ();



extern _Float32x hypotf32x (_Float32x __x, _Float32x __y) throw (); extern _Float32x __hypotf32x (_Float32x __x, _Float32x __y) throw ();




extern _Float32x cbrtf32x (_Float32x __x) throw (); extern _Float32x __cbrtf32x (_Float32x __x) throw ();






extern _Float32x ceilf32x (_Float32x __x) throw () __attribute__ ((__const__)); extern _Float32x __ceilf32x (_Float32x __x) throw () __attribute__ ((__const__));


extern _Float32x fabsf32x (_Float32x __x) throw () __attribute__ ((__const__)); extern _Float32x __fabsf32x (_Float32x __x) throw () __attribute__ ((__const__));


extern _Float32x floorf32x (_Float32x __x) throw () __attribute__ ((__const__)); extern _Float32x __floorf32x (_Float32x __x) throw () __attribute__ ((__const__));


extern _Float32x fmodf32x (_Float32x __x, _Float32x __y) throw (); extern _Float32x __fmodf32x (_Float32x __x, _Float32x __y) throw ();
# 196 "/usr/include/bits/mathcalls.h" 3 4
extern _Float32x copysignf32x (_Float32x __x, _Float32x __y) throw () __attribute__ ((__const__)); extern _Float32x __copysignf32x (_Float32x __x, _Float32x __y) throw () __attribute__ ((__const__));




extern _Float32x nanf32x (const char *__tagb) throw (); extern _Float32x __nanf32x (const char *__tagb) throw ();
# 217 "/usr/include/bits/mathcalls.h" 3 4
extern _Float32x j0f32x (_Float32x) throw (); extern _Float32x __j0f32x (_Float32x) throw ();
extern _Float32x j1f32x (_Float32x) throw (); extern _Float32x __j1f32x (_Float32x) throw ();
extern _Float32x jnf32x (int, _Float32x) throw (); extern _Float32x __jnf32x (int, _Float32x) throw ();
extern _Float32x y0f32x (_Float32x) throw (); extern _Float32x __y0f32x (_Float32x) throw ();
extern _Float32x y1f32x (_Float32x) throw (); extern _Float32x __y1f32x (_Float32x) throw ();
extern _Float32x ynf32x (int, _Float32x) throw (); extern _Float32x __ynf32x (int, _Float32x) throw ();





extern _Float32x erff32x (_Float32x) throw (); extern _Float32x __erff32x (_Float32x) throw ();
extern _Float32x erfcf32x (_Float32x) throw (); extern _Float32x __erfcf32x (_Float32x) throw ();
extern _Float32x lgammaf32x (_Float32x) throw (); extern _Float32x __lgammaf32x (_Float32x) throw ();




extern _Float32x tgammaf32x (_Float32x) throw (); extern _Float32x __tgammaf32x (_Float32x) throw ();
# 249 "/usr/include/bits/mathcalls.h" 3 4
extern _Float32x lgammaf32x_r (_Float32x, int *__signgamp) throw (); extern _Float32x __lgammaf32x_r (_Float32x, int *__signgamp) throw ();






extern _Float32x rintf32x (_Float32x __x) throw (); extern _Float32x __rintf32x (_Float32x __x) throw ();


extern _Float32x nextafterf32x (_Float32x __x, _Float32x __y) throw (); extern _Float32x __nextafterf32x (_Float32x __x, _Float32x __y) throw ();






extern _Float32x nextdownf32x (_Float32x __x) throw (); extern _Float32x __nextdownf32x (_Float32x __x) throw ();

extern _Float32x nextupf32x (_Float32x __x) throw (); extern _Float32x __nextupf32x (_Float32x __x) throw ();



extern _Float32x remainderf32x (_Float32x __x, _Float32x __y) throw (); extern _Float32x __remainderf32x (_Float32x __x, _Float32x __y) throw ();



extern _Float32x scalbnf32x (_Float32x __x, int __n) throw (); extern _Float32x __scalbnf32x (_Float32x __x, int __n) throw ();



extern int ilogbf32x (_Float32x __x) throw (); extern int __ilogbf32x (_Float32x __x) throw ();




extern long int llogbf32x (_Float32x __x) throw (); extern long int __llogbf32x (_Float32x __x) throw ();




extern _Float32x scalblnf32x (_Float32x __x, long int __n) throw (); extern _Float32x __scalblnf32x (_Float32x __x, long int __n) throw ();



extern _Float32x nearbyintf32x (_Float32x __x) throw (); extern _Float32x __nearbyintf32x (_Float32x __x) throw ();



extern _Float32x roundf32x (_Float32x __x) throw () __attribute__ ((__const__)); extern _Float32x __roundf32x (_Float32x __x) throw () __attribute__ ((__const__));



extern _Float32x truncf32x (_Float32x __x) throw () __attribute__ ((__const__)); extern _Float32x __truncf32x (_Float32x __x) throw () __attribute__ ((__const__));




extern _Float32x remquof32x (_Float32x __x, _Float32x __y, int *__quo) throw (); extern _Float32x __remquof32x (_Float32x __x, _Float32x __y, int *__quo) throw ();






extern long int lrintf32x (_Float32x __x) throw (); extern long int __lrintf32x (_Float32x __x) throw ();
__extension__
extern long long int llrintf32x (_Float32x __x) throw (); extern long long int __llrintf32x (_Float32x __x) throw ();



extern long int lroundf32x (_Float32x __x) throw (); extern long int __lroundf32x (_Float32x __x) throw ();
__extension__
extern long long int llroundf32x (_Float32x __x) throw (); extern long long int __llroundf32x (_Float32x __x) throw ();



extern _Float32x fdimf32x (_Float32x __x, _Float32x __y) throw (); extern _Float32x __fdimf32x (_Float32x __x, _Float32x __y) throw ();


extern _Float32x fmaxf32x (_Float32x __x, _Float32x __y) throw () __attribute__ ((__const__)); extern _Float32x __fmaxf32x (_Float32x __x, _Float32x __y) throw () __attribute__ ((__const__));


extern _Float32x fminf32x (_Float32x __x, _Float32x __y) throw () __attribute__ ((__const__)); extern _Float32x __fminf32x (_Float32x __x, _Float32x __y) throw () __attribute__ ((__const__));


extern _Float32x fmaf32x (_Float32x __x, _Float32x __y, _Float32x __z) throw (); extern _Float32x __fmaf32x (_Float32x __x, _Float32x __y, _Float32x __z) throw ();




extern _Float32x roundevenf32x (_Float32x __x) throw () __attribute__ ((__const__)); extern _Float32x __roundevenf32x (_Float32x __x) throw () __attribute__ ((__const__));



extern __intmax_t fromfpf32x (_Float32x __x, int __round, unsigned int __width) throw (); extern __intmax_t __fromfpf32x (_Float32x __x, int __round, unsigned int __width) throw ();




extern __uintmax_t ufromfpf32x (_Float32x __x, int __round, unsigned int __width) throw (); extern __uintmax_t __ufromfpf32x (_Float32x __x, int __round, unsigned int __width) throw ();





extern __intmax_t fromfpxf32x (_Float32x __x, int __round, unsigned int __width) throw (); extern __intmax_t __fromfpxf32x (_Float32x __x, int __round, unsigned int __width) throw ();





extern __uintmax_t ufromfpxf32x (_Float32x __x, int __round, unsigned int __width) throw (); extern __uintmax_t __ufromfpxf32x (_Float32x __x, int __round, unsigned int __width) throw ();



extern _Float32x fmaxmagf32x (_Float32x __x, _Float32x __y) throw () __attribute__ ((__const__)); extern _Float32x __fmaxmagf32x (_Float32x __x, _Float32x __y) throw () __attribute__ ((__const__));


extern _Float32x fminmagf32x (_Float32x __x, _Float32x __y) throw () __attribute__ ((__const__)); extern _Float32x __fminmagf32x (_Float32x __x, _Float32x __y) throw () __attribute__ ((__const__));


extern int totalorderf32x (_Float32x __x, _Float32x __y) throw ()
     __attribute__ ((__const__));


extern int totalordermagf32x (_Float32x __x, _Float32x __y) throw ()
     __attribute__ ((__const__));


extern int canonicalizef32x (_Float32x *__cx, const _Float32x *__x) throw ();


extern _Float32x getpayloadf32x (const _Float32x *__x) throw (); extern _Float32x __getpayloadf32x (const _Float32x *__x) throw ();


extern int setpayloadf32x (_Float32x *__x, _Float32x __payload) throw ();


extern int setpayloadsigf32x (_Float32x *__x, _Float32x __payload) throw ();
# 441 "/usr/include/math.h" 2 3 4
# 457 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/bits/mathcalls.h" 3 4
extern _Float64x acosf64x (_Float64x __x) throw (); extern _Float64x __acosf64x (_Float64x __x) throw ();

extern _Float64x asinf64x (_Float64x __x) throw (); extern _Float64x __asinf64x (_Float64x __x) throw ();

extern _Float64x atanf64x (_Float64x __x) throw (); extern _Float64x __atanf64x (_Float64x __x) throw ();

extern _Float64x atan2f64x (_Float64x __y, _Float64x __x) throw (); extern _Float64x __atan2f64x (_Float64x __y, _Float64x __x) throw ();


 extern _Float64x cosf64x (_Float64x __x) throw (); extern _Float64x __cosf64x (_Float64x __x) throw ();

 extern _Float64x sinf64x (_Float64x __x) throw (); extern _Float64x __sinf64x (_Float64x __x) throw ();

extern _Float64x tanf64x (_Float64x __x) throw (); extern _Float64x __tanf64x (_Float64x __x) throw ();




extern _Float64x coshf64x (_Float64x __x) throw (); extern _Float64x __coshf64x (_Float64x __x) throw ();

extern _Float64x sinhf64x (_Float64x __x) throw (); extern _Float64x __sinhf64x (_Float64x __x) throw ();

extern _Float64x tanhf64x (_Float64x __x) throw (); extern _Float64x __tanhf64x (_Float64x __x) throw ();



 extern void sincosf64x (_Float64x __x, _Float64x *__sinx, _Float64x *__cosx) throw (); extern void __sincosf64x (_Float64x __x, _Float64x *__sinx, _Float64x *__cosx) throw ();





extern _Float64x acoshf64x (_Float64x __x) throw (); extern _Float64x __acoshf64x (_Float64x __x) throw ();

extern _Float64x asinhf64x (_Float64x __x) throw (); extern _Float64x __asinhf64x (_Float64x __x) throw ();

extern _Float64x atanhf64x (_Float64x __x) throw (); extern _Float64x __atanhf64x (_Float64x __x) throw ();





 extern _Float64x expf64x (_Float64x __x) throw (); extern _Float64x __expf64x (_Float64x __x) throw ();


extern _Float64x frexpf64x (_Float64x __x, int *__exponent) throw (); extern _Float64x __frexpf64x (_Float64x __x, int *__exponent) throw ();


extern _Float64x ldexpf64x (_Float64x __x, int __exponent) throw (); extern _Float64x __ldexpf64x (_Float64x __x, int __exponent) throw ();


 extern _Float64x logf64x (_Float64x __x) throw (); extern _Float64x __logf64x (_Float64x __x) throw ();


extern _Float64x log10f64x (_Float64x __x) throw (); extern _Float64x __log10f64x (_Float64x __x) throw ();


extern _Float64x modff64x (_Float64x __x, _Float64x *__iptr) throw (); extern _Float64x __modff64x (_Float64x __x, _Float64x *__iptr) throw () __attribute__ ((__nonnull__ (2)));



extern _Float64x exp10f64x (_Float64x __x) throw (); extern _Float64x __exp10f64x (_Float64x __x) throw ();




extern _Float64x expm1f64x (_Float64x __x) throw (); extern _Float64x __expm1f64x (_Float64x __x) throw ();


extern _Float64x log1pf64x (_Float64x __x) throw (); extern _Float64x __log1pf64x (_Float64x __x) throw ();


extern _Float64x logbf64x (_Float64x __x) throw (); extern _Float64x __logbf64x (_Float64x __x) throw ();




extern _Float64x exp2f64x (_Float64x __x) throw (); extern _Float64x __exp2f64x (_Float64x __x) throw ();


extern _Float64x log2f64x (_Float64x __x) throw (); extern _Float64x __log2f64x (_Float64x __x) throw ();






 extern _Float64x powf64x (_Float64x __x, _Float64x __y) throw (); extern _Float64x __powf64x (_Float64x __x, _Float64x __y) throw ();


extern _Float64x sqrtf64x (_Float64x __x) throw (); extern _Float64x __sqrtf64x (_Float64x __x) throw ();



extern _Float64x hypotf64x (_Float64x __x, _Float64x __y) throw (); extern _Float64x __hypotf64x (_Float64x __x, _Float64x __y) throw ();




extern _Float64x cbrtf64x (_Float64x __x) throw (); extern _Float64x __cbrtf64x (_Float64x __x) throw ();






extern _Float64x ceilf64x (_Float64x __x) throw () __attribute__ ((__const__)); extern _Float64x __ceilf64x (_Float64x __x) throw () __attribute__ ((__const__));


extern _Float64x fabsf64x (_Float64x __x) throw () __attribute__ ((__const__)); extern _Float64x __fabsf64x (_Float64x __x) throw () __attribute__ ((__const__));


extern _Float64x floorf64x (_Float64x __x) throw () __attribute__ ((__const__)); extern _Float64x __floorf64x (_Float64x __x) throw () __attribute__ ((__const__));


extern _Float64x fmodf64x (_Float64x __x, _Float64x __y) throw (); extern _Float64x __fmodf64x (_Float64x __x, _Float64x __y) throw ();
# 196 "/usr/include/bits/mathcalls.h" 3 4
extern _Float64x copysignf64x (_Float64x __x, _Float64x __y) throw () __attribute__ ((__const__)); extern _Float64x __copysignf64x (_Float64x __x, _Float64x __y) throw () __attribute__ ((__const__));




extern _Float64x nanf64x (const char *__tagb) throw (); extern _Float64x __nanf64x (const char *__tagb) throw ();
# 217 "/usr/include/bits/mathcalls.h" 3 4
extern _Float64x j0f64x (_Float64x) throw (); extern _Float64x __j0f64x (_Float64x) throw ();
extern _Float64x j1f64x (_Float64x) throw (); extern _Float64x __j1f64x (_Float64x) throw ();
extern _Float64x jnf64x (int, _Float64x) throw (); extern _Float64x __jnf64x (int, _Float64x) throw ();
extern _Float64x y0f64x (_Float64x) throw (); extern _Float64x __y0f64x (_Float64x) throw ();
extern _Float64x y1f64x (_Float64x) throw (); extern _Float64x __y1f64x (_Float64x) throw ();
extern _Float64x ynf64x (int, _Float64x) throw (); extern _Float64x __ynf64x (int, _Float64x) throw ();





extern _Float64x erff64x (_Float64x) throw (); extern _Float64x __erff64x (_Float64x) throw ();
extern _Float64x erfcf64x (_Float64x) throw (); extern _Float64x __erfcf64x (_Float64x) throw ();
extern _Float64x lgammaf64x (_Float64x) throw (); extern _Float64x __lgammaf64x (_Float64x) throw ();




extern _Float64x tgammaf64x (_Float64x) throw (); extern _Float64x __tgammaf64x (_Float64x) throw ();
# 249 "/usr/include/bits/mathcalls.h" 3 4
extern _Float64x lgammaf64x_r (_Float64x, int *__signgamp) throw (); extern _Float64x __lgammaf64x_r (_Float64x, int *__signgamp) throw ();






extern _Float64x rintf64x (_Float64x __x) throw (); extern _Float64x __rintf64x (_Float64x __x) throw ();


extern _Float64x nextafterf64x (_Float64x __x, _Float64x __y) throw (); extern _Float64x __nextafterf64x (_Float64x __x, _Float64x __y) throw ();






extern _Float64x nextdownf64x (_Float64x __x) throw (); extern _Float64x __nextdownf64x (_Float64x __x) throw ();

extern _Float64x nextupf64x (_Float64x __x) throw (); extern _Float64x __nextupf64x (_Float64x __x) throw ();



extern _Float64x remainderf64x (_Float64x __x, _Float64x __y) throw (); extern _Float64x __remainderf64x (_Float64x __x, _Float64x __y) throw ();



extern _Float64x scalbnf64x (_Float64x __x, int __n) throw (); extern _Float64x __scalbnf64x (_Float64x __x, int __n) throw ();



extern int ilogbf64x (_Float64x __x) throw (); extern int __ilogbf64x (_Float64x __x) throw ();




extern long int llogbf64x (_Float64x __x) throw (); extern long int __llogbf64x (_Float64x __x) throw ();




extern _Float64x scalblnf64x (_Float64x __x, long int __n) throw (); extern _Float64x __scalblnf64x (_Float64x __x, long int __n) throw ();



extern _Float64x nearbyintf64x (_Float64x __x) throw (); extern _Float64x __nearbyintf64x (_Float64x __x) throw ();



extern _Float64x roundf64x (_Float64x __x) throw () __attribute__ ((__const__)); extern _Float64x __roundf64x (_Float64x __x) throw () __attribute__ ((__const__));



extern _Float64x truncf64x (_Float64x __x) throw () __attribute__ ((__const__)); extern _Float64x __truncf64x (_Float64x __x) throw () __attribute__ ((__const__));




extern _Float64x remquof64x (_Float64x __x, _Float64x __y, int *__quo) throw (); extern _Float64x __remquof64x (_Float64x __x, _Float64x __y, int *__quo) throw ();






extern long int lrintf64x (_Float64x __x) throw (); extern long int __lrintf64x (_Float64x __x) throw ();
__extension__
extern long long int llrintf64x (_Float64x __x) throw (); extern long long int __llrintf64x (_Float64x __x) throw ();



extern long int lroundf64x (_Float64x __x) throw (); extern long int __lroundf64x (_Float64x __x) throw ();
__extension__
extern long long int llroundf64x (_Float64x __x) throw (); extern long long int __llroundf64x (_Float64x __x) throw ();



extern _Float64x fdimf64x (_Float64x __x, _Float64x __y) throw (); extern _Float64x __fdimf64x (_Float64x __x, _Float64x __y) throw ();


extern _Float64x fmaxf64x (_Float64x __x, _Float64x __y) throw () __attribute__ ((__const__)); extern _Float64x __fmaxf64x (_Float64x __x, _Float64x __y) throw () __attribute__ ((__const__));


extern _Float64x fminf64x (_Float64x __x, _Float64x __y) throw () __attribute__ ((__const__)); extern _Float64x __fminf64x (_Float64x __x, _Float64x __y) throw () __attribute__ ((__const__));


extern _Float64x fmaf64x (_Float64x __x, _Float64x __y, _Float64x __z) throw (); extern _Float64x __fmaf64x (_Float64x __x, _Float64x __y, _Float64x __z) throw ();




extern _Float64x roundevenf64x (_Float64x __x) throw () __attribute__ ((__const__)); extern _Float64x __roundevenf64x (_Float64x __x) throw () __attribute__ ((__const__));



extern __intmax_t fromfpf64x (_Float64x __x, int __round, unsigned int __width) throw (); extern __intmax_t __fromfpf64x (_Float64x __x, int __round, unsigned int __width) throw ();




extern __uintmax_t ufromfpf64x (_Float64x __x, int __round, unsigned int __width) throw (); extern __uintmax_t __ufromfpf64x (_Float64x __x, int __round, unsigned int __width) throw ();





extern __intmax_t fromfpxf64x (_Float64x __x, int __round, unsigned int __width) throw (); extern __intmax_t __fromfpxf64x (_Float64x __x, int __round, unsigned int __width) throw ();





extern __uintmax_t ufromfpxf64x (_Float64x __x, int __round, unsigned int __width) throw (); extern __uintmax_t __ufromfpxf64x (_Float64x __x, int __round, unsigned int __width) throw ();



extern _Float64x fmaxmagf64x (_Float64x __x, _Float64x __y) throw () __attribute__ ((__const__)); extern _Float64x __fmaxmagf64x (_Float64x __x, _Float64x __y) throw () __attribute__ ((__const__));


extern _Float64x fminmagf64x (_Float64x __x, _Float64x __y) throw () __attribute__ ((__const__)); extern _Float64x __fminmagf64x (_Float64x __x, _Float64x __y) throw () __attribute__ ((__const__));


extern int totalorderf64x (_Float64x __x, _Float64x __y) throw ()
     __attribute__ ((__const__));


extern int totalordermagf64x (_Float64x __x, _Float64x __y) throw ()
     __attribute__ ((__const__));


extern int canonicalizef64x (_Float64x *__cx, const _Float64x *__x) throw ();


extern _Float64x getpayloadf64x (const _Float64x *__x) throw (); extern _Float64x __getpayloadf64x (const _Float64x *__x) throw ();


extern int setpayloadf64x (_Float64x *__x, _Float64x __payload) throw ();


extern int setpayloadsigf64x (_Float64x *__x, _Float64x __payload) throw ();
# 458 "/usr/include/math.h" 2 3 4
# 503 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/bits/mathcalls-narrow.h" 3 4
extern float fadd (double __x, double __y) throw ();


extern float fdiv (double __x, double __y) throw ();


extern float fmul (double __x, double __y) throw ();


extern float fsub (double __x, double __y) throw ();
# 504 "/usr/include/math.h" 2 3 4
# 517 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/bits/mathcalls-narrow.h" 3 4
extern float faddl (long double __x, long double __y) throw ();


extern float fdivl (long double __x, long double __y) throw ();


extern float fmull (long double __x, long double __y) throw ();


extern float fsubl (long double __x, long double __y) throw ();
# 518 "/usr/include/math.h" 2 3 4
# 537 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/bits/mathcalls-narrow.h" 3 4
extern double daddl (long double __x, long double __y) throw ();


extern double ddivl (long double __x, long double __y) throw ();


extern double dmull (long double __x, long double __y) throw ();


extern double dsubl (long double __x, long double __y) throw ();
# 538 "/usr/include/math.h" 2 3 4
# 616 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/bits/mathcalls-narrow.h" 3 4
extern _Float32 f32addf32x (_Float32x __x, _Float32x __y) throw ();


extern _Float32 f32divf32x (_Float32x __x, _Float32x __y) throw ();


extern _Float32 f32mulf32x (_Float32x __x, _Float32x __y) throw ();


extern _Float32 f32subf32x (_Float32x __x, _Float32x __y) throw ();
# 617 "/usr/include/math.h" 2 3 4
# 626 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/bits/mathcalls-narrow.h" 3 4
extern _Float32 f32addf64 (_Float64 __x, _Float64 __y) throw ();


extern _Float32 f32divf64 (_Float64 __x, _Float64 __y) throw ();


extern _Float32 f32mulf64 (_Float64 __x, _Float64 __y) throw ();


extern _Float32 f32subf64 (_Float64 __x, _Float64 __y) throw ();
# 627 "/usr/include/math.h" 2 3 4
# 636 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/bits/mathcalls-narrow.h" 3 4
extern _Float32 f32addf64x (_Float64x __x, _Float64x __y) throw ();


extern _Float32 f32divf64x (_Float64x __x, _Float64x __y) throw ();


extern _Float32 f32mulf64x (_Float64x __x, _Float64x __y) throw ();


extern _Float32 f32subf64x (_Float64x __x, _Float64x __y) throw ();
# 637 "/usr/include/math.h" 2 3 4
# 666 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/bits/mathcalls-narrow.h" 3 4
extern _Float32x f32xaddf64 (_Float64 __x, _Float64 __y) throw ();


extern _Float32x f32xdivf64 (_Float64 __x, _Float64 __y) throw ();


extern _Float32x f32xmulf64 (_Float64 __x, _Float64 __y) throw ();


extern _Float32x f32xsubf64 (_Float64 __x, _Float64 __y) throw ();
# 667 "/usr/include/math.h" 2 3 4
# 676 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/bits/mathcalls-narrow.h" 3 4
extern _Float32x f32xaddf64x (_Float64x __x, _Float64x __y) throw ();


extern _Float32x f32xdivf64x (_Float64x __x, _Float64x __y) throw ();


extern _Float32x f32xmulf64x (_Float64x __x, _Float64x __y) throw ();


extern _Float32x f32xsubf64x (_Float64x __x, _Float64x __y) throw ();
# 677 "/usr/include/math.h" 2 3 4
# 706 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/bits/mathcalls-narrow.h" 3 4
extern _Float64 f64addf64x (_Float64x __x, _Float64x __y) throw ();


extern _Float64 f64divf64x (_Float64x __x, _Float64x __y) throw ();


extern _Float64 f64mulf64x (_Float64x __x, _Float64x __y) throw ();


extern _Float64 f64subf64x (_Float64x __x, _Float64x __y) throw ();
# 707 "/usr/include/math.h" 2 3 4
# 773 "/usr/include/math.h" 3 4
extern int signgam;
# 853 "/usr/include/math.h" 3 4
enum
  {
    FP_NAN =

      0,
    FP_INFINITE =

      1,
    FP_ZERO =

      2,
    FP_SUBNORMAL =

      3,
    FP_NORMAL =

      4
  };
# 973 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/iscanonical.h" 1 3 4
# 23 "/usr/include/bits/iscanonical.h" 3 4
extern int __iscanonicall (long double __x)
     throw () __attribute__ ((__const__));
# 46 "/usr/include/bits/iscanonical.h" 3 4
extern "C++" {
inline int iscanonical (float __val) { return ((void) (__typeof (__val)) (__val), 1); }
inline int iscanonical (double __val) { return ((void) (__typeof (__val)) (__val), 1); }
inline int iscanonical (long double __val) { return __iscanonicall (__val); }



}
# 974 "/usr/include/math.h" 2 3 4
# 985 "/usr/include/math.h" 3 4
extern "C++" {
inline int issignaling (float __val) { return __issignalingf (__val); }
inline int issignaling (double __val) { return __issignaling (__val); }
inline int
issignaling (long double __val)
{



  return __issignalingl (__val);

}





}
# 1016 "/usr/include/math.h" 3 4
extern "C++" {
# 1047 "/usr/include/math.h" 3 4
template <class __T> inline bool
iszero (__T __val)
{
  return __val == 0;
}

}
# 1245 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathinline.h" 1 3 4
# 1246 "/usr/include/math.h" 2 3 4
# 1498 "/usr/include/math.h" 3 4
extern "C++" {
template<typename> struct __iseqsig_type;

template<> struct __iseqsig_type<float>
{
  static int __call (float __x, float __y) throw ()
  {
    return __iseqsigf (__x, __y);
  }
};

template<> struct __iseqsig_type<double>
{
  static int __call (double __x, double __y) throw ()
  {
    return __iseqsig (__x, __y);
  }
};

template<> struct __iseqsig_type<long double>
{
  static int __call (long double __x, long double __y) throw ()
  {

    return __iseqsigl (__x, __y);



  }
};
# 1541 "/usr/include/math.h" 3 4
template<typename _T1, typename _T2>
inline int
iseqsig (_T1 __x, _T2 __y) throw ()
{

  typedef decltype (((__x) + (__y) + 0.0f)) _T3;



  return __iseqsig_type<_T3>::__call (__x, __y);
}

}




}
# 302 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/math.h" 2 3






extern "C++" {
# 358 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/math.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__math/abs.h" 1 3
# 18 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__math/abs.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

namespace __math {



[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) float fabs(float __x) noexcept { return __builtin_fabsf(__x); }

template <class = int>
[[__nodiscard__]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) double fabs(double __x) noexcept {
  return __builtin_fabs(__x);
}

[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) long double fabs(long double __x) noexcept {
  return __builtin_fabsl(__x);
}

template <class _A1, __enable_if_t<is_integral<_A1>::value, int> = 0>
[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) double fabs(_A1 __x) noexcept {
  return __builtin_fabs((double)__x);
}

}

}}
# 359 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/math.h" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__math/copysign.h" 1 3
# 20 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__math/copysign.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

namespace __math {



[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) float copysign(float __x, float __y) noexcept {
  return ::__builtin_copysignf(__x, __y);
}

[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) long double copysign(long double __x, long double __y) noexcept {
  return ::__builtin_copysignl(__x, __y);
}

template <class _A1, class _A2, __enable_if_t<is_arithmetic<_A1>::value && is_arithmetic<_A2>::value, int> = 0>
[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) typename __promote<_A1, _A2>::type
copysign(_A1 __x, _A2 __y) noexcept {
  return ::__builtin_copysign(__x, __y);
}

}

}}
# 360 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/math.h" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__math/error_functions.h" 1 3
# 18 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__math/error_functions.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

namespace __math {



inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) float erf(float __x) noexcept { return __builtin_erff(__x); }

template <class = int>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) double erf(double __x) noexcept {
  return __builtin_erf(__x);
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) long double erf(long double __x) noexcept { return __builtin_erfl(__x); }

template <class _A1, __enable_if_t<is_integral<_A1>::value, int> = 0>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) double erf(_A1 __x) noexcept {
  return __builtin_erf((double)__x);
}



inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) float erfc(float __x) noexcept { return __builtin_erfcf(__x); }

template <class = int>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) double erfc(double __x) noexcept {
  return __builtin_erfc(__x);
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) long double erfc(long double __x) noexcept { return __builtin_erfcl(__x); }

template <class _A1, __enable_if_t<is_integral<_A1>::value, int> = 0>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) double erfc(_A1 __x) noexcept {
  return __builtin_erfc((double)__x);
}

}

}}
# 361 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/math.h" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__math/exponential_functions.h" 1 3
# 21 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__math/exponential_functions.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

namespace __math {



inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) float exp(float __x) noexcept { return __builtin_expf(__x); }

template <class = int>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) double exp(double __x) noexcept {
  return __builtin_exp(__x);
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) long double exp(long double __x) noexcept { return __builtin_expl(__x); }

template <class _A1, __enable_if_t<is_integral<_A1>::value, int> = 0>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) double exp(_A1 __x) noexcept {
  return __builtin_exp((double)__x);
}



inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) float frexp(float __x, int* __e) noexcept { return __builtin_frexpf(__x, __e); }

template <class = int>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) double frexp(double __x, int* __e) noexcept {
  return __builtin_frexp(__x, __e);
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) long double frexp(long double __x, int* __e) noexcept {
  return __builtin_frexpl(__x, __e);
}

template <class _A1, __enable_if_t<is_integral<_A1>::value, int> = 0>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) double frexp(_A1 __x, int* __e) noexcept {
  return __builtin_frexp((double)__x, __e);
}



inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) float ldexp(float __x, int __e) noexcept { return __builtin_ldexpf(__x, __e); }

template <class = int>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) double ldexp(double __x, int __e) noexcept {
  return __builtin_ldexp(__x, __e);
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) long double ldexp(long double __x, int __e) noexcept {
  return __builtin_ldexpl(__x, __e);
}

template <class _A1, __enable_if_t<is_integral<_A1>::value, int> = 0>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) double ldexp(_A1 __x, int __e) noexcept {
  return __builtin_ldexp((double)__x, __e);
}



inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) float exp2(float __x) noexcept { return __builtin_exp2f(__x); }

template <class = int>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) double exp2(double __x) noexcept {
  return __builtin_exp2(__x);
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) long double exp2(long double __x) noexcept { return __builtin_exp2l(__x); }

template <class _A1, __enable_if_t<is_integral<_A1>::value, int> = 0>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) double exp2(_A1 __x) noexcept {
  return __builtin_exp2((double)__x);
}



inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) float expm1(float __x) noexcept { return __builtin_expm1f(__x); }

template <class = int>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) double expm1(double __x) noexcept {
  return __builtin_expm1(__x);
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) long double expm1(long double __x) noexcept { return __builtin_expm1l(__x); }

template <class _A1, __enable_if_t<is_integral<_A1>::value, int> = 0>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) double expm1(_A1 __x) noexcept {
  return __builtin_expm1((double)__x);
}



inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) float scalbln(float __x, long __y) noexcept { return __builtin_scalblnf(__x, __y); }

template <class = int>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) double scalbln(double __x, long __y) noexcept {
  return __builtin_scalbln(__x, __y);
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) long double scalbln(long double __x, long __y) noexcept {
  return __builtin_scalblnl(__x, __y);
}

template <class _A1, __enable_if_t<is_integral<_A1>::value, int> = 0>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) double scalbln(_A1 __x, long __y) noexcept {
  return __builtin_scalbln((double)__x, __y);
}



inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) float scalbn(float __x, int __y) noexcept { return __builtin_scalbnf(__x, __y); }

template <class = int>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) double scalbn(double __x, int __y) noexcept {
  return __builtin_scalbn(__x, __y);
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) long double scalbn(long double __x, int __y) noexcept {
  return __builtin_scalbnl(__x, __y);
}

template <class _A1, __enable_if_t<is_integral<_A1>::value, int> = 0>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) double scalbn(_A1 __x, int __y) noexcept {
  return __builtin_scalbn((double)__x, __y);
}



inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) float pow(float __x, float __y) noexcept { return __builtin_powf(__x, __y); }

template <class = int>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) double pow(double __x, double __y) noexcept {
  return __builtin_pow(__x, __y);
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) long double pow(long double __x, long double __y) noexcept {
  return __builtin_powl(__x, __y);
}

template <class _A1, class _A2, __enable_if_t<is_arithmetic<_A1>::value && is_arithmetic<_A2>::value, int> = 0>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) typename __promote<_A1, _A2>::type pow(_A1 __x, _A2 __y) noexcept {
  using __result_type = typename __promote<_A1, _A2>::type;
  static_assert((!(_IsSame<_A1, __result_type>::value && _IsSame<_A2, __result_type>::value)), "");
  return __math::pow((__result_type)__x, (__result_type)__y);
}

}

}}
# 362 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/math.h" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__math/fdim.h" 1 3
# 20 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__math/fdim.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

namespace __math {

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) float fdim(float __x, float __y) noexcept { return __builtin_fdimf(__x, __y); }

template <class = int>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) double fdim(double __x, double __y) noexcept {
  return __builtin_fdim(__x, __y);
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) long double fdim(long double __x, long double __y) noexcept {
  return __builtin_fdiml(__x, __y);
}

template <class _A1, class _A2, __enable_if_t<is_arithmetic<_A1>::value && is_arithmetic<_A2>::value, int> = 0>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) typename __promote<_A1, _A2>::type fdim(_A1 __x, _A2 __y) noexcept {
  using __result_type = typename __promote<_A1, _A2>::type;
  static_assert((!(_IsSame<_A1, __result_type>::value && _IsSame<_A2, __result_type>::value)), "");
  return __math::fdim((__result_type)__x, (__result_type)__y);
}

}

}}
# 363 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/math.h" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__math/fma.h" 1 3
# 20 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__math/fma.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

namespace __math {

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) float fma(float __x, float __y, float __z) noexcept {
  return __builtin_fmaf(__x, __y, __z);
}

template <class = int>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) double fma(double __x, double __y, double __z) noexcept {
  return __builtin_fma(__x, __y, __z);
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) long double fma(long double __x, long double __y, long double __z) noexcept {
  return __builtin_fmal(__x, __y, __z);
}

template <class _A1,
          class _A2,
          class _A3,
          __enable_if_t<is_arithmetic<_A1>::value && is_arithmetic<_A2>::value && is_arithmetic<_A3>::value, int> = 0>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) typename __promote<_A1, _A2, _A3>::type fma(_A1 __x, _A2 __y, _A3 __z) noexcept {
  using __result_type = typename __promote<_A1, _A2, _A3>::type;
  static_assert((!(_IsSame<_A1, __result_type>::value && _IsSame<_A2, __result_type>::value &&
                   _IsSame<_A3, __result_type>::value)),
                "");
  return __builtin_fma((__result_type)__x, (__result_type)__y, (__result_type)__z);
}

}

}}
# 364 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/math.h" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__math/gamma.h" 1 3
# 18 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__math/gamma.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

namespace __math {



inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) float lgamma(float __x) noexcept { return __builtin_lgammaf(__x); }

template <class = int>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) double lgamma(double __x) noexcept {
  return __builtin_lgamma(__x);
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) long double lgamma(long double __x) noexcept { return __builtin_lgammal(__x); }

template <class _A1, __enable_if_t<is_integral<_A1>::value, int> = 0>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) double lgamma(_A1 __x) noexcept {
  return __builtin_lgamma((double)__x);
}





inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) float tgamma(float __x) noexcept { return __builtin_tgammaf(__x); }

template <class = int>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) double tgamma(double __x) noexcept {
  return __builtin_tgamma(__x);
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) long double tgamma(long double __x) noexcept { return __builtin_tgammal(__x); }

template <class _A1, __enable_if_t<is_integral<_A1>::value, int> = 0>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) double tgamma(_A1 __x) noexcept {
  return __builtin_tgamma((double)__x);
}

}

}}
# 365 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/math.h" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__math/hyperbolic_functions.h" 1 3
# 18 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__math/hyperbolic_functions.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

namespace __math {



inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) float cosh(float __x) noexcept { return __builtin_coshf(__x); }

template <class = int>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) double cosh(double __x) noexcept {
  return __builtin_cosh(__x);
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) long double cosh(long double __x) noexcept { return __builtin_coshl(__x); }

template <class _A1, __enable_if_t<is_integral<_A1>::value, int> = 0>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) double cosh(_A1 __x) noexcept {
  return __builtin_cosh((double)__x);
}



inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) float sinh(float __x) noexcept { return __builtin_sinhf(__x); }

template <class = int>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) double sinh(double __x) noexcept {
  return __builtin_sinh(__x);
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) long double sinh(long double __x) noexcept { return __builtin_sinhl(__x); }

template <class _A1, __enable_if_t<is_integral<_A1>::value, int> = 0>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) double sinh(_A1 __x) noexcept {
  return __builtin_sinh((double)__x);
}



inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) float tanh(float __x) noexcept { return __builtin_tanhf(__x); }

template <class = int>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) double tanh(double __x) noexcept {
  return __builtin_tanh(__x);
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) long double tanh(long double __x) noexcept { return __builtin_tanhl(__x); }

template <class _A1, __enable_if_t<is_integral<_A1>::value, int> = 0>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) double tanh(_A1 __x) noexcept {
  return __builtin_tanh((double)__x);
}

}

}}
# 366 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/math.h" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__math/hypot.h" 1 3
# 20 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__math/hypot.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

namespace __math {

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) float hypot(float __x, float __y) noexcept { return __builtin_hypotf(__x, __y); }

template <class = int>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) double hypot(double __x, double __y) noexcept {
  return __builtin_hypot(__x, __y);
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) long double hypot(long double __x, long double __y) noexcept {
  return __builtin_hypotl(__x, __y);
}

template <class _A1, class _A2, __enable_if_t<is_arithmetic<_A1>::value && is_arithmetic<_A2>::value, int> = 0>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) typename __promote<_A1, _A2>::type hypot(_A1 __x, _A2 __y) noexcept {
  using __result_type = typename __promote<_A1, _A2>::type;
  static_assert((!(_IsSame<_A1, __result_type>::value && _IsSame<_A2, __result_type>::value)), "");
  return __math::hypot((__result_type)__x, (__result_type)__y);
}

}

}}
# 367 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/math.h" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__math/inverse_hyperbolic_functions.h" 1 3
# 18 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__math/inverse_hyperbolic_functions.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

namespace __math {



inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) float acosh(float __x) noexcept { return __builtin_acoshf(__x); }

template <class = int>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) double acosh(double __x) noexcept {
  return __builtin_acosh(__x);
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) long double acosh(long double __x) noexcept { return __builtin_acoshl(__x); }

template <class _A1, __enable_if_t<is_integral<_A1>::value, int> = 0>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) double acosh(_A1 __x) noexcept {
  return __builtin_acosh((double)__x);
}



inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) float asinh(float __x) noexcept { return __builtin_asinhf(__x); }

template <class = int>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) double asinh(double __x) noexcept {
  return __builtin_asinh(__x);
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) long double asinh(long double __x) noexcept { return __builtin_asinhl(__x); }

template <class _A1, __enable_if_t<is_integral<_A1>::value, int> = 0>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) double asinh(_A1 __x) noexcept {
  return __builtin_asinh((double)__x);
}



inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) float atanh(float __x) noexcept { return __builtin_atanhf(__x); }

template <class = int>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) double atanh(double __x) noexcept {
  return __builtin_atanh(__x);
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) long double atanh(long double __x) noexcept { return __builtin_atanhl(__x); }

template <class _A1, __enable_if_t<is_integral<_A1>::value, int> = 0>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) double atanh(_A1 __x) noexcept {
  return __builtin_atanh((double)__x);
}

}

}}
# 368 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/math.h" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__math/inverse_trigonometric_functions.h" 1 3
# 21 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__math/inverse_trigonometric_functions.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

namespace __math {



inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) float acos(float __x) noexcept { return __builtin_acosf(__x); }

template <class = int>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) double acos(double __x) noexcept {
  return __builtin_acos(__x);
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) long double acos(long double __x) noexcept { return __builtin_acosl(__x); }

template <class _A1, __enable_if_t<is_integral<_A1>::value, int> = 0>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) double acos(_A1 __x) noexcept {
  return __builtin_acos((double)__x);
}



inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) float asin(float __x) noexcept { return __builtin_asinf(__x); }

template <class = int>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) double asin(double __x) noexcept {
  return __builtin_asin(__x);
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) long double asin(long double __x) noexcept { return __builtin_asinl(__x); }

template <class _A1, __enable_if_t<is_integral<_A1>::value, int> = 0>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) double asin(_A1 __x) noexcept {
  return __builtin_asin((double)__x);
}



inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) float atan(float __x) noexcept { return __builtin_atanf(__x); }

template <class = int>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) double atan(double __x) noexcept {
  return __builtin_atan(__x);
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) long double atan(long double __x) noexcept { return __builtin_atanl(__x); }

template <class _A1, __enable_if_t<is_integral<_A1>::value, int> = 0>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) double atan(_A1 __x) noexcept {
  return __builtin_atan((double)__x);
}



inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) float atan2(float __y, float __x) noexcept { return __builtin_atan2f(__y, __x); }

template <class = int>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) double atan2(double __x, double __y) noexcept {
  return __builtin_atan2(__x, __y);
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) long double atan2(long double __y, long double __x) noexcept {
  return __builtin_atan2l(__y, __x);
}

template <class _A1, class _A2, __enable_if_t<is_arithmetic<_A1>::value && is_arithmetic<_A2>::value, int> = 0>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) typename __promote<_A1, _A2>::type atan2(_A1 __y, _A2 __x) noexcept {
  using __result_type = typename __promote<_A1, _A2>::type;
  static_assert((!(_IsSame<_A1, __result_type>::value && _IsSame<_A2, __result_type>::value)), "");
  return __math::atan2((__result_type)__y, (__result_type)__x);
}

}

}}
# 369 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/math.h" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__math/logarithms.h" 1 3
# 18 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__math/logarithms.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

namespace __math {



inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) float log(float __x) noexcept { return __builtin_logf(__x); }

template <class = int>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) double log(double __x) noexcept {
  return __builtin_log(__x);
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) long double log(long double __x) noexcept { return __builtin_logl(__x); }

template <class _A1, __enable_if_t<is_integral<_A1>::value, int> = 0>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) double log(_A1 __x) noexcept {
  return __builtin_log((double)__x);
}



inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) float log10(float __x) noexcept { return __builtin_log10f(__x); }

template <class = int>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) double log10(double __x) noexcept {
  return __builtin_log10(__x);
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) long double log10(long double __x) noexcept { return __builtin_log10l(__x); }

template <class _A1, __enable_if_t<is_integral<_A1>::value, int> = 0>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) double log10(_A1 __x) noexcept {
  return __builtin_log10((double)__x);
}



inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) int ilogb(float __x) noexcept { return __builtin_ilogbf(__x); }

template <class = int>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) double ilogb(double __x) noexcept {
  return __builtin_ilogb(__x);
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) int ilogb(long double __x) noexcept { return __builtin_ilogbl(__x); }

template <class _A1, __enable_if_t<is_integral<_A1>::value, int> = 0>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) int ilogb(_A1 __x) noexcept {
  return __builtin_ilogb((double)__x);
}



inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) float log1p(float __x) noexcept { return __builtin_log1pf(__x); }

template <class = int>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) double log1p(double __x) noexcept {
  return __builtin_log1p(__x);
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) long double log1p(long double __x) noexcept { return __builtin_log1pl(__x); }

template <class _A1, __enable_if_t<is_integral<_A1>::value, int> = 0>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) double log1p(_A1 __x) noexcept {
  return __builtin_log1p((double)__x);
}



inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) float log2(float __x) noexcept { return __builtin_log2f(__x); }

template <class = int>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) double log2(double __x) noexcept {
  return __builtin_log2(__x);
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) long double log2(long double __x) noexcept { return __builtin_log2l(__x); }

template <class _A1, __enable_if_t<is_integral<_A1>::value, int> = 0>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) double log2(_A1 __x) noexcept {
  return __builtin_log2((double)__x);
}



inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) float logb(float __x) noexcept { return __builtin_logbf(__x); }

template <class = int>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) double logb(double __x) noexcept {
  return __builtin_logb(__x);
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) long double logb(long double __x) noexcept { return __builtin_logbl(__x); }

template <class _A1, __enable_if_t<is_integral<_A1>::value, int> = 0>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) double logb(_A1 __x) noexcept {
  return __builtin_logb((double)__x);
}

}

}}
# 370 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/math.h" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__math/min_max.h" 1 3
# 20 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__math/min_max.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

namespace __math {



[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) float fmax(float __x, float __y) noexcept {
  return __builtin_fmaxf(__x, __y);
}

template <class = int>
[[__nodiscard__]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) double fmax(double __x, double __y) noexcept {
  return __builtin_fmax(__x, __y);
}

[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) long double fmax(long double __x, long double __y) noexcept {
  return __builtin_fmaxl(__x, __y);
}

template <class _A1, class _A2, __enable_if_t<is_arithmetic<_A1>::value && is_arithmetic<_A2>::value, int> = 0>
[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) typename __promote<_A1, _A2>::type fmax(_A1 __x, _A2 __y) noexcept {
  using __result_type = typename __promote<_A1, _A2>::type;
  static_assert((!(_IsSame<_A1, __result_type>::value && _IsSame<_A2, __result_type>::value)), "");
  return __math::fmax((__result_type)__x, (__result_type)__y);
}



[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) float fmin(float __x, float __y) noexcept {
  return __builtin_fminf(__x, __y);
}

template <class = int>
[[__nodiscard__]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) double fmin(double __x, double __y) noexcept {
  return __builtin_fmin(__x, __y);
}

[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) long double fmin(long double __x, long double __y) noexcept {
  return __builtin_fminl(__x, __y);
}

template <class _A1, class _A2, __enable_if_t<is_arithmetic<_A1>::value && is_arithmetic<_A2>::value, int> = 0>
[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) typename __promote<_A1, _A2>::type fmin(_A1 __x, _A2 __y) noexcept {
  using __result_type = typename __promote<_A1, _A2>::type;
  static_assert((!(_IsSame<_A1, __result_type>::value && _IsSame<_A2, __result_type>::value)), "");
  return __math::fmin((__result_type)__x, (__result_type)__y);
}

}

}}
# 371 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/math.h" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__math/modulo.h" 1 3
# 20 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__math/modulo.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

namespace __math {



inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) float fmod(float __x, float __y) noexcept { return __builtin_fmodf(__x, __y); }

template <class = int>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) double fmod(double __x, double __y) noexcept {
  return __builtin_fmod(__x, __y);
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) long double fmod(long double __x, long double __y) noexcept {
  return __builtin_fmodl(__x, __y);
}

template <class _A1, class _A2, __enable_if_t<is_arithmetic<_A1>::value && is_arithmetic<_A2>::value, int> = 0>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) typename __promote<_A1, _A2>::type fmod(_A1 __x, _A2 __y) noexcept {
  using __result_type = typename __promote<_A1, _A2>::type;
  static_assert((!(_IsSame<_A1, __result_type>::value && _IsSame<_A2, __result_type>::value)), "");
  return __math::fmod((__result_type)__x, (__result_type)__y);
}



inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) float modf(float __x, float* __y) noexcept { return __builtin_modff(__x, __y); }

template <class = int>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) double modf(double __x, double* __y) noexcept {
  return __builtin_modf(__x, __y);
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) long double modf(long double __x, long double* __y) noexcept {
  return __builtin_modfl(__x, __y);
}

}

}}
# 372 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/math.h" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__math/remainder.h" 1 3
# 21 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__math/remainder.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

namespace __math {



inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) float remainder(float __x, float __y) noexcept { return __builtin_remainderf(__x, __y); }

template <class = int>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) double remainder(double __x, double __y) noexcept {
  return __builtin_remainder(__x, __y);
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) long double remainder(long double __x, long double __y) noexcept {
  return __builtin_remainderl(__x, __y);
}

template <class _A1, class _A2, __enable_if_t<is_arithmetic<_A1>::value && is_arithmetic<_A2>::value, int> = 0>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) typename __promote<_A1, _A2>::type remainder(_A1 __x, _A2 __y) noexcept {
  using __result_type = typename __promote<_A1, _A2>::type;
  static_assert((!(_IsSame<_A1, __result_type>::value && _IsSame<_A2, __result_type>::value)), "");
  return __math::remainder((__result_type)__x, (__result_type)__y);
}



inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) float remquo(float __x, float __y, int* __z) noexcept {
  return __builtin_remquof(__x, __y, __z);
}

template <class = int>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) double remquo(double __x, double __y, int* __z) noexcept {
  return __builtin_remquo(__x, __y, __z);
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) long double remquo(long double __x, long double __y, int* __z) noexcept {
  return __builtin_remquol(__x, __y, __z);
}

template <class _A1, class _A2, __enable_if_t<is_arithmetic<_A1>::value && is_arithmetic<_A2>::value, int> = 0>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) typename __promote<_A1, _A2>::type remquo(_A1 __x, _A2 __y, int* __z) noexcept {
  using __result_type = typename __promote<_A1, _A2>::type;
  static_assert((!(_IsSame<_A1, __result_type>::value && _IsSame<_A2, __result_type>::value)), "");
  return __math::remquo((__result_type)__x, (__result_type)__y, __z);
}

}

}}
# 373 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/math.h" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__math/roots.h" 1 3
# 18 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__math/roots.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

namespace __math {



inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) float sqrt(float __x) noexcept { return __builtin_sqrtf(__x); }

template <class = int>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) double sqrt(double __x) noexcept {
  return __builtin_sqrt(__x);
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) long double sqrt(long double __x) noexcept { return __builtin_sqrtl(__x); }

template <class _A1, __enable_if_t<is_integral<_A1>::value, int> = 0>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) double sqrt(_A1 __x) noexcept {
  return __builtin_sqrt((double)__x);
}



[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) float cbrt(float __x) noexcept { return __builtin_cbrtf(__x); }

template <class = int>
[[__nodiscard__]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) double cbrt(double __x) noexcept {
  return __builtin_cbrt(__x);
}

[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) long double cbrt(long double __x) noexcept {
  return __builtin_cbrtl(__x);
}

template <class _A1, __enable_if_t<is_integral<_A1>::value, int> = 0>
[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) double cbrt(_A1 __x) noexcept {
  return __builtin_cbrt((double)__x);
}

}

}}
# 374 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/math.h" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__math/rounding_functions.h" 1 3
# 21 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__math/rounding_functions.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

namespace __math {



[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) float ceil(float __x) noexcept { return __builtin_ceilf(__x); }

template <class = int>
[[__nodiscard__]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) double ceil(double __x) noexcept {
  return __builtin_ceil(__x);
}

[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) long double ceil(long double __x) noexcept {
  return __builtin_ceill(__x);
}

template <class _A1, __enable_if_t<is_integral<_A1>::value, int> = 0>
[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) double ceil(_A1 __x) noexcept {
  return __builtin_ceil((double)__x);
}



[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) float floor(float __x) noexcept { return __builtin_floorf(__x); }

template <class = int>
[[__nodiscard__]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) double floor(double __x) noexcept {
  return __builtin_floor(__x);
}

[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) long double floor(long double __x) noexcept {
  return __builtin_floorl(__x);
}

template <class _A1, __enable_if_t<is_integral<_A1>::value, int> = 0>
[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) double floor(_A1 __x) noexcept {
  return __builtin_floor((double)__x);
}



inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) long long llrint(float __x) noexcept { return __builtin_llrintf(__x); }

template <class = int>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) long long llrint(double __x) noexcept {
  return __builtin_llrint(__x);
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) long long llrint(long double __x) noexcept { return __builtin_llrintl(__x); }

template <class _A1, __enable_if_t<is_integral<_A1>::value, int> = 0>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) long long llrint(_A1 __x) noexcept {
  return __builtin_llrint((double)__x);
}



inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) long long llround(float __x) noexcept { return __builtin_llroundf(__x); }

template <class = int>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) long long llround(double __x) noexcept {
  return __builtin_llround(__x);
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) long long llround(long double __x) noexcept { return __builtin_llroundl(__x); }

template <class _A1, __enable_if_t<is_integral<_A1>::value, int> = 0>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) long long llround(_A1 __x) noexcept {
  return __builtin_llround((double)__x);
}



inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) long lrint(float __x) noexcept { return __builtin_lrintf(__x); }

template <class = int>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) long lrint(double __x) noexcept {
  return __builtin_lrint(__x);
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) long lrint(long double __x) noexcept { return __builtin_lrintl(__x); }

template <class _A1, __enable_if_t<is_integral<_A1>::value, int> = 0>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) long lrint(_A1 __x) noexcept {
  return __builtin_lrint((double)__x);
}



inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) long lround(float __x) noexcept { return __builtin_lroundf(__x); }

template <class = int>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) long lround(double __x) noexcept {
  return __builtin_lround(__x);
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) long lround(long double __x) noexcept { return __builtin_lroundl(__x); }

template <class _A1, __enable_if_t<is_integral<_A1>::value, int> = 0>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) long lround(_A1 __x) noexcept {
  return __builtin_lround((double)__x);
}



[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) float nearbyint(float __x) noexcept {
  return __builtin_nearbyintf(__x);
}

template <class = int>
[[__nodiscard__]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) double nearbyint(double __x) noexcept {
  return __builtin_nearbyint(__x);
}

[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) long double nearbyint(long double __x) noexcept {
  return __builtin_nearbyintl(__x);
}

template <class _A1, __enable_if_t<is_integral<_A1>::value, int> = 0>
[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) double nearbyint(_A1 __x) noexcept {
  return __builtin_nearbyint((double)__x);
}



inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) float nextafter(float __x, float __y) noexcept { return __builtin_nextafterf(__x, __y); }

template <class = int>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) double nextafter(double __x, double __y) noexcept {
  return __builtin_nextafter(__x, __y);
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) long double nextafter(long double __x, long double __y) noexcept {
  return __builtin_nextafterl(__x, __y);
}

template <class _A1, class _A2, __enable_if_t<is_arithmetic<_A1>::value && is_arithmetic<_A2>::value, int> = 0>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) typename __promote<_A1, _A2>::type nextafter(_A1 __x, _A2 __y) noexcept {
  using __result_type = typename __promote<_A1, _A2>::type;
  static_assert((!(_IsSame<_A1, __result_type>::value && _IsSame<_A2, __result_type>::value)), "");
  return __math::nextafter((__result_type)__x, (__result_type)__y);
}



inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) float nexttoward(float __x, long double __y) noexcept {
  return __builtin_nexttowardf(__x, __y);
}

template <class = int>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) double nexttoward(double __x, long double __y) noexcept {
  return __builtin_nexttoward(__x, __y);
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) long double nexttoward(long double __x, long double __y) noexcept {
  return __builtin_nexttowardl(__x, __y);
}

template <class _A1, __enable_if_t<is_integral<_A1>::value, int> = 0>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) double nexttoward(_A1 __x, long double __y) noexcept {
  return __builtin_nexttoward((double)__x, __y);
}



[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) float rint(float __x) noexcept { return __builtin_rintf(__x); }

template <class = int>
[[__nodiscard__]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) double rint(double __x) noexcept {
  return __builtin_rint(__x);
}

[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) long double rint(long double __x) noexcept {
  return __builtin_rintl(__x);
}

template <class _A1, __enable_if_t<is_integral<_A1>::value, int> = 0>
[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) double rint(_A1 __x) noexcept {
  return __builtin_rint((double)__x);
}



[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) float round(float __x) noexcept { return __builtin_round(__x); }

template <class = int>
[[__nodiscard__]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) double round(double __x) noexcept {
  return __builtin_round(__x);
}

[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) long double round(long double __x) noexcept {
  return __builtin_roundl(__x);
}

template <class _A1, __enable_if_t<is_integral<_A1>::value, int> = 0>
[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) double round(_A1 __x) noexcept {
  return __builtin_round((double)__x);
}



[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) float trunc(float __x) noexcept { return __builtin_trunc(__x); }

template <class = int>
[[__nodiscard__]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) double trunc(double __x) noexcept {
  return __builtin_trunc(__x);
}

[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) long double trunc(long double __x) noexcept {
  return __builtin_truncl(__x);
}

template <class _A1, __enable_if_t<is_integral<_A1>::value, int> = 0>
[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) double trunc(_A1 __x) noexcept {
  return __builtin_trunc((double)__x);
}

}

}}
# 375 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/math.h" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__math/traits.h" 1 3
# 23 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__math/traits.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

namespace __math {



template <class _A1, __enable_if_t<is_floating_point<_A1>::value, int> = 0>
[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) bool signbit(_A1 __x) noexcept {
  return __builtin_signbit(__x);
}

template <class _A1, __enable_if_t<is_integral<_A1>::value && is_signed<_A1>::value, int> = 0>
[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) bool signbit(_A1 __x) noexcept {
  return __x < 0;
}

template <class _A1, __enable_if_t<is_integral<_A1>::value && !is_signed<_A1>::value, int> = 0>
[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) bool signbit(_A1) noexcept {
  return false;
}



template <class _A1, __enable_if_t<is_arithmetic<_A1>::value && numeric_limits<_A1>::has_infinity, int> = 0>
[[__nodiscard__]] constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) bool isfinite(_A1 __x) noexcept {
  return __builtin_isfinite((typename __promote<_A1>::type)__x);
}

template <class _A1, __enable_if_t<is_arithmetic<_A1>::value && !numeric_limits<_A1>::has_infinity, int> = 0>
[[__nodiscard__]] constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) bool isfinite(_A1) noexcept {
  return true;
}



template <class _A1, __enable_if_t<is_arithmetic<_A1>::value && numeric_limits<_A1>::has_infinity, int> = 0>
[[__nodiscard__]] constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) bool isinf(_A1 __x) noexcept {
  return __builtin_isinf((typename __promote<_A1>::type)__x);
}

template <class _A1, __enable_if_t<is_arithmetic<_A1>::value && !numeric_limits<_A1>::has_infinity, int> = 0>
[[__nodiscard__]] constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) bool isinf(_A1) noexcept {
  return false;
}


[[__nodiscard__]] inline constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) bool isinf(float __x) noexcept {
  return __builtin_isinf(__x);
}

[[__nodiscard__]] inline constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) __attribute__((__enable_if__(true, ""))) bool
isinf(double __x) noexcept {
  return __builtin_isinf(__x);
}

[[__nodiscard__]] inline constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) bool isinf(long double __x) noexcept {
  return __builtin_isinf(__x);
}




template <class _A1, __enable_if_t<is_floating_point<_A1>::value, int> = 0>
[[__nodiscard__]] constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) bool isnan(_A1 __x) noexcept {
  return __builtin_isnan(__x);
}

template <class _A1, __enable_if_t<is_integral<_A1>::value, int> = 0>
[[__nodiscard__]] constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) bool isnan(_A1) noexcept {
  return false;
}


[[__nodiscard__]] inline constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) bool isnan(float __x) noexcept {
  return __builtin_isnan(__x);
}

[[__nodiscard__]] inline constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) __attribute__((__enable_if__(true, ""))) bool
isnan(double __x) noexcept {
  return __builtin_isnan(__x);
}

[[__nodiscard__]] inline constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) bool isnan(long double __x) noexcept {
  return __builtin_isnan(__x);
}




template <class _A1, __enable_if_t<is_floating_point<_A1>::value, int> = 0>
[[__nodiscard__]] constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) bool isnormal(_A1 __x) noexcept {
  return __builtin_isnormal(__x);
}

template <class _A1, __enable_if_t<is_integral<_A1>::value, int> = 0>
[[__nodiscard__]] constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) bool isnormal(_A1 __x) noexcept {
  return __x != 0;
}



template <class _A1, class _A2, __enable_if_t<is_arithmetic<_A1>::value && is_arithmetic<_A2>::value, int> = 0>
[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) bool isgreater(_A1 __x, _A2 __y) noexcept {
  using type = typename __promote<_A1, _A2>::type;
  return __builtin_isgreater((type)__x, (type)__y);
}



template <class _A1, class _A2, __enable_if_t<is_arithmetic<_A1>::value && is_arithmetic<_A2>::value, int> = 0>
[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) bool isgreaterequal(_A1 __x, _A2 __y) noexcept {
  using type = typename __promote<_A1, _A2>::type;
  return __builtin_isgreaterequal((type)__x, (type)__y);
}



template <class _A1, class _A2, __enable_if_t<is_arithmetic<_A1>::value && is_arithmetic<_A2>::value, int> = 0>
[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) bool isless(_A1 __x, _A2 __y) noexcept {
  using type = typename __promote<_A1, _A2>::type;
  return __builtin_isless((type)__x, (type)__y);
}



template <class _A1, class _A2, __enable_if_t<is_arithmetic<_A1>::value && is_arithmetic<_A2>::value, int> = 0>
[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) bool islessequal(_A1 __x, _A2 __y) noexcept {
  using type = typename __promote<_A1, _A2>::type;
  return __builtin_islessequal((type)__x, (type)__y);
}



template <class _A1, class _A2, __enable_if_t<is_arithmetic<_A1>::value && is_arithmetic<_A2>::value, int> = 0>
[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) bool islessgreater(_A1 __x, _A2 __y) noexcept {
  using type = typename __promote<_A1, _A2>::type;
  return __builtin_islessgreater((type)__x, (type)__y);
}



template <class _A1, class _A2, __enable_if_t<is_arithmetic<_A1>::value && is_arithmetic<_A2>::value, int> = 0>
[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) bool isunordered(_A1 __x, _A2 __y) noexcept {
  using type = typename __promote<_A1, _A2>::type;
  return __builtin_isunordered((type)__x, (type)__y);
}

}

}}
# 376 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/math.h" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__math/trigonometric_functions.h" 1 3
# 18 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__math/trigonometric_functions.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

namespace __math {



inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) float cos(float __x) noexcept { return __builtin_cosf(__x); }

template <class = int>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) double cos(double __x) noexcept {
  return __builtin_cos(__x);
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) long double cos(long double __x) noexcept { return __builtin_cosl(__x); }

template <class _A1, __enable_if_t<is_integral<_A1>::value, int> = 0>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) double cos(_A1 __x) noexcept {
  return __builtin_cos((double)__x);
}



inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) float sin(float __x) noexcept { return __builtin_sinf(__x); }

template <class = int>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) double sin(double __x) noexcept {
  return __builtin_sin(__x);
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) long double sin(long double __x) noexcept { return __builtin_sinl(__x); }

template <class _A1, __enable_if_t<is_integral<_A1>::value, int> = 0>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) double sin(_A1 __x) noexcept {
  return __builtin_sin((double)__x);
}



inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) float tan(float __x) noexcept { return __builtin_tanf(__x); }

template <class = int>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) double tan(double __x) noexcept {
  return __builtin_tan(__x);
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) long double tan(long double __x) noexcept { return __builtin_tanl(__x); }

template <class _A1, __enable_if_t<is_integral<_A1>::value, int> = 0>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) double tan(_A1 __x) noexcept {
  return __builtin_tan((double)__x);
}

}

}}
# 377 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/math.h" 2 3







namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

namespace __math {



template <class _A1, std::__enable_if_t<std::is_floating_point<_A1>::value, int> = 0>
[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) int fpclassify(_A1 __x) noexcept {
  return __builtin_fpclassify(0, 1, 4, 3, 2, __x);
}

template <class _A1, std::__enable_if_t<std::is_integral<_A1>::value, int> = 0>
[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) int fpclassify(_A1 __x) noexcept {
  return __x == 0 ? 2 : 4;
}

}

}}

using std::__math::fpclassify;
using std::__math::signbit;



using std::__math::isfinite;
using std::__math::isgreater;
using std::__math::isgreaterequal;
using std::__math::isinf;
using std::__math::isless;
using std::__math::islessequal;
using std::__math::islessgreater;
using std::__math::isnan;
using std::__math::isnormal;
using std::__math::isunordered;
# 434 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/math.h" 3
using std::__math::acosh;
using std::__math::acos;
using std::__math::asinh;
using std::__math::asin;
using std::__math::atanh;
using std::__math::atan;
using std::__math::atan2;
using std::__math::cbrt;
using std::__math::ceil;
using std::__math::copysign;
using std::__math::cos;
using std::__math::cosh;
using std::__math::erf;
using std::__math::erfc;
using std::__math::exp;
using std::__math::exp2;
using std::__math::expm1;
using std::__math::fabs;
using std::__math::fdim;
using std::__math::floor;
using std::__math::fma;
using std::__math::fmax;
using std::__math::fmin;
using std::__math::fmod;
using std::__math::frexp;
using std::__math::hypot;
using std::__math::ilogb;
using std::__math::ldexp;
using std::__math::lgamma;
using std::__math::llrint;
using std::__math::llround;
using std::__math::lrint;
using std::__math::lround;
using std::__math::log;
using std::__math::log10;
using std::__math::log1p;
using std::__math::log2;
using std::__math::logb;
using std::__math::modf;
using std::__math::nearbyint;
using std::__math::nextafter;
using std::__math::nexttoward;
using std::__math::pow;
using std::__math::remainder;
using std::__math::remquo;
using std::__math::rint;
using std::__math::round;
using std::__math::scalbln;
using std::__math::scalbn;
using std::__math::signbit;
using std::__math::sin;
using std::__math::sinh;
using std::__math::sqrt;
using std::__math::tan;
using std::__math::tanh;
using std::__math::tgamma;
using std::__math::trunc;

}
# 31 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/openmp_wrappers/math.h" 2 3
# 40 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/openmp_wrappers/math.h" 3
#pragma omp begin declare variant match( device = {arch(nvptx, nvptx64)}, implementation = {extension(match_any)})




# 1 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/__clang_cuda_math.h" 1 3
# 56 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/__clang_cuda_math.h" 3
static constexpr __attribute__((always_inline, nothrow)) int abs(int __a) { return __nv_abs(__a); }
static constexpr __attribute__((always_inline, nothrow)) double fabs(double __a) { return __nv_fabs(__a); }
static constexpr __attribute__((always_inline, nothrow)) double acos(double __a) { return __nv_acos(__a); }
static constexpr __attribute__((always_inline, nothrow)) float acosf(float __a) { return __nv_acosf(__a); }
static constexpr __attribute__((always_inline, nothrow)) double acosh(double __a) { return __nv_acosh(__a); }
static constexpr __attribute__((always_inline, nothrow)) float acoshf(float __a) { return __nv_acoshf(__a); }
static constexpr __attribute__((always_inline, nothrow)) double asin(double __a) { return __nv_asin(__a); }
static constexpr __attribute__((always_inline, nothrow)) float asinf(float __a) { return __nv_asinf(__a); }
static constexpr __attribute__((always_inline, nothrow)) double asinh(double __a) { return __nv_asinh(__a); }
static constexpr __attribute__((always_inline, nothrow)) float asinhf(float __a) { return __nv_asinhf(__a); }
static constexpr __attribute__((always_inline, nothrow)) double atan(double __a) { return __nv_atan(__a); }
static constexpr __attribute__((always_inline, nothrow)) double atan2(double __a, double __b) { return __nv_atan2(__a, __b); }
static constexpr __attribute__((always_inline, nothrow)) float atan2f(float __a, float __b) { return __nv_atan2f(__a, __b); }
static constexpr __attribute__((always_inline, nothrow)) float atanf(float __a) { return __nv_atanf(__a); }
static constexpr __attribute__((always_inline, nothrow)) double atanh(double __a) { return __nv_atanh(__a); }
static constexpr __attribute__((always_inline, nothrow)) float atanhf(float __a) { return __nv_atanhf(__a); }
static constexpr __attribute__((always_inline, nothrow)) double cbrt(double __a) { return __nv_cbrt(__a); }
static constexpr __attribute__((always_inline, nothrow)) float cbrtf(float __a) { return __nv_cbrtf(__a); }
static constexpr __attribute__((always_inline, nothrow)) double ceil(double __a) { return __nv_ceil(__a); }
static constexpr __attribute__((always_inline, nothrow)) float ceilf(float __a) { return __nv_ceilf(__a); }
static constexpr __attribute__((always_inline, nothrow)) double copysign(double __a, double __b) {
  return __nv_copysign(__a, __b);
}
static constexpr __attribute__((always_inline, nothrow)) float copysignf(float __a, float __b) {
  return __nv_copysignf(__a, __b);
}
static constexpr __attribute__((always_inline, nothrow)) double cos(double __a) { return __nv_cos(__a); }
static constexpr __attribute__((always_inline, nothrow)) float cosf(float __a) {
  return __nv_cosf(__a);
}
static constexpr __attribute__((always_inline, nothrow)) double cosh(double __a) { return __nv_cosh(__a); }
static constexpr __attribute__((always_inline, nothrow)) float coshf(float __a) { return __nv_coshf(__a); }
static constexpr __attribute__((always_inline, nothrow)) double cospi(double __a) { return __nv_cospi(__a); }
static constexpr __attribute__((always_inline, nothrow)) float cospif(float __a) { return __nv_cospif(__a); }
static constexpr __attribute__((always_inline, nothrow)) double cyl_bessel_i0(double __a) { return __nv_cyl_bessel_i0(__a); }
static constexpr __attribute__((always_inline, nothrow)) float cyl_bessel_i0f(float __a) { return __nv_cyl_bessel_i0f(__a); }
static constexpr __attribute__((always_inline, nothrow)) double cyl_bessel_i1(double __a) { return __nv_cyl_bessel_i1(__a); }
static constexpr __attribute__((always_inline, nothrow)) float cyl_bessel_i1f(float __a) { return __nv_cyl_bessel_i1f(__a); }
static constexpr __attribute__((always_inline, nothrow)) double erf(double __a) { return __nv_erf(__a); }
static constexpr __attribute__((always_inline, nothrow)) double erfc(double __a) { return __nv_erfc(__a); }
static constexpr __attribute__((always_inline, nothrow)) float erfcf(float __a) { return __nv_erfcf(__a); }
static constexpr __attribute__((always_inline, nothrow)) double erfcinv(double __a) { return __nv_erfcinv(__a); }
static constexpr __attribute__((always_inline, nothrow)) float erfcinvf(float __a) { return __nv_erfcinvf(__a); }
static constexpr __attribute__((always_inline, nothrow)) double erfcx(double __a) { return __nv_erfcx(__a); }
static constexpr __attribute__((always_inline, nothrow)) float erfcxf(float __a) { return __nv_erfcxf(__a); }
static constexpr __attribute__((always_inline, nothrow)) float erff(float __a) { return __nv_erff(__a); }
static constexpr __attribute__((always_inline, nothrow)) double erfinv(double __a) { return __nv_erfinv(__a); }
static constexpr __attribute__((always_inline, nothrow)) float erfinvf(float __a) { return __nv_erfinvf(__a); }
static constexpr __attribute__((always_inline, nothrow)) double exp(double __a) { return __nv_exp(__a); }
static constexpr __attribute__((always_inline, nothrow)) double exp10(double __a) { return __nv_exp10(__a); }
static constexpr __attribute__((always_inline, nothrow)) float exp10f(float __a) { return __nv_exp10f(__a); }
static constexpr __attribute__((always_inline, nothrow)) double exp2(double __a) { return __nv_exp2(__a); }
static constexpr __attribute__((always_inline, nothrow)) float exp2f(float __a) { return __nv_exp2f(__a); }
static constexpr __attribute__((always_inline, nothrow)) float expf(float __a) { return __nv_expf(__a); }
static constexpr __attribute__((always_inline, nothrow)) double expm1(double __a) { return __nv_expm1(__a); }
static constexpr __attribute__((always_inline, nothrow)) float expm1f(float __a) { return __nv_expm1f(__a); }
static constexpr __attribute__((always_inline, nothrow)) float fabsf(float __a) { return __nv_fabsf(__a); }
static constexpr __attribute__((always_inline, nothrow)) double fdim(double __a, double __b) { return __nv_fdim(__a, __b); }
static constexpr __attribute__((always_inline, nothrow)) float fdimf(float __a, float __b) { return __nv_fdimf(__a, __b); }
static constexpr __attribute__((always_inline, nothrow)) double fdivide(double __a, double __b) { return __a / __b; }
static constexpr __attribute__((always_inline, nothrow)) float fdividef(float __a, float __b) {



  return __a / __b;

}
static constexpr __attribute__((always_inline, nothrow)) double floor(double __f) { return __nv_floor(__f); }
static constexpr __attribute__((always_inline, nothrow)) float floorf(float __f) { return __nv_floorf(__f); }
static constexpr __attribute__((always_inline, nothrow)) double fma(double __a, double __b, double __c) {
  return __nv_fma(__a, __b, __c);
}
static constexpr __attribute__((always_inline, nothrow)) float fmaf(float __a, float __b, float __c) {
  return __nv_fmaf(__a, __b, __c);
}
static constexpr __attribute__((always_inline, nothrow)) double fmax(double __a, double __b) { return __nv_fmax(__a, __b); }
static constexpr __attribute__((always_inline, nothrow)) float fmaxf(float __a, float __b) { return __nv_fmaxf(__a, __b); }
static constexpr __attribute__((always_inline, nothrow)) double fmin(double __a, double __b) { return __nv_fmin(__a, __b); }
static constexpr __attribute__((always_inline, nothrow)) float fminf(float __a, float __b) { return __nv_fminf(__a, __b); }
static constexpr __attribute__((always_inline, nothrow)) double fmod(double __a, double __b) { return __nv_fmod(__a, __b); }
static constexpr __attribute__((always_inline, nothrow)) float fmodf(float __a, float __b) { return __nv_fmodf(__a, __b); }
static constexpr __attribute__((always_inline, nothrow)) double frexp(double __a, int *__b) { return __nv_frexp(__a, __b); }
static constexpr __attribute__((always_inline, nothrow)) float frexpf(float __a, int *__b) { return __nv_frexpf(__a, __b); }
static constexpr __attribute__((always_inline, nothrow)) double hypot(double __a, double __b) { return __nv_hypot(__a, __b); }
static constexpr __attribute__((always_inline, nothrow)) float hypotf(float __a, float __b) { return __nv_hypotf(__a, __b); }
static constexpr __attribute__((always_inline, nothrow)) int ilogb(double __a) { return __nv_ilogb(__a); }
static constexpr __attribute__((always_inline, nothrow)) int ilogbf(float __a) { return __nv_ilogbf(__a); }
static constexpr __attribute__((always_inline, nothrow)) double j0(double __a) { return __nv_j0(__a); }
static constexpr __attribute__((always_inline, nothrow)) float j0f(float __a) { return __nv_j0f(__a); }
static constexpr __attribute__((always_inline, nothrow)) double j1(double __a) { return __nv_j1(__a); }
static constexpr __attribute__((always_inline, nothrow)) float j1f(float __a) { return __nv_j1f(__a); }
static constexpr __attribute__((always_inline, nothrow)) double jn(int __n, double __a) { return __nv_jn(__n, __a); }
static constexpr __attribute__((always_inline, nothrow)) float jnf(int __n, float __a) { return __nv_jnf(__n, __a); }

static constexpr __attribute__((always_inline, nothrow)) long labs(long __a) { return __nv_llabs(__a); };



static constexpr __attribute__((always_inline, nothrow)) double ldexp(double __a, int __b) { return __nv_ldexp(__a, __b); }
static constexpr __attribute__((always_inline, nothrow)) float ldexpf(float __a, int __b) { return __nv_ldexpf(__a, __b); }
static constexpr __attribute__((always_inline, nothrow)) double lgamma(double __a) { return __nv_lgamma(__a); }
static constexpr __attribute__((always_inline, nothrow)) float lgammaf(float __a) { return __nv_lgammaf(__a); }
static constexpr __attribute__((always_inline, nothrow)) long long llabs(long long __a) { return __nv_llabs(__a); }
static constexpr __attribute__((always_inline, nothrow)) long long llmax(long long __a, long long __b) {
  return __nv_llmax(__a, __b);
}
static constexpr __attribute__((always_inline, nothrow)) long long llmin(long long __a, long long __b) {
  return __nv_llmin(__a, __b);
}
static constexpr __attribute__((always_inline, nothrow)) long long llrint(double __a) { return __nv_llrint(__a); }
static constexpr __attribute__((always_inline, nothrow)) long long llrintf(float __a) { return __nv_llrintf(__a); }
static constexpr __attribute__((always_inline, nothrow)) long long llround(double __a) { return __nv_llround(__a); }
static constexpr __attribute__((always_inline, nothrow)) long long llroundf(float __a) { return __nv_llroundf(__a); }
static constexpr __attribute__((always_inline, nothrow)) double round(double __a) { return __nv_round(__a); }
static constexpr __attribute__((always_inline, nothrow)) float roundf(float __a) { return __nv_roundf(__a); }
static constexpr __attribute__((always_inline, nothrow)) double log(double __a) { return __nv_log(__a); }
static constexpr __attribute__((always_inline, nothrow)) double log10(double __a) { return __nv_log10(__a); }
static constexpr __attribute__((always_inline, nothrow)) float log10f(float __a) { return __nv_log10f(__a); }
static constexpr __attribute__((always_inline, nothrow)) double log1p(double __a) { return __nv_log1p(__a); }
static constexpr __attribute__((always_inline, nothrow)) float log1pf(float __a) { return __nv_log1pf(__a); }
static constexpr __attribute__((always_inline, nothrow)) double log2(double __a) { return __nv_log2(__a); }
static constexpr __attribute__((always_inline, nothrow)) float log2f(float __a) {
  return __nv_log2f(__a);
}
static constexpr __attribute__((always_inline, nothrow)) double logb(double __a) { return __nv_logb(__a); }
static constexpr __attribute__((always_inline, nothrow)) float logbf(float __a) { return __nv_logbf(__a); }
static constexpr __attribute__((always_inline, nothrow)) float logf(float __a) {
  return __nv_logf(__a);
}

static constexpr __attribute__((always_inline, nothrow)) long lrint(double __a) { return llrint(__a); }
static constexpr __attribute__((always_inline, nothrow)) long lrintf(float __a) { return __float2ll_rn(__a); }
static constexpr __attribute__((always_inline, nothrow)) long lround(double __a) { return llround(__a); }
static constexpr __attribute__((always_inline, nothrow)) long lroundf(float __a) { return llroundf(__a); }






static constexpr __attribute__((always_inline, nothrow)) int max(int __a, int __b) { return __nv_max(__a, __b); }
static constexpr __attribute__((always_inline, nothrow)) int min(int __a, int __b) { return __nv_min(__a, __b); }
static constexpr __attribute__((always_inline, nothrow)) double modf(double __a, double *__b) { return __nv_modf(__a, __b); }
static constexpr __attribute__((always_inline, nothrow)) float modff(float __a, float *__b) { return __nv_modff(__a, __b); }
static constexpr __attribute__((always_inline, nothrow)) double nearbyint(double __a) { return __builtin_nearbyint(__a); }
static constexpr __attribute__((always_inline, nothrow)) float nearbyintf(float __a) { return __builtin_nearbyintf(__a); }
static constexpr __attribute__((always_inline, nothrow)) double nextafter(double __a, double __b) {
  return __nv_nextafter(__a, __b);
}
static constexpr __attribute__((always_inline, nothrow)) float nextafterf(float __a, float __b) {
  return __nv_nextafterf(__a, __b);
}
static constexpr __attribute__((always_inline, nothrow)) double norm(int __dim, const double *__t) {
  return __nv_norm(__dim, __t);
}
static constexpr __attribute__((always_inline, nothrow)) double norm3d(double __a, double __b, double __c) {
  return __nv_norm3d(__a, __b, __c);
}
static constexpr __attribute__((always_inline, nothrow)) float norm3df(float __a, float __b, float __c) {
  return __nv_norm3df(__a, __b, __c);
}
static constexpr __attribute__((always_inline, nothrow)) double norm4d(double __a, double __b, double __c, double __d) {
  return __nv_norm4d(__a, __b, __c, __d);
}
static constexpr __attribute__((always_inline, nothrow)) float norm4df(float __a, float __b, float __c, float __d) {
  return __nv_norm4df(__a, __b, __c, __d);
}
static constexpr __attribute__((always_inline, nothrow)) double normcdf(double __a) { return __nv_normcdf(__a); }
static constexpr __attribute__((always_inline, nothrow)) float normcdff(float __a) { return __nv_normcdff(__a); }
static constexpr __attribute__((always_inline, nothrow)) double normcdfinv(double __a) { return __nv_normcdfinv(__a); }
static constexpr __attribute__((always_inline, nothrow)) float normcdfinvf(float __a) { return __nv_normcdfinvf(__a); }
static constexpr __attribute__((always_inline, nothrow)) float normf(int __dim, const float *__t) {
  return __nv_normf(__dim, __t);
}
static constexpr __attribute__((always_inline, nothrow)) double pow(double __a, double __b) { return __nv_pow(__a, __b); }
static constexpr __attribute__((always_inline, nothrow)) float powf(float __a, float __b) { return __nv_powf(__a, __b); }
static constexpr __attribute__((always_inline, nothrow)) double powi(double __a, int __b) { return __nv_powi(__a, __b); }
static constexpr __attribute__((always_inline, nothrow)) float powif(float __a, int __b) { return __nv_powif(__a, __b); }
static constexpr __attribute__((always_inline, nothrow)) double rcbrt(double __a) { return __nv_rcbrt(__a); }
static constexpr __attribute__((always_inline, nothrow)) float rcbrtf(float __a) { return __nv_rcbrtf(__a); }
static constexpr __attribute__((always_inline, nothrow)) double remainder(double __a, double __b) {
  return __nv_remainder(__a, __b);
}
static constexpr __attribute__((always_inline, nothrow)) float remainderf(float __a, float __b) {
  return __nv_remainderf(__a, __b);
}
static constexpr __attribute__((always_inline, nothrow)) double remquo(double __a, double __b, int *__c) {
  return __nv_remquo(__a, __b, __c);
}
static constexpr __attribute__((always_inline, nothrow)) float remquof(float __a, float __b, int *__c) {
  return __nv_remquof(__a, __b, __c);
}
static constexpr __attribute__((always_inline, nothrow)) double rhypot(double __a, double __b) {
  return __nv_rhypot(__a, __b);
}
static constexpr __attribute__((always_inline, nothrow)) float rhypotf(float __a, float __b) {
  return __nv_rhypotf(__a, __b);
}

static constexpr __attribute__((always_inline, nothrow)) double rint(double __a) { return __builtin_rint(__a); }
static constexpr __attribute__((always_inline, nothrow)) float rintf(float __a) { return __builtin_rintf(__a); }
static constexpr __attribute__((always_inline, nothrow)) double rnorm(int __a, const double *__b) {
  return __nv_rnorm(__a, __b);
}
static constexpr __attribute__((always_inline, nothrow)) double rnorm3d(double __a, double __b, double __c) {
  return __nv_rnorm3d(__a, __b, __c);
}
static constexpr __attribute__((always_inline, nothrow)) float rnorm3df(float __a, float __b, float __c) {
  return __nv_rnorm3df(__a, __b, __c);
}
static constexpr __attribute__((always_inline, nothrow)) double rnorm4d(double __a, double __b, double __c, double __d) {
  return __nv_rnorm4d(__a, __b, __c, __d);
}
static constexpr __attribute__((always_inline, nothrow)) float rnorm4df(float __a, float __b, float __c, float __d) {
  return __nv_rnorm4df(__a, __b, __c, __d);
}
static constexpr __attribute__((always_inline, nothrow)) float rnormf(int __dim, const float *__t) {
  return __nv_rnormf(__dim, __t);
}
static constexpr __attribute__((always_inline, nothrow)) double rsqrt(double __a) { return __nv_rsqrt(__a); }
static constexpr __attribute__((always_inline, nothrow)) float rsqrtf(float __a) { return __nv_rsqrtf(__a); }
static constexpr __attribute__((always_inline, nothrow)) double scalbn(double __a, int __b) { return __nv_scalbn(__a, __b); }
static constexpr __attribute__((always_inline, nothrow)) float scalbnf(float __a, int __b) { return __nv_scalbnf(__a, __b); }
static constexpr __attribute__((always_inline, nothrow)) double scalbln(double __a, long __b) {
  if (__b > 2147483647)
    return __a > 0 ? (__builtin_huge_val ()) : -(__builtin_huge_val ());
  if (__b < (-2147483647 -1))
    return __a > 0 ? 0.0 : -0.0;
  return scalbn(__a, (int)__b);
}
static constexpr __attribute__((always_inline, nothrow)) float scalblnf(float __a, long __b) {
  if (__b > 2147483647)
    return __a > 0 ? (__builtin_huge_valf ()) : -(__builtin_huge_valf ());
  if (__b < (-2147483647 -1))
    return __a > 0 ? 0.f : -0.f;
  return scalbnf(__a, (int)__b);
}
static constexpr __attribute__((always_inline, nothrow)) double sin(double __a) { return __nv_sin(__a); }
static constexpr __attribute__((always_inline, nothrow)) void sincos(double __a, double *__s, double *__c) {
  return __nv_sincos(__a, __s, __c);
}
static constexpr __attribute__((always_inline, nothrow)) void sincosf(float __a, float *__s, float *__c) {
  return __nv_sincosf(__a, __s, __c);
}
static constexpr __attribute__((always_inline, nothrow)) void sincospi(double __a, double *__s, double *__c) {
  return __nv_sincospi(__a, __s, __c);
}
static constexpr __attribute__((always_inline, nothrow)) void sincospif(float __a, float *__s, float *__c) {
  return __nv_sincospif(__a, __s, __c);
}
static constexpr __attribute__((always_inline, nothrow)) float sinf(float __a) {
  return __nv_sinf(__a);
}
static constexpr __attribute__((always_inline, nothrow)) double sinh(double __a) { return __nv_sinh(__a); }
static constexpr __attribute__((always_inline, nothrow)) float sinhf(float __a) { return __nv_sinhf(__a); }
static constexpr __attribute__((always_inline, nothrow)) double sinpi(double __a) { return __nv_sinpi(__a); }
static constexpr __attribute__((always_inline, nothrow)) float sinpif(float __a) { return __nv_sinpif(__a); }
static constexpr __attribute__((always_inline, nothrow)) double sqrt(double __a) { return __nv_sqrt(__a); }
static constexpr __attribute__((always_inline, nothrow)) float sqrtf(float __a) { return __nv_sqrtf(__a); }
static constexpr __attribute__((always_inline, nothrow)) double tan(double __a) { return __nv_tan(__a); }
static constexpr __attribute__((always_inline, nothrow)) float tanf(float __a) { return __nv_tanf(__a); }
static constexpr __attribute__((always_inline, nothrow)) double tanh(double __a) { return __nv_tanh(__a); }
static constexpr __attribute__((always_inline, nothrow)) float tanhf(float __a) { return __nv_tanhf(__a); }
static constexpr __attribute__((always_inline, nothrow)) double tgamma(double __a) { return __nv_tgamma(__a); }
static constexpr __attribute__((always_inline, nothrow)) float tgammaf(float __a) { return __nv_tgammaf(__a); }
static constexpr __attribute__((always_inline, nothrow)) double trunc(double __a) { return __nv_trunc(__a); }
static constexpr __attribute__((always_inline, nothrow)) float truncf(float __a) { return __nv_truncf(__a); }
static constexpr __attribute__((always_inline, nothrow)) unsigned long long ullmax(unsigned long long __a,
                                     unsigned long long __b) {
  return __nv_ullmax(__a, __b);
}
static constexpr __attribute__((always_inline, nothrow)) unsigned long long ullmin(unsigned long long __a,
                                     unsigned long long __b) {
  return __nv_ullmin(__a, __b);
}
static constexpr __attribute__((always_inline, nothrow)) unsigned int umax(unsigned int __a, unsigned int __b) {
  return __nv_umax(__a, __b);
}
static constexpr __attribute__((always_inline, nothrow)) unsigned int umin(unsigned int __a, unsigned int __b) {
  return __nv_umin(__a, __b);
}
static constexpr __attribute__((always_inline, nothrow)) double y0(double __a) { return __nv_y0(__a); }
static constexpr __attribute__((always_inline, nothrow)) float y0f(float __a) { return __nv_y0f(__a); }
static constexpr __attribute__((always_inline, nothrow)) double y1(double __a) { return __nv_y1(__a); }
static constexpr __attribute__((always_inline, nothrow)) float y1f(float __a) { return __nv_y1f(__a); }
static constexpr __attribute__((always_inline, nothrow)) double yn(int __a, double __b) { return __nv_yn(__a, __b); }
static constexpr __attribute__((always_inline, nothrow)) float ynf(int __a, float __b) { return __nv_ynf(__a, __b); }
# 46 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/openmp_wrappers/math.h" 2 3



#pragma omp end declare variant


#pragma omp begin declare variant match(device = {arch(amdgcn)})


# 1 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/__clang_hip_math.h" 1 3
# 18 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/__clang_hip_math.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/algorithm" 1 3
# 19 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/__clang_hip_math.h" 2 3




# 1 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/omp.h" 1 3
# 27 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/omp.h" 3
    extern "C" {
# 48 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/omp.h" 3
    typedef enum omp_sched_t {
        omp_sched_static = 1,
        omp_sched_dynamic = 2,
        omp_sched_guided = 3,
        omp_sched_auto = 4,
        omp_sched_monotonic = 0x80000000
    } omp_sched_t;


    extern void omp_set_num_threads (int);
    extern void omp_set_dynamic (int);
    extern void omp_set_nested (int);
    extern void omp_set_max_active_levels (int);
    extern void omp_set_schedule (omp_sched_t, int);


    extern int omp_get_num_threads (void);
    extern int omp_get_dynamic (void);
    extern int omp_get_nested (void);
    extern int omp_get_max_threads (void);
    extern int omp_get_thread_num (void);
    extern int omp_get_num_procs (void);
    extern int omp_in_parallel (void);
    extern int omp_in_final (void);
    extern int omp_get_active_level (void);
    extern int omp_get_level (void);
    extern int omp_get_ancestor_thread_num (int);
    extern int omp_get_team_size (int);
    extern int omp_get_thread_limit (void);
    extern int omp_get_max_active_levels (void);
    extern void omp_get_schedule (omp_sched_t *, int *);
    extern int omp_get_max_task_priority (void);


    typedef struct omp_lock_t {
        void * _lk;
    } omp_lock_t;

    extern void omp_init_lock (omp_lock_t *);
    extern void omp_set_lock (omp_lock_t *);
    extern void omp_unset_lock (omp_lock_t *);
    extern void omp_destroy_lock (omp_lock_t *);
    extern int omp_test_lock (omp_lock_t *);


    typedef struct omp_nest_lock_t {
        void * _lk;
    } omp_nest_lock_t;

    extern void omp_init_nest_lock (omp_nest_lock_t *);
    extern void omp_set_nest_lock (omp_nest_lock_t *);
    extern void omp_unset_nest_lock (omp_nest_lock_t *);
    extern void omp_destroy_nest_lock (omp_nest_lock_t *);
    extern int omp_test_nest_lock (omp_nest_lock_t *);


    typedef enum omp_sync_hint_t {
        omp_sync_hint_none = 0,
        omp_lock_hint_none = omp_sync_hint_none,
        omp_sync_hint_uncontended = 1,
        omp_lock_hint_uncontended = omp_sync_hint_uncontended,
        omp_sync_hint_contended = (1<<1),
        omp_lock_hint_contended = omp_sync_hint_contended,
        omp_sync_hint_nonspeculative = (1<<2),
        omp_lock_hint_nonspeculative = omp_sync_hint_nonspeculative,
        omp_sync_hint_speculative = (1<<3),
        omp_lock_hint_speculative = omp_sync_hint_speculative,
        kmp_lock_hint_hle = (1<<16),
        kmp_lock_hint_rtm = (1<<17),
        kmp_lock_hint_adaptive = (1<<18)
    } omp_sync_hint_t;


    typedef omp_sync_hint_t omp_lock_hint_t;


    extern void omp_init_lock_with_hint(omp_lock_t *, omp_lock_hint_t);
    extern void omp_init_nest_lock_with_hint(omp_nest_lock_t *, omp_lock_hint_t);


    extern double omp_get_wtime (void);
    extern double omp_get_wtick (void);


    extern int omp_get_default_device (void);
    extern void omp_set_default_device (int);
    extern int omp_is_initial_device (void);
    extern int omp_get_num_devices (void);
    extern int omp_get_num_teams (void);
    extern int omp_get_team_num (void);
    extern int omp_get_cancellation (void);


    extern int omp_get_initial_device (void);
    extern void* omp_target_alloc(size_t, int);
    extern void omp_target_free(void *, int);
    extern int omp_target_is_present(const void *, int);
    extern int omp_target_memcpy(void *, const void *, size_t, size_t, size_t, int, int);
    extern int omp_target_memcpy_rect(void *, const void *, size_t, int, const size_t *,
                                            const size_t *, const size_t *, const size_t *, const size_t *, int, int);
    extern int omp_target_associate_ptr(const void *, const void *, size_t, size_t, int);
    extern int omp_target_disassociate_ptr(const void *, int);


    extern int omp_get_device_num (void);
    typedef void * omp_depend_t;


    typedef intptr_t omp_intptr_t;


    typedef enum omp_interop_property {
        omp_ipr_fr_id = -1,
        omp_ipr_fr_name = -2,
        omp_ipr_vendor = -3,
        omp_ipr_vendor_name = -4,
        omp_ipr_device_num = -5,
        omp_ipr_platform = -6,
        omp_ipr_device = -7,
        omp_ipr_device_context = -8,
        omp_ipr_targetsync = -9,
        omp_ipr_first = -9
    } omp_interop_property_t;



    typedef enum omp_interop_rc {
        omp_irc_no_value = 1,
        omp_irc_success = 0,
        omp_irc_empty = -1,
        omp_irc_out_of_range = -2,
        omp_irc_type_int = -3,
        omp_irc_type_ptr = -4,
        omp_irc_type_str = -5,
        omp_irc_other = -6
    } omp_interop_rc_t;

    typedef enum omp_interop_fr {
        omp_ifr_cuda = 1,
        omp_ifr_cuda_driver = 2,
        omp_ifr_opencl = 3,
        omp_ifr_sycl = 4,
        omp_ifr_hip = 5,
        omp_ifr_level_zero = 6,
        omp_ifr_last = 7
    } omp_interop_fr_t;

    typedef void * omp_interop_t;




    extern int omp_get_num_interop_properties(const omp_interop_t);



    extern omp_intptr_t omp_get_interop_int(const omp_interop_t, omp_interop_property_t, int *);



    extern void * omp_get_interop_ptr(const omp_interop_t, omp_interop_property_t, int *);



    extern const char * omp_get_interop_str(const omp_interop_t, omp_interop_property_t, int *);



    extern const char * omp_get_interop_name(const omp_interop_t, omp_interop_property_t);



    extern const char * omp_get_interop_type_desc(const omp_interop_t, omp_interop_property_t);



    extern const char * omp_get_interop_rc_desc(const omp_interop_t, omp_interop_rc_t);






    extern int omp_target_memcpy_async(void *, const void *, size_t, size_t, size_t, int,
                                             int, int, omp_depend_t *);



    extern int omp_target_memcpy_rect_async(void *, const void *, size_t, int, const size_t *,
                                             const size_t *, const size_t *, const size_t *, const size_t *, int, int,
                                             int, omp_depend_t *);



    extern void * omp_get_mapped_ptr(const void *, int);
    extern int omp_target_is_accessible(const void *, size_t, int);


    extern int kmp_get_stacksize (void);
    extern void kmp_set_stacksize (int);
    extern size_t kmp_get_stacksize_s (void);
    extern void kmp_set_stacksize_s (size_t);
    extern int kmp_get_blocktime (void);
    extern int kmp_get_library (void);
    extern void kmp_set_blocktime (int);
    extern void kmp_set_library (int);
    extern void kmp_set_library_serial (void);
    extern void kmp_set_library_turnaround (void);
    extern void kmp_set_library_throughput (void);
    extern void kmp_set_defaults (char const *);
    extern void kmp_set_disp_num_buffers (int);


    typedef void * kmp_affinity_mask_t;

    extern int kmp_set_affinity (kmp_affinity_mask_t *);
    extern int kmp_get_affinity (kmp_affinity_mask_t *);
    extern int kmp_get_affinity_max_proc (void);
    extern void kmp_create_affinity_mask (kmp_affinity_mask_t *);
    extern void kmp_destroy_affinity_mask (kmp_affinity_mask_t *);
    extern int kmp_set_affinity_mask_proc (int, kmp_affinity_mask_t *);
    extern int kmp_unset_affinity_mask_proc (int, kmp_affinity_mask_t *);
    extern int kmp_get_affinity_mask_proc (int, kmp_affinity_mask_t *);


    typedef enum omp_proc_bind_t {
        omp_proc_bind_false = 0,
        omp_proc_bind_true = 1,
        omp_proc_bind_master = 2,
        omp_proc_bind_close = 3,
        omp_proc_bind_spread = 4
    } omp_proc_bind_t;

    extern omp_proc_bind_t omp_get_proc_bind (void);


    extern int omp_get_num_places (void);
    extern int omp_get_place_num_procs (int);
    extern void omp_get_place_proc_ids (int, int *);
    extern int omp_get_place_num (void);
    extern int omp_get_partition_num_places (void);
    extern void omp_get_partition_place_nums (int *);

    extern void * kmp_malloc (size_t);
    extern void * kmp_aligned_malloc (size_t, size_t);
    extern void * kmp_calloc (size_t, size_t);
    extern void * kmp_realloc (void *, size_t);
    extern void kmp_free (void *);

    extern void kmp_set_warnings_on(void);
    extern void kmp_set_warnings_off(void);


    typedef enum omp_control_tool_result_t {
        omp_control_tool_notool = -2,
        omp_control_tool_nocallback = -1,
        omp_control_tool_success = 0,
        omp_control_tool_ignored = 1
    } omp_control_tool_result_t;

    typedef enum omp_control_tool_t {
        omp_control_tool_start = 1,
        omp_control_tool_pause = 2,
        omp_control_tool_flush = 3,
        omp_control_tool_end = 4
    } omp_control_tool_t;

    extern int omp_control_tool(int, int, void*);


    typedef uintptr_t omp_uintptr_t;

    typedef enum {
        omp_atk_sync_hint = 1,
        omp_atk_alignment = 2,
        omp_atk_access = 3,
        omp_atk_pool_size = 4,
        omp_atk_fallback = 5,
        omp_atk_fb_data = 6,
        omp_atk_pinned = 7,
        omp_atk_partition = 8
    } omp_alloctrait_key_t;

    typedef enum {
        omp_atv_false = 0,
        omp_atv_true = 1,
        omp_atv_contended = 3,
        omp_atv_uncontended = 4,
        omp_atv_serialized = 5,
        omp_atv_sequential = omp_atv_serialized,
        omp_atv_private = 6,
        omp_atv_all = 7,
        omp_atv_thread = 8,
        omp_atv_pteam = 9,
        omp_atv_cgroup = 10,
        omp_atv_default_mem_fb = 11,
        omp_atv_null_fb = 12,
        omp_atv_abort_fb = 13,
        omp_atv_allocator_fb = 14,
        omp_atv_environment = 15,
        omp_atv_nearest = 16,
        omp_atv_blocked = 17,
        omp_atv_interleaved = 18
    } omp_alloctrait_value_t;


    typedef struct {
        omp_alloctrait_key_t key;
        omp_uintptr_t value;
    } omp_alloctrait_t;
# 386 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/omp.h" 3
    typedef enum omp_allocator_handle_t : omp_uintptr_t



    {
      omp_null_allocator = 0,
      omp_default_mem_alloc = 1,
      omp_large_cap_mem_alloc = 2,
      omp_const_mem_alloc = 3,
      omp_high_bw_mem_alloc = 4,
      omp_low_lat_mem_alloc = 5,
      omp_cgroup_mem_alloc = 6,
      omp_pteam_mem_alloc = 7,
      omp_thread_mem_alloc = 8,
      llvm_omp_target_host_mem_alloc = 100,
      llvm_omp_target_shared_mem_alloc = 101,
      llvm_omp_target_device_mem_alloc = 102,
      KMP_ALLOCATOR_MAX_HANDLE = (18446744073709551615UL)
    } omp_allocator_handle_t;

    typedef enum omp_memspace_handle_t : omp_uintptr_t



    {
      omp_default_mem_space = 0,
      omp_large_cap_mem_space = 1,
      omp_const_mem_space = 2,
      omp_high_bw_mem_space = 3,
      omp_low_lat_mem_space = 4,
      llvm_omp_target_host_mem_space = 100,
      llvm_omp_target_shared_mem_space = 101,
      llvm_omp_target_device_mem_space = 102,
      KMP_MEMSPACE_MAX_HANDLE = (18446744073709551615UL)
    } omp_memspace_handle_t;

    extern omp_allocator_handle_t omp_init_allocator(omp_memspace_handle_t m,
                                                       int ntraits, omp_alloctrait_t traits[]);
    extern void omp_destroy_allocator(omp_allocator_handle_t allocator);

    extern void omp_set_default_allocator(omp_allocator_handle_t a);
    extern omp_allocator_handle_t omp_get_default_allocator(void);

    extern void * omp_alloc(size_t size, omp_allocator_handle_t a = omp_null_allocator);
    extern void * omp_aligned_alloc(size_t align, size_t size,
                                                         omp_allocator_handle_t a = omp_null_allocator);
    extern void * omp_calloc(size_t nmemb, size_t size,
                                                  omp_allocator_handle_t a = omp_null_allocator);
    extern void * omp_aligned_calloc(size_t align, size_t nmemb, size_t size,
                                                          omp_allocator_handle_t a = omp_null_allocator);
    extern void * omp_realloc(void *ptr, size_t size,
                                                   omp_allocator_handle_t allocator = omp_null_allocator,
                                                   omp_allocator_handle_t free_allocator = omp_null_allocator);
    extern void omp_free(void * ptr, omp_allocator_handle_t a = omp_null_allocator);
# 453 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/omp.h" 3
    extern void ompc_set_affinity_format(char const *);
    extern size_t ompc_get_affinity_format(char *, size_t);
    extern void ompc_display_affinity(char const *);
    extern size_t ompc_capture_affinity(char *, size_t, char const *);






    typedef enum omp_event_handle_t { KMP_EVENT_MAX_HANDLE = (18446744073709551615UL) } omp_event_handle_t;

    extern void omp_fulfill_event ( omp_event_handle_t event );


    typedef enum omp_pause_resource_t {
      omp_pause_resume = 0,
      omp_pause_soft = 1,
      omp_pause_hard = 2
    } omp_pause_resource_t;
    extern int omp_pause_resource(omp_pause_resource_t, int);
    extern int omp_pause_resource_all(omp_pause_resource_t);

    extern int omp_get_supported_active_levels(void);


    extern void omp_set_num_teams(int num_teams);
    extern int omp_get_max_teams(void);
    extern void omp_set_teams_thread_limit(int limit);
    extern int omp_get_teams_thread_limit(void);


    extern void omp_display_env(int verbose);


#pragma omp begin declare variant match(device={kind(host)})
    static inline int omp_is_initial_device(void) { return 1; }
#pragma omp end declare variant
#pragma omp begin declare variant match(device={kind(nohost)})
    static inline int omp_is_initial_device(void) { return 0; }
#pragma omp end declare variant



    extern int omp_in_explicit_task(void);


    extern void *llvm_omp_target_dynamic_shared_alloc();







    typedef int omp_int_t;
    typedef double omp_wtime_t;


    }
# 24 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/__clang_hip_math.h" 2 3
# 83 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/__clang_hip_math.h" 3
static inline __attribute__((always_inline, nothrow))
uint64_t __make_mantissa_base8(const char *__tagp __attribute__((nonnull))) {
  uint64_t __r = 0;
  while (*__tagp != '\0') {
    char __tmp = *__tagp;

    if (__tmp >= '0' && __tmp <= '7')
      __r = (__r * 8u) + __tmp - '0';
    else
      return 0;

    ++__tagp;
  }

  return __r;
}

static inline __attribute__((always_inline, nothrow))
uint64_t __make_mantissa_base10(const char *__tagp __attribute__((nonnull))) {
  uint64_t __r = 0;
  while (*__tagp != '\0') {
    char __tmp = *__tagp;

    if (__tmp >= '0' && __tmp <= '9')
      __r = (__r * 10u) + __tmp - '0';
    else
      return 0;

    ++__tagp;
  }

  return __r;
}

static inline __attribute__((always_inline, nothrow))
uint64_t __make_mantissa_base16(const char *__tagp __attribute__((nonnull))) {
  uint64_t __r = 0;
  while (*__tagp != '\0') {
    char __tmp = *__tagp;

    if (__tmp >= '0' && __tmp <= '9')
      __r = (__r * 16u) + __tmp - '0';
    else if (__tmp >= 'a' && __tmp <= 'f')
      __r = (__r * 16u) + __tmp - 'a' + 10;
    else if (__tmp >= 'A' && __tmp <= 'F')
      __r = (__r * 16u) + __tmp - 'A' + 10;
    else
      return 0;

    ++__tagp;
  }

  return __r;
}

static inline __attribute__((always_inline, nothrow))
uint64_t __make_mantissa(const char *__tagp __attribute__((nonnull))) {
  if (*__tagp == '0') {
    ++__tagp;

    if (*__tagp == 'x' || *__tagp == 'X')
      return __make_mantissa_base16(__tagp);
    else
      return __make_mantissa_base8(__tagp);
  }

  return __make_mantissa_base10(__tagp);
}





static inline __attribute__((always_inline, nothrow))
float __cosf(float __x) { return __ocml_native_cos_f32(__x); }

static inline __attribute__((always_inline, nothrow))
float __exp10f(float __x) {
  const float __log2_10 = 0x1.a934f0p+1f;
  return __builtin_amdgcn_exp2f(__log2_10 * __x);
}

static inline __attribute__((always_inline, nothrow))
float __expf(float __x) {
  const float __log2_e = 0x1.715476p+0;
  return __builtin_amdgcn_exp2f(__log2_e * __x);
}
# 181 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/__clang_hip_math.h" 3
static inline __attribute__((always_inline, nothrow))
float __fadd_rn(float __x, float __y) { return __x + __y; }
# 195 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/__clang_hip_math.h" 3
static inline __attribute__((always_inline, nothrow))
float __fdiv_rn(float __x, float __y) { return __x / __y; }


static inline __attribute__((always_inline, nothrow))
float __fdividef(float __x, float __y) { return __x / __y; }
# 220 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/__clang_hip_math.h" 3
static inline __attribute__((always_inline, nothrow))
float __fmaf_rn(float __x, float __y, float __z) {
  return __builtin_fmaf(__x, __y, __z);
}
# 236 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/__clang_hip_math.h" 3
static inline __attribute__((always_inline, nothrow))
float __fmul_rn(float __x, float __y) { return __x * __y; }
# 250 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/__clang_hip_math.h" 3
static inline __attribute__((always_inline, nothrow))
float __frcp_rn(float __x) { return 1.0f / __x; }


static inline __attribute__((always_inline, nothrow))
float __frsqrt_rn(float __x) { return __builtin_amdgcn_rsqf(__x); }
# 267 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/__clang_hip_math.h" 3
static inline __attribute__((always_inline, nothrow))
float __fsqrt_rn(float __x) { return __ocml_native_sqrt_f32(__x); }
# 281 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/__clang_hip_math.h" 3
static inline __attribute__((always_inline, nothrow))
float __fsub_rn(float __x, float __y) { return __x - __y; }


static inline __attribute__((always_inline, nothrow))
float __log10f(float __x) { return __builtin_log10f(__x); }

static inline __attribute__((always_inline, nothrow))
float __log2f(float __x) { return __builtin_amdgcn_logf(__x); }

static inline __attribute__((always_inline, nothrow))
float __logf(float __x) { return __builtin_logf(__x); }

static inline __attribute__((always_inline, nothrow))
float __powf(float __x, float __y) { return __ocml_pow_f32(__x, __y); }

static inline __attribute__((always_inline, nothrow))
float __saturatef(float __x) { return (__x < 0) ? 0 : ((__x > 1) ? 1 : __x); }

static inline __attribute__((always_inline, nothrow))
void __sincosf(float __x, float *__sinptr, float *__cosptr) {
  *__sinptr = __ocml_native_sin_f32(__x);
  *__cosptr = __ocml_native_cos_f32(__x);
}

static inline __attribute__((always_inline, nothrow))
float __sinf(float __x) { return __ocml_native_sin_f32(__x); }

static inline __attribute__((always_inline, nothrow))
float __tanf(float __x) {
  return __sinf(__x) * __builtin_amdgcn_rcpf(__cosf(__x));
}



static inline __attribute__((always_inline, nothrow))
int abs(int __x) {
  return __builtin_abs(__x);
}
static inline __attribute__((always_inline, nothrow))
long labs(long __x) {
  return __builtin_labs(__x);
}
static inline __attribute__((always_inline, nothrow))
long long llabs(long long __x) {
  return __builtin_llabs(__x);
}


static inline __attribute__((always_inline, nothrow))
float acosf(float __x) { return __ocml_acos_f32(__x); }

static inline __attribute__((always_inline, nothrow))
float acoshf(float __x) { return __ocml_acosh_f32(__x); }

static inline __attribute__((always_inline, nothrow))
float asinf(float __x) { return __ocml_asin_f32(__x); }

static inline __attribute__((always_inline, nothrow))
float asinhf(float __x) { return __ocml_asinh_f32(__x); }

static inline __attribute__((always_inline, nothrow))
float atan2f(float __x, float __y) { return __ocml_atan2_f32(__x, __y); }

static inline __attribute__((always_inline, nothrow))
float atanf(float __x) { return __ocml_atan_f32(__x); }

static inline __attribute__((always_inline, nothrow))
float atanhf(float __x) { return __ocml_atanh_f32(__x); }

static inline __attribute__((always_inline, nothrow))
float cbrtf(float __x) { return __ocml_cbrt_f32(__x); }

static inline __attribute__((always_inline, nothrow))
float ceilf(float __x) { return __builtin_ceilf(__x); }

static inline __attribute__((always_inline, nothrow))
float copysignf(float __x, float __y) { return __builtin_copysignf(__x, __y); }

static inline __attribute__((always_inline, nothrow))
float cosf(float __x) { return __ocml_cos_f32(__x); }

static inline __attribute__((always_inline, nothrow))
float coshf(float __x) { return __ocml_cosh_f32(__x); }

static inline __attribute__((always_inline, nothrow))
float cospif(float __x) { return __ocml_cospi_f32(__x); }

static inline __attribute__((always_inline, nothrow))
float cyl_bessel_i0f(float __x) { return __ocml_i0_f32(__x); }

static inline __attribute__((always_inline, nothrow))
float cyl_bessel_i1f(float __x) { return __ocml_i1_f32(__x); }

static inline __attribute__((always_inline, nothrow))
float erfcf(float __x) { return __ocml_erfc_f32(__x); }

static inline __attribute__((always_inline, nothrow))
float erfcinvf(float __x) { return __ocml_erfcinv_f32(__x); }

static inline __attribute__((always_inline, nothrow))
float erfcxf(float __x) { return __ocml_erfcx_f32(__x); }

static inline __attribute__((always_inline, nothrow))
float erff(float __x) { return __ocml_erf_f32(__x); }

static inline __attribute__((always_inline, nothrow))
float erfinvf(float __x) { return __ocml_erfinv_f32(__x); }

static inline __attribute__((always_inline, nothrow))
float exp10f(float __x) { return __ocml_exp10_f32(__x); }

static inline __attribute__((always_inline, nothrow))
float exp2f(float __x) { return __builtin_exp2f(__x); }

static inline __attribute__((always_inline, nothrow))
float expf(float __x) { return __builtin_expf(__x); }

static inline __attribute__((always_inline, nothrow))
float expm1f(float __x) { return __ocml_expm1_f32(__x); }

static inline __attribute__((always_inline, nothrow))
float fabsf(float __x) { return __builtin_fabsf(__x); }

static inline __attribute__((always_inline, nothrow))
float fdimf(float __x, float __y) { return __ocml_fdim_f32(__x, __y); }

static inline __attribute__((always_inline, nothrow))
float fdividef(float __x, float __y) { return __x / __y; }

static inline __attribute__((always_inline, nothrow))
float floorf(float __x) { return __builtin_floorf(__x); }

static inline __attribute__((always_inline, nothrow))
float fmaf(float __x, float __y, float __z) {
  return __builtin_fmaf(__x, __y, __z);
}

static inline __attribute__((always_inline, nothrow))
float fmaxf(float __x, float __y) { return __builtin_fmaxf(__x, __y); }

static inline __attribute__((always_inline, nothrow))
float fminf(float __x, float __y) { return __builtin_fminf(__x, __y); }

static inline __attribute__((always_inline, nothrow))
float fmodf(float __x, float __y) { return __ocml_fmod_f32(__x, __y); }

static inline __attribute__((always_inline, nothrow))
float frexpf(float __x, int *__nptr) {
  return __builtin_frexpf(__x, __nptr);
}

static inline __attribute__((always_inline, nothrow))
float hypotf(float __x, float __y) { return __ocml_hypot_f32(__x, __y); }

static inline __attribute__((always_inline, nothrow))
int ilogbf(float __x) { return __ocml_ilogb_f32(__x); }

static inline __attribute__((always_inline, nothrow))
int __finitef(float __x) { return __builtin_isfinite(__x); }

static inline __attribute__((always_inline, nothrow))
int __isinff(float __x) { return __builtin_isinf(__x); }

static inline __attribute__((always_inline, nothrow))
int __isnanf(float __x) { return __builtin_isnan(__x); }

static inline __attribute__((always_inline, nothrow))
float j0f(float __x) { return __ocml_j0_f32(__x); }

static inline __attribute__((always_inline, nothrow))
float j1f(float __x) { return __ocml_j1_f32(__x); }

static inline __attribute__((always_inline, nothrow))
float jnf(int __n, float __x) {



  if (__n == 0)
    return j0f(__x);
  if (__n == 1)
    return j1f(__x);

  float __x0 = j0f(__x);
  float __x1 = j1f(__x);
  for (int __i = 1; __i < __n; ++__i) {
    float __x2 = (2 * __i) / __x * __x1 - __x0;
    __x0 = __x1;
    __x1 = __x2;
  }

  return __x1;
}

static inline __attribute__((always_inline, nothrow))
float ldexpf(float __x, int __e) { return __builtin_amdgcn_ldexpf(__x, __e); }

static inline __attribute__((always_inline, nothrow))
float lgammaf(float __x) { return __ocml_lgamma_f32(__x); }

static inline __attribute__((always_inline, nothrow))
long long int llrintf(float __x) { return __builtin_rintf(__x); }

static inline __attribute__((always_inline, nothrow))
long long int llroundf(float __x) { return __builtin_roundf(__x); }

static inline __attribute__((always_inline, nothrow))
float log10f(float __x) { return __builtin_log10f(__x); }

static inline __attribute__((always_inline, nothrow))
float log1pf(float __x) { return __ocml_log1p_f32(__x); }

static inline __attribute__((always_inline, nothrow))
float log2f(float __x) { return __ocml_log2_f32(__x); }

static inline __attribute__((always_inline, nothrow))
float logbf(float __x) { return __ocml_logb_f32(__x); }

static inline __attribute__((always_inline, nothrow))
float logf(float __x) { return __ocml_log_f32(__x); }

static inline __attribute__((always_inline, nothrow))
long int lrintf(float __x) { return __builtin_rintf(__x); }

static inline __attribute__((always_inline, nothrow))
long int lroundf(float __x) { return __builtin_roundf(__x); }

static inline __attribute__((always_inline, nothrow))
float modff(float __x, float *__iptr) {
  float __tmp;

#pragma omp allocate(__tmp) allocator(omp_thread_mem_alloc)

  float __r =
      __ocml_modf_f32(__x, (__attribute__((address_space(5))) float *)&__tmp);
  *__iptr = __tmp;
  return __r;
}

static inline __attribute__((always_inline, nothrow))
float nanf(const char *__tagp __attribute__((nonnull))) {
  union {
    float val;
    struct ieee_float {
      unsigned int mantissa : 22;
      unsigned int quiet : 1;
      unsigned int exponent : 8;
      unsigned int sign : 1;
    } bits;
  } __tmp;
  static_assert((sizeof(__tmp.val)) == (sizeof(__tmp.bits)), "");

  __tmp.bits.sign = 0u;
  __tmp.bits.exponent = ~0u;
  __tmp.bits.quiet = 1u;
  __tmp.bits.mantissa = __make_mantissa(__tagp);

  return __tmp.val;
}

static inline __attribute__((always_inline, nothrow))
float nearbyintf(float __x) { return __builtin_nearbyintf(__x); }

static inline __attribute__((always_inline, nothrow))
float nextafterf(float __x, float __y) {
  return __ocml_nextafter_f32(__x, __y);
}

static inline __attribute__((always_inline, nothrow))
float norm3df(float __x, float __y, float __z) {
  return __ocml_len3_f32(__x, __y, __z);
}

static inline __attribute__((always_inline, nothrow))
float norm4df(float __x, float __y, float __z, float __w) {
  return __ocml_len4_f32(__x, __y, __z, __w);
}

static inline __attribute__((always_inline, nothrow))
float normcdff(float __x) { return __ocml_ncdf_f32(__x); }

static inline __attribute__((always_inline, nothrow))
float normcdfinvf(float __x) { return __ocml_ncdfinv_f32(__x); }

static inline __attribute__((always_inline, nothrow))
float normf(int __dim,
            const float *__a) {
  float __r = 0;
  while (__dim--) {
    __r += __a[0] * __a[0];
    ++__a;
  }

  return __builtin_sqrtf(__r);
}

static inline __attribute__((always_inline, nothrow))
float powf(float __x, float __y) { return __ocml_pow_f32(__x, __y); }

static inline __attribute__((always_inline, nothrow))
float powif(float __x, int __y) { return __ocml_pown_f32(__x, __y); }

static inline __attribute__((always_inline, nothrow))
float rcbrtf(float __x) { return __ocml_rcbrt_f32(__x); }

static inline __attribute__((always_inline, nothrow))
float remainderf(float __x, float __y) {
  return __ocml_remainder_f32(__x, __y);
}

static inline __attribute__((always_inline, nothrow))
float remquof(float __x, float __y, int *__quo) {
  int __tmp;

#pragma omp allocate(__tmp) allocator(omp_thread_mem_alloc)

  float __r = __ocml_remquo_f32(
      __x, __y, (__attribute__((address_space(5))) int *)&__tmp);
  *__quo = __tmp;

  return __r;
}

static inline __attribute__((always_inline, nothrow))
float rhypotf(float __x, float __y) { return __ocml_rhypot_f32(__x, __y); }

static inline __attribute__((always_inline, nothrow))
float rintf(float __x) { return __builtin_rintf(__x); }

static inline __attribute__((always_inline, nothrow))
float rnorm3df(float __x, float __y, float __z) {
  return __ocml_rlen3_f32(__x, __y, __z);
}

static inline __attribute__((always_inline, nothrow))
float rnorm4df(float __x, float __y, float __z, float __w) {
  return __ocml_rlen4_f32(__x, __y, __z, __w);
}

static inline __attribute__((always_inline, nothrow))
float rnormf(int __dim,
             const float *__a) {
  float __r = 0;
  while (__dim--) {
    __r += __a[0] * __a[0];
    ++__a;
  }

  return __ocml_rsqrt_f32(__r);
}

static inline __attribute__((always_inline, nothrow))
float roundf(float __x) { return __builtin_roundf(__x); }

static inline __attribute__((always_inline, nothrow))
float rsqrtf(float __x) { return __ocml_rsqrt_f32(__x); }

static inline __attribute__((always_inline, nothrow))
float scalblnf(float __x, long int __n) {
  return (__n < 2147483647) ? __builtin_amdgcn_ldexpf(__x, __n)
                         : __ocml_scalb_f32(__x, __n);
}

static inline __attribute__((always_inline, nothrow))
float scalbnf(float __x, int __n) { return __builtin_amdgcn_ldexpf(__x, __n); }

static inline __attribute__((always_inline, nothrow))
int __signbitf(float __x) { return __builtin_signbitf(__x); }

static inline __attribute__((always_inline, nothrow))
void sincosf(float __x, float *__sinptr, float *__cosptr) {
  float __tmp;

#pragma omp allocate(__tmp) allocator(omp_thread_mem_alloc)




  *__sinptr =
      __ocml_sincos_f32(__x, (__attribute__((address_space(5))) float *)&__tmp);
  *__cosptr = __tmp;

}

static inline __attribute__((always_inline, nothrow))
void sincospif(float __x, float *__sinptr, float *__cosptr) {
  float __tmp;

#pragma omp allocate(__tmp) allocator(omp_thread_mem_alloc)

  *__sinptr = __ocml_sincospi_f32(
      __x, (__attribute__((address_space(5))) float *)&__tmp);
  *__cosptr = __tmp;
}

static inline __attribute__((always_inline, nothrow))
float sinf(float __x) { return __ocml_sin_f32(__x); }

static inline __attribute__((always_inline, nothrow))
float sinhf(float __x) { return __ocml_sinh_f32(__x); }

static inline __attribute__((always_inline, nothrow))
float sinpif(float __x) { return __ocml_sinpi_f32(__x); }

static inline __attribute__((always_inline, nothrow))
float sqrtf(float __x) { return __builtin_sqrtf(__x); }

static inline __attribute__((always_inline, nothrow))
float tanf(float __x) { return __ocml_tan_f32(__x); }

static inline __attribute__((always_inline, nothrow))
float tanhf(float __x) { return __ocml_tanh_f32(__x); }

static inline __attribute__((always_inline, nothrow))
float tgammaf(float __x) { return __ocml_tgamma_f32(__x); }

static inline __attribute__((always_inline, nothrow))
float truncf(float __x) { return __builtin_truncf(__x); }

static inline __attribute__((always_inline, nothrow))
float y0f(float __x) { return __ocml_y0_f32(__x); }

static inline __attribute__((always_inline, nothrow))
float y1f(float __x) { return __ocml_y1_f32(__x); }

static inline __attribute__((always_inline, nothrow))
float ynf(int __n, float __x) {




  if (__n == 0)
    return y0f(__x);
  if (__n == 1)
    return y1f(__x);

  float __x0 = y0f(__x);
  float __x1 = y1f(__x);
  for (int __i = 1; __i < __n; ++__i) {
    float __x2 = (2 * __i) / __x * __x1 - __x0;
    __x0 = __x1;
    __x1 = __x2;
  }

  return __x1;
}





static inline __attribute__((always_inline, nothrow))
double acos(double __x) { return __ocml_acos_f64(__x); }

static inline __attribute__((always_inline, nothrow))
double acosh(double __x) { return __ocml_acosh_f64(__x); }

static inline __attribute__((always_inline, nothrow))
double asin(double __x) { return __ocml_asin_f64(__x); }

static inline __attribute__((always_inline, nothrow))
double asinh(double __x) { return __ocml_asinh_f64(__x); }

static inline __attribute__((always_inline, nothrow))
double atan(double __x) { return __ocml_atan_f64(__x); }

static inline __attribute__((always_inline, nothrow))
double atan2(double __x, double __y) { return __ocml_atan2_f64(__x, __y); }

static inline __attribute__((always_inline, nothrow))
double atanh(double __x) { return __ocml_atanh_f64(__x); }

static inline __attribute__((always_inline, nothrow))
double cbrt(double __x) { return __ocml_cbrt_f64(__x); }

static inline __attribute__((always_inline, nothrow))
double ceil(double __x) { return __builtin_ceil(__x); }

static inline __attribute__((always_inline, nothrow))
double copysign(double __x, double __y) {
  return __builtin_copysign(__x, __y);
}

static inline __attribute__((always_inline, nothrow))
double cos(double __x) { return __ocml_cos_f64(__x); }

static inline __attribute__((always_inline, nothrow))
double cosh(double __x) { return __ocml_cosh_f64(__x); }

static inline __attribute__((always_inline, nothrow))
double cospi(double __x) { return __ocml_cospi_f64(__x); }

static inline __attribute__((always_inline, nothrow))
double cyl_bessel_i0(double __x) { return __ocml_i0_f64(__x); }

static inline __attribute__((always_inline, nothrow))
double cyl_bessel_i1(double __x) { return __ocml_i1_f64(__x); }

static inline __attribute__((always_inline, nothrow))
double erf(double __x) { return __ocml_erf_f64(__x); }

static inline __attribute__((always_inline, nothrow))
double erfc(double __x) { return __ocml_erfc_f64(__x); }

static inline __attribute__((always_inline, nothrow))
double erfcinv(double __x) { return __ocml_erfcinv_f64(__x); }

static inline __attribute__((always_inline, nothrow))
double erfcx(double __x) { return __ocml_erfcx_f64(__x); }

static inline __attribute__((always_inline, nothrow))
double erfinv(double __x) { return __ocml_erfinv_f64(__x); }

static inline __attribute__((always_inline, nothrow))
double exp(double __x) { return __ocml_exp_f64(__x); }

static inline __attribute__((always_inline, nothrow))
double exp10(double __x) { return __ocml_exp10_f64(__x); }

static inline __attribute__((always_inline, nothrow))
double exp2(double __x) { return __ocml_exp2_f64(__x); }

static inline __attribute__((always_inline, nothrow))
double expm1(double __x) { return __ocml_expm1_f64(__x); }

static inline __attribute__((always_inline, nothrow))
double fabs(double __x) { return __builtin_fabs(__x); }

static inline __attribute__((always_inline, nothrow))
double fdim(double __x, double __y) { return __ocml_fdim_f64(__x, __y); }

static inline __attribute__((always_inline, nothrow))
double floor(double __x) { return __builtin_floor(__x); }

static inline __attribute__((always_inline, nothrow))
double fma(double __x, double __y, double __z) {
  return __builtin_fma(__x, __y, __z);
}

static inline __attribute__((always_inline, nothrow))
double fmax(double __x, double __y) { return __builtin_fmax(__x, __y); }

static inline __attribute__((always_inline, nothrow))
double fmin(double __x, double __y) { return __builtin_fmin(__x, __y); }

static inline __attribute__((always_inline, nothrow))
double fmod(double __x, double __y) { return __ocml_fmod_f64(__x, __y); }

static inline __attribute__((always_inline, nothrow))
double frexp(double __x, int *__nptr) {
  return __builtin_frexp(__x, __nptr);
}

static inline __attribute__((always_inline, nothrow))
double hypot(double __x, double __y) { return __ocml_hypot_f64(__x, __y); }

static inline __attribute__((always_inline, nothrow))
int ilogb(double __x) { return __ocml_ilogb_f64(__x); }

static inline __attribute__((always_inline, nothrow))
int __finite(double __x) { return __builtin_isfinite(__x); }

static inline __attribute__((always_inline, nothrow))
int __isinf(double __x) { return __builtin_isinf(__x); }

static inline __attribute__((always_inline, nothrow))
int __isnan(double __x) { return __builtin_isnan(__x); }

static inline __attribute__((always_inline, nothrow))
double j0(double __x) { return __ocml_j0_f64(__x); }

static inline __attribute__((always_inline, nothrow))
double j1(double __x) { return __ocml_j1_f64(__x); }

static inline __attribute__((always_inline, nothrow))
double jn(int __n, double __x) {




  if (__n == 0)
    return j0(__x);
  if (__n == 1)
    return j1(__x);

  double __x0 = j0(__x);
  double __x1 = j1(__x);
  for (int __i = 1; __i < __n; ++__i) {
    double __x2 = (2 * __i) / __x * __x1 - __x0;
    __x0 = __x1;
    __x1 = __x2;
  }
  return __x1;
}

static inline __attribute__((always_inline, nothrow))
double ldexp(double __x, int __e) { return __builtin_amdgcn_ldexp(__x, __e); }

static inline __attribute__((always_inline, nothrow))
double lgamma(double __x) { return __ocml_lgamma_f64(__x); }

static inline __attribute__((always_inline, nothrow))
long long int llrint(double __x) { return __builtin_rint(__x); }

static inline __attribute__((always_inline, nothrow))
long long int llround(double __x) { return __builtin_round(__x); }

static inline __attribute__((always_inline, nothrow))
double log(double __x) { return __ocml_log_f64(__x); }

static inline __attribute__((always_inline, nothrow))
double log10(double __x) { return __ocml_log10_f64(__x); }

static inline __attribute__((always_inline, nothrow))
double log1p(double __x) { return __ocml_log1p_f64(__x); }

static inline __attribute__((always_inline, nothrow))
double log2(double __x) { return __ocml_log2_f64(__x); }

static inline __attribute__((always_inline, nothrow))
double logb(double __x) { return __ocml_logb_f64(__x); }

static inline __attribute__((always_inline, nothrow))
long int lrint(double __x) { return __builtin_rint(__x); }

static inline __attribute__((always_inline, nothrow))
long int lround(double __x) { return __builtin_round(__x); }

static inline __attribute__((always_inline, nothrow))
double modf(double __x, double *__iptr) {
  double __tmp;

#pragma omp allocate(__tmp) allocator(omp_thread_mem_alloc)

  double __r =
      __ocml_modf_f64(__x, (__attribute__((address_space(5))) double *)&__tmp);
  *__iptr = __tmp;

  return __r;
}

static inline __attribute__((always_inline, nothrow))
double nan(const char *__tagp) {

  union {
    double val;
    struct ieee_double {
      uint64_t mantissa : 51;
      uint32_t quiet : 1;
      uint32_t exponent : 11;
      uint32_t sign : 1;
    } bits;
  } __tmp;
  static_assert((sizeof(__tmp.val)) == (sizeof(__tmp.bits)), "");

  __tmp.bits.sign = 0u;
  __tmp.bits.exponent = ~0u;
  __tmp.bits.quiet = 1u;
  __tmp.bits.mantissa = __make_mantissa(__tagp);

  return __tmp.val;






}

static inline __attribute__((always_inline, nothrow))
double nearbyint(double __x) { return __builtin_nearbyint(__x); }

static inline __attribute__((always_inline, nothrow))
double nextafter(double __x, double __y) {
  return __ocml_nextafter_f64(__x, __y);
}

static inline __attribute__((always_inline, nothrow))
double norm(int __dim,
            const double *__a) {
  double __r = 0;
  while (__dim--) {
    __r += __a[0] * __a[0];
    ++__a;
  }

  return __builtin_sqrt(__r);
}

static inline __attribute__((always_inline, nothrow))
double norm3d(double __x, double __y, double __z) {
  return __ocml_len3_f64(__x, __y, __z);
}

static inline __attribute__((always_inline, nothrow))
double norm4d(double __x, double __y, double __z, double __w) {
  return __ocml_len4_f64(__x, __y, __z, __w);
}

static inline __attribute__((always_inline, nothrow))
double normcdf(double __x) { return __ocml_ncdf_f64(__x); }

static inline __attribute__((always_inline, nothrow))
double normcdfinv(double __x) { return __ocml_ncdfinv_f64(__x); }

static inline __attribute__((always_inline, nothrow))
double pow(double __x, double __y) { return __ocml_pow_f64(__x, __y); }

static inline __attribute__((always_inline, nothrow))
double powi(double __x, int __y) { return __ocml_pown_f64(__x, __y); }

static inline __attribute__((always_inline, nothrow))
double rcbrt(double __x) { return __ocml_rcbrt_f64(__x); }

static inline __attribute__((always_inline, nothrow))
double remainder(double __x, double __y) {
  return __ocml_remainder_f64(__x, __y);
}

static inline __attribute__((always_inline, nothrow))
double remquo(double __x, double __y, int *__quo) {
  int __tmp;

#pragma omp allocate(__tmp) allocator(omp_thread_mem_alloc)

  double __r = __ocml_remquo_f64(
      __x, __y, (__attribute__((address_space(5))) int *)&__tmp);
  *__quo = __tmp;

  return __r;
}

static inline __attribute__((always_inline, nothrow))
double rhypot(double __x, double __y) { return __ocml_rhypot_f64(__x, __y); }

static inline __attribute__((always_inline, nothrow))
double rint(double __x) { return __builtin_rint(__x); }

static inline __attribute__((always_inline, nothrow))
double rnorm(int __dim,
             const double *__a) {
  double __r = 0;
  while (__dim--) {
    __r += __a[0] * __a[0];
    ++__a;
  }

  return __ocml_rsqrt_f64(__r);
}

static inline __attribute__((always_inline, nothrow))
double rnorm3d(double __x, double __y, double __z) {
  return __ocml_rlen3_f64(__x, __y, __z);
}

static inline __attribute__((always_inline, nothrow))
double rnorm4d(double __x, double __y, double __z, double __w) {
  return __ocml_rlen4_f64(__x, __y, __z, __w);
}

static inline __attribute__((always_inline, nothrow))
double round(double __x) { return __builtin_round(__x); }

static inline __attribute__((always_inline, nothrow))
double rsqrt(double __x) { return __ocml_rsqrt_f64(__x); }

static inline __attribute__((always_inline, nothrow))
double scalbln(double __x, long int __n) {
  return (__n < 2147483647) ? __builtin_amdgcn_ldexp(__x, __n)
                         : __ocml_scalb_f64(__x, __n);
}
static inline __attribute__((always_inline, nothrow))
double scalbn(double __x, int __n) { return __builtin_amdgcn_ldexp(__x, __n); }

static inline __attribute__((always_inline, nothrow))
int __signbit(double __x) { return __builtin_signbit(__x); }

static inline __attribute__((always_inline, nothrow))
double sin(double __x) { return __ocml_sin_f64(__x); }

static inline __attribute__((always_inline, nothrow))
void sincos(double __x, double *__sinptr, double *__cosptr) {
  double __tmp;

#pragma omp allocate(__tmp) allocator(omp_thread_mem_alloc)

  *__sinptr = __ocml_sincos_f64(
      __x, (__attribute__((address_space(5))) double *)&__tmp);
  *__cosptr = __tmp;
}

static inline __attribute__((always_inline, nothrow))
void sincospi(double __x, double *__sinptr, double *__cosptr) {
  double __tmp;

#pragma omp allocate(__tmp) allocator(omp_thread_mem_alloc)

  *__sinptr = __ocml_sincospi_f64(
      __x, (__attribute__((address_space(5))) double *)&__tmp);
  *__cosptr = __tmp;
}

static inline __attribute__((always_inline, nothrow))
double sinh(double __x) { return __ocml_sinh_f64(__x); }

static inline __attribute__((always_inline, nothrow))
double sinpi(double __x) { return __ocml_sinpi_f64(__x); }

static inline __attribute__((always_inline, nothrow))
double sqrt(double __x) { return __builtin_sqrt(__x); }

static inline __attribute__((always_inline, nothrow))
double tan(double __x) { return __ocml_tan_f64(__x); }

static inline __attribute__((always_inline, nothrow))
double tanh(double __x) { return __ocml_tanh_f64(__x); }

static inline __attribute__((always_inline, nothrow))
double tgamma(double __x) { return __ocml_tgamma_f64(__x); }

static inline __attribute__((always_inline, nothrow))
double trunc(double __x) { return __builtin_trunc(__x); }

static inline __attribute__((always_inline, nothrow))
double y0(double __x) { return __ocml_y0_f64(__x); }

static inline __attribute__((always_inline, nothrow))
double y1(double __x) { return __ocml_y1_f64(__x); }

static inline __attribute__((always_inline, nothrow))
double yn(int __n, double __x) {




  if (__n == 0)
    return y0(__x);
  if (__n == 1)
    return y1(__x);

  double __x0 = y0(__x);
  double __x1 = y1(__x);
  for (int __i = 1; __i < __n; ++__i) {
    double __x2 = (2 * __i) / __x * __x1 - __x0;
    __x0 = __x1;
    __x1 = __x2;
  }

  return __x1;
}
# 1151 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/__clang_hip_math.h" 3
static inline __attribute__((always_inline, nothrow))
double __dadd_rn(double __x, double __y) { return __x + __y; }
# 1173 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/__clang_hip_math.h" 3
static inline __attribute__((always_inline, nothrow))
double __ddiv_rn(double __x, double __y) { return __x / __y; }
# 1195 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/__clang_hip_math.h" 3
static inline __attribute__((always_inline, nothrow))
double __dmul_rn(double __x, double __y) { return __x * __y; }
# 1209 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/__clang_hip_math.h" 3
static inline __attribute__((always_inline, nothrow))
double __drcp_rn(double __x) { return 1.0 / __x; }
# 1223 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/__clang_hip_math.h" 3
static inline __attribute__((always_inline, nothrow))
double __dsqrt_rn(double __x) { return __builtin_sqrt(__x); }
# 1245 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/__clang_hip_math.h" 3
static inline __attribute__((always_inline, nothrow))
double __dsub_rn(double __x, double __y) { return __x - __y; }
# 1267 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/__clang_hip_math.h" 3
static inline __attribute__((always_inline, nothrow))
double __fma_rn(double __x, double __y, double __z) {
  return __builtin_fma(__x, __y, __z);
}
# 1285 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/__clang_hip_math.h" 3
template <class T> static inline __attribute__((always_inline, nothrow)) T min(T __arg1, T __arg2) {
  return (__arg1 < __arg2) ? __arg1 : __arg2;
}

template <class T> static inline __attribute__((always_inline, nothrow)) T max(T __arg1, T __arg2) {
  return (__arg1 > __arg2) ? __arg1 : __arg2;
}

static inline __attribute__((always_inline, nothrow)) int min(int __arg1, int __arg2) {
  return (__arg1 < __arg2) ? __arg1 : __arg2;
}
static inline __attribute__((always_inline, nothrow)) int max(int __arg1, int __arg2) {
  return (__arg1 > __arg2) ? __arg1 : __arg2;
}

static inline __attribute__((always_inline, nothrow))
float max(float __x, float __y) { return __builtin_fmaxf(__x, __y); }

static inline __attribute__((always_inline, nothrow))
double max(double __x, double __y) { return __builtin_fmax(__x, __y); }

static inline __attribute__((always_inline, nothrow))
float min(float __x, float __y) { return __builtin_fminf(__x, __y); }

static inline __attribute__((always_inline, nothrow))
double min(double __x, double __y) { return __builtin_fmin(__x, __y); }
# 56 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/openmp_wrappers/math.h" 2 3


#pragma omp end declare variant
# 320 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/cmath" 2 3
# 331 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/cmath" 3



# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__undef_macros" 1 3
# 335 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/cmath" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

using ::signbit __attribute__((__using_if_exists__));
using ::fpclassify __attribute__((__using_if_exists__));
using ::isfinite __attribute__((__using_if_exists__));
using ::isinf __attribute__((__using_if_exists__));
using ::isnan __attribute__((__using_if_exists__));
using ::isnormal __attribute__((__using_if_exists__));
using ::isgreater __attribute__((__using_if_exists__));
using ::isgreaterequal __attribute__((__using_if_exists__));
using ::isless __attribute__((__using_if_exists__));
using ::islessequal __attribute__((__using_if_exists__));
using ::islessgreater __attribute__((__using_if_exists__));
using ::isunordered __attribute__((__using_if_exists__));
using ::isunordered __attribute__((__using_if_exists__));

using ::float_t __attribute__((__using_if_exists__));
using ::double_t __attribute__((__using_if_exists__));

using ::abs __attribute__((__using_if_exists__));

using ::acos __attribute__((__using_if_exists__));
using ::acosf __attribute__((__using_if_exists__));
using ::asin __attribute__((__using_if_exists__));
using ::asinf __attribute__((__using_if_exists__));
using ::atan __attribute__((__using_if_exists__));
using ::atanf __attribute__((__using_if_exists__));
using ::atan2 __attribute__((__using_if_exists__));
using ::atan2f __attribute__((__using_if_exists__));
using ::ceil __attribute__((__using_if_exists__));
using ::ceilf __attribute__((__using_if_exists__));
using ::cos __attribute__((__using_if_exists__));
using ::cosf __attribute__((__using_if_exists__));
using ::cosh __attribute__((__using_if_exists__));
using ::coshf __attribute__((__using_if_exists__));

using ::exp __attribute__((__using_if_exists__));
using ::expf __attribute__((__using_if_exists__));

using ::fabs __attribute__((__using_if_exists__));
using ::fabsf __attribute__((__using_if_exists__));
using ::floor __attribute__((__using_if_exists__));
using ::floorf __attribute__((__using_if_exists__));

using ::fmod __attribute__((__using_if_exists__));
using ::fmodf __attribute__((__using_if_exists__));

using ::frexp __attribute__((__using_if_exists__));
using ::frexpf __attribute__((__using_if_exists__));
using ::ldexp __attribute__((__using_if_exists__));
using ::ldexpf __attribute__((__using_if_exists__));

using ::log __attribute__((__using_if_exists__));
using ::logf __attribute__((__using_if_exists__));

using ::log10 __attribute__((__using_if_exists__));
using ::log10f __attribute__((__using_if_exists__));
using ::modf __attribute__((__using_if_exists__));
using ::modff __attribute__((__using_if_exists__));

using ::pow __attribute__((__using_if_exists__));
using ::powf __attribute__((__using_if_exists__));

using ::sin __attribute__((__using_if_exists__));
using ::sinf __attribute__((__using_if_exists__));
using ::sinh __attribute__((__using_if_exists__));
using ::sinhf __attribute__((__using_if_exists__));

using ::sqrt __attribute__((__using_if_exists__));
using ::sqrtf __attribute__((__using_if_exists__));
using ::tan __attribute__((__using_if_exists__));
using ::tanf __attribute__((__using_if_exists__));

using ::tanh __attribute__((__using_if_exists__));
using ::tanhf __attribute__((__using_if_exists__));

using ::acosh __attribute__((__using_if_exists__));
using ::acoshf __attribute__((__using_if_exists__));
using ::asinh __attribute__((__using_if_exists__));
using ::asinhf __attribute__((__using_if_exists__));
using ::atanh __attribute__((__using_if_exists__));
using ::atanhf __attribute__((__using_if_exists__));
using ::cbrt __attribute__((__using_if_exists__));
using ::cbrtf __attribute__((__using_if_exists__));

using ::copysign __attribute__((__using_if_exists__));
using ::copysignf __attribute__((__using_if_exists__));

using ::erf __attribute__((__using_if_exists__));
using ::erff __attribute__((__using_if_exists__));
using ::erfc __attribute__((__using_if_exists__));
using ::erfcf __attribute__((__using_if_exists__));
using ::exp2 __attribute__((__using_if_exists__));
using ::exp2f __attribute__((__using_if_exists__));
using ::expm1 __attribute__((__using_if_exists__));
using ::expm1f __attribute__((__using_if_exists__));
using ::fdim __attribute__((__using_if_exists__));
using ::fdimf __attribute__((__using_if_exists__));
using ::fmaf __attribute__((__using_if_exists__));
using ::fma __attribute__((__using_if_exists__));
using ::fmax __attribute__((__using_if_exists__));
using ::fmaxf __attribute__((__using_if_exists__));
using ::fmin __attribute__((__using_if_exists__));
using ::fminf __attribute__((__using_if_exists__));
using ::hypot __attribute__((__using_if_exists__));
using ::hypotf __attribute__((__using_if_exists__));
using ::ilogb __attribute__((__using_if_exists__));
using ::ilogbf __attribute__((__using_if_exists__));
using ::lgamma __attribute__((__using_if_exists__));
using ::lgammaf __attribute__((__using_if_exists__));
using ::llrint __attribute__((__using_if_exists__));
using ::llrintf __attribute__((__using_if_exists__));
using ::llround __attribute__((__using_if_exists__));
using ::llroundf __attribute__((__using_if_exists__));
using ::log1p __attribute__((__using_if_exists__));
using ::log1pf __attribute__((__using_if_exists__));
using ::log2 __attribute__((__using_if_exists__));
using ::log2f __attribute__((__using_if_exists__));
using ::logb __attribute__((__using_if_exists__));
using ::logbf __attribute__((__using_if_exists__));
using ::lrint __attribute__((__using_if_exists__));
using ::lrintf __attribute__((__using_if_exists__));
using ::lround __attribute__((__using_if_exists__));
using ::lroundf __attribute__((__using_if_exists__));

using ::nan __attribute__((__using_if_exists__));
using ::nanf __attribute__((__using_if_exists__));

using ::nearbyint __attribute__((__using_if_exists__));
using ::nearbyintf __attribute__((__using_if_exists__));
using ::nextafter __attribute__((__using_if_exists__));
using ::nextafterf __attribute__((__using_if_exists__));
using ::nexttoward __attribute__((__using_if_exists__));
using ::nexttowardf __attribute__((__using_if_exists__));
using ::remainder __attribute__((__using_if_exists__));
using ::remainderf __attribute__((__using_if_exists__));
using ::remquo __attribute__((__using_if_exists__));
using ::remquof __attribute__((__using_if_exists__));
using ::rint __attribute__((__using_if_exists__));
using ::rintf __attribute__((__using_if_exists__));
using ::round __attribute__((__using_if_exists__));
using ::roundf __attribute__((__using_if_exists__));
using ::scalbln __attribute__((__using_if_exists__));
using ::scalblnf __attribute__((__using_if_exists__));
using ::scalbn __attribute__((__using_if_exists__));
using ::scalbnf __attribute__((__using_if_exists__));
using ::tgamma __attribute__((__using_if_exists__));
using ::tgammaf __attribute__((__using_if_exists__));
using ::trunc __attribute__((__using_if_exists__));
using ::truncf __attribute__((__using_if_exists__));

using ::acosl __attribute__((__using_if_exists__));
using ::asinl __attribute__((__using_if_exists__));
using ::atanl __attribute__((__using_if_exists__));
using ::atan2l __attribute__((__using_if_exists__));
using ::ceill __attribute__((__using_if_exists__));
using ::cosl __attribute__((__using_if_exists__));
using ::coshl __attribute__((__using_if_exists__));
using ::expl __attribute__((__using_if_exists__));
using ::fabsl __attribute__((__using_if_exists__));
using ::floorl __attribute__((__using_if_exists__));
using ::fmodl __attribute__((__using_if_exists__));
using ::frexpl __attribute__((__using_if_exists__));
using ::ldexpl __attribute__((__using_if_exists__));
using ::logl __attribute__((__using_if_exists__));
using ::log10l __attribute__((__using_if_exists__));
using ::modfl __attribute__((__using_if_exists__));
using ::powl __attribute__((__using_if_exists__));
using ::sinl __attribute__((__using_if_exists__));
using ::sinhl __attribute__((__using_if_exists__));
using ::sqrtl __attribute__((__using_if_exists__));
using ::tanl __attribute__((__using_if_exists__));

using ::tanhl __attribute__((__using_if_exists__));
using ::acoshl __attribute__((__using_if_exists__));
using ::asinhl __attribute__((__using_if_exists__));
using ::atanhl __attribute__((__using_if_exists__));
using ::cbrtl __attribute__((__using_if_exists__));

using ::copysignl __attribute__((__using_if_exists__));

using ::erfl __attribute__((__using_if_exists__));
using ::erfcl __attribute__((__using_if_exists__));
using ::exp2l __attribute__((__using_if_exists__));
using ::expm1l __attribute__((__using_if_exists__));
using ::fdiml __attribute__((__using_if_exists__));
using ::fmal __attribute__((__using_if_exists__));
using ::fmaxl __attribute__((__using_if_exists__));
using ::fminl __attribute__((__using_if_exists__));
using ::hypotl __attribute__((__using_if_exists__));
using ::ilogbl __attribute__((__using_if_exists__));
using ::lgammal __attribute__((__using_if_exists__));
using ::llrintl __attribute__((__using_if_exists__));
using ::llroundl __attribute__((__using_if_exists__));
using ::log1pl __attribute__((__using_if_exists__));
using ::log2l __attribute__((__using_if_exists__));
using ::logbl __attribute__((__using_if_exists__));
using ::lrintl __attribute__((__using_if_exists__));
using ::lroundl __attribute__((__using_if_exists__));
using ::nanl __attribute__((__using_if_exists__));
using ::nearbyintl __attribute__((__using_if_exists__));
using ::nextafterl __attribute__((__using_if_exists__));
using ::nexttowardl __attribute__((__using_if_exists__));
using ::remainderl __attribute__((__using_if_exists__));
using ::remquol __attribute__((__using_if_exists__));
using ::rintl __attribute__((__using_if_exists__));
using ::roundl __attribute__((__using_if_exists__));
using ::scalblnl __attribute__((__using_if_exists__));
using ::scalbnl __attribute__((__using_if_exists__));
using ::tgammal __attribute__((__using_if_exists__));
using ::truncl __attribute__((__using_if_exists__));


inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) float hypot( float __x, float __y, float __z ) { return sqrt(__x*__x + __y*__y + __z*__z); }
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) double hypot( double __x, double __y, double __z ) { return sqrt(__x*__x + __y*__y + __z*__z); }
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) long double hypot( long double __x, long double __y, long double __z ) { return sqrt(__x*__x + __y*__y + __z*__z); }

template <class _A1, class _A2, class _A3>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
typename enable_if_t
<
    is_arithmetic<_A1>::value &&
    is_arithmetic<_A2>::value &&
    is_arithmetic<_A3>::value,
    __promote<_A1, _A2, _A3>
>::type
hypot(_A1 __lcpp_x, _A2 __lcpp_y, _A3 __lcpp_z) noexcept
{
    typedef typename __promote<_A1, _A2, _A3>::type __result_type;
    static_assert((!(is_same<_A1, __result_type>::value &&
                     is_same<_A2, __result_type>::value &&
                     is_same<_A3, __result_type>::value)), "");
    return std::hypot((__result_type)__lcpp_x, (__result_type)__lcpp_y, (__result_type)__lcpp_z);
}


template <class _A1, __enable_if_t<is_floating_point<_A1>::value, int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
constexpr bool
__constexpr_isnan(_A1 __lcpp_x) noexcept
{

    return __builtin_isnan(__lcpp_x);



}

template <class _A1, __enable_if_t<!is_floating_point<_A1>::value, int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
constexpr bool
__constexpr_isnan(_A1 __lcpp_x) noexcept
{
    return std::isnan(__lcpp_x);
}

template <class _A1, __enable_if_t<is_floating_point<_A1>::value, int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
constexpr bool
__constexpr_isinf(_A1 __lcpp_x) noexcept
{

    return __builtin_isinf(__lcpp_x);



}

template <class _A1, __enable_if_t<!is_floating_point<_A1>::value, int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
constexpr bool
__constexpr_isinf(_A1 __lcpp_x) noexcept
{
    return std::isinf(__lcpp_x);
}

template <class _A1, __enable_if_t<is_floating_point<_A1>::value, int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
constexpr bool
__constexpr_isfinite(_A1 __lcpp_x) noexcept
{

    return __builtin_isfinite(__lcpp_x);



}

template <class _A1, __enable_if_t<!is_floating_point<_A1>::value, int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
constexpr bool
__constexpr_isfinite(_A1 __lcpp_x) noexcept
{
    return __builtin_isfinite(__lcpp_x);
}

constexpr inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) float __constexpr_copysign(float __x, float __y) noexcept {
    return __builtin_copysignf(__x, __y);
}

constexpr inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) double __constexpr_copysign(double __x, double __y) noexcept {
    return __builtin_copysign(__x, __y);
}

constexpr inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) long double
__constexpr_copysign(long double __x, long double __y) noexcept {
    return __builtin_copysignl(__x, __y);
}

template <class _A1, class _A2, __enable_if_t<std::is_arithmetic<_A1>::value && std::is_arithmetic<_A2>::value, int> = 0>
constexpr inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    typename __promote<_A1, _A2>::type
    __constexpr_copysign(_A1 __x, _A2 __y) noexcept {
    typedef typename std::__promote<_A1, _A2>::type __result_type;
    static_assert((!(std::_IsSame<_A1, __result_type>::value && std::_IsSame<_A2, __result_type>::value)), "");
    return __builtin_copysign((__result_type)__x, (__result_type)__y);
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr float __constexpr_fabs(float __x) noexcept {
    return __builtin_fabsf(__x);
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr double __constexpr_fabs(double __x) noexcept {
    return __builtin_fabs(__x);
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr long double __constexpr_fabs(long double __x) noexcept {
    return __builtin_fabsl(__x);
}

template <class _Tp, __enable_if_t<is_integral<_Tp>::value, int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr double __constexpr_fabs(_Tp __x) noexcept {
    return __builtin_fabs(static_cast<double>(__x));
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr float __constexpr_fmax(float __x, float __y) noexcept {
# 681 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/cmath" 3
  return __builtin_fmaxf(__x, __y);
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr double __constexpr_fmax(double __x, double __y) noexcept {
# 694 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/cmath" 3
  return __builtin_fmax(__x, __y);
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr long double
__constexpr_fmax(long double __x, long double __y) noexcept {
# 708 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/cmath" 3
  return __builtin_fmaxl(__x, __y);
}

template <class _Tp, class _Up, __enable_if_t<is_arithmetic<_Tp>::value && is_arithmetic<_Up>::value, int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr typename __promote<_Tp, _Up>::type
__constexpr_fmax(_Tp __x, _Up __y) noexcept {
  using __result_type = typename __promote<_Tp, _Up>::type;
  return std::__constexpr_fmax(static_cast<__result_type>(__x), static_cast<__result_type>(__y));
}

template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr _Tp __constexpr_logb(_Tp __x) {

  if (__libcpp_is_constant_evaluated()) {
    if (__x == _Tp(0)) {

      return -numeric_limits<_Tp>::infinity();
    }

    if (std::__constexpr_isinf(__x))
      return numeric_limits<_Tp>::infinity();

    if (std::__constexpr_isnan(__x))
      return numeric_limits<_Tp>::quiet_NaN();

    __x = std::__constexpr_fabs(__x);
    unsigned long long __exp = 0;
    while (__x >= numeric_limits<_Tp>::radix) {
      __x /= numeric_limits<_Tp>::radix;
      __exp += 1;
    }
    return _Tp(__exp);
  }

  return __builtin_logb(__x);
}

template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr _Tp __constexpr_scalbn(_Tp __x, int __exp) {

  if (__libcpp_is_constant_evaluated()) {
    if (__x == _Tp(0))
      return __x;

    if (std::__constexpr_isinf(__x))
      return __x;

    if (__exp == _Tp(0))
      return __x;

    if (std::__constexpr_isnan(__x))
      return numeric_limits<_Tp>::quiet_NaN();

    _Tp __mult(1);
    if (__exp > 0) {
      __mult = numeric_limits<_Tp>::radix;
      --__exp;
    } else {
      ++__exp;
      __exp = -__exp;
      __mult /= numeric_limits<_Tp>::radix;
    }

    while (__exp > 0) {
      if (!(__exp & 1)) {
        __mult *= __mult;
        __exp >>= 1;
      } else {
        __x *= __mult;
        --__exp;
      }
    }
    return __x;
  }

  return __builtin_scalbn(__x, __exp);
}


template <typename _Fp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
_Fp __lerp(_Fp __a, _Fp __b, _Fp __t) noexcept {
    if ((__a <= 0 && __b >= 0) || (__a >= 0 && __b <= 0))
        return __t * __b + (1 - __t) * __a;

    if (__t == 1) return __b;
    const _Fp __x = __a + __t * (__b - __a);
    if ((__t > 1) == (__b > __a))
        return __b < __x ? __x : __b;
    else
        return __x < __b ? __x : __b;
}

__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr float
lerp(float __a, float __b, float __t) noexcept { return __lerp(__a, __b, __t); }

__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr double
lerp(double __a, double __b, double __t) noexcept { return __lerp(__a, __b, __t); }

__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr long double
lerp(long double __a, long double __b, long double __t) noexcept { return __lerp(__a, __b, __t); }

template <class _A1, class _A2, class _A3>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
constexpr typename enable_if_t
<
    is_arithmetic<_A1>::value &&
    is_arithmetic<_A2>::value &&
    is_arithmetic<_A3>::value,
    __promote<_A1, _A2, _A3>
>::type
lerp(_A1 __a, _A2 __b, _A3 __t) noexcept
{
    typedef typename __promote<_A1, _A2, _A3>::type __result_type;
    static_assert(!(_IsSame<_A1, __result_type>::value &&
                    _IsSame<_A2, __result_type>::value &&
                    _IsSame<_A3, __result_type>::value));
    return std::__lerp((__result_type)__a, (__result_type)__b, (__result_type)__t);
}


}}
# 18 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/openmp_wrappers/cmath" 2 3



# 1 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/openmp_wrappers/math.h" 1 3
# 20 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/openmp_wrappers/math.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/openmp_wrappers/cmath" 1 3
# 21 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/openmp_wrappers/math.h" 2 3
# 22 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/openmp_wrappers/cmath" 2 3








#pragma omp begin declare variant match( device = {arch(nvptx, nvptx64)}, implementation = {extension(match_any, allow_templates)})




# 1 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/__clang_cuda_cmath.h" 1 3
# 41 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/__clang_cuda_cmath.h" 3
static constexpr __attribute__((always_inline, nothrow)) long long abs(long long __n) { return ::llabs(__n); }
static constexpr __attribute__((always_inline, nothrow)) long abs(long __n) { return ::labs(__n); }
static constexpr __attribute__((always_inline, nothrow)) float abs(float __x) { return ::fabsf(__x); }
static constexpr __attribute__((always_inline, nothrow)) double abs(double __x) { return ::fabs(__x); }
static constexpr __attribute__((always_inline, nothrow)) float acos(float __x) { return ::acosf(__x); }
static constexpr __attribute__((always_inline, nothrow)) float asin(float __x) { return ::asinf(__x); }
static constexpr __attribute__((always_inline, nothrow)) float atan(float __x) { return ::atanf(__x); }
static constexpr __attribute__((always_inline, nothrow)) float atan2(float __x, float __y) { return ::atan2f(__x, __y); }
static constexpr __attribute__((always_inline, nothrow)) float ceil(float __x) { return ::ceilf(__x); }
static constexpr __attribute__((always_inline, nothrow)) float cos(float __x) { return ::cosf(__x); }
static constexpr __attribute__((always_inline, nothrow)) float cosh(float __x) { return ::coshf(__x); }
static constexpr __attribute__((always_inline, nothrow)) float exp(float __x) { return ::expf(__x); }
static constexpr __attribute__((always_inline, nothrow)) float fabs(float __x) { return ::fabsf(__x); }
static constexpr __attribute__((always_inline, nothrow)) float floor(float __x) { return ::floorf(__x); }
static constexpr __attribute__((always_inline, nothrow)) float fmod(float __x, float __y) { return ::fmodf(__x, __y); }
static constexpr __attribute__((always_inline, nothrow)) int fpclassify(float __x) {
  return __builtin_fpclassify(0, 1, 4, 3,
                              2, __x);
}
static constexpr __attribute__((always_inline, nothrow)) int fpclassify(double __x) {
  return __builtin_fpclassify(0, 1, 4, 3,
                              2, __x);
}
static constexpr __attribute__((always_inline, nothrow)) float frexp(float __arg, int *__exp) {
  return ::frexpf(__arg, __exp);
}
# 79 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/__clang_cuda_cmath.h" 3
#pragma omp begin declare variant match( implementation = {extension(disable_implicit_base)})








#pragma omp begin declare variant match(implementation = {vendor(llvm)})

static constexpr __attribute__((always_inline, nothrow)) int isinf(float __x) { return ::__isinff(__x); }
static constexpr __attribute__((always_inline, nothrow)) int isinf(double __x) { return ::__isinf(__x); }
static constexpr __attribute__((always_inline, nothrow)) int isfinite(float __x) { return ::__finitef(__x); }
static constexpr __attribute__((always_inline, nothrow)) int isfinite(double __x) { return ::__isfinited(__x); }
static constexpr __attribute__((always_inline, nothrow)) int isnan(float __x) { return ::__isnanf(__x); }
static constexpr __attribute__((always_inline, nothrow)) int isnan(double __x) { return ::__isnan(__x); }

#pragma omp end declare variant



static constexpr __attribute__((always_inline, nothrow)) bool isinf(float __x) { return ::__isinff(__x); }
static constexpr __attribute__((always_inline, nothrow)) bool isinf(double __x) { return ::__isinf(__x); }
static constexpr __attribute__((always_inline, nothrow)) bool isfinite(float __x) { return ::__finitef(__x); }



static constexpr __attribute__((always_inline, nothrow)) bool isfinite(double __x) { return ::__isfinited(__x); }
static constexpr __attribute__((always_inline, nothrow)) bool isnan(float __x) { return ::__isnanf(__x); }
static constexpr __attribute__((always_inline, nothrow)) bool isnan(double __x) { return ::__isnan(__x); }


#pragma omp end declare variant




static constexpr __attribute__((always_inline, nothrow)) bool isgreater(float __x, float __y) {
  return __builtin_isgreater(__x, __y);
}
static constexpr __attribute__((always_inline, nothrow)) bool isgreater(double __x, double __y) {
  return __builtin_isgreater(__x, __y);
}
static constexpr __attribute__((always_inline, nothrow)) bool isgreaterequal(float __x, float __y) {
  return __builtin_isgreaterequal(__x, __y);
}
static constexpr __attribute__((always_inline, nothrow)) bool isgreaterequal(double __x, double __y) {
  return __builtin_isgreaterequal(__x, __y);
}
static constexpr __attribute__((always_inline, nothrow)) bool isless(float __x, float __y) {
  return __builtin_isless(__x, __y);
}
static constexpr __attribute__((always_inline, nothrow)) bool isless(double __x, double __y) {
  return __builtin_isless(__x, __y);
}
static constexpr __attribute__((always_inline, nothrow)) bool islessequal(float __x, float __y) {
  return __builtin_islessequal(__x, __y);
}
static constexpr __attribute__((always_inline, nothrow)) bool islessequal(double __x, double __y) {
  return __builtin_islessequal(__x, __y);
}
static constexpr __attribute__((always_inline, nothrow)) bool islessgreater(float __x, float __y) {
  return __builtin_islessgreater(__x, __y);
}
static constexpr __attribute__((always_inline, nothrow)) bool islessgreater(double __x, double __y) {
  return __builtin_islessgreater(__x, __y);
}
static constexpr __attribute__((always_inline, nothrow)) bool isnormal(float __x) { return __builtin_isnormal(__x); }
static constexpr __attribute__((always_inline, nothrow)) bool isnormal(double __x) { return __builtin_isnormal(__x); }
static constexpr __attribute__((always_inline, nothrow)) bool isunordered(float __x, float __y) {
  return __builtin_isunordered(__x, __y);
}
static constexpr __attribute__((always_inline, nothrow)) bool isunordered(double __x, double __y) {
  return __builtin_isunordered(__x, __y);
}
static constexpr __attribute__((always_inline, nothrow)) float ldexp(float __arg, int __exp) {
  return ::ldexpf(__arg, __exp);
}
static constexpr __attribute__((always_inline, nothrow)) float log(float __x) { return ::logf(__x); }
static constexpr __attribute__((always_inline, nothrow)) float log10(float __x) { return ::log10f(__x); }
static constexpr __attribute__((always_inline, nothrow)) float modf(float __x, float *__iptr) { return ::modff(__x, __iptr); }
static constexpr __attribute__((always_inline, nothrow)) float pow(float __base, float __exp) {
  return ::powf(__base, __exp);
}
static constexpr __attribute__((always_inline, nothrow)) float pow(float __base, int __iexp) {
  return ::powif(__base, __iexp);
}
static constexpr __attribute__((always_inline, nothrow)) double pow(double __base, int __iexp) {
  return ::powi(__base, __iexp);
}
static constexpr __attribute__((always_inline, nothrow)) bool signbit(float __x) { return ::__signbitf(__x); }
static constexpr __attribute__((always_inline, nothrow)) bool signbit(double __x) { return ::__signbitd(__x); }
static constexpr __attribute__((always_inline, nothrow)) float sin(float __x) { return ::sinf(__x); }
static constexpr __attribute__((always_inline, nothrow)) float sinh(float __x) { return ::sinhf(__x); }
static constexpr __attribute__((always_inline, nothrow)) float sqrt(float __x) { return ::sqrtf(__x); }
static constexpr __attribute__((always_inline, nothrow)) float tan(float __x) { return ::tanf(__x); }
static constexpr __attribute__((always_inline, nothrow)) float tanh(float __x) { return ::tanhf(__x); }





static constexpr __attribute__((always_inline, nothrow)) float remquo(float __n, float __d, int *__q) {
  return ::remquof(__n, __d, __q);
}
# 36 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/openmp_wrappers/cmath" 2 3







static constexpr __attribute__((always_inline, nothrow)) float acosh(float __x) { return ::acoshf(__x); }
static constexpr __attribute__((always_inline, nothrow)) float asinh(float __x) { return ::asinhf(__x); }
static constexpr __attribute__((always_inline, nothrow)) float atanh(float __x) { return ::atanhf(__x); }
static constexpr __attribute__((always_inline, nothrow)) float cbrt(float __x) { return ::cbrtf(__x); }
static constexpr __attribute__((always_inline, nothrow)) float erf(float __x) { return ::erff(__x); }
static constexpr __attribute__((always_inline, nothrow)) float erfc(float __x) { return ::erfcf(__x); }
static constexpr __attribute__((always_inline, nothrow)) float exp2(float __x) { return ::exp2f(__x); }
static constexpr __attribute__((always_inline, nothrow)) float expm1(float __x) { return ::expm1f(__x); }
static constexpr __attribute__((always_inline, nothrow)) float fdim(float __x, float __y) { return ::fdimf(__x, __y); }
static constexpr __attribute__((always_inline, nothrow)) float hypot(float __x, float __y) { return ::hypotf(__x, __y); }
static constexpr __attribute__((always_inline, nothrow)) int ilogb(float __x) { return ::ilogbf(__x); }
static constexpr __attribute__((always_inline, nothrow)) float lgamma(float __x) { return ::lgammaf(__x); }
static constexpr __attribute__((always_inline, nothrow)) long long int llrint(float __x) { return ::llrintf(__x); }
static constexpr __attribute__((always_inline, nothrow)) long long int llround(float __x) { return ::llroundf(__x); }
static constexpr __attribute__((always_inline, nothrow)) float log1p(float __x) { return ::log1pf(__x); }
static constexpr __attribute__((always_inline, nothrow)) float log2(float __x) { return ::log2f(__x); }
static constexpr __attribute__((always_inline, nothrow)) float logb(float __x) { return ::logbf(__x); }
static constexpr __attribute__((always_inline, nothrow)) long int lrint(float __x) { return ::lrintf(__x); }
static constexpr __attribute__((always_inline, nothrow)) long int lround(float __x) { return ::lroundf(__x); }
static constexpr __attribute__((always_inline, nothrow)) float nextafter(float __x, float __y) {
  return ::nextafterf(__x, __y);
}
static constexpr __attribute__((always_inline, nothrow)) float remainder(float __x, float __y) {
  return ::remainderf(__x, __y);
}
static constexpr __attribute__((always_inline, nothrow)) float scalbln(float __x, long int __y) {
  return ::scalblnf(__x, __y);
}
static constexpr __attribute__((always_inline, nothrow)) float scalbn(float __x, int __y) { return ::scalbnf(__x, __y); }
static constexpr __attribute__((always_inline, nothrow)) float tgamma(float __x) { return ::tgammaf(__x); }



#pragma omp end declare variant


#pragma omp begin declare variant match(device = {arch(amdgcn)})





# 1 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/__clang_hip_cmath.h" 1 3
# 20 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/__clang_hip_cmath.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/type_traits" 1 3
# 428 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/type_traits" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/aligned_storage.h" 1 3
# 21 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/aligned_storage.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Tp>
struct __align_type {
  static const size_t value = __alignof(_Tp);
  typedef _Tp type;
};

struct __struct_double {
  long double __lx;
};
struct __struct_double4 {
  double __lx[4];
};


typedef __type_list<__align_type<unsigned char>,
        __type_list<__align_type<unsigned short>,
        __type_list<__align_type<unsigned int>,
        __type_list<__align_type<unsigned long>,
        __type_list<__align_type<unsigned long long>,
        __type_list<__align_type<double>,
        __type_list<__align_type<long double>,
        __type_list<__align_type<__struct_double>,
        __type_list<__align_type<__struct_double4>,
        __type_list<__align_type<int*>,
        __nat
        > > > > > > > > > > __all_types;


template <size_t _Align>
struct alignas(_Align) __fallback_overaligned {};

template <class _TL, size_t _Align>
struct __find_pod;

template <class _Hp, size_t _Align>
struct __find_pod<__type_list<_Hp, __nat>, _Align> {
  typedef __conditional_t<_Align == _Hp::value, typename _Hp::type, __fallback_overaligned<_Align> > type;
};

template <class _Hp, class _Tp, size_t _Align>
struct __find_pod<__type_list<_Hp, _Tp>, _Align> {
  typedef __conditional_t<_Align == _Hp::value, typename _Hp::type, typename __find_pod<_Tp, _Align>::type> type;
};

template <class _TL, size_t _Len>
struct __find_max_align;

template <class _Hp, size_t _Len>
struct __find_max_align<__type_list<_Hp, __nat>, _Len> : public integral_constant<size_t, _Hp::value> {};

template <size_t _Len, size_t _A1, size_t _A2>
struct __select_align {
private:
  static const size_t __min = _A2 < _A1 ? _A2 : _A1;
  static const size_t __max = _A1 < _A2 ? _A2 : _A1;

public:
  static const size_t value = _Len < __max ? __min : __max;
};

template <class _Hp, class _Tp, size_t _Len>
struct __find_max_align<__type_list<_Hp, _Tp>, _Len>
    : public integral_constant<size_t, __select_align<_Len, _Hp::value, __find_max_align<_Tp, _Len>::value>::value> {};

template <size_t _Len, size_t _Align = __find_max_align<__all_types, _Len>::value>
struct __attribute__((__deprecated__)) aligned_storage {
  typedef typename __find_pod<__all_types, _Align>::type _Aligner;
  union type {
    _Aligner __align;
    unsigned char __data[(_Len + _Align - 1) / _Align * _Align];
  };
};



#pragma GCC diagnostic push
# 100 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/aligned_storage.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
# 100 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/aligned_storage.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
template <size_t _Len, size_t _Align = __find_max_align<__all_types, _Len>::value>
using aligned_storage_t __attribute__((__deprecated__)) = typename aligned_storage<_Len, _Align>::type;
#pragma GCC diagnostic pop
# 115 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/aligned_storage.h" 3
template <size_t _Len> struct __attribute__((__deprecated__)) aligned_storage<_Len, 0x1> { struct alignas(0x1) type { unsigned char __lx[(_Len + 0x1 - 1) / 0x1 * 0x1]; }; };
template <size_t _Len> struct __attribute__((__deprecated__)) aligned_storage<_Len, 0x2> { struct alignas(0x2) type { unsigned char __lx[(_Len + 0x2 - 1) / 0x2 * 0x2]; }; };
template <size_t _Len> struct __attribute__((__deprecated__)) aligned_storage<_Len, 0x4> { struct alignas(0x4) type { unsigned char __lx[(_Len + 0x4 - 1) / 0x4 * 0x4]; }; };
template <size_t _Len> struct __attribute__((__deprecated__)) aligned_storage<_Len, 0x8> { struct alignas(0x8) type { unsigned char __lx[(_Len + 0x8 - 1) / 0x8 * 0x8]; }; };
template <size_t _Len> struct __attribute__((__deprecated__)) aligned_storage<_Len, 0x10> { struct alignas(0x10) type { unsigned char __lx[(_Len + 0x10 - 1) / 0x10 * 0x10]; }; };
template <size_t _Len> struct __attribute__((__deprecated__)) aligned_storage<_Len, 0x20> { struct alignas(0x20) type { unsigned char __lx[(_Len + 0x20 - 1) / 0x20 * 0x20]; }; };
template <size_t _Len> struct __attribute__((__deprecated__)) aligned_storage<_Len, 0x40> { struct alignas(0x40) type { unsigned char __lx[(_Len + 0x40 - 1) / 0x40 * 0x40]; }; };
template <size_t _Len> struct __attribute__((__deprecated__)) aligned_storage<_Len, 0x80> { struct alignas(0x80) type { unsigned char __lx[(_Len + 0x80 - 1) / 0x80 * 0x80]; }; };
template <size_t _Len> struct __attribute__((__deprecated__)) aligned_storage<_Len, 0x100> { struct alignas(0x100) type { unsigned char __lx[(_Len + 0x100 - 1) / 0x100 * 0x100]; }; };
template <size_t _Len> struct __attribute__((__deprecated__)) aligned_storage<_Len, 0x200> { struct alignas(0x200) type { unsigned char __lx[(_Len + 0x200 - 1) / 0x200 * 0x200]; }; };
template <size_t _Len> struct __attribute__((__deprecated__)) aligned_storage<_Len, 0x400> { struct alignas(0x400) type { unsigned char __lx[(_Len + 0x400 - 1) / 0x400 * 0x400]; }; };
template <size_t _Len> struct __attribute__((__deprecated__)) aligned_storage<_Len, 0x800> { struct alignas(0x800) type { unsigned char __lx[(_Len + 0x800 - 1) / 0x800 * 0x800]; }; };
template <size_t _Len> struct __attribute__((__deprecated__)) aligned_storage<_Len, 0x1000> { struct alignas(0x1000) type { unsigned char __lx[(_Len + 0x1000 - 1) / 0x1000 * 0x1000]; }; };
template <size_t _Len> struct __attribute__((__deprecated__)) aligned_storage<_Len, 0x2000> { struct alignas(0x2000) type { unsigned char __lx[(_Len + 0x2000 - 1) / 0x2000 * 0x2000]; }; };


template <size_t _Len> struct __attribute__((__deprecated__)) aligned_storage<_Len, 0x4000> { struct alignas(0x4000) type { unsigned char __lx[(_Len + 0x4000 - 1) / 0x4000 * 0x4000]; }; };




}}
# 429 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/type_traits" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/aligned_union.h" 1 3
# 19 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/aligned_union.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <size_t _I0, size_t... _In>
struct __static_max;

template <size_t _I0>
struct __static_max<_I0> {
  static const size_t value = _I0;
};

template <size_t _I0, size_t _I1, size_t... _In>
struct __static_max<_I0, _I1, _In...> {
  static const size_t value = _I0 >= _I1 ? __static_max<_I0, _In...>::value : __static_max<_I1, _In...>::value;
};

template <size_t _Len, class _Type0, class... _Types>
struct __attribute__((__deprecated__)) aligned_union {
  static const size_t alignment_value =
      __static_max<__alignof(_Type0), __alignof(_Types)...>::value;
  static const size_t __len = __static_max<_Len, sizeof(_Type0), sizeof(_Types)...>::value;
  typedef typename aligned_storage<__len, alignment_value>::type type;
};


template <size_t _Len, class... _Types>
using aligned_union_t __attribute__((__deprecated__)) = typename aligned_union<_Len, _Types...>::type;


}}
# 430 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/type_traits" 2 3


# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/can_extract_key.h" 1 3
# 18 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/can_extract_key.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/remove_const_ref.h" 1 3
# 18 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/remove_const_ref.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Tp>
using __remove_const_ref_t = __remove_const_t<__libcpp_remove_reference_t<_Tp> >;

}}
# 19 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/can_extract_key.h" 2 3
# 22 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/can_extract_key.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {


struct __extract_key_fail_tag {};
struct __extract_key_self_tag {};
struct __extract_key_first_tag {};

template <class _ValTy, class _Key, class _RawValTy = __remove_const_ref_t<_ValTy> >
struct __can_extract_key
    : __conditional_t<_IsSame<_RawValTy, _Key>::value, __extract_key_self_tag, __extract_key_fail_tag> {};

template <class _Pair, class _Key, class _First, class _Second>
struct __can_extract_key<_Pair, _Key, pair<_First, _Second> >
    : __conditional_t<_IsSame<__remove_const_t<_First>, _Key>::value, __extract_key_first_tag, __extract_key_fail_tag> {
};




template <class _ValTy, class _Key, class _ContainerValueTy, class _RawValTy = __remove_const_ref_t<_ValTy> >
struct __can_extract_map_key : integral_constant<bool, _IsSame<_RawValTy, _Key>::value> {};



template <class _ValTy, class _Key, class _RawValTy>
struct __can_extract_map_key<_ValTy, _Key, _Key, _RawValTy> : false_type {};

}}
# 433 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/type_traits" 2 3
# 442 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/type_traits" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/has_unique_object_representation.h" 1 3
# 19 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/has_unique_object_representation.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {



template <class _Tp>
struct has_unique_object_representations
    : public integral_constant<bool, __has_unique_object_representations(remove_cv_t<remove_all_extents_t<_Tp>>)> {};

template <class _Tp>
inline constexpr bool has_unique_object_representations_v = has_unique_object_representations<_Tp>::value;



}}
# 443 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/type_traits" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/has_virtual_destructor.h" 1 3
# 17 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/has_virtual_destructor.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Tp>
struct has_virtual_destructor : public integral_constant<bool, __has_virtual_destructor(_Tp)> {};


template <class _Tp>
inline constexpr bool has_virtual_destructor_v = __has_virtual_destructor(_Tp);


}}
# 444 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/type_traits" 2 3


# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_abstract.h" 1 3
# 17 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_abstract.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Tp>
struct is_abstract : public integral_constant<bool, __is_abstract(_Tp)> {};


template <class _Tp>
inline constexpr bool is_abstract_v = __is_abstract(_Tp);


}}
# 447 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/type_traits" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_aggregate.h" 1 3
# 17 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_aggregate.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {



template <class _Tp>
struct is_aggregate : public integral_constant<bool, __is_aggregate(_Tp)> {};

template <class _Tp>
inline constexpr bool is_aggregate_v = __is_aggregate(_Tp);



}}
# 448 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/type_traits" 2 3




# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_bounded_array.h" 1 3
# 18 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_bounded_array.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class>
struct __libcpp_is_bounded_array : false_type {};
template <class _Tp, size_t _Np>
struct __libcpp_is_bounded_array<_Tp[_Np]> : true_type {};



template <class>
struct is_bounded_array : false_type {};
template <class _Tp, size_t _Np>
struct is_bounded_array<_Tp[_Np]> : true_type {};

template <class _Tp>
inline constexpr bool is_bounded_array_v = is_bounded_array<_Tp>::value;



}}
# 453 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/type_traits" 2 3

# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_char_like_type.h" 1 3
# 14 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_char_like_type.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_standard_layout.h" 1 3
# 17 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_standard_layout.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Tp>
struct is_standard_layout : public integral_constant<bool, __is_standard_layout(_Tp)> {};


template <class _Tp>
inline constexpr bool is_standard_layout_v = __is_standard_layout(_Tp);


}}
# 15 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_char_like_type.h" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_trivial.h" 1 3
# 17 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_trivial.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Tp>
struct is_trivial : public integral_constant<bool, __is_trivial(_Tp)> {};


template <class _Tp>
inline constexpr bool is_trivial_v = __is_trivial(_Tp);


}}
# 16 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_char_like_type.h" 2 3
# 19 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_char_like_type.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _CharT>
using _IsCharLikeType = _And<is_standard_layout<_CharT>, is_trivial<_CharT> >;

}}
# 455 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/type_traits" 2 3

# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_compound.h" 1 3
# 14 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_compound.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_fundamental.h" 1 3
# 19 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_fundamental.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {



template <class _Tp>
struct is_fundamental : _BoolConstant<__is_fundamental(_Tp)> {};


template <class _Tp>
inline constexpr bool is_fundamental_v = __is_fundamental(_Tp);
# 46 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_fundamental.h" 3
}}
# 15 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_compound.h" 2 3
# 18 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_compound.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {



template <class _Tp>
struct is_compound : _BoolConstant<__is_compound(_Tp)> {};


template <class _Tp>
inline constexpr bool is_compound_v = __is_compound(_Tp);
# 44 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_compound.h" 3
}}
# 457 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/type_traits" 2 3
# 473 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/type_traits" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_literal_type.h" 1 3
# 17 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_literal_type.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 32 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_literal_type.h" 3
}}
# 474 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/type_traits" 2 3







# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_nothrow_convertible.h" 1 3
# 18 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_nothrow_convertible.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/lazy.h" 1 3
# 16 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/lazy.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <template <class...> class _Func, class... _Args>
struct _Lazy : _Func<_Args...> {};

}}
# 19 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_nothrow_convertible.h" 2 3
# 23 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_nothrow_convertible.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {



template <typename _Tp>
void __test_noexcept(_Tp) noexcept;

template <typename _Fm, typename _To>
bool_constant<noexcept(std::__test_noexcept<_To>(std::declval<_Fm>()))> __is_nothrow_convertible_test();

template <typename _Fm, typename _To>
struct __is_nothrow_convertible_helper : decltype(__is_nothrow_convertible_test<_Fm, _To>()) {};

template <typename _Fm, typename _To>
struct is_nothrow_convertible
    : _Or<_And<is_void<_To>, is_void<_Fm>>,
          _Lazy<_And, is_convertible<_Fm, _To>, __is_nothrow_convertible_helper<_Fm, _To> > >::type {};

template <typename _Fm, typename _To>
inline constexpr bool is_nothrow_convertible_v = is_nothrow_convertible<_Fm, _To>::value;



}}
# 482 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/type_traits" 2 3








# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_pod.h" 1 3
# 17 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_pod.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Tp>
struct is_pod : public integral_constant<bool, __is_pod(_Tp)> {};


template <class _Tp>
inline constexpr bool is_pod_v = __is_pod(_Tp);


}}
# 491 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/type_traits" 2 3

# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_polymorphic.h" 1 3
# 17 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_polymorphic.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Tp>
struct is_polymorphic : public integral_constant<bool, __is_polymorphic(_Tp)> {};


template <class _Tp>
inline constexpr bool is_polymorphic_v = __is_polymorphic(_Tp);


}}
# 493 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/type_traits" 2 3





# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_scoped_enum.h" 1 3
# 20 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_scoped_enum.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {


template <class _Tp, bool = is_enum_v<_Tp> >
struct __is_scoped_enum_helper : false_type {};

template <class _Tp>
struct __is_scoped_enum_helper<_Tp, true> : public bool_constant<!is_convertible_v<_Tp, underlying_type_t<_Tp> > > {};

template <class _Tp>
struct is_scoped_enum : public __is_scoped_enum_helper<_Tp> {};

template <class _Tp>
inline constexpr bool is_scoped_enum_v = is_scoped_enum<_Tp>::value;


}}
# 499 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/type_traits" 2 3

# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_specialization.h" 1 3
# 29 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_specialization.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {



template <class _Tp, template <class...> class _Template>
inline constexpr bool __is_specialization_v = false;

template <template <class...> class _Template, class... _Args>
inline constexpr bool __is_specialization_v<_Template<_Args...>, _Template> = true;



}}
# 501 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/type_traits" 2 3




# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_trivially_constructible.h" 1 3
# 17 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_trivially_constructible.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Tp, class... _Args>
struct is_trivially_constructible
    : integral_constant<bool, __is_trivially_constructible(_Tp, _Args...)> {};


template <class _Tp, class... _Args>
inline constexpr bool is_trivially_constructible_v = __is_trivially_constructible(_Tp, _Args...);


}}
# 506 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/type_traits" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_trivially_copy_assignable.h" 1 3
# 19 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_trivially_copy_assignable.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Tp>
struct is_trivially_copy_assignable
    : public integral_constant<bool,
                               __is_trivially_assignable(__add_lvalue_reference_t<_Tp>,
                                                         __add_lvalue_reference_t<typename add_const<_Tp>::type>)> {};


template <class _Tp>
inline constexpr bool is_trivially_copy_assignable_v = is_trivially_copy_assignable<_Tp>::value;


}}
# 507 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/type_traits" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_trivially_copy_constructible.h" 1 3
# 18 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_trivially_copy_constructible.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Tp>
struct is_trivially_copy_constructible
    : public integral_constant<bool, __is_trivially_constructible(_Tp, __add_lvalue_reference_t<const _Tp>)> {};


template <class _Tp>
inline constexpr bool is_trivially_copy_constructible_v = is_trivially_copy_constructible<_Tp>::value;


}}
# 508 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/type_traits" 2 3

# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_trivially_default_constructible.h" 1 3
# 17 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_trivially_default_constructible.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Tp>
struct is_trivially_default_constructible
    : public integral_constant<bool, __is_trivially_constructible(_Tp)> {};


template <class _Tp>
inline constexpr bool is_trivially_default_constructible_v = __is_trivially_constructible(_Tp);


}}
# 510 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/type_traits" 2 3


# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_trivially_move_constructible.h" 1 3
# 18 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_trivially_move_constructible.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Tp>
struct is_trivially_move_constructible
    : public integral_constant<bool, __is_trivially_constructible(_Tp, __add_rvalue_reference_t<_Tp>)> {};


template <class _Tp>
inline constexpr bool is_trivially_move_constructible_v = is_trivially_move_constructible<_Tp>::value;


}}
# 513 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/type_traits" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_unbounded_array.h" 1 3
# 17 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_unbounded_array.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class>
struct __libcpp_is_unbounded_array : false_type {};
template <class _Tp>
struct __libcpp_is_unbounded_array<_Tp[]> : true_type {};



template <class>
struct is_unbounded_array : false_type {};
template <class _Tp>
struct is_unbounded_array<_Tp[]> : true_type {};

template <class _Tp>
inline constexpr bool is_unbounded_array_v = is_unbounded_array<_Tp>::value;



}}
# 514 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/type_traits" 2 3







# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/maybe_const.h" 1 3
# 17 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/maybe_const.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <bool _Const, class _Tp>
using __maybe_const = __conditional_t<_Const, const _Tp, _Tp>;

}}
# 522 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/type_traits" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/negation.h" 1 3
# 17 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/negation.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Pred>
struct _Not : _BoolConstant<!_Pred::value> {};


template <class _Tp>
struct negation : _Not<_Tp> {};
template <class _Tp>
inline constexpr bool negation_v = !_Tp::value;


}}
# 523 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/type_traits" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/rank.h" 1 3
# 18 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/rank.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 30 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/rank.h" 3
template <class _Tp>
struct rank : public integral_constant<size_t, 0> {};
template <class _Tp>
struct rank<_Tp[]> : public integral_constant<size_t, rank<_Tp>::value + 1> {};
template <class _Tp, size_t _Np>
struct rank<_Tp[_Np]> : public integral_constant<size_t, rank<_Tp>::value + 1> {};




template <class _Tp>
inline constexpr size_t rank_v = rank<_Tp>::value;


}}
# 524 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/type_traits" 2 3








# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/result_of.h" 1 3
# 17 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/result_of.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 36 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/result_of.h" 3
}}
# 533 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/type_traits" 2 3
# 544 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/type_traits" 3
# 21 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/__clang_hip_cmath.h" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/utility" 1 3
# 251 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/utility" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__utility/as_const.h" 1 3
# 19 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__utility/as_const.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {


template <class _Tp>
[[__nodiscard__]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr add_const_t<_Tp>& as_const(_Tp& __t) noexcept { return __t; }

template <class _Tp>
void as_const(const _Tp&&) = delete;


}}
# 252 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/utility" 2 3

# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__utility/cmp.h" 1 3
# 24 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__utility/cmp.h" 3



# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__undef_macros" 1 3
# 28 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__utility/cmp.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {


template<class _Tp, class... _Up>
struct _IsSameAsAny : _Or<_IsSame<_Tp, _Up>...> {};

template<class _Tp>
concept __is_safe_integral_cmp = is_integral_v<_Tp> &&
                      !_IsSameAsAny<_Tp, bool, char, char16_t, char32_t

                                    , char8_t


                                    , wchar_t

                                    >::value;

template<__is_safe_integral_cmp _Tp, __is_safe_integral_cmp _Up>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
bool cmp_equal(_Tp __t, _Up __u) noexcept
{
  if constexpr (is_signed_v<_Tp> == is_signed_v<_Up>)
    return __t == __u;
  else if constexpr (is_signed_v<_Tp>)
    return __t < 0 ? false : make_unsigned_t<_Tp>(__t) == __u;
  else
    return __u < 0 ? false : __t == make_unsigned_t<_Up>(__u);
}

template<__is_safe_integral_cmp _Tp, __is_safe_integral_cmp _Up>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
bool cmp_not_equal(_Tp __t, _Up __u) noexcept
{
  return !std::cmp_equal(__t, __u);
}

template<__is_safe_integral_cmp _Tp, __is_safe_integral_cmp _Up>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
bool cmp_less(_Tp __t, _Up __u) noexcept
{
  if constexpr (is_signed_v<_Tp> == is_signed_v<_Up>)
    return __t < __u;
  else if constexpr (is_signed_v<_Tp>)
    return __t < 0 ? true : make_unsigned_t<_Tp>(__t) < __u;
  else
    return __u < 0 ? false : __t < make_unsigned_t<_Up>(__u);
}

template<__is_safe_integral_cmp _Tp, __is_safe_integral_cmp _Up>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
bool cmp_greater(_Tp __t, _Up __u) noexcept
{
  return std::cmp_less(__u, __t);
}

template<__is_safe_integral_cmp _Tp, __is_safe_integral_cmp _Up>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
bool cmp_less_equal(_Tp __t, _Up __u) noexcept
{
  return !std::cmp_greater(__t, __u);
}

template<__is_safe_integral_cmp _Tp, __is_safe_integral_cmp _Up>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
bool cmp_greater_equal(_Tp __t, _Up __u) noexcept
{
  return !std::cmp_less(__t, __u);
}

template<__is_safe_integral_cmp _Tp, __is_safe_integral_cmp _Up>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
bool in_range(_Up __u) noexcept
{
  return std::cmp_less_equal(__u, numeric_limits<_Tp>::max()) &&
         std::cmp_greater_equal(__u, numeric_limits<_Tp>::min());
}


}}
# 254 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/utility" 2 3

# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__utility/exception_guard.h" 1 3
# 20 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__utility/exception_guard.h" 3



# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__undef_macros" 1 3
# 24 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__utility/exception_guard.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 64 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__utility/exception_guard.h" 3
template <class _Rollback>
struct __exception_guard_exceptions {
  __exception_guard_exceptions() = delete;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr explicit __exception_guard_exceptions(_Rollback __rollback)
      : __rollback_(std::move(__rollback)), __completed_(false) {}

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
  __exception_guard_exceptions(__exception_guard_exceptions&& __other)
      noexcept(is_nothrow_move_constructible<_Rollback>::value)
      : __rollback_(std::move(__other.__rollback_)), __completed_(__other.__completed_) {
    __other.__completed_ = true;
  }

  __exception_guard_exceptions(__exception_guard_exceptions const&) = delete;
  __exception_guard_exceptions& operator=(__exception_guard_exceptions const&) = delete;
  __exception_guard_exceptions& operator=(__exception_guard_exceptions&&) = delete;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr void __complete() noexcept { __completed_ = true; }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr ~__exception_guard_exceptions() {
    if (!__completed_)
      __rollback_();
  }

private:
  _Rollback __rollback_;
  bool __completed_;
};

template <class... _Tag> [[maybe_unused]] __exception_guard_exceptions(typename _Tag::__allow_ctad...)->__exception_guard_exceptions<_Tag...>;

template <class _Rollback>
struct __exception_guard_noexceptions {
  __exception_guard_noexceptions() = delete;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
      __attribute__((__nodebug__)) explicit __exception_guard_noexceptions(_Rollback) {}

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr __attribute__((__nodebug__))
  __exception_guard_noexceptions(__exception_guard_noexceptions&& __other)
      noexcept(is_nothrow_move_constructible<_Rollback>::value)
      : __completed_(__other.__completed_) {
    __other.__completed_ = true;
  }

  __exception_guard_noexceptions(__exception_guard_noexceptions const&) = delete;
  __exception_guard_noexceptions& operator=(__exception_guard_noexceptions const&) = delete;
  __exception_guard_noexceptions& operator=(__exception_guard_noexceptions&&) = delete;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr __attribute__((__nodebug__)) void __complete() noexcept {
    __completed_ = true;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr __attribute__((__nodebug__)) ~__exception_guard_noexceptions() {
    ((void)0);
  }

private:
  bool __completed_ = false;
};

template <class... _Tag> [[maybe_unused]] __exception_guard_noexceptions(typename _Tag::__allow_ctad...)->__exception_guard_noexceptions<_Tag...>;


template <class _Rollback>
using __exception_guard = __exception_guard_noexceptions<_Rollback>;





template <class _Rollback>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr __exception_guard<_Rollback> __make_exception_guard(_Rollback __rollback) {
  return __exception_guard<_Rollback>(std::move(__rollback));
}

}}
# 256 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/utility" 2 3


# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__utility/forward_like.h" 1 3
# 21 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__utility/forward_like.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {



template <class _Ap, class _Bp>
using _CopyConst = _If<is_const_v<_Ap>, const _Bp, _Bp>;

template <class _Ap, class _Bp>
using _OverrideRef = _If<is_rvalue_reference_v<_Ap>, remove_reference_t<_Bp>&&, _Bp&>;

template <class _Ap, class _Bp>
using _ForwardLike = _OverrideRef<_Ap&&, _CopyConst<remove_reference_t<_Ap>, remove_reference_t<_Bp>>>;

template <class _Tp, class _Up>
[[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr auto forward_like([[_Clang::__lifetimebound__]] _Up&& __ux) noexcept
    -> _ForwardLike<_Tp, _Up> {
  return static_cast<_ForwardLike<_Tp, _Up>>(__ux);
}



}}
# 259 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/utility" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__utility/in_place.h" 1 3
# 18 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__utility/in_place.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {



struct __attribute__((__visibility__("default"))) in_place_t {
  explicit in_place_t() = default;
};
inline constexpr in_place_t in_place{};

template <class _Tp>
struct in_place_type_t {
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) explicit in_place_type_t() = default;
};
template <class _Tp>
inline constexpr in_place_type_t<_Tp> in_place_type{};

template <size_t _Idx>
struct in_place_index_t {
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) explicit in_place_index_t() = default;
};
template <size_t _Idx>
inline constexpr in_place_index_t<_Idx> in_place_index{};

template <class _Tp> struct __is_inplace_type_imp : false_type {};
template <class _Tp> struct __is_inplace_type_imp<in_place_type_t<_Tp>> : true_type {};

template <class _Tp>
using __is_inplace_type = __is_inplace_type_imp<__remove_cvref_t<_Tp>>;

template <class _Tp> struct __is_inplace_index_imp : false_type {};
template <size_t _Idx> struct __is_inplace_index_imp<in_place_index_t<_Idx>> : true_type {};

template <class _Tp>
using __is_inplace_index = __is_inplace_index_imp<__remove_cvref_t<_Tp>>;



}}
# 260 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/utility" 2 3




# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__utility/priority_tag.h" 1 3
# 17 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__utility/priority_tag.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template<size_t _Ip> struct __priority_tag : __priority_tag<_Ip - 1> {};
template<> struct __priority_tag<0> {};

}}
# 265 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/utility" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__utility/rel_ops.h" 1 3
# 16 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__utility/rel_ops.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

namespace rel_ops
{

template<class _Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
bool
operator!=(const _Tp& __x, const _Tp& __y)
{
    return !(__x == __y);
}

template<class _Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
bool
operator> (const _Tp& __x, const _Tp& __y)
{
    return __y < __x;
}

template<class _Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
bool
operator<=(const _Tp& __x, const _Tp& __y)
{
    return !(__y < __x);
}

template<class _Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
bool
operator>=(const _Tp& __x, const _Tp& __y)
{
    return !(__x < __y);
}

}

}}
# 266 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/utility" 2 3

# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__utility/to_underlying.h" 1 3
# 18 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__utility/to_underlying.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {


template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr typename underlying_type<_Tp>::type
__to_underlying(_Tp __val) noexcept {
  return static_cast<typename underlying_type<_Tp>::type>(__val);
}



template <class _Tp>
[[__nodiscard__]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr underlying_type_t<_Tp>
to_underlying(_Tp __val) noexcept {
  return std::__to_underlying(__val);
}


}}
# 268 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/utility" 2 3






# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/compare" 1 3
# 145 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/compare" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__compare/compare_partial_order_fallback.h" 1 3
# 13 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__compare/compare_partial_order_fallback.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__compare/partial_order.h" 1 3
# 14 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__compare/partial_order.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__compare/weak_order.h" 1 3
# 14 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__compare/weak_order.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__compare/strong_order.h" 1 3
# 12 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__compare/strong_order.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__bit/bit_cast.h" 1 3
# 18 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__bit/bit_cast.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {



template <class _ToType, class _FromType>
  requires(sizeof(_ToType) == sizeof(_FromType) &&
           is_trivially_copyable_v<_ToType> &&
           is_trivially_copyable_v<_FromType>)
[[__nodiscard__]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr _ToType bit_cast(const _FromType& __from) noexcept {
  return __builtin_bit_cast(_ToType, __from);
}



}}
# 13 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__compare/strong_order.h" 2 3







# 1 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/openmp_wrappers/cmath" 1 3
# 21 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__compare/strong_order.h" 2 3
# 26 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__compare/strong_order.h" 3



# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__undef_macros" 1 3
# 30 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__compare/strong_order.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {




namespace __strong_order {
    struct __fn {

        template<class _Tp, class _Up>
            requires is_same_v<decay_t<_Tp>, decay_t<_Up>>
        __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) static constexpr auto
        __go(_Tp&& __t, _Up&& __u, __priority_tag<2>)
            noexcept(noexcept(strong_ordering(strong_order(std::forward<_Tp>(__t), std::forward<_Up>(__u)))))
            -> decltype( strong_ordering(strong_order(std::forward<_Tp>(__t), std::forward<_Up>(__u))))
            { return strong_ordering(strong_order(std::forward<_Tp>(__t), std::forward<_Up>(__u))); }


        template<class _Tp, class _Up, class _Dp = decay_t<_Tp>>
            requires is_same_v<_Dp, decay_t<_Up>> && is_floating_point_v<_Dp>
        __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) static constexpr strong_ordering
        __go(_Tp&& __t, _Up&& __u, __priority_tag<1>) noexcept
        {
            if constexpr (numeric_limits<_Dp>::is_iec559 && sizeof(_Dp) == sizeof(int32_t)) {
                int32_t __rx = std::bit_cast<int32_t>(__t);
                int32_t __ry = std::bit_cast<int32_t>(__u);
                __rx = (__rx < 0) ? (numeric_limits<int32_t>::min() - __rx - 1) : __rx;
                __ry = (__ry < 0) ? (numeric_limits<int32_t>::min() - __ry - 1) : __ry;
                return (__rx <=> __ry);
            } else if constexpr (numeric_limits<_Dp>::is_iec559 && sizeof(_Dp) == sizeof(int64_t)) {
                int64_t __rx = std::bit_cast<int64_t>(__t);
                int64_t __ry = std::bit_cast<int64_t>(__u);
                __rx = (__rx < 0) ? (numeric_limits<int64_t>::min() - __rx - 1) : __rx;
                __ry = (__ry < 0) ? (numeric_limits<int64_t>::min() - __ry - 1) : __ry;
                return (__rx <=> __ry);
            } else if (__t < __u) {
                return strong_ordering::less;
            } else if (__t > __u) {
                return strong_ordering::greater;
            } else if (__t == __u) {
                if constexpr (numeric_limits<_Dp>::radix == 2) {
                    return std::signbit(__u) <=> std::signbit(__t);
                } else {



                    if (__t == 0 || std::isinf(__t)) {
                        return std::signbit(__u) <=> std::signbit(__t);
                    } else {
                        int __texp, __uexp;
                        (void)std::frexp(__t, &__texp);
                        (void)std::frexp(__u, &__uexp);
                        return (__t < 0) ? (__texp <=> __uexp) : (__uexp <=> __texp);
                    }
                }
            } else {


                bool __t_is_nan = std::isnan(__t);
                bool __u_is_nan = std::isnan(__u);
                bool __t_is_negative = std::signbit(__t);
                bool __u_is_negative = std::signbit(__u);
                using _IntType = conditional_t<
                    sizeof(__t) == sizeof(int32_t), int32_t, conditional_t<
                    sizeof(__t) == sizeof(int64_t), int64_t, void>
                >;
                if constexpr (is_same_v<_IntType, void>) {
                    static_assert(sizeof(_Dp) == 0, "std::strong_order is unimplemented for this floating-point type");
                } else if (__t_is_nan && __u_is_nan) {

                    if (__t_is_negative != __u_is_negative) {
                        return (__u_is_negative <=> __t_is_negative);
                    } else {
                        return std::bit_cast<_IntType>(__t) <=> std::bit_cast<_IntType>(__u);
                    }
                } else if (__t_is_nan) {
                    return __t_is_negative ? strong_ordering::less : strong_ordering::greater;
                } else {
                    return __u_is_negative ? strong_ordering::greater : strong_ordering::less;
                }
            }
        }

        template<class _Tp, class _Up>
            requires is_same_v<decay_t<_Tp>, decay_t<_Up>>
        __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) static constexpr auto
        __go(_Tp&& __t, _Up&& __u, __priority_tag<0>)
            noexcept(noexcept(strong_ordering(compare_three_way()(std::forward<_Tp>(__t), std::forward<_Up>(__u)))))
            -> decltype( strong_ordering(compare_three_way()(std::forward<_Tp>(__t), std::forward<_Up>(__u))))
            { return strong_ordering(compare_three_way()(std::forward<_Tp>(__t), std::forward<_Up>(__u))); }

        template<class _Tp, class _Up>
        __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr auto operator()(_Tp&& __t, _Up&& __u) const
            noexcept(noexcept(__go(std::forward<_Tp>(__t), std::forward<_Up>(__u), __priority_tag<2>())))
            -> decltype( __go(std::forward<_Tp>(__t), std::forward<_Up>(__u), __priority_tag<2>()))
            { return __go(std::forward<_Tp>(__t), std::forward<_Up>(__u), __priority_tag<2>()); }
    };
}

inline namespace __cpo {
    inline constexpr auto strong_order = __strong_order::__fn{};
}



}}
# 15 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__compare/weak_order.h" 2 3




# 1 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/openmp_wrappers/cmath" 1 3
# 20 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__compare/weak_order.h" 2 3
# 23 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__compare/weak_order.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {




namespace __weak_order {
    struct __fn {

        template<class _Tp, class _Up>
            requires is_same_v<decay_t<_Tp>, decay_t<_Up>>
        __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) static constexpr auto
        __go(_Tp&& __t, _Up&& __u, __priority_tag<3>)
            noexcept(noexcept(weak_ordering(weak_order(std::forward<_Tp>(__t), std::forward<_Up>(__u)))))
            -> decltype( weak_ordering(weak_order(std::forward<_Tp>(__t), std::forward<_Up>(__u))))
            { return weak_ordering(weak_order(std::forward<_Tp>(__t), std::forward<_Up>(__u))); }


        template<class _Tp, class _Up, class _Dp = decay_t<_Tp>>
            requires is_same_v<_Dp, decay_t<_Up>> && is_floating_point_v<_Dp>
        __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) static constexpr weak_ordering
        __go(_Tp&& __t, _Up&& __u, __priority_tag<2>) noexcept
        {
            partial_ordering __po = (__t <=> __u);
            if (__po == partial_ordering::less) {
                return weak_ordering::less;
            } else if (__po == partial_ordering::equivalent) {
                return weak_ordering::equivalent;
            } else if (__po == partial_ordering::greater) {
                return weak_ordering::greater;
            } else {

                bool __t_is_nan = std::isnan(__t);
                bool __u_is_nan = std::isnan(__u);
                bool __t_is_negative = std::signbit(__t);
                bool __u_is_negative = std::signbit(__u);
                if (__t_is_nan && __u_is_nan) {
                    return (__u_is_negative <=> __t_is_negative);
                } else if (__t_is_nan) {
                    return __t_is_negative ? weak_ordering::less : weak_ordering::greater;
                } else {
                    return __u_is_negative ? weak_ordering::greater : weak_ordering::less;
                }
            }
        }

        template<class _Tp, class _Up>
            requires is_same_v<decay_t<_Tp>, decay_t<_Up>>
        __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) static constexpr auto
        __go(_Tp&& __t, _Up&& __u, __priority_tag<1>)
            noexcept(noexcept(weak_ordering(compare_three_way()(std::forward<_Tp>(__t), std::forward<_Up>(__u)))))
            -> decltype( weak_ordering(compare_three_way()(std::forward<_Tp>(__t), std::forward<_Up>(__u))))
            { return weak_ordering(compare_three_way()(std::forward<_Tp>(__t), std::forward<_Up>(__u))); }

        template<class _Tp, class _Up>
            requires is_same_v<decay_t<_Tp>, decay_t<_Up>>
        __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) static constexpr auto
        __go(_Tp&& __t, _Up&& __u, __priority_tag<0>)
            noexcept(noexcept(weak_ordering(std::strong_order(std::forward<_Tp>(__t), std::forward<_Up>(__u)))))
            -> decltype( weak_ordering(std::strong_order(std::forward<_Tp>(__t), std::forward<_Up>(__u))))
            { return weak_ordering(std::strong_order(std::forward<_Tp>(__t), std::forward<_Up>(__u))); }

        template<class _Tp, class _Up>
        __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr auto operator()(_Tp&& __t, _Up&& __u) const
            noexcept(noexcept(__go(std::forward<_Tp>(__t), std::forward<_Up>(__u), __priority_tag<3>())))
            -> decltype( __go(std::forward<_Tp>(__t), std::forward<_Up>(__u), __priority_tag<3>()))
            { return __go(std::forward<_Tp>(__t), std::forward<_Up>(__u), __priority_tag<3>()); }
    };
}

inline namespace __cpo {
    inline constexpr auto weak_order = __weak_order::__fn{};
}



}}
# 15 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__compare/partial_order.h" 2 3
# 23 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__compare/partial_order.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {




namespace __partial_order {
    struct __fn {

        template<class _Tp, class _Up>
            requires is_same_v<decay_t<_Tp>, decay_t<_Up>>
        __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) static constexpr auto
        __go(_Tp&& __t, _Up&& __u, __priority_tag<2>)
            noexcept(noexcept(partial_ordering(partial_order(std::forward<_Tp>(__t), std::forward<_Up>(__u)))))
            -> decltype( partial_ordering(partial_order(std::forward<_Tp>(__t), std::forward<_Up>(__u))))
            { return partial_ordering(partial_order(std::forward<_Tp>(__t), std::forward<_Up>(__u))); }


        template<class _Tp, class _Up>
            requires is_same_v<decay_t<_Tp>, decay_t<_Up>>
        __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) static constexpr auto
        __go(_Tp&& __t, _Up&& __u, __priority_tag<1>)
            noexcept(noexcept(partial_ordering(compare_three_way()(std::forward<_Tp>(__t), std::forward<_Up>(__u)))))
            -> decltype( partial_ordering(compare_three_way()(std::forward<_Tp>(__t), std::forward<_Up>(__u))))
            { return partial_ordering(compare_three_way()(std::forward<_Tp>(__t), std::forward<_Up>(__u))); }

        template<class _Tp, class _Up>
            requires is_same_v<decay_t<_Tp>, decay_t<_Up>>
        __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) static constexpr auto
        __go(_Tp&& __t, _Up&& __u, __priority_tag<0>)
            noexcept(noexcept(partial_ordering(std::weak_order(std::forward<_Tp>(__t), std::forward<_Up>(__u)))))
            -> decltype( partial_ordering(std::weak_order(std::forward<_Tp>(__t), std::forward<_Up>(__u))))
            { return partial_ordering(std::weak_order(std::forward<_Tp>(__t), std::forward<_Up>(__u))); }

        template<class _Tp, class _Up>
        __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr auto operator()(_Tp&& __t, _Up&& __u) const
            noexcept(noexcept(__go(std::forward<_Tp>(__t), std::forward<_Up>(__u), __priority_tag<2>())))
            -> decltype( __go(std::forward<_Tp>(__t), std::forward<_Up>(__u), __priority_tag<2>()))
            { return __go(std::forward<_Tp>(__t), std::forward<_Up>(__u), __priority_tag<2>()); }
    };
}

inline namespace __cpo {
    inline constexpr auto partial_order = __partial_order::__fn{};
}



}}
# 14 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__compare/compare_partial_order_fallback.h" 2 3
# 22 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__compare/compare_partial_order_fallback.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {




namespace __compare_partial_order_fallback {
    struct __fn {
        template<class _Tp, class _Up>
            requires is_same_v<decay_t<_Tp>, decay_t<_Up>>
        __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) static constexpr auto
        __go(_Tp&& __t, _Up&& __u, __priority_tag<1>)
            noexcept(noexcept(std::partial_order(std::forward<_Tp>(__t), std::forward<_Up>(__u))))
            -> decltype( std::partial_order(std::forward<_Tp>(__t), std::forward<_Up>(__u)))
            { return std::partial_order(std::forward<_Tp>(__t), std::forward<_Up>(__u)); }

        template<class _Tp, class _Up>
            requires is_same_v<decay_t<_Tp>, decay_t<_Up>>
        __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) static constexpr auto
        __go(_Tp&& __t, _Up&& __u, __priority_tag<0>)
            noexcept(noexcept(std::forward<_Tp>(__t) == std::forward<_Up>(__u) ? partial_ordering::equivalent :
                              std::forward<_Tp>(__t) < std::forward<_Up>(__u) ? partial_ordering::less :
                              std::forward<_Up>(__u) < std::forward<_Tp>(__t) ? partial_ordering::greater :
                              partial_ordering::unordered))
            -> decltype( std::forward<_Tp>(__t) == std::forward<_Up>(__u) ? partial_ordering::equivalent :
                              std::forward<_Tp>(__t) < std::forward<_Up>(__u) ? partial_ordering::less :
                              std::forward<_Up>(__u) < std::forward<_Tp>(__t) ? partial_ordering::greater :
                              partial_ordering::unordered)
        {
            return std::forward<_Tp>(__t) == std::forward<_Up>(__u) ? partial_ordering::equivalent :
                              std::forward<_Tp>(__t) < std::forward<_Up>(__u) ? partial_ordering::less :
                              std::forward<_Up>(__u) < std::forward<_Tp>(__t) ? partial_ordering::greater :
                              partial_ordering::unordered;
        }

        template<class _Tp, class _Up>
        __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr auto operator()(_Tp&& __t, _Up&& __u) const
            noexcept(noexcept(__go(std::forward<_Tp>(__t), std::forward<_Up>(__u), __priority_tag<1>())))
            -> decltype( __go(std::forward<_Tp>(__t), std::forward<_Up>(__u), __priority_tag<1>()))
            { return __go(std::forward<_Tp>(__t), std::forward<_Up>(__u), __priority_tag<1>()); }
    };
}

inline namespace __cpo {
    inline constexpr auto compare_partial_order_fallback = __compare_partial_order_fallback::__fn{};
}



}}
# 146 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/compare" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__compare/compare_strong_order_fallback.h" 1 3
# 22 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__compare/compare_strong_order_fallback.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {




namespace __compare_strong_order_fallback {
    struct __fn {
        template<class _Tp, class _Up>
            requires is_same_v<decay_t<_Tp>, decay_t<_Up>>
        __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) static constexpr auto
        __go(_Tp&& __t, _Up&& __u, __priority_tag<1>)
            noexcept(noexcept(std::strong_order(std::forward<_Tp>(__t), std::forward<_Up>(__u))))
            -> decltype( std::strong_order(std::forward<_Tp>(__t), std::forward<_Up>(__u)))
            { return std::strong_order(std::forward<_Tp>(__t), std::forward<_Up>(__u)); }

        template<class _Tp, class _Up>
            requires is_same_v<decay_t<_Tp>, decay_t<_Up>>
        __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) static constexpr auto
        __go(_Tp&& __t, _Up&& __u, __priority_tag<0>)
            noexcept(noexcept(std::forward<_Tp>(__t) == std::forward<_Up>(__u) ? strong_ordering::equal :
                              std::forward<_Tp>(__t) < std::forward<_Up>(__u) ? strong_ordering::less :
                              strong_ordering::greater))
            -> decltype( std::forward<_Tp>(__t) == std::forward<_Up>(__u) ? strong_ordering::equal :
                              std::forward<_Tp>(__t) < std::forward<_Up>(__u) ? strong_ordering::less :
                              strong_ordering::greater)
        {
            return std::forward<_Tp>(__t) == std::forward<_Up>(__u) ? strong_ordering::equal :
                              std::forward<_Tp>(__t) < std::forward<_Up>(__u) ? strong_ordering::less :
                              strong_ordering::greater;
        }

        template<class _Tp, class _Up>
        __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr auto operator()(_Tp&& __t, _Up&& __u) const
            noexcept(noexcept(__go(std::forward<_Tp>(__t), std::forward<_Up>(__u), __priority_tag<1>())))
            -> decltype( __go(std::forward<_Tp>(__t), std::forward<_Up>(__u), __priority_tag<1>()))
            { return __go(std::forward<_Tp>(__t), std::forward<_Up>(__u), __priority_tag<1>()); }
    };
}

inline namespace __cpo {
    inline constexpr auto compare_strong_order_fallback = __compare_strong_order_fallback::__fn{};
}



}}
# 147 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/compare" 2 3


# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__compare/compare_weak_order_fallback.h" 1 3
# 22 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__compare/compare_weak_order_fallback.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {




namespace __compare_weak_order_fallback {
    struct __fn {
        template<class _Tp, class _Up>
            requires is_same_v<decay_t<_Tp>, decay_t<_Up>>
        __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) static constexpr auto
        __go(_Tp&& __t, _Up&& __u, __priority_tag<1>)
            noexcept(noexcept(std::weak_order(std::forward<_Tp>(__t), std::forward<_Up>(__u))))
            -> decltype( std::weak_order(std::forward<_Tp>(__t), std::forward<_Up>(__u)))
            { return std::weak_order(std::forward<_Tp>(__t), std::forward<_Up>(__u)); }

        template<class _Tp, class _Up>
            requires is_same_v<decay_t<_Tp>, decay_t<_Up>>
        __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) static constexpr auto
        __go(_Tp&& __t, _Up&& __u, __priority_tag<0>)
            noexcept(noexcept(std::forward<_Tp>(__t) == std::forward<_Up>(__u) ? weak_ordering::equivalent :
                              std::forward<_Tp>(__t) < std::forward<_Up>(__u) ? weak_ordering::less :
                              weak_ordering::greater))
            -> decltype( std::forward<_Tp>(__t) == std::forward<_Up>(__u) ? weak_ordering::equivalent :
                              std::forward<_Tp>(__t) < std::forward<_Up>(__u) ? weak_ordering::less :
                              weak_ordering::greater)
        {
            return std::forward<_Tp>(__t) == std::forward<_Up>(__u) ? weak_ordering::equivalent :
                              std::forward<_Tp>(__t) < std::forward<_Up>(__u) ? weak_ordering::less :
                              weak_ordering::greater;
        }

        template<class _Tp, class _Up>
        __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr auto operator()(_Tp&& __t, _Up&& __u) const
            noexcept(noexcept(__go(std::forward<_Tp>(__t), std::forward<_Up>(__u), __priority_tag<1>())))
            -> decltype( __go(std::forward<_Tp>(__t), std::forward<_Up>(__u), __priority_tag<1>()))
            { return __go(std::forward<_Tp>(__t), std::forward<_Up>(__u), __priority_tag<1>()); }
    };
}

inline namespace __cpo {
    inline constexpr auto compare_weak_order_fallback = __compare_weak_order_fallback::__fn{};
}



}}
# 150 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/compare" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__compare/is_eq.h" 1 3
# 17 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__compare/is_eq.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {



__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) inline constexpr bool is_eq(partial_ordering __c) noexcept { return __c == 0; }
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) inline constexpr bool is_neq(partial_ordering __c) noexcept { return __c != 0; }
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) inline constexpr bool is_lt(partial_ordering __c) noexcept { return __c < 0; }
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) inline constexpr bool is_lteq(partial_ordering __c) noexcept { return __c <= 0; }
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) inline constexpr bool is_gt(partial_ordering __c) noexcept { return __c > 0; }
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) inline constexpr bool is_gteq(partial_ordering __c) noexcept { return __c >= 0; }



}}
# 151 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/compare" 2 3
# 162 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/compare" 3
# 275 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/utility" 2 3
# 283 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/utility" 3
# 22 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/__clang_hip_cmath.h" 2 3
# 40 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/__clang_hip_cmath.h" 3
static __attribute__((always_inline, nothrow)) constexpr float fabs(float __x) { return ::fabsf(__x); }
static __attribute__((always_inline, nothrow)) constexpr float sin(float __x) { return ::sinf(__x); }
static __attribute__((always_inline, nothrow)) constexpr float cos(float __x) { return ::cosf(__x); }

static __attribute__((always_inline, nothrow)) constexpr double abs(double __x) { return ::fabs(__x); }
static __attribute__((always_inline, nothrow)) constexpr float abs(float __x) { return ::fabsf(__x); }
static __attribute__((always_inline, nothrow)) constexpr long long abs(long long __n) { return ::llabs(__n); }
static __attribute__((always_inline, nothrow)) constexpr long abs(long __n) { return ::labs(__n); }
static __attribute__((always_inline, nothrow)) constexpr float fma(float __x, float __y, float __z) {
  return ::fmaf(__x, __y, __z);
}



static __attribute__((always_inline, nothrow)) constexpr int fpclassify(float __x) {
  return __builtin_fpclassify(0, 1, 4, 3,
                              2, __x);
}
static __attribute__((always_inline, nothrow)) constexpr int fpclassify(double __x) {
  return __builtin_fpclassify(0, 1, 4, 3,
                              2, __x);
}


static __attribute__((always_inline, nothrow)) constexpr float frexp(float __arg, int *__exp) {
  return ::frexpf(__arg, __exp);
}








#pragma omp begin declare variant match( implementation = {extension(disable_implicit_base)})








#pragma omp begin declare variant match(implementation = {vendor(llvm)})

static __attribute__((always_inline, nothrow)) constexpr int isinf(float __x) { return ::__isinff(__x); }
static __attribute__((always_inline, nothrow)) constexpr int isinf(double __x) { return ::__isinf(__x); }
static __attribute__((always_inline, nothrow)) constexpr int isfinite(float __x) { return ::__finitef(__x); }
static __attribute__((always_inline, nothrow)) constexpr int isfinite(double __x) { return ::__finite(__x); }
static __attribute__((always_inline, nothrow)) constexpr int isnan(float __x) { return ::__isnanf(__x); }
static __attribute__((always_inline, nothrow)) constexpr int isnan(double __x) { return ::__isnan(__x); }

#pragma omp end declare variant


static __attribute__((always_inline, nothrow)) constexpr bool isinf(float __x) { return ::__isinff(__x); }
static __attribute__((always_inline, nothrow)) constexpr bool isinf(double __x) { return ::__isinf(__x); }
static __attribute__((always_inline, nothrow)) constexpr bool isfinite(float __x) { return ::__finitef(__x); }
static __attribute__((always_inline, nothrow)) constexpr bool isfinite(double __x) { return ::__finite(__x); }
static __attribute__((always_inline, nothrow)) constexpr bool isnan(float __x) { return ::__isnanf(__x); }
static __attribute__((always_inline, nothrow)) constexpr bool isnan(double __x) { return ::__isnan(__x); }


#pragma omp end declare variant


static __attribute__((always_inline, nothrow)) constexpr bool isgreater(float __x, float __y) {
  return __builtin_isgreater(__x, __y);
}
static __attribute__((always_inline, nothrow)) constexpr bool isgreater(double __x, double __y) {
  return __builtin_isgreater(__x, __y);
}
static __attribute__((always_inline, nothrow)) constexpr bool isgreaterequal(float __x, float __y) {
  return __builtin_isgreaterequal(__x, __y);
}
static __attribute__((always_inline, nothrow)) constexpr bool isgreaterequal(double __x, double __y) {
  return __builtin_isgreaterequal(__x, __y);
}
static __attribute__((always_inline, nothrow)) constexpr bool isless(float __x, float __y) {
  return __builtin_isless(__x, __y);
}
static __attribute__((always_inline, nothrow)) constexpr bool isless(double __x, double __y) {
  return __builtin_isless(__x, __y);
}
static __attribute__((always_inline, nothrow)) constexpr bool islessequal(float __x, float __y) {
  return __builtin_islessequal(__x, __y);
}
static __attribute__((always_inline, nothrow)) constexpr bool islessequal(double __x, double __y) {
  return __builtin_islessequal(__x, __y);
}
static __attribute__((always_inline, nothrow)) constexpr bool islessgreater(float __x, float __y) {
  return __builtin_islessgreater(__x, __y);
}
static __attribute__((always_inline, nothrow)) constexpr bool islessgreater(double __x, double __y) {
  return __builtin_islessgreater(__x, __y);
}
static __attribute__((always_inline, nothrow)) constexpr bool isnormal(float __x) {
  return __builtin_isnormal(__x);
}
static __attribute__((always_inline, nothrow)) constexpr bool isnormal(double __x) {
  return __builtin_isnormal(__x);
}
static __attribute__((always_inline, nothrow)) constexpr bool isunordered(float __x, float __y) {
  return __builtin_isunordered(__x, __y);
}
static __attribute__((always_inline, nothrow)) constexpr bool isunordered(double __x, double __y) {
  return __builtin_isunordered(__x, __y);
}
static __attribute__((always_inline, nothrow)) constexpr float modf(float __x, float *__iptr) {
  return ::modff(__x, __iptr);
}
static __attribute__((always_inline, nothrow)) constexpr float pow(float __base, int __iexp) {
  return ::powif(__base, __iexp);
}
static __attribute__((always_inline, nothrow)) constexpr double pow(double __base, int __iexp) {
  return ::powi(__base, __iexp);
}
static __attribute__((always_inline, nothrow)) constexpr float remquo(float __x, float __y, int *__quo) {
  return ::remquof(__x, __y, __quo);
}
static __attribute__((always_inline, nothrow)) constexpr float scalbln(float __x, long int __n) {
  return ::scalblnf(__x, __n);
}
static __attribute__((always_inline, nothrow)) constexpr bool signbit(float __x) { return ::__signbitf(__x); }
static __attribute__((always_inline, nothrow)) constexpr bool signbit(double __x) { return ::__signbit(__x); }






static __attribute__((always_inline, nothrow)) constexpr _Float16 fma(_Float16 __x, _Float16 __y,
                                      _Float16 __z) {
  return __builtin_fmaf16(__x, __y, __z);
}
static __attribute__((always_inline, nothrow)) constexpr _Float16 pow(_Float16 __base, int __iexp) {
  return __ocml_pown_f16(__base, __iexp);
}
# 86 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/openmp_wrappers/cmath" 2 3







static constexpr __attribute__((always_inline, nothrow)) float acos(float __x) { return ::acosf(__x); }
static constexpr __attribute__((always_inline, nothrow)) float acosh(float __x) { return ::acoshf(__x); }
static constexpr __attribute__((always_inline, nothrow)) float asin(float __x) { return ::asinf(__x); }
static constexpr __attribute__((always_inline, nothrow)) float asinh(float __x) { return ::asinhf(__x); }
static constexpr __attribute__((always_inline, nothrow)) float atan(float __x) { return ::atanf(__x); }
static constexpr __attribute__((always_inline, nothrow)) float atan2(float __x, float __y) { return ::atan2f(__x, __y); }
static constexpr __attribute__((always_inline, nothrow)) float atanh(float __x) { return ::atanhf(__x); }
static constexpr __attribute__((always_inline, nothrow)) float cbrt(float __x) { return ::cbrtf(__x); }
static constexpr __attribute__((always_inline, nothrow)) float cosh(float __x) { return ::coshf(__x); }
static constexpr __attribute__((always_inline, nothrow)) float erf(float __x) { return ::erff(__x); }
static constexpr __attribute__((always_inline, nothrow)) float erfc(float __x) { return ::erfcf(__x); }
static constexpr __attribute__((always_inline, nothrow)) float exp2(float __x) { return ::exp2f(__x); }
static constexpr __attribute__((always_inline, nothrow)) float expm1(float __x) { return ::expm1f(__x); }
static constexpr __attribute__((always_inline, nothrow)) float fdim(float __x, float __y) { return ::fdimf(__x, __y); }
static constexpr __attribute__((always_inline, nothrow)) float hypot(float __x, float __y) { return ::hypotf(__x, __y); }
static constexpr __attribute__((always_inline, nothrow)) int ilogb(float __x) { return ::ilogbf(__x); }
static constexpr __attribute__((always_inline, nothrow)) float ldexp(float __arg, int __exp) {
  return ::ldexpf(__arg, __exp);
}
static constexpr __attribute__((always_inline, nothrow)) float lgamma(float __x) { return ::lgammaf(__x); }
static constexpr __attribute__((always_inline, nothrow)) float log1p(float __x) { return ::log1pf(__x); }
static constexpr __attribute__((always_inline, nothrow)) float logb(float __x) { return ::logbf(__x); }
static constexpr __attribute__((always_inline, nothrow)) float nextafter(float __x, float __y) {
  return ::nextafterf(__x, __y);
}
static constexpr __attribute__((always_inline, nothrow)) float remainder(float __x, float __y) {
  return ::remainderf(__x, __y);
}
static constexpr __attribute__((always_inline, nothrow)) float scalbn(float __x, int __y) { return ::scalbnf(__x, __y); }
static constexpr __attribute__((always_inline, nothrow)) float sinh(float __x) { return ::sinhf(__x); }
static constexpr __attribute__((always_inline, nothrow)) float tan(float __x) { return ::tanf(__x); }
static constexpr __attribute__((always_inline, nothrow)) float tanh(float __x) { return ::tanhf(__x); }
static constexpr __attribute__((always_inline, nothrow)) float tgamma(float __x) { return ::tgammaf(__x); }



#pragma omp end declare variant
# 21 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/openmp_wrappers/math.h" 2 3
# 41 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__threading_support" 2 3

# 1 "/usr/include/pthread.h" 1 3 4
# 23 "/usr/include/pthread.h" 3 4
# 1 "/usr/include/sched.h" 1 3 4
# 29 "/usr/include/sched.h" 3 4
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/stddef.h" 1 3 4
# 15 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/stddef.h" 3


# 1 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/stddef.h" 1 3
# 59 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/stddef.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/__stddef_size_t.h" 1 3
# 15 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/__stddef_size_t.h" 3
typedef long unsigned int size_t;
# 60 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/stddef.h" 2 3
# 74 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/stddef.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/__stddef_null.h" 1 3
# 75 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/stddef.h" 2 3
# 18 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/stddef.h" 2 3
# 30 "/usr/include/sched.h" 2 3 4
# 43 "/usr/include/sched.h" 3 4
# 1 "/usr/include/bits/sched.h" 1 3 4
# 74 "/usr/include/bits/sched.h" 3 4
# 1 "/usr/include/bits/types/struct_sched_param.h" 1 3 4
# 23 "/usr/include/bits/types/struct_sched_param.h" 3 4
struct sched_param
{
  int sched_priority;
};
# 75 "/usr/include/bits/sched.h" 2 3 4

extern "C" {



extern int clone (int (*__fn) (void *__arg), void *__child_stack,
    int __flags, void *__arg, ...) throw ();


extern int unshare (int __flags) throw ();


extern int sched_getcpu (void) throw ();


extern int setns (int __fd, int __nstype) throw ();


}
# 44 "/usr/include/sched.h" 2 3 4
# 1 "/usr/include/bits/cpu-set.h" 1 3 4
# 32 "/usr/include/bits/cpu-set.h" 3 4
typedef unsigned long int __cpu_mask;






typedef struct
{
  __cpu_mask __bits[1024 / (8 * sizeof (__cpu_mask))];
} cpu_set_t;
# 115 "/usr/include/bits/cpu-set.h" 3 4
extern "C" {

extern int __sched_cpucount (size_t __setsize, const cpu_set_t *__setp)
     throw ();
extern cpu_set_t *__sched_cpualloc (size_t __count) throw () ;
extern void __sched_cpufree (cpu_set_t *__set) throw ();

}
# 45 "/usr/include/sched.h" 2 3 4






extern "C" {


extern int sched_setparam (__pid_t __pid, const struct sched_param *__param)
     throw ();


extern int sched_getparam (__pid_t __pid, struct sched_param *__param) throw ();


extern int sched_setscheduler (__pid_t __pid, int __policy,
          const struct sched_param *__param) throw ();


extern int sched_getscheduler (__pid_t __pid) throw ();


extern int sched_yield (void) throw ();


extern int sched_get_priority_max (int __algorithm) throw ();


extern int sched_get_priority_min (int __algorithm) throw ();


extern int sched_rr_get_interval (__pid_t __pid, struct timespec *__t) throw ();
# 121 "/usr/include/sched.h" 3 4
extern int sched_setaffinity (__pid_t __pid, size_t __cpusetsize,
         const cpu_set_t *__cpuset) throw ();


extern int sched_getaffinity (__pid_t __pid, size_t __cpusetsize,
         cpu_set_t *__cpuset) throw ();


}
# 24 "/usr/include/pthread.h" 2 3 4



# 1 "/usr/include/bits/setjmp.h" 1 3 4
# 26 "/usr/include/bits/setjmp.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 27 "/usr/include/bits/setjmp.h" 2 3 4




typedef long int __jmp_buf[8];
# 28 "/usr/include/pthread.h" 2 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 29 "/usr/include/pthread.h" 2 3 4




enum
{
  PTHREAD_CREATE_JOINABLE,

  PTHREAD_CREATE_DETACHED

};



enum
{
  PTHREAD_MUTEX_TIMED_NP,
  PTHREAD_MUTEX_RECURSIVE_NP,
  PTHREAD_MUTEX_ERRORCHECK_NP,
  PTHREAD_MUTEX_ADAPTIVE_NP

  ,
  PTHREAD_MUTEX_NORMAL = PTHREAD_MUTEX_TIMED_NP,
  PTHREAD_MUTEX_RECURSIVE = PTHREAD_MUTEX_RECURSIVE_NP,
  PTHREAD_MUTEX_ERRORCHECK = PTHREAD_MUTEX_ERRORCHECK_NP,
  PTHREAD_MUTEX_DEFAULT = PTHREAD_MUTEX_NORMAL



  , PTHREAD_MUTEX_FAST_NP = PTHREAD_MUTEX_TIMED_NP

};




enum
{
  PTHREAD_MUTEX_STALLED,
  PTHREAD_MUTEX_STALLED_NP = PTHREAD_MUTEX_STALLED,
  PTHREAD_MUTEX_ROBUST,
  PTHREAD_MUTEX_ROBUST_NP = PTHREAD_MUTEX_ROBUST
};





enum
{
  PTHREAD_PRIO_NONE,
  PTHREAD_PRIO_INHERIT,
  PTHREAD_PRIO_PROTECT
};
# 115 "/usr/include/pthread.h" 3 4
enum
{
  PTHREAD_RWLOCK_PREFER_READER_NP,
  PTHREAD_RWLOCK_PREFER_WRITER_NP,
  PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP,
  PTHREAD_RWLOCK_DEFAULT_NP = PTHREAD_RWLOCK_PREFER_READER_NP
};
# 156 "/usr/include/pthread.h" 3 4
enum
{
  PTHREAD_INHERIT_SCHED,

  PTHREAD_EXPLICIT_SCHED

};



enum
{
  PTHREAD_SCOPE_SYSTEM,

  PTHREAD_SCOPE_PROCESS

};



enum
{
  PTHREAD_PROCESS_PRIVATE,

  PTHREAD_PROCESS_SHARED

};
# 191 "/usr/include/pthread.h" 3 4
struct _pthread_cleanup_buffer
{
  void (*__routine) (void *);
  void *__arg;
  int __canceltype;
  struct _pthread_cleanup_buffer *__prev;
};


enum
{
  PTHREAD_CANCEL_ENABLE,

  PTHREAD_CANCEL_DISABLE

};
enum
{
  PTHREAD_CANCEL_DEFERRED,

  PTHREAD_CANCEL_ASYNCHRONOUS

};
# 229 "/usr/include/pthread.h" 3 4
extern "C" {




extern int pthread_create (pthread_t *__restrict __newthread,
      const pthread_attr_t *__restrict __attr,
      void *(*__start_routine) (void *),
      void *__restrict __arg) throw () __attribute__ ((__nonnull__ (1, 3)));





extern void pthread_exit (void *__retval) __attribute__ ((__noreturn__));







extern int pthread_join (pthread_t __th, void **__thread_return);




extern int pthread_tryjoin_np (pthread_t __th, void **__thread_return) throw ();







extern int pthread_timedjoin_np (pthread_t __th, void **__thread_return,
     const struct timespec *__abstime);






extern int pthread_detach (pthread_t __th) throw ();



extern pthread_t pthread_self (void) throw () __attribute__ ((__const__));


extern int pthread_equal (pthread_t __thread1, pthread_t __thread2)
  throw () __attribute__ ((__const__));







extern int pthread_attr_init (pthread_attr_t *__attr) throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_destroy (pthread_attr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_getdetachstate (const pthread_attr_t *__attr,
     int *__detachstate)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setdetachstate (pthread_attr_t *__attr,
     int __detachstate)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_attr_getguardsize (const pthread_attr_t *__attr,
          size_t *__guardsize)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setguardsize (pthread_attr_t *__attr,
          size_t __guardsize)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_attr_getschedparam (const pthread_attr_t *__restrict __attr,
           struct sched_param *__restrict __param)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setschedparam (pthread_attr_t *__restrict __attr,
           const struct sched_param *__restrict
           __param) throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_getschedpolicy (const pthread_attr_t *__restrict
     __attr, int *__restrict __policy)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setschedpolicy (pthread_attr_t *__attr, int __policy)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_getinheritsched (const pthread_attr_t *__restrict
      __attr, int *__restrict __inherit)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setinheritsched (pthread_attr_t *__attr,
      int __inherit)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_attr_getscope (const pthread_attr_t *__restrict __attr,
      int *__restrict __scope)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setscope (pthread_attr_t *__attr, int __scope)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_getstackaddr (const pthread_attr_t *__restrict
          __attr, void **__restrict __stackaddr)
     throw () __attribute__ ((__nonnull__ (1, 2))) __attribute__ ((__deprecated__));





extern int pthread_attr_setstackaddr (pthread_attr_t *__attr,
          void *__stackaddr)
     throw () __attribute__ ((__nonnull__ (1))) __attribute__ ((__deprecated__));


extern int pthread_attr_getstacksize (const pthread_attr_t *__restrict
          __attr, size_t *__restrict __stacksize)
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern int pthread_attr_setstacksize (pthread_attr_t *__attr,
          size_t __stacksize)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_attr_getstack (const pthread_attr_t *__restrict __attr,
      void **__restrict __stackaddr,
      size_t *__restrict __stacksize)
     throw () __attribute__ ((__nonnull__ (1, 2, 3)));




extern int pthread_attr_setstack (pthread_attr_t *__attr, void *__stackaddr,
      size_t __stacksize) throw () __attribute__ ((__nonnull__ (1)));





extern int pthread_attr_setaffinity_np (pthread_attr_t *__attr,
     size_t __cpusetsize,
     const cpu_set_t *__cpuset)
     throw () __attribute__ ((__nonnull__ (1, 3)));



extern int pthread_attr_getaffinity_np (const pthread_attr_t *__attr,
     size_t __cpusetsize,
     cpu_set_t *__cpuset)
     throw () __attribute__ ((__nonnull__ (1, 3)));


extern int pthread_getattr_default_np (pthread_attr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_setattr_default_np (const pthread_attr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));




extern int pthread_getattr_np (pthread_t __th, pthread_attr_t *__attr)
     throw () __attribute__ ((__nonnull__ (2)));







extern int pthread_setschedparam (pthread_t __target_thread, int __policy,
      const struct sched_param *__param)
     throw () __attribute__ ((__nonnull__ (3)));


extern int pthread_getschedparam (pthread_t __target_thread,
      int *__restrict __policy,
      struct sched_param *__restrict __param)
     throw () __attribute__ ((__nonnull__ (2, 3)));


extern int pthread_setschedprio (pthread_t __target_thread, int __prio)
     throw ();




extern int pthread_getname_np (pthread_t __target_thread, char *__buf,
          size_t __buflen)
     throw () __attribute__ ((__nonnull__ (2)));


extern int pthread_setname_np (pthread_t __target_thread, const char *__name)
     throw () __attribute__ ((__nonnull__ (2)));





extern int pthread_getconcurrency (void) throw ();


extern int pthread_setconcurrency (int __level) throw ();







extern int pthread_yield (void) throw ();




extern int pthread_setaffinity_np (pthread_t __th, size_t __cpusetsize,
       const cpu_set_t *__cpuset)
     throw () __attribute__ ((__nonnull__ (3)));


extern int pthread_getaffinity_np (pthread_t __th, size_t __cpusetsize,
       cpu_set_t *__cpuset)
     throw () __attribute__ ((__nonnull__ (3)));
# 495 "/usr/include/pthread.h" 3 4
extern int pthread_once (pthread_once_t *__once_control,
    void (*__init_routine) (void)) __attribute__ ((__nonnull__ (1, 2)));
# 507 "/usr/include/pthread.h" 3 4
extern int pthread_setcancelstate (int __state, int *__oldstate);



extern int pthread_setcanceltype (int __type, int *__oldtype);


extern int pthread_cancel (pthread_t __th);




extern void pthread_testcancel (void);




typedef struct
{
  struct
  {
    __jmp_buf __cancel_jmp_buf;
    int __mask_was_saved;
  } __cancel_jmp_buf[1];
  void *__pad[4];
} __pthread_unwind_buf_t __attribute__ ((__aligned__));
# 541 "/usr/include/pthread.h" 3 4
struct __pthread_cleanup_frame
{
  void (*__cancel_routine) (void *);
  void *__cancel_arg;
  int __do_it;
  int __cancel_type;
};
# 681 "/usr/include/pthread.h" 3 4
extern void __pthread_register_cancel (__pthread_unwind_buf_t *__buf)
                            ;
# 693 "/usr/include/pthread.h" 3 4
extern void __pthread_unregister_cancel (__pthread_unwind_buf_t *__buf)
                         ;
# 716 "/usr/include/pthread.h" 3 4
extern void __pthread_register_cancel_defer (__pthread_unwind_buf_t *__buf)
                            ;
# 729 "/usr/include/pthread.h" 3 4
extern void __pthread_unregister_cancel_restore (__pthread_unwind_buf_t *__buf)
                         ;



extern void __pthread_unwind_next (__pthread_unwind_buf_t *__buf)
                             __attribute__ ((__noreturn__))

     __attribute__ ((__weak__))

     ;



struct __jmp_buf_tag;
extern int __sigsetjmp (struct __jmp_buf_tag *__env, int __savemask) throw ();





extern int pthread_mutex_init (pthread_mutex_t *__mutex,
          const pthread_mutexattr_t *__mutexattr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutex_destroy (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutex_trylock (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutex_lock (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_mutex_timedlock (pthread_mutex_t *__restrict __mutex,
        const struct timespec *__restrict
        __abstime) throw () __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_mutex_unlock (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_mutex_getprioceiling (const pthread_mutex_t *
      __restrict __mutex,
      int *__restrict __prioceiling)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_mutex_setprioceiling (pthread_mutex_t *__restrict __mutex,
      int __prioceiling,
      int *__restrict __old_ceiling)
     throw () __attribute__ ((__nonnull__ (1, 3)));




extern int pthread_mutex_consistent (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));

extern int pthread_mutex_consistent_np (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));
# 807 "/usr/include/pthread.h" 3 4
extern int pthread_mutexattr_init (pthread_mutexattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutexattr_destroy (pthread_mutexattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutexattr_getpshared (const pthread_mutexattr_t *
      __restrict __attr,
      int *__restrict __pshared)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_mutexattr_setpshared (pthread_mutexattr_t *__attr,
      int __pshared)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_mutexattr_gettype (const pthread_mutexattr_t *__restrict
          __attr, int *__restrict __kind)
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern int pthread_mutexattr_settype (pthread_mutexattr_t *__attr, int __kind)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_mutexattr_getprotocol (const pthread_mutexattr_t *
       __restrict __attr,
       int *__restrict __protocol)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_mutexattr_setprotocol (pthread_mutexattr_t *__attr,
       int __protocol)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutexattr_getprioceiling (const pthread_mutexattr_t *
          __restrict __attr,
          int *__restrict __prioceiling)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_mutexattr_setprioceiling (pthread_mutexattr_t *__attr,
          int __prioceiling)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_mutexattr_getrobust (const pthread_mutexattr_t *__attr,
     int *__robustness)
     throw () __attribute__ ((__nonnull__ (1, 2)));

extern int pthread_mutexattr_getrobust_np (const pthread_mutexattr_t *__attr,
        int *__robustness)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_mutexattr_setrobust (pthread_mutexattr_t *__attr,
     int __robustness)
     throw () __attribute__ ((__nonnull__ (1)));

extern int pthread_mutexattr_setrobust_np (pthread_mutexattr_t *__attr,
        int __robustness)
     throw () __attribute__ ((__nonnull__ (1)));
# 889 "/usr/include/pthread.h" 3 4
extern int pthread_rwlock_init (pthread_rwlock_t *__restrict __rwlock,
    const pthread_rwlockattr_t *__restrict
    __attr) throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlock_destroy (pthread_rwlock_t *__rwlock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlock_rdlock (pthread_rwlock_t *__rwlock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlock_tryrdlock (pthread_rwlock_t *__rwlock)
  throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_rwlock_timedrdlock (pthread_rwlock_t *__restrict __rwlock,
           const struct timespec *__restrict
           __abstime) throw () __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_rwlock_wrlock (pthread_rwlock_t *__rwlock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlock_trywrlock (pthread_rwlock_t *__rwlock)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_rwlock_timedwrlock (pthread_rwlock_t *__restrict __rwlock,
           const struct timespec *__restrict
           __abstime) throw () __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_rwlock_unlock (pthread_rwlock_t *__rwlock)
     throw () __attribute__ ((__nonnull__ (1)));





extern int pthread_rwlockattr_init (pthread_rwlockattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlockattr_destroy (pthread_rwlockattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlockattr_getpshared (const pthread_rwlockattr_t *
       __restrict __attr,
       int *__restrict __pshared)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_rwlockattr_setpshared (pthread_rwlockattr_t *__attr,
       int __pshared)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlockattr_getkind_np (const pthread_rwlockattr_t *
       __restrict __attr,
       int *__restrict __pref)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_rwlockattr_setkind_np (pthread_rwlockattr_t *__attr,
       int __pref) throw () __attribute__ ((__nonnull__ (1)));







extern int pthread_cond_init (pthread_cond_t *__restrict __cond,
         const pthread_condattr_t *__restrict __cond_attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_cond_destroy (pthread_cond_t *__cond)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_cond_signal (pthread_cond_t *__cond)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_cond_broadcast (pthread_cond_t *__cond)
     throw () __attribute__ ((__nonnull__ (1)));






extern int pthread_cond_wait (pthread_cond_t *__restrict __cond,
         pthread_mutex_t *__restrict __mutex)
     __attribute__ ((__nonnull__ (1, 2)));
# 1001 "/usr/include/pthread.h" 3 4
extern int pthread_cond_timedwait (pthread_cond_t *__restrict __cond,
       pthread_mutex_t *__restrict __mutex,
       const struct timespec *__restrict __abstime)
     __attribute__ ((__nonnull__ (1, 2, 3)));




extern int pthread_condattr_init (pthread_condattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_condattr_destroy (pthread_condattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_condattr_getpshared (const pthread_condattr_t *
     __restrict __attr,
     int *__restrict __pshared)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_condattr_setpshared (pthread_condattr_t *__attr,
     int __pshared) throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_condattr_getclock (const pthread_condattr_t *
          __restrict __attr,
          __clockid_t *__restrict __clock_id)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_condattr_setclock (pthread_condattr_t *__attr,
          __clockid_t __clock_id)
     throw () __attribute__ ((__nonnull__ (1)));
# 1045 "/usr/include/pthread.h" 3 4
extern int pthread_spin_init (pthread_spinlock_t *__lock, int __pshared)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_spin_destroy (pthread_spinlock_t *__lock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_spin_lock (pthread_spinlock_t *__lock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_spin_trylock (pthread_spinlock_t *__lock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_spin_unlock (pthread_spinlock_t *__lock)
     throw () __attribute__ ((__nonnull__ (1)));






extern int pthread_barrier_init (pthread_barrier_t *__restrict __barrier,
     const pthread_barrierattr_t *__restrict
     __attr, unsigned int __count)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_barrier_destroy (pthread_barrier_t *__barrier)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_barrier_wait (pthread_barrier_t *__barrier)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_barrierattr_init (pthread_barrierattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_barrierattr_destroy (pthread_barrierattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_barrierattr_getpshared (const pthread_barrierattr_t *
        __restrict __attr,
        int *__restrict __pshared)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_barrierattr_setpshared (pthread_barrierattr_t *__attr,
        int __pshared)
     throw () __attribute__ ((__nonnull__ (1)));
# 1112 "/usr/include/pthread.h" 3 4
extern int pthread_key_create (pthread_key_t *__key,
          void (*__destr_function) (void *))
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_key_delete (pthread_key_t __key) throw ();


extern void *pthread_getspecific (pthread_key_t __key) throw ();


extern int pthread_setspecific (pthread_key_t __key,
    const void *__pointer) throw () ;




extern int pthread_getcpuclockid (pthread_t __thread_id,
      __clockid_t *__clock_id)
     throw () __attribute__ ((__nonnull__ (2)));
# 1146 "/usr/include/pthread.h" 3 4
extern int pthread_atfork (void (*__prepare) (void),
      void (*__parent) (void),
      void (*__child) (void)) throw ();




extern __inline __attribute__ ((__gnu_inline__)) int
 pthread_equal (pthread_t __thread1, pthread_t __thread2) throw ()
{
  return __thread1 == __thread2;
}


}
# 43 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__threading_support" 2 3
# 54 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__threading_support" 3
typedef ::timespec __libcpp_timespec_t;


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {





typedef pthread_mutex_t __libcpp_mutex_t;


typedef pthread_mutex_t __libcpp_recursive_mutex_t;


typedef pthread_cond_t __libcpp_condvar_t;



typedef pthread_once_t __libcpp_exec_once_flag;






  typedef pthread_t __libcpp_thread_id;




typedef pthread_t __libcpp_thread_t;


typedef pthread_key_t __libcpp_tls_key;
# 157 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__threading_support" 3
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
int __libcpp_recursive_mutex_init(__libcpp_recursive_mutex_t *__m);

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
int __libcpp_recursive_mutex_lock(__libcpp_recursive_mutex_t *__m);

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
bool __libcpp_recursive_mutex_trylock(__libcpp_recursive_mutex_t *__m);

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
int __libcpp_recursive_mutex_unlock(__libcpp_recursive_mutex_t *__m);

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
int __libcpp_recursive_mutex_destroy(__libcpp_recursive_mutex_t *__m);

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
int __libcpp_mutex_lock(__libcpp_mutex_t *__m);

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
bool __libcpp_mutex_trylock(__libcpp_mutex_t *__m);

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
int __libcpp_mutex_unlock(__libcpp_mutex_t *__m);

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
int __libcpp_mutex_destroy(__libcpp_mutex_t *__m);


inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
int __libcpp_condvar_signal(__libcpp_condvar_t* __cv);

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
int __libcpp_condvar_broadcast(__libcpp_condvar_t* __cv);

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
int __libcpp_condvar_wait(__libcpp_condvar_t* __cv, __libcpp_mutex_t* __m);

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
int __libcpp_condvar_timedwait(__libcpp_condvar_t *__cv, __libcpp_mutex_t *__m,
                               __libcpp_timespec_t *__ts);

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
int __libcpp_condvar_destroy(__libcpp_condvar_t* __cv);


inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
int __libcpp_execute_once(__libcpp_exec_once_flag *__flag,
                          void (*__init_routine)());


inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
bool __libcpp_thread_id_equal(__libcpp_thread_id __t1, __libcpp_thread_id __t2);

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
bool __libcpp_thread_id_less(__libcpp_thread_id __t1, __libcpp_thread_id __t2);


inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
bool __libcpp_thread_isnull(const __libcpp_thread_t *__t);

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
int __libcpp_thread_create(__libcpp_thread_t *__t, void *(*__func)(void *),
                           void *__arg);

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
__libcpp_thread_id __libcpp_thread_get_current_id();

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
__libcpp_thread_id __libcpp_thread_get_id(const __libcpp_thread_t *__t);

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
int __libcpp_thread_join(__libcpp_thread_t *__t);

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
int __libcpp_thread_detach(__libcpp_thread_t *__t);

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
void __libcpp_thread_yield();

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
void __libcpp_thread_sleep_for(const chrono::nanoseconds& __ns);


inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
int __libcpp_tls_create(__libcpp_tls_key* __key,
                        void(* __at_exit)(void*));

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
void *__libcpp_tls_get(__libcpp_tls_key __key);

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
int __libcpp_tls_set(__libcpp_tls_key __key, void *__p);





int __libcpp_recursive_mutex_init(__libcpp_recursive_mutex_t *__m)
{
  pthread_mutexattr_t __attr;
  int __ec = pthread_mutexattr_init(&__attr);
  if (__ec)
    return __ec;
  __ec = pthread_mutexattr_settype(&__attr, PTHREAD_MUTEX_RECURSIVE);
  if (__ec) {
    pthread_mutexattr_destroy(&__attr);
    return __ec;
  }
  __ec = pthread_mutex_init(__m, &__attr);
  if (__ec) {
    pthread_mutexattr_destroy(&__attr);
    return __ec;
  }
  __ec = pthread_mutexattr_destroy(&__attr);
  if (__ec) {
    pthread_mutex_destroy(__m);
    return __ec;
  }
  return 0;
}

int __libcpp_recursive_mutex_lock(__libcpp_recursive_mutex_t *__m)
{
  return pthread_mutex_lock(__m);
}

bool __libcpp_recursive_mutex_trylock(__libcpp_recursive_mutex_t *__m)
{
  return pthread_mutex_trylock(__m) == 0;
}

int __libcpp_recursive_mutex_unlock(__libcpp_recursive_mutex_t *__m)
{
  return pthread_mutex_unlock(__m);
}

int __libcpp_recursive_mutex_destroy(__libcpp_recursive_mutex_t *__m)
{
  return pthread_mutex_destroy(__m);
}

int __libcpp_mutex_lock(__libcpp_mutex_t *__m)
{
  return pthread_mutex_lock(__m);
}

bool __libcpp_mutex_trylock(__libcpp_mutex_t *__m)
{
  return pthread_mutex_trylock(__m) == 0;
}

int __libcpp_mutex_unlock(__libcpp_mutex_t *__m)
{
  return pthread_mutex_unlock(__m);
}

int __libcpp_mutex_destroy(__libcpp_mutex_t *__m)
{
  return pthread_mutex_destroy(__m);
}


int __libcpp_condvar_signal(__libcpp_condvar_t *__cv)
{
  return pthread_cond_signal(__cv);
}

int __libcpp_condvar_broadcast(__libcpp_condvar_t *__cv)
{
  return pthread_cond_broadcast(__cv);
}

int __libcpp_condvar_wait(__libcpp_condvar_t *__cv, __libcpp_mutex_t *__m)
{
  return pthread_cond_wait(__cv, __m);
}

int __libcpp_condvar_timedwait(__libcpp_condvar_t *__cv, __libcpp_mutex_t *__m,
                               __libcpp_timespec_t *__ts)
{
  return pthread_cond_timedwait(__cv, __m, __ts);
}

int __libcpp_condvar_destroy(__libcpp_condvar_t *__cv)
{
  return pthread_cond_destroy(__cv);
}


int __libcpp_execute_once(__libcpp_exec_once_flag *__flag,
                          void (*__init_routine)()) {
  return pthread_once(__flag, __init_routine);
}



bool __libcpp_thread_id_equal(__libcpp_thread_id __t1, __libcpp_thread_id __t2)
{
  return __t1 == __t2;
}


bool __libcpp_thread_id_less(__libcpp_thread_id __t1, __libcpp_thread_id __t2)
{
  return __t1 < __t2;
}


bool __libcpp_thread_isnull(const __libcpp_thread_t *__t) {
  return __libcpp_thread_get_id(__t) == 0;
}

int __libcpp_thread_create(__libcpp_thread_t *__t, void *(*__func)(void *),
                           void *__arg)
{
  return pthread_create(__t, nullptr, __func, __arg);
}

__libcpp_thread_id __libcpp_thread_get_current_id()
{
  const __libcpp_thread_t __current_thread = pthread_self();
  return __libcpp_thread_get_id(&__current_thread);
}

__libcpp_thread_id __libcpp_thread_get_id(const __libcpp_thread_t *__t)
{



  return *__t;

}

int __libcpp_thread_join(__libcpp_thread_t *__t)
{
  return pthread_join(*__t, nullptr);
}

int __libcpp_thread_detach(__libcpp_thread_t *__t)
{
  return pthread_detach(*__t);
}

void __libcpp_thread_yield()
{
  sched_yield();
}

void __libcpp_thread_sleep_for(const chrono::nanoseconds& __ns)
{
   __libcpp_timespec_t __ts = std::__convert_to_timespec<__libcpp_timespec_t>(__ns);
   while (nanosleep(&__ts, &__ts) == -1 && (*__errno_location ()) == 4);
}


int __libcpp_tls_create(__libcpp_tls_key *__key, void (*__at_exit)(void *))
{
  return pthread_key_create(__key, __at_exit);
}

void *__libcpp_tls_get(__libcpp_tls_key __key)
{
  return pthread_getspecific(__key);
}

int __libcpp_tls_set(__libcpp_tls_key __key, void *__p)
{
    return pthread_setspecific(__key, __p);
}
# 588 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__threading_support" 3
}}
# 21 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__atomic/atomic_sync.h" 2 3
# 26 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__atomic/atomic_sync.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {



                          __attribute__((__visibility__("default"))) void __cxx_atomic_notify_one(void const volatile*);
                          __attribute__((__visibility__("default"))) void __cxx_atomic_notify_all(void const volatile*);
                          __attribute__((__visibility__("default"))) __cxx_contention_t __libcpp_atomic_monitor(void const volatile*);
                          __attribute__((__visibility__("default"))) void __libcpp_atomic_wait(void const volatile*, __cxx_contention_t);

                          __attribute__((__visibility__("default"))) void __cxx_atomic_notify_one(__cxx_atomic_contention_t const volatile*);
                          __attribute__((__visibility__("default"))) void __cxx_atomic_notify_all(__cxx_atomic_contention_t const volatile*);
                          __attribute__((__visibility__("default"))) __cxx_contention_t __libcpp_atomic_monitor(__cxx_atomic_contention_t const volatile*);
                          __attribute__((__visibility__("default"))) void __libcpp_atomic_wait(__cxx_atomic_contention_t const volatile*, __cxx_contention_t);

template <class _Atp, class _Fn>
struct __libcpp_atomic_wait_backoff_impl {
    _Atp* __a;
    _Fn __test_fn;

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) bool operator()(chrono::nanoseconds __elapsed) const
    {
        if(__elapsed > chrono::microseconds(64))
        {
            auto const __monitor = std::__libcpp_atomic_monitor(__a);
            if(__test_fn())
                return true;
            std::__libcpp_atomic_wait(__a, __monitor);
        }
        else if(__elapsed > chrono::microseconds(4))
            __libcpp_thread_yield();
        else
            {}
        return false;
    }
};

template <class _Atp, class _Fn>

__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) bool __cxx_atomic_wait(_Atp* __a, _Fn && __test_fn)
{
    __libcpp_atomic_wait_backoff_impl<_Atp, __decay_t<_Fn> > __backoff_fn = {__a, __test_fn};
    return std::__libcpp_thread_poll_with_backoff(__test_fn, __backoff_fn);
}
# 86 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__atomic/atomic_sync.h" 3
template <typename _Tp> __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
bool __cxx_nonatomic_compare_equal(_Tp const& __lhs, _Tp const& __rhs) {
    return std::memcmp(std::addressof(__lhs), std::addressof(__rhs), sizeof(_Tp)) == 0;
}

template <class _Atp, class _Tp>
struct __cxx_atomic_wait_test_fn_impl {
    _Atp* __a;
    _Tp __val;
    memory_order __order;
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) bool operator()() const
    {
        return !std::__cxx_nonatomic_compare_equal(std::__cxx_atomic_load(__a, __order), __val);
    }
};

template <class _Atp, class _Tp>

__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) bool __cxx_atomic_wait(_Atp* __a, _Tp const __val, memory_order __order)
{
    __cxx_atomic_wait_test_fn_impl<_Atp, _Tp> __test_fn = {__a, __val, __order};
    return std::__cxx_atomic_wait(__a, __test_fn);
}

}}
# 13 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__atomic/atomic_base.h" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__atomic/check_memory_order.h" 1 3
# 16 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__atomic/check_memory_order.h" 3
# 14 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__atomic/atomic_base.h" 2 3
# 27 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__atomic/atomic_base.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Tp, bool = is_integral<_Tp>::value && !is_same<_Tp, bool>::value>
struct __atomic_base
{
    mutable __cxx_atomic_impl<_Tp> __a_;


  static constexpr bool is_always_lock_free = __libcpp_is_always_lock_free<__cxx_atomic_impl<_Tp> >::__value;


    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    bool is_lock_free() const volatile noexcept
        {return __c11_atomic_is_lock_free(sizeof(_Tp));}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    bool is_lock_free() const noexcept
        {return static_cast<__atomic_base const volatile*>(this)->is_lock_free();}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) void store(_Tp __d, memory_order __m = memory_order_seq_cst) volatile noexcept
        __attribute__((__diagnose_if__(__m == memory_order_consume || __m == memory_order_acquire || __m == memory_order_acq_rel, "memory order argument to atomic operation is invalid", "warning"))) {
      std::__cxx_atomic_store(std::addressof(__a_), __d, __m);
    }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) void store(_Tp __d, memory_order __m = memory_order_seq_cst) noexcept
        __attribute__((__diagnose_if__(__m == memory_order_consume || __m == memory_order_acquire || __m == memory_order_acq_rel, "memory order argument to atomic operation is invalid", "warning"))) {
      std::__cxx_atomic_store(std::addressof(__a_), __d, __m);
    }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) _Tp load(memory_order __m = memory_order_seq_cst) const volatile noexcept
        __attribute__((__diagnose_if__(__m == memory_order_release || __m == memory_order_acq_rel, "memory order argument to atomic operation is invalid", "warning"))) {
      return std::__cxx_atomic_load(std::addressof(__a_), __m);
    }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) _Tp load(memory_order __m = memory_order_seq_cst) const noexcept
        __attribute__((__diagnose_if__(__m == memory_order_release || __m == memory_order_acq_rel, "memory order argument to atomic operation is invalid", "warning"))) {
      return std::__cxx_atomic_load(std::addressof(__a_), __m);
    }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    operator _Tp() const volatile noexcept {return load();}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    operator _Tp() const noexcept {return load();}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) _Tp exchange(_Tp __d, memory_order __m = memory_order_seq_cst) volatile noexcept {
      return std::__cxx_atomic_exchange(std::addressof(__a_), __d, __m);
    }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) _Tp exchange(_Tp __d, memory_order __m = memory_order_seq_cst) noexcept {
      return std::__cxx_atomic_exchange(std::addressof(__a_), __d, __m);
    }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) bool
    compare_exchange_weak(_Tp& __e, _Tp __d, memory_order __s, memory_order __f) volatile noexcept
        __attribute__((__diagnose_if__(__f == memory_order_release || __f == memory_order_acq_rel, "memory order argument to atomic operation is invalid", "warning"))) {
      return std::__cxx_atomic_compare_exchange_weak(std::addressof(__a_), std::addressof(__e), __d, __s, __f);
    }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) bool compare_exchange_weak(_Tp& __e, _Tp __d, memory_order __s, memory_order __f) noexcept
        __attribute__((__diagnose_if__(__f == memory_order_release || __f == memory_order_acq_rel, "memory order argument to atomic operation is invalid", "warning"))) {
      return std::__cxx_atomic_compare_exchange_weak(std::addressof(__a_), std::addressof(__e), __d, __s, __f);
    }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) bool
    compare_exchange_strong(_Tp& __e, _Tp __d, memory_order __s, memory_order __f) volatile noexcept
        __attribute__((__diagnose_if__(__f == memory_order_release || __f == memory_order_acq_rel, "memory order argument to atomic operation is invalid", "warning"))) {
      return std::__cxx_atomic_compare_exchange_strong(std::addressof(__a_), std::addressof(__e), __d, __s, __f);
    }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) bool compare_exchange_strong(_Tp& __e, _Tp __d, memory_order __s, memory_order __f) noexcept
        __attribute__((__diagnose_if__(__f == memory_order_release || __f == memory_order_acq_rel, "memory order argument to atomic operation is invalid", "warning"))) {
      return std::__cxx_atomic_compare_exchange_strong(std::addressof(__a_), std::addressof(__e), __d, __s, __f);
    }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) bool
    compare_exchange_weak(_Tp& __e, _Tp __d, memory_order __m = memory_order_seq_cst) volatile noexcept {
      return std::__cxx_atomic_compare_exchange_weak(std::addressof(__a_), std::addressof(__e), __d, __m, __m);
    }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) bool
    compare_exchange_weak(_Tp& __e, _Tp __d, memory_order __m = memory_order_seq_cst) noexcept {
      return std::__cxx_atomic_compare_exchange_weak(std::addressof(__a_), std::addressof(__e), __d, __m, __m);
    }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) bool
    compare_exchange_strong(_Tp& __e, _Tp __d, memory_order __m = memory_order_seq_cst) volatile noexcept {
      return std::__cxx_atomic_compare_exchange_strong(std::addressof(__a_), std::addressof(__e), __d, __m, __m);
    }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) bool
    compare_exchange_strong(_Tp& __e, _Tp __d, memory_order __m = memory_order_seq_cst) noexcept {
      return std::__cxx_atomic_compare_exchange_strong(std::addressof(__a_), std::addressof(__e), __d, __m, __m);
    }

                              __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) void wait(_Tp __v, memory_order __m = memory_order_seq_cst) const
        volatile noexcept {
      std::__cxx_atomic_wait(std::addressof(__a_), __v, __m);
    }
                              __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) void
    wait(_Tp __v, memory_order __m = memory_order_seq_cst) const noexcept {
      std::__cxx_atomic_wait(std::addressof(__a_), __v, __m);
    }
                              __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) void notify_one() volatile noexcept {
      std::__cxx_atomic_notify_one(std::addressof(__a_));
    }
                              __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) void notify_one() noexcept {
      std::__cxx_atomic_notify_one(std::addressof(__a_));
    }
                              __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) void notify_all() volatile noexcept {
      std::__cxx_atomic_notify_all(std::addressof(__a_));
    }
                              __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) void notify_all() noexcept {
      std::__cxx_atomic_notify_all(std::addressof(__a_));
    }


    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    __atomic_base() noexcept(is_nothrow_default_constructible_v<_Tp>) : __a_(_Tp()) {}





    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    __atomic_base(_Tp __d) noexcept : __a_(__d) {}

    __atomic_base(const __atomic_base&) = delete;
};


template <class _Tp, bool __b>
constexpr bool __atomic_base<_Tp, __b>::is_always_lock_free;




template <class _Tp>
struct __atomic_base<_Tp, true>
    : public __atomic_base<_Tp, false>
{
    using __base = __atomic_base<_Tp, false>;

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    __atomic_base() noexcept = default;

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    constexpr __atomic_base(_Tp __d) noexcept : __base(__d) {}

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) _Tp fetch_add(_Tp __op, memory_order __m = memory_order_seq_cst) volatile noexcept {
      return std::__cxx_atomic_fetch_add(std::addressof(this->__a_), __op, __m);
    }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) _Tp fetch_add(_Tp __op, memory_order __m = memory_order_seq_cst) noexcept {
      return std::__cxx_atomic_fetch_add(std::addressof(this->__a_), __op, __m);
    }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) _Tp fetch_sub(_Tp __op, memory_order __m = memory_order_seq_cst) volatile noexcept {
      return std::__cxx_atomic_fetch_sub(std::addressof(this->__a_), __op, __m);
    }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) _Tp fetch_sub(_Tp __op, memory_order __m = memory_order_seq_cst) noexcept {
      return std::__cxx_atomic_fetch_sub(std::addressof(this->__a_), __op, __m);
    }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) _Tp fetch_and(_Tp __op, memory_order __m = memory_order_seq_cst) volatile noexcept {
      return std::__cxx_atomic_fetch_and(std::addressof(this->__a_), __op, __m);
    }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) _Tp fetch_and(_Tp __op, memory_order __m = memory_order_seq_cst) noexcept {
      return std::__cxx_atomic_fetch_and(std::addressof(this->__a_), __op, __m);
    }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) _Tp fetch_or(_Tp __op, memory_order __m = memory_order_seq_cst) volatile noexcept {
      return std::__cxx_atomic_fetch_or(std::addressof(this->__a_), __op, __m);
    }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) _Tp fetch_or(_Tp __op, memory_order __m = memory_order_seq_cst) noexcept {
      return std::__cxx_atomic_fetch_or(std::addressof(this->__a_), __op, __m);
    }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) _Tp fetch_xor(_Tp __op, memory_order __m = memory_order_seq_cst) volatile noexcept {
      return std::__cxx_atomic_fetch_xor(std::addressof(this->__a_), __op, __m);
    }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) _Tp fetch_xor(_Tp __op, memory_order __m = memory_order_seq_cst) noexcept {
      return std::__cxx_atomic_fetch_xor(std::addressof(this->__a_), __op, __m);
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    _Tp operator++(int) volatile noexcept {return fetch_add(_Tp(1));}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    _Tp operator++(int) noexcept {return fetch_add(_Tp(1));}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    _Tp operator--(int) volatile noexcept {return fetch_sub(_Tp(1));}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    _Tp operator--(int) noexcept {return fetch_sub(_Tp(1));}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    _Tp operator++() volatile noexcept {return fetch_add(_Tp(1)) + _Tp(1);}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    _Tp operator++() noexcept {return fetch_add(_Tp(1)) + _Tp(1);}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    _Tp operator--() volatile noexcept {return fetch_sub(_Tp(1)) - _Tp(1);}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    _Tp operator--() noexcept {return fetch_sub(_Tp(1)) - _Tp(1);}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    _Tp operator+=(_Tp __op) volatile noexcept {return fetch_add(__op) + __op;}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    _Tp operator+=(_Tp __op) noexcept {return fetch_add(__op) + __op;}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    _Tp operator-=(_Tp __op) volatile noexcept {return fetch_sub(__op) - __op;}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    _Tp operator-=(_Tp __op) noexcept {return fetch_sub(__op) - __op;}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    _Tp operator&=(_Tp __op) volatile noexcept {return fetch_and(__op) & __op;}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    _Tp operator&=(_Tp __op) noexcept {return fetch_and(__op) & __op;}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    _Tp operator|=(_Tp __op) volatile noexcept {return fetch_or(__op) | __op;}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    _Tp operator|=(_Tp __op) noexcept {return fetch_or(__op) | __op;}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    _Tp operator^=(_Tp __op) volatile noexcept {return fetch_xor(__op) ^ __op;}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    _Tp operator^=(_Tp __op) noexcept {return fetch_xor(__op) ^ __op;}
};

}}
# 13 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__atomic/atomic.h" 2 3
# 25 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__atomic/atomic.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Tp>
struct atomic
    : public __atomic_base<_Tp>
{
  using __base = __atomic_base<_Tp>;
  using value_type = _Tp;
  using difference_type = value_type;


    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    atomic() = default;





    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    constexpr atomic(_Tp __d) noexcept : __base(__d) {}

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    _Tp operator=(_Tp __d) volatile noexcept
        {__base::store(__d); return __d;}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    _Tp operator=(_Tp __d) noexcept
        {__base::store(__d); return __d;}

    atomic& operator=(const atomic&) = delete;
    atomic& operator=(const atomic&) volatile = delete;
};



template <class _Tp>
struct atomic<_Tp*>
    : public __atomic_base<_Tp*>
{
    using __base = __atomic_base<_Tp*>;
    using value_type = _Tp*;
    using difference_type = ptrdiff_t;

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    atomic() noexcept = default;

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    constexpr atomic(_Tp* __d) noexcept : __base(__d) {}

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    _Tp* operator=(_Tp* __d) volatile noexcept
        {__base::store(__d); return __d;}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    _Tp* operator=(_Tp* __d) noexcept
        {__base::store(__d); return __d;}

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    _Tp* fetch_add(ptrdiff_t __op, memory_order __m = memory_order_seq_cst) volatile noexcept {

        static_assert(!is_function<__remove_pointer_t<_Tp> >::value, "Pointer to function isn't allowed");
        return std::__cxx_atomic_fetch_add(std::addressof(this->__a_), __op, __m);
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    _Tp* fetch_add(ptrdiff_t __op, memory_order __m = memory_order_seq_cst) noexcept {

        static_assert(!is_function<__remove_pointer_t<_Tp> >::value, "Pointer to function isn't allowed");
        return std::__cxx_atomic_fetch_add(std::addressof(this->__a_), __op, __m);
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    _Tp* fetch_sub(ptrdiff_t __op, memory_order __m = memory_order_seq_cst) volatile noexcept {

        static_assert(!is_function<__remove_pointer_t<_Tp> >::value, "Pointer to function isn't allowed");
        return std::__cxx_atomic_fetch_sub(std::addressof(this->__a_), __op, __m);
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    _Tp* fetch_sub(ptrdiff_t __op, memory_order __m = memory_order_seq_cst) noexcept {

        static_assert(!is_function<__remove_pointer_t<_Tp> >::value, "Pointer to function isn't allowed");
        return std::__cxx_atomic_fetch_sub(std::addressof(this->__a_), __op, __m);
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    _Tp* operator++(int) volatile noexcept {return fetch_add(1);}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    _Tp* operator++(int) noexcept {return fetch_add(1);}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    _Tp* operator--(int) volatile noexcept {return fetch_sub(1);}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    _Tp* operator--(int) noexcept {return fetch_sub(1);}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    _Tp* operator++() volatile noexcept {return fetch_add(1) + 1;}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    _Tp* operator++() noexcept {return fetch_add(1) + 1;}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    _Tp* operator--() volatile noexcept {return fetch_sub(1) - 1;}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    _Tp* operator--() noexcept {return fetch_sub(1) - 1;}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    _Tp* operator+=(ptrdiff_t __op) volatile noexcept {return fetch_add(__op) + __op;}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    _Tp* operator+=(ptrdiff_t __op) noexcept {return fetch_add(__op) + __op;}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    _Tp* operator-=(ptrdiff_t __op) volatile noexcept {return fetch_sub(__op) - __op;}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    _Tp* operator-=(ptrdiff_t __op) noexcept {return fetch_sub(__op) - __op;}

    atomic& operator=(const atomic&) = delete;
    atomic& operator=(const atomic&) volatile = delete;
};



template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
bool
atomic_is_lock_free(const volatile atomic<_Tp>* __o) noexcept
{
    return __o->is_lock_free();
}

template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
bool
atomic_is_lock_free(const atomic<_Tp>* __o) noexcept
{
    return __o->is_lock_free();
}



template <class _Tp>
__attribute__((__deprecated__)) __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
void
atomic_init(volatile atomic<_Tp>* __o, typename atomic<_Tp>::value_type __d) noexcept
{
    std::__cxx_atomic_init(std::addressof(__o->__a_), __d);
}

template <class _Tp>
__attribute__((__deprecated__)) __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
void
atomic_init(atomic<_Tp>* __o, typename atomic<_Tp>::value_type __d) noexcept
{
    std::__cxx_atomic_init(std::addressof(__o->__a_), __d);
}



template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
void
atomic_store(volatile atomic<_Tp>* __o, typename atomic<_Tp>::value_type __d) noexcept
{
    __o->store(__d);
}

template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
void
atomic_store(atomic<_Tp>* __o, typename atomic<_Tp>::value_type __d) noexcept
{
    __o->store(__d);
}



template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
void
atomic_store_explicit(volatile atomic<_Tp>* __o, typename atomic<_Tp>::value_type __d, memory_order __m) noexcept
  __attribute__((__diagnose_if__(__m == memory_order_consume || __m == memory_order_acquire || __m == memory_order_acq_rel, "memory order argument to atomic operation is invalid", "warning")))
{
    __o->store(__d, __m);
}

template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
void
atomic_store_explicit(atomic<_Tp>* __o, typename atomic<_Tp>::value_type __d, memory_order __m) noexcept
  __attribute__((__diagnose_if__(__m == memory_order_consume || __m == memory_order_acquire || __m == memory_order_acq_rel, "memory order argument to atomic operation is invalid", "warning")))
{
    __o->store(__d, __m);
}



template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
_Tp
atomic_load(const volatile atomic<_Tp>* __o) noexcept
{
    return __o->load();
}

template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
_Tp
atomic_load(const atomic<_Tp>* __o) noexcept
{
    return __o->load();
}



template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
_Tp
atomic_load_explicit(const volatile atomic<_Tp>* __o, memory_order __m) noexcept
  __attribute__((__diagnose_if__(__m == memory_order_release || __m == memory_order_acq_rel, "memory order argument to atomic operation is invalid", "warning")))
{
    return __o->load(__m);
}

template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
_Tp
atomic_load_explicit(const atomic<_Tp>* __o, memory_order __m) noexcept
  __attribute__((__diagnose_if__(__m == memory_order_release || __m == memory_order_acq_rel, "memory order argument to atomic operation is invalid", "warning")))
{
    return __o->load(__m);
}



template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
_Tp
atomic_exchange(volatile atomic<_Tp>* __o, typename atomic<_Tp>::value_type __d) noexcept
{
    return __o->exchange(__d);
}

template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
_Tp
atomic_exchange(atomic<_Tp>* __o, typename atomic<_Tp>::value_type __d) noexcept
{
    return __o->exchange(__d);
}



template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
_Tp
atomic_exchange_explicit(volatile atomic<_Tp>* __o, typename atomic<_Tp>::value_type __d, memory_order __m) noexcept
{
    return __o->exchange(__d, __m);
}

template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
_Tp
atomic_exchange_explicit(atomic<_Tp>* __o, typename atomic<_Tp>::value_type __d, memory_order __m) noexcept
{
    return __o->exchange(__d, __m);
}



template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
bool
atomic_compare_exchange_weak(volatile atomic<_Tp>* __o, typename atomic<_Tp>::value_type* __e, typename atomic<_Tp>::value_type __d) noexcept
{
    return __o->compare_exchange_weak(*__e, __d);
}

template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
bool
atomic_compare_exchange_weak(atomic<_Tp>* __o, typename atomic<_Tp>::value_type* __e, typename atomic<_Tp>::value_type __d) noexcept
{
    return __o->compare_exchange_weak(*__e, __d);
}



template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
bool
atomic_compare_exchange_strong(volatile atomic<_Tp>* __o, typename atomic<_Tp>::value_type* __e, typename atomic<_Tp>::value_type __d) noexcept
{
    return __o->compare_exchange_strong(*__e, __d);
}

template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
bool
atomic_compare_exchange_strong(atomic<_Tp>* __o, typename atomic<_Tp>::value_type* __e, typename atomic<_Tp>::value_type __d) noexcept
{
    return __o->compare_exchange_strong(*__e, __d);
}



template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
bool
atomic_compare_exchange_weak_explicit(volatile atomic<_Tp>* __o, typename atomic<_Tp>::value_type* __e,
                                      typename atomic<_Tp>::value_type __d,
                                      memory_order __s, memory_order __f) noexcept
  __attribute__((__diagnose_if__(__f == memory_order_release || __f == memory_order_acq_rel, "memory order argument to atomic operation is invalid", "warning")))
{
    return __o->compare_exchange_weak(*__e, __d, __s, __f);
}

template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
bool
atomic_compare_exchange_weak_explicit(atomic<_Tp>* __o, typename atomic<_Tp>::value_type* __e, typename atomic<_Tp>::value_type __d,
                                      memory_order __s, memory_order __f) noexcept
  __attribute__((__diagnose_if__(__f == memory_order_release || __f == memory_order_acq_rel, "memory order argument to atomic operation is invalid", "warning")))
{
    return __o->compare_exchange_weak(*__e, __d, __s, __f);
}



template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
bool
atomic_compare_exchange_strong_explicit(volatile atomic<_Tp>* __o,
                                        typename atomic<_Tp>::value_type* __e, typename atomic<_Tp>::value_type __d,
                                        memory_order __s, memory_order __f) noexcept
  __attribute__((__diagnose_if__(__f == memory_order_release || __f == memory_order_acq_rel, "memory order argument to atomic operation is invalid", "warning")))
{
    return __o->compare_exchange_strong(*__e, __d, __s, __f);
}

template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
bool
atomic_compare_exchange_strong_explicit(atomic<_Tp>* __o, typename atomic<_Tp>::value_type* __e,
                                        typename atomic<_Tp>::value_type __d,
                                        memory_order __s, memory_order __f) noexcept
  __attribute__((__diagnose_if__(__f == memory_order_release || __f == memory_order_acq_rel, "memory order argument to atomic operation is invalid", "warning")))
{
    return __o->compare_exchange_strong(*__e, __d, __s, __f);
}



template <class _Tp>
                          __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
void atomic_wait(const volatile atomic<_Tp>* __o,
                 typename atomic<_Tp>::value_type __v) noexcept
{
    return __o->wait(__v);
}

template <class _Tp>
                          __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
void atomic_wait(const atomic<_Tp>* __o,
                 typename atomic<_Tp>::value_type __v) noexcept
{
    return __o->wait(__v);
}



template <class _Tp>
                          __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
void atomic_wait_explicit(const volatile atomic<_Tp>* __o,
                          typename atomic<_Tp>::value_type __v,
                          memory_order __m) noexcept
  __attribute__((__diagnose_if__(__m == memory_order_release || __m == memory_order_acq_rel, "memory order argument to atomic operation is invalid", "warning")))
{
    return __o->wait(__v, __m);
}

template <class _Tp>
                          __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
void atomic_wait_explicit(const atomic<_Tp>* __o,
                          typename atomic<_Tp>::value_type __v,
                          memory_order __m) noexcept
  __attribute__((__diagnose_if__(__m == memory_order_release || __m == memory_order_acq_rel, "memory order argument to atomic operation is invalid", "warning")))
{
    return __o->wait(__v, __m);
}



template <class _Tp>
                          __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
void atomic_notify_one(volatile atomic<_Tp>* __o) noexcept
{
    __o->notify_one();
}
template <class _Tp>
                          __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
void atomic_notify_one(atomic<_Tp>* __o) noexcept
{
    __o->notify_one();
}



template <class _Tp>
                          __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
void atomic_notify_all(volatile atomic<_Tp>* __o) noexcept
{
    __o->notify_all();
}
template <class _Tp>
                          __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
void atomic_notify_all(atomic<_Tp>* __o) noexcept
{
    __o->notify_all();
}



template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
_Tp
atomic_fetch_add(volatile atomic<_Tp>* __o, typename atomic<_Tp>::difference_type __op) noexcept
{
    return __o->fetch_add(__op);
}

template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
_Tp
atomic_fetch_add(atomic<_Tp>* __o, typename atomic<_Tp>::difference_type __op) noexcept
{
    return __o->fetch_add(__op);
}



template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
_Tp atomic_fetch_add_explicit(volatile atomic<_Tp>* __o, typename atomic<_Tp>::difference_type __op, memory_order __m) noexcept
{
    return __o->fetch_add(__op, __m);
}

template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
_Tp atomic_fetch_add_explicit(atomic<_Tp>* __o, typename atomic<_Tp>::difference_type __op, memory_order __m) noexcept
{
    return __o->fetch_add(__op, __m);
}



template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
_Tp atomic_fetch_sub(volatile atomic<_Tp>* __o, typename atomic<_Tp>::difference_type __op) noexcept
{
    return __o->fetch_sub(__op);
}

template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
_Tp atomic_fetch_sub(atomic<_Tp>* __o, typename atomic<_Tp>::difference_type __op) noexcept
{
    return __o->fetch_sub(__op);
}



template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
_Tp atomic_fetch_sub_explicit(volatile atomic<_Tp>* __o, typename atomic<_Tp>::difference_type __op, memory_order __m) noexcept
{
    return __o->fetch_sub(__op, __m);
}

template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
_Tp atomic_fetch_sub_explicit(atomic<_Tp>* __o, typename atomic<_Tp>::difference_type __op, memory_order __m) noexcept
{
    return __o->fetch_sub(__op, __m);
}



template <class _Tp, __enable_if_t<is_integral<_Tp>::value && !is_same<_Tp, bool>::value, int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
_Tp
atomic_fetch_and(volatile atomic<_Tp>* __o, typename atomic<_Tp>::value_type __op) noexcept
{
    return __o->fetch_and(__op);
}

template <class _Tp, __enable_if_t<is_integral<_Tp>::value && !is_same<_Tp, bool>::value, int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
_Tp
atomic_fetch_and(atomic<_Tp>* __o, typename atomic<_Tp>::value_type __op) noexcept
{
    return __o->fetch_and(__op);
}



template <class _Tp, __enable_if_t<is_integral<_Tp>::value && !is_same<_Tp, bool>::value, int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
_Tp
atomic_fetch_and_explicit(volatile atomic<_Tp>* __o, typename atomic<_Tp>::value_type __op, memory_order __m) noexcept
{
    return __o->fetch_and(__op, __m);
}

template <class _Tp, __enable_if_t<is_integral<_Tp>::value && !is_same<_Tp, bool>::value, int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
_Tp
atomic_fetch_and_explicit(atomic<_Tp>* __o, typename atomic<_Tp>::value_type __op, memory_order __m) noexcept
{
    return __o->fetch_and(__op, __m);
}



template <class _Tp, __enable_if_t<is_integral<_Tp>::value && !is_same<_Tp, bool>::value, int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
_Tp
atomic_fetch_or(volatile atomic<_Tp>* __o, typename atomic<_Tp>::value_type __op) noexcept
{
    return __o->fetch_or(__op);
}

template <class _Tp, __enable_if_t<is_integral<_Tp>::value && !is_same<_Tp, bool>::value, int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
_Tp
atomic_fetch_or(atomic<_Tp>* __o, typename atomic<_Tp>::value_type __op) noexcept
{
    return __o->fetch_or(__op);
}



template <class _Tp, __enable_if_t<is_integral<_Tp>::value && !is_same<_Tp, bool>::value, int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
_Tp
atomic_fetch_or_explicit(volatile atomic<_Tp>* __o, typename atomic<_Tp>::value_type __op, memory_order __m) noexcept
{
    return __o->fetch_or(__op, __m);
}

template <class _Tp, __enable_if_t<is_integral<_Tp>::value && !is_same<_Tp, bool>::value, int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
_Tp
atomic_fetch_or_explicit(atomic<_Tp>* __o, typename atomic<_Tp>::value_type __op, memory_order __m) noexcept
{
    return __o->fetch_or(__op, __m);
}



template <class _Tp, __enable_if_t<is_integral<_Tp>::value && !is_same<_Tp, bool>::value, int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
_Tp
atomic_fetch_xor(volatile atomic<_Tp>* __o, typename atomic<_Tp>::value_type __op) noexcept
{
    return __o->fetch_xor(__op);
}

template <class _Tp, __enable_if_t<is_integral<_Tp>::value && !is_same<_Tp, bool>::value, int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
_Tp
atomic_fetch_xor(atomic<_Tp>* __o, typename atomic<_Tp>::value_type __op) noexcept
{
    return __o->fetch_xor(__op);
}



template <class _Tp, __enable_if_t<is_integral<_Tp>::value && !is_same<_Tp, bool>::value, int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
_Tp
atomic_fetch_xor_explicit(volatile atomic<_Tp>* __o, typename atomic<_Tp>::value_type __op, memory_order __m) noexcept
{
    return __o->fetch_xor(__op, __m);
}

template <class _Tp, __enable_if_t<is_integral<_Tp>::value && !is_same<_Tp, bool>::value, int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
_Tp
atomic_fetch_xor_explicit(atomic<_Tp>* __o, typename atomic<_Tp>::value_type __op, memory_order __m) noexcept
{
    return __o->fetch_xor(__op, __m);
}

}}
# 16 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/cpu_backends/any_of.h" 2 3




# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_execution_policy.h" 1 3
# 17 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_execution_policy.h" 3




namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class>
inline constexpr bool is_execution_policy_v = false;

template <class>
inline constexpr bool __is_unsequenced_execution_policy_impl = false;

template <class _Tp>
inline constexpr bool __is_unsequenced_execution_policy_v =
    __is_unsequenced_execution_policy_impl<__remove_cvref_t<_Tp>>;

template <class>
inline constexpr bool __is_parallel_execution_policy_impl = false;

template <class _Tp>
inline constexpr bool __is_parallel_execution_policy_v = __is_parallel_execution_policy_impl<__remove_cvref_t<_Tp>>;

namespace execution {
struct __disable_user_instantiations_tag {
  explicit __disable_user_instantiations_tag() = default;
};
}


template <class _ExecutionPolicy>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) auto
__remove_parallel_policy(const _ExecutionPolicy& = _ExecutionPolicy{execution::__disable_user_instantiations_tag{}});



template <class _ExecutionPolicy>
using __remove_parallel_policy_t = decltype(std::__remove_parallel_policy<_ExecutionPolicy>());

}}
# 21 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/cpu_backends/any_of.h" 2 3

# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__utility/terminate_on_exception.h" 1 3
# 13 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__utility/terminate_on_exception.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__exception/terminate.h" 1 3
# 16 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__exception/terminate.h" 3


namespace std {
[[noreturn]] __attribute__((__visibility__("default"))) void terminate() noexcept;
}
# 14 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__utility/terminate_on_exception.h" 2 3
# 18 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__utility/terminate_on_exception.h" 3




namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 37 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__utility/terminate_on_exception.h" 3
template <class _Func>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) auto __terminate_on_exception(_Func __func) {
  return __func();
}



}}
# 23 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/cpu_backends/any_of.h" 2 3




namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Index, class _Brick>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) bool __parallel_or(_Index __first, _Index __last, _Brick __f) {
  std::atomic<bool> __found(false);
  __par_backend::__parallel_for(__first, __last, [__f, &__found](_Index __i, _Index __j) {
    if (!__found.load(std::memory_order_relaxed) && __f(__i, __j)) {
      __found.store(true, std::memory_order_relaxed);
      __par_backend::__cancel_execution();
    }
  });
  return __found;
}


template <class _Index, class _DifferenceType, class _Pred>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) bool __simd_or(_Index __first, _DifferenceType __n, _Pred __pred) noexcept {
  _DifferenceType __block_size = 4 < __n ? 4 : __n;
  const _Index __last = __first + __n;
  while (__last != __first) {
    int32_t __flag = 1;
#pragma omp simd reduction(& : __flag)
    for (_DifferenceType __i = 0; __i < __block_size; ++__i)
      if (__pred(*(__first + __i)))
        __flag = 0;
    if (!__flag)
      return true;

    __first += __block_size;
    if (__last - __first >= __block_size << 1) {

      __block_size <<= 1;
    } else {
      __block_size = __last - __first;
    }
  }
  return false;
}

template <class _ExecutionPolicy, class _ForwardIterator, class _Predicate>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) bool
__pstl_any_of(__cpu_backend_tag, _ForwardIterator __first, _ForwardIterator __last, _Predicate __pred) {
  if constexpr (__is_parallel_execution_policy_v<_ExecutionPolicy> &&
                __has_random_access_iterator_category_or_concept<_ForwardIterator>::value) {
    return std::__terminate_on_exception([&] {
      return std::__parallel_or(
          __first, __last, [&__pred](_ForwardIterator __brick_first, _ForwardIterator __brick_last) {
            return std::__pstl_any_of<__remove_parallel_policy_t<_ExecutionPolicy>>(
                __cpu_backend_tag{}, __brick_first, __brick_last, __pred);
          });
    });
  } else if constexpr (__is_unsequenced_execution_policy_v<_ExecutionPolicy> &&
                       __has_random_access_iterator_category_or_concept<_ForwardIterator>::value) {
    return std::__simd_or(__first, __last - __first, __pred);
  } else {
    return std::any_of(__first, __last, __pred);
  }
}

}}
# 50 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/cpu_backend.h" 2 3

# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/cpu_backends/fill.h" 1 3
# 21 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/cpu_backends/fill.h" 3




namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Index, class _DifferenceType, class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) _Index __simd_fill_n(_Index __first, _DifferenceType __n, const _Tp& __value) noexcept {

#pragma omp simd
  for (_DifferenceType __i = 0; __i < __n; ++__i)
    __first[__i] = __value;
  return __first + __n;
}

template <class _ExecutionPolicy, class _ForwardIterator, class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) void
__pstl_fill(__cpu_backend_tag, _ForwardIterator __first, _ForwardIterator __last, const _Tp& __value) {
  if constexpr (__is_parallel_execution_policy_v<_ExecutionPolicy> &&
                __has_random_access_iterator_category_or_concept<_ForwardIterator>::value) {
    std::__terminate_on_exception([&] {
      __par_backend::__parallel_for(
          __first, __last, [&__value](_ForwardIterator __brick_first, _ForwardIterator __brick_last) {
            std::__pstl_fill<__remove_parallel_policy_t<_ExecutionPolicy>>(
                __cpu_backend_tag{}, __brick_first, __brick_last, __value);
          });
    });
  } else if constexpr (__is_unsequenced_execution_policy_v<_ExecutionPolicy> &&
                       __has_random_access_iterator_category_or_concept<_ForwardIterator>::value) {
    std::__simd_fill_n(__first, __last - __first, __value);
  } else {
    std::fill(__first, __last, __value);
  }
}

}}
# 52 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/cpu_backend.h" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/cpu_backends/find_if.h" 1 3
# 26 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/cpu_backends/find_if.h" 3




namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Index, class _Brick, class _Compare>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) _Index
__parallel_find(_Index __first, _Index __last, _Brick __f, _Compare __comp, bool __b_first) {
  typedef typename std::iterator_traits<_Index>::difference_type _DifferenceType;
  const _DifferenceType __n = __last - __first;
  _DifferenceType __initial_dist = __b_first ? __n : -1;
  std::atomic<_DifferenceType> __extremum(__initial_dist);

  __par_backend::__parallel_for(__first, __last, [__comp, __f, __first, &__extremum](_Index __i, _Index __j) {


    if (__comp(__i - __first, __extremum)) {
      _Index __res = __f(__i, __j);

      if (__res != __j) {
        const _DifferenceType __k = __res - __first;
        for (_DifferenceType __old = __extremum; __comp(__k, __old); __old = __extremum) {
          __extremum.compare_exchange_weak(__old, __k);
        }
      }
    }
  });
  return __extremum != __initial_dist ? __first + __extremum : __last;
}

template <class _Index, class _DifferenceType, class _Compare>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) _Index
__simd_first(_Index __first, _DifferenceType __begin, _DifferenceType __end, _Compare __comp) noexcept {

  const _DifferenceType __block_size = 8;
  alignas(__lane_size) _DifferenceType __lane[__block_size] = {0};
  while (__end - __begin >= __block_size) {
    _DifferenceType __found = 0;
#pragma omp simd reduction(| : __found)
# 65 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/cpu_backends/find_if.h" 3
                                             for (_DifferenceType __i = __begin; __i < __begin + __block_size; ++__i) {
      const _DifferenceType __t = __comp(__first, __i);
      __lane[__i - __begin] = __t;
      __found |= __t;
    }
    if (__found) {
      _DifferenceType __i;

      for (__i = 0; __i < __block_size; ++__i) {
        if (__lane[__i]) {
          break;
        }
      }
      return __first + __begin + __i;
    }
    __begin += __block_size;
  }


  while (__begin != __end) {
    if (__comp(__first, __begin)) {
      return __first + __begin;
    }
    ++__begin;
  }
  return __first + __end;
}

template <class _ExecutionPolicy, class _ForwardIterator, class _Predicate>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) _ForwardIterator
__pstl_find_if(__cpu_backend_tag, _ForwardIterator __first, _ForwardIterator __last, _Predicate __pred) {
  if constexpr (__is_parallel_execution_policy_v<_ExecutionPolicy> &&
                __has_random_access_iterator_category_or_concept<_ForwardIterator>::value) {
    return std::__terminate_on_exception([&] {
      return std::__parallel_find(
          __first,
          __last,
          [&__pred](_ForwardIterator __brick_first, _ForwardIterator __brick_last) {
            return std::__pstl_find_if<__remove_parallel_policy_t<_ExecutionPolicy>>(
                __cpu_backend_tag{}, __brick_first, __brick_last, __pred);
          },
          less<>{},
          true);
    });
  } else if constexpr (__is_unsequenced_execution_policy_v<_ExecutionPolicy> &&
                       __has_random_access_iterator_category_or_concept<_ForwardIterator>::value) {
    using __diff_t = __iter_diff_t<_ForwardIterator>;
    return std::__simd_first(__first, __diff_t(0), __last - __first, [&__pred](_ForwardIterator __iter, __diff_t __i) {
      return __pred(__iter[__i]);
    });
  } else {
    return std::find_if(__first, __last, __pred);
  }
}

}}
# 53 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/cpu_backend.h" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/cpu_backends/for_each.h" 1 3
# 21 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/cpu_backends/for_each.h" 3




namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Iterator, class _DifferenceType, class _Function>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) _Iterator __simd_walk_1(_Iterator __first, _DifferenceType __n, _Function __f) noexcept {
#pragma omp simd
  for (_DifferenceType __i = 0; __i < __n; ++__i)
    __f(__first[__i]);

  return __first + __n;
}

template <class _ExecutionPolicy, class _ForwardIterator, class _Functor>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) void
__pstl_for_each(__cpu_backend_tag, _ForwardIterator __first, _ForwardIterator __last, _Functor __func) {
  if constexpr (__is_parallel_execution_policy_v<_ExecutionPolicy> &&
                __has_random_access_iterator_category_or_concept<_ForwardIterator>::value) {
    std::__terminate_on_exception([&] {
      std::__par_backend::__parallel_for(
          __first, __last, [__func](_ForwardIterator __brick_first, _ForwardIterator __brick_last) {
            std::__pstl_for_each<__remove_parallel_policy_t<_ExecutionPolicy>>(
                __cpu_backend_tag{}, __brick_first, __brick_last, __func);
          });
    });
  } else if constexpr (__is_unsequenced_execution_policy_v<_ExecutionPolicy> &&
                       __has_random_access_iterator_category_or_concept<_ForwardIterator>::value) {
    std::__simd_walk_1(__first, __last - __first, __func);
  } else {
    std::for_each(__first, __last, __func);
  }
}

}}
# 54 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/cpu_backend.h" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/cpu_backends/merge.h" 1 3
# 22 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/cpu_backends/merge.h" 3




namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _ExecutionPolicy,
          class _ForwardIterator1,
          class _ForwardIterator2,
          class _ForwardOutIterator,
          class _Comp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) _ForwardOutIterator __pstl_merge(
    __cpu_backend_tag,
    _ForwardIterator1 __first1,
    _ForwardIterator1 __last1,
    _ForwardIterator2 __first2,
    _ForwardIterator2 __last2,
    _ForwardOutIterator __result,
    _Comp __comp) {
  if constexpr (__is_parallel_execution_policy_v<_ExecutionPolicy> &&
                __has_random_access_iterator_category_or_concept<_ForwardIterator1>::value &&
                __has_random_access_iterator_category_or_concept<_ForwardIterator2>::value &&
                __has_random_access_iterator_category_or_concept<_ForwardOutIterator>::value) {
    return std::__terminate_on_exception([&] {
      __par_backend::__parallel_merge(
          __first1,
          __last1,
          __first2,
          __last2,
          __result,
          __comp,
          [](_ForwardIterator1 __g_first1,
             _ForwardIterator1 __g_last1,
             _ForwardIterator2 __g_first2,
             _ForwardIterator2 __g_last2,
             _ForwardOutIterator __g_result,
             _Comp __g_comp) {
            return std::__pstl_merge<__remove_parallel_policy_t<_ExecutionPolicy>>(
                __cpu_backend_tag{},
                std::move(__g_first1),
                std::move(__g_last1),
                std::move(__g_first2),
                std::move(__g_last2),
                std::move(__g_result),
                std::move(__g_comp));
          });
      return __result + (__last1 - __first1) + (__last2 - __first2);
    });
  } else {
    return std::merge(__first1, __last1, __first2, __last2, __result, __comp);
  }
}

}}
# 55 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/cpu_backend.h" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/cpu_backends/stable_sort.h" 1 3
# 13 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/cpu_backends/stable_sort.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/stable_sort.h" 1 3
# 30 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/stable_sort.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _AlgPolicy, class _Compare, class _BidirectionalIterator>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
void __insertion_sort_move(_BidirectionalIterator __first1, _BidirectionalIterator __last1,
                           typename iterator_traits<_BidirectionalIterator>::value_type* __first2, _Compare __comp) {
  using _Ops = _IterOps<_AlgPolicy>;

  typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;
  if (__first1 != __last1) {
    __destruct_n __d(0);
    unique_ptr<value_type, __destruct_n&> __h(__first2, __d);
    value_type* __last2 = __first2;
    ::new ((void*)__last2) value_type(_Ops::__iter_move(__first1));
    __d.template __incr<value_type>();
    for (++__last2; ++__first1 != __last1; ++__last2) {
      value_type* __j2 = __last2;
      value_type* __i2 = __j2;
      if (__comp(*__first1, *--__i2)) {
        ::new ((void*)__j2) value_type(std::move(*__i2));
        __d.template __incr<value_type>();
        for (--__j2; __i2 != __first2 && __comp(*__first1, *--__i2); --__j2)
          *__j2 = std::move(*__i2);
        *__j2 = _Ops::__iter_move(__first1);
      } else {
        ::new ((void*)__j2) value_type(_Ops::__iter_move(__first1));
        __d.template __incr<value_type>();
      }
    }
    __h.release();
  }
}

template <class _AlgPolicy, class _Compare, class _InputIterator1, class _InputIterator2>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) void
__merge_move_construct(_InputIterator1 __first1, _InputIterator1 __last1,
        _InputIterator2 __first2, _InputIterator2 __last2,
        typename iterator_traits<_InputIterator1>::value_type* __result, _Compare __comp)
{
    using _Ops = _IterOps<_AlgPolicy>;

    typedef typename iterator_traits<_InputIterator1>::value_type value_type;
    __destruct_n __d(0);
    unique_ptr<value_type, __destruct_n&> __h(__result, __d);
    for (; true; ++__result)
    {
        if (__first1 == __last1)
        {
            for (; __first2 != __last2; ++__first2, (void) ++__result, __d.template __incr<value_type>())
                ::new ((void*)__result) value_type(_Ops::__iter_move(__first2));
            __h.release();
            return;
        }
        if (__first2 == __last2)
        {
            for (; __first1 != __last1; ++__first1, (void) ++__result, __d.template __incr<value_type>())
                ::new ((void*)__result) value_type(_Ops::__iter_move(__first1));
            __h.release();
            return;
        }
        if (__comp(*__first2, *__first1))
        {
            ::new ((void*)__result) value_type(_Ops::__iter_move(__first2));
            __d.template __incr<value_type>();
            ++__first2;
        }
        else
        {
            ::new ((void*)__result) value_type(_Ops::__iter_move(__first1));
            __d.template __incr<value_type>();
            ++__first1;
        }
    }
}

template <class _AlgPolicy, class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) void
__merge_move_assign(_InputIterator1 __first1, _InputIterator1 __last1,
        _InputIterator2 __first2, _InputIterator2 __last2,
        _OutputIterator __result, _Compare __comp)
{
    using _Ops = _IterOps<_AlgPolicy>;

    for (; __first1 != __last1; ++__result)
    {
        if (__first2 == __last2)
        {
            for (; __first1 != __last1; ++__first1, (void) ++__result)
                *__result = _Ops::__iter_move(__first1);
            return;
        }
        if (__comp(*__first2, *__first1))
        {
            *__result = _Ops::__iter_move(__first2);
            ++__first2;
        }
        else
        {
            *__result = _Ops::__iter_move(__first1);
            ++__first1;
        }
    }
    for (; __first2 != __last2; ++__first2, (void) ++__result)
        *__result = _Ops::__iter_move(__first2);
}

template <class _AlgPolicy, class _Compare, class _RandomAccessIterator>
void
__stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp,
              typename iterator_traits<_RandomAccessIterator>::difference_type __len,
              typename iterator_traits<_RandomAccessIterator>::value_type* __buff, ptrdiff_t __buff_size);

template <class _AlgPolicy, class _Compare, class _RandomAccessIterator>
void
__stable_sort_move(_RandomAccessIterator __first1, _RandomAccessIterator __last1, _Compare __comp,
                   typename iterator_traits<_RandomAccessIterator>::difference_type __len,
                   typename iterator_traits<_RandomAccessIterator>::value_type* __first2)
{
    using _Ops = _IterOps<_AlgPolicy>;

    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;
    switch (__len)
    {
    case 0:
        return;
    case 1:
        ::new ((void*)__first2) value_type(_Ops::__iter_move(__first1));
        return;
    case 2:
        __destruct_n __d(0);
        unique_ptr<value_type, __destruct_n&> __h2(__first2, __d);
        if (__comp(*--__last1, *__first1))
        {
            ::new ((void*)__first2) value_type(_Ops::__iter_move(__last1));
            __d.template __incr<value_type>();
            ++__first2;
            ::new ((void*)__first2) value_type(_Ops::__iter_move(__first1));
        }
        else
        {
            ::new ((void*)__first2) value_type(_Ops::__iter_move(__first1));
            __d.template __incr<value_type>();
            ++__first2;
            ::new ((void*)__first2) value_type(_Ops::__iter_move(__last1));
        }
        __h2.release();
        return;
    }
    if (__len <= 8)
    {
        std::__insertion_sort_move<_AlgPolicy, _Compare>(__first1, __last1, __first2, __comp);
        return;
    }
    typename iterator_traits<_RandomAccessIterator>::difference_type __l2 = __len / 2;
    _RandomAccessIterator __m = __first1 + __l2;
    std::__stable_sort<_AlgPolicy, _Compare>(__first1, __m, __comp, __l2, __first2, __l2);
    std::__stable_sort<_AlgPolicy, _Compare>(__m, __last1, __comp, __len - __l2, __first2 + __l2, __len - __l2);
    std::__merge_move_construct<_AlgPolicy, _Compare>(__first1, __m, __m, __last1, __first2, __comp);
}

template <class _Tp>
struct __stable_sort_switch
{
    static const unsigned value = 128*is_trivially_copy_assignable<_Tp>::value;
};

template <class _AlgPolicy, class _Compare, class _RandomAccessIterator>
void
__stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp,
              typename iterator_traits<_RandomAccessIterator>::difference_type __len,
              typename iterator_traits<_RandomAccessIterator>::value_type* __buff, ptrdiff_t __buff_size)
{
    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;
    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
    switch (__len)
    {
    case 0:
    case 1:
        return;
    case 2:
        if (__comp(*--__last, *__first))
            _IterOps<_AlgPolicy>::iter_swap(__first, __last);
        return;
    }
    if (__len <= static_cast<difference_type>(__stable_sort_switch<value_type>::value))
    {
        std::__insertion_sort<_AlgPolicy, _Compare>(__first, __last, __comp);
        return;
    }
    typename iterator_traits<_RandomAccessIterator>::difference_type __l2 = __len / 2;
    _RandomAccessIterator __m = __first + __l2;
    if (__len <= __buff_size)
    {
        __destruct_n __d(0);
        unique_ptr<value_type, __destruct_n&> __h2(__buff, __d);
        std::__stable_sort_move<_AlgPolicy, _Compare>(__first, __m, __comp, __l2, __buff);
        __d.__set(__l2, (value_type*)nullptr);
        std::__stable_sort_move<_AlgPolicy, _Compare>(__m, __last, __comp, __len - __l2, __buff + __l2);
        __d.__set(__len, (value_type*)nullptr);
        std::__merge_move_assign<_AlgPolicy, _Compare>(
            __buff, __buff + __l2, __buff + __l2, __buff + __len, __first, __comp);





        return;
    }
    std::__stable_sort<_AlgPolicy, _Compare>(__first, __m, __comp, __l2, __buff, __buff_size);
    std::__stable_sort<_AlgPolicy, _Compare>(__m, __last, __comp, __len - __l2, __buff, __buff_size);
    std::__inplace_merge<_AlgPolicy>(__first, __m, __last, __comp, __l2, __len - __l2, __buff, __buff_size);
}

template <class _AlgPolicy, class _RandomAccessIterator, class _Compare>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
void __stable_sort_impl(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare& __comp) {
  using value_type = typename iterator_traits<_RandomAccessIterator>::value_type;
  using difference_type = typename iterator_traits<_RandomAccessIterator>::difference_type;

  difference_type __len = __last - __first;
  pair<value_type*, ptrdiff_t> __buf(0, 0);
  unique_ptr<value_type, __return_temporary_buffer> __h;
  if (__len > static_cast<difference_type>(__stable_sort_switch<value_type>::value)) {

#pragma GCC diagnostic push
# 256 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/stable_sort.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
# 256 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/stable_sort.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
      __buf = std::get_temporary_buffer<value_type>(__len);
#pragma GCC diagnostic pop
      __h.reset(__buf.first);
  }

  std::__stable_sort<_AlgPolicy, __comp_ref_type<_Compare> >(__first, __last, __comp, __len, __buf.first, __buf.second);
  std::__check_strict_weak_ordering_sorted(__first, __last, __comp);
}

template <class _RandomAccessIterator, class _Compare>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
void stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp) {
  std::__stable_sort_impl<_ClassicAlgPolicy>(std::move(__first), std::move(__last), __comp);
}

template <class _RandomAccessIterator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
void stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last) {
  std::stable_sort(__first, __last, __less<>());
}

}}
# 14 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/cpu_backends/stable_sort.h" 2 3
# 20 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/cpu_backends/stable_sort.h" 3




namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _ExecutionPolicy, class _RandomAccessIterator, class _Comp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) void
__pstl_stable_sort(__cpu_backend_tag, _RandomAccessIterator __first, _RandomAccessIterator __last, _Comp __comp) {
  if constexpr (__is_parallel_execution_policy_v<_ExecutionPolicy>) {
    std::__terminate_on_exception([&] {
      __par_backend::__parallel_stable_sort(
          __first, __last, __comp, [](_RandomAccessIterator __g_first, _RandomAccessIterator __g_last, _Comp __g_comp) {
            std::stable_sort(__g_first, __g_last, __g_comp);
          });
    });
  } else {
    std::stable_sort(__first, __last, __comp);
  }
}

}}
# 56 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/cpu_backend.h" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/cpu_backends/transform.h" 1 3
# 13 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/cpu_backends/transform.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/transform.h" 1 3
# 16 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/transform.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _InputIterator, class _OutputIterator, class _UnaryOperation>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
_OutputIterator
transform(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _UnaryOperation __op)
{
    for (; __first != __last; ++__first, (void) ++__result)
        *__result = __op(*__first);
    return __result;
}

template <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _BinaryOperation>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
_OutputIterator
transform(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2,
          _OutputIterator __result, _BinaryOperation __binary_op)
{
    for (; __first1 != __last1; ++__first1, (void) ++__first2, ++__result)
        *__result = __binary_op(*__first1, *__first2);
    return __result;
}

}}
# 14 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/cpu_backends/transform.h" 2 3
# 24 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/cpu_backends/transform.h" 3




namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Iterator1, class _DifferenceType, class _Iterator2, class _Function>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) _Iterator2
__simd_walk_2(_Iterator1 __first1, _DifferenceType __n, _Iterator2 __first2, _Function __f) noexcept {
#pragma omp simd
  for (_DifferenceType __i = 0; __i < __n; ++__i)
    __f(__first1[__i], __first2[__i]);
  return __first2 + __n;
}

template <class _ExecutionPolicy, class _ForwardIterator, class _ForwardOutIterator, class _UnaryOperation>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) _ForwardOutIterator __pstl_transform(
    __cpu_backend_tag,
    _ForwardIterator __first,
    _ForwardIterator __last,
    _ForwardOutIterator __result,
    _UnaryOperation __op) {
  if constexpr (__is_parallel_execution_policy_v<_ExecutionPolicy> &&
                __has_random_access_iterator_category_or_concept<_ForwardIterator>::value &&
                __has_random_access_iterator_category_or_concept<_ForwardOutIterator>::value) {
    std::__terminate_on_exception([&] {
      std::__par_backend::__parallel_for(
          __first, __last, [__op, __first, __result](_ForwardIterator __brick_first, _ForwardIterator __brick_last) {
            return std::__pstl_transform<__remove_parallel_policy_t<_ExecutionPolicy>>(
                __cpu_backend_tag{}, __brick_first, __brick_last, __result + (__brick_first - __first), __op);
          });
    });
    return __result + (__last - __first);
  } else if constexpr (__is_unsequenced_execution_policy_v<_ExecutionPolicy> &&
                       __has_random_access_iterator_category_or_concept<_ForwardIterator>::value &&
                       __has_random_access_iterator_category_or_concept<_ForwardOutIterator>::value) {
    return std::__simd_walk_2(
        __first,
        __last - __first,
        __result,
        [&](__iter_reference<_ForwardIterator> __in_value, __iter_reference<_ForwardOutIterator> __out_value) {
          __out_value = __op(__in_value);
        });
  } else {
    return std::transform(__first, __last, __result, __op);
  }
}

template <class _Iterator1, class _DifferenceType, class _Iterator2, class _Iterator3, class _Function>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) _Iterator3 __simd_walk_3(
    _Iterator1 __first1, _DifferenceType __n, _Iterator2 __first2, _Iterator3 __first3, _Function __f) noexcept {
#pragma omp simd
  for (_DifferenceType __i = 0; __i < __n; ++__i)
    __f(__first1[__i], __first2[__i], __first3[__i]);
  return __first3 + __n;
}
template <class _ExecutionPolicy,
          class _ForwardIterator1,
          class _ForwardIterator2,
          class _ForwardOutIterator,
          class _BinaryOperation,
          enable_if_t<is_execution_policy_v<__remove_cvref_t<_ExecutionPolicy>>, int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) _ForwardOutIterator __pstl_transform(
    __cpu_backend_tag,
    _ForwardIterator1 __first1,
    _ForwardIterator1 __last1,
    _ForwardIterator2 __first2,
    _ForwardOutIterator __result,
    _BinaryOperation __op) {
  if constexpr (__is_parallel_execution_policy_v<_ExecutionPolicy> &&
                __has_random_access_iterator_category_or_concept<_ForwardIterator1>::value &&
                __has_random_access_iterator_category_or_concept<_ForwardIterator2>::value &&
                __has_random_access_iterator_category_or_concept<_ForwardOutIterator>::value) {
    std::__terminate_on_exception([&] {
      std::__par_backend::__parallel_for(
          __first1,
          __last1,
          [__op, __first1, __first2, __result](_ForwardIterator1 __brick_first, _ForwardIterator1 __brick_last) {
            return std::__pstl_transform<__remove_parallel_policy_t<_ExecutionPolicy>>(
                __cpu_backend_tag{},
                __brick_first,
                __brick_last,
                __first2 + (__brick_first - __first1),
                __result + (__brick_first - __first1),
                __op);
          });
    });
    return __result + (__last1 - __first1);
  } else if constexpr (__is_unsequenced_execution_policy_v<_ExecutionPolicy> &&
                       __has_random_access_iterator_category_or_concept<_ForwardIterator1>::value &&
                       __has_random_access_iterator_category_or_concept<_ForwardIterator2>::value &&
                       __has_random_access_iterator_category_or_concept<_ForwardOutIterator>::value) {
    return std::__simd_walk_3(
        __first1,
        __last1 - __first1,
        __first2,
        __result,
        [&](__iter_reference<_ForwardIterator1> __in1,
            __iter_reference<_ForwardIterator2> __in2,
            __iter_reference<_ForwardOutIterator> __out_value) { __out_value = __op(__in1, __in2); });
  } else {
    return std::transform(__first1, __last1, __first2, __result, __op);
  }
}

}}
# 57 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/cpu_backend.h" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/cpu_backends/transform_reduce.h" 1 3
# 16 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/cpu_backends/transform_reduce.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__numeric/transform_reduce.h" 1 3
# 19 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__numeric/transform_reduce.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {


template <class _InputIterator, class _Tp, class _BinaryOp, class _UnaryOp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr _Tp transform_reduce(_InputIterator __first,
                                                                             _InputIterator __last, _Tp __init,
                                                                             _BinaryOp __b, _UnaryOp __u) {
  for (; __first != __last; ++__first)
    __init = __b(std::move(__init), __u(*__first));
  return __init;
}

template <class _InputIterator1, class _InputIterator2, class _Tp, class _BinaryOp1, class _BinaryOp2>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr _Tp transform_reduce(_InputIterator1 __first1,
                                                                             _InputIterator1 __last1,
                                                                             _InputIterator2 __first2, _Tp __init,
                                                                             _BinaryOp1 __b1, _BinaryOp2 __b2) {
  for (; __first1 != __last1; ++__first1, (void)++__first2)
    __init = __b1(std::move(__init), __b2(*__first1, *__first2));
  return __init;
}

template <class _InputIterator1, class _InputIterator2, class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr _Tp transform_reduce(_InputIterator1 __first1,
                                                                             _InputIterator1 __last1,
                                                                             _InputIterator2 __first2, _Tp __init) {
  return std::transform_reduce(__first1, __last1, __first2, std::move(__init), std::plus<>(),
                                 std::multiplies<>());
}


}}
# 17 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/cpu_backends/transform_reduce.h" 2 3
# 26 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/cpu_backends/transform_reduce.h" 3




namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <
    typename _DifferenceType,
    typename _Tp,
    typename _BinaryOperation,
    typename _UnaryOperation,
    __enable_if_t<__is_trivial_plus_operation<_BinaryOperation, _Tp, _Tp>::value && is_arithmetic_v<_Tp>, int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) _Tp
__simd_transform_reduce(_DifferenceType __n, _Tp __init, _BinaryOperation, _UnaryOperation __f) noexcept {
#pragma omp simd reduction(+ : __init)
  for (_DifferenceType __i = 0; __i < __n; ++__i)
    __init += __f(__i);
  return __init;
}

template <
    typename _Size,
    typename _Tp,
    typename _BinaryOperation,
    typename _UnaryOperation,
    __enable_if_t<!(__is_trivial_plus_operation<_BinaryOperation, _Tp, _Tp>::value && is_arithmetic_v<_Tp>), int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) _Tp
__simd_transform_reduce(_Size __n, _Tp __init, _BinaryOperation __binary_op, _UnaryOperation __f) noexcept {
  const _Size __block_size = __lane_size / sizeof(_Tp);
  if (__n > 2 * __block_size && __block_size > 1) {
    alignas(__lane_size) char __lane_buffer[__lane_size];
    _Tp* __lane = reinterpret_cast<_Tp*>(__lane_buffer);


#pragma omp simd
    for (_Size __i = 0; __i < __block_size; ++__i) {
      ::new (__lane + __i) _Tp(__binary_op(__f(__i), __f(__block_size + __i)));
    }

    _Size __i = 2 * __block_size;
    const _Size __last_iteration = __block_size * (__n / __block_size);
    for (; __i < __last_iteration; __i += __block_size) {
#pragma omp simd
      for (_Size __j = 0; __j < __block_size; ++__j) {
        __lane[__j] = __binary_op(std::move(__lane[__j]), __f(__i + __j));
      }
    }

#pragma omp simd
    for (_Size __j = 0; __j < __n - __last_iteration; ++__j) {
      __lane[__j] = __binary_op(std::move(__lane[__j]), __f(__last_iteration + __j));
    }

    for (_Size __j = 0; __j < __block_size; ++__j) {
      __init = __binary_op(std::move(__init), std::move(__lane[__j]));
    }

#pragma omp simd
    for (_Size __j = 0; __j < __block_size; ++__j) {
      __lane[__j].~_Tp();
    }
  } else {
    for (_Size __i = 0; __i < __n; ++__i) {
      __init = __binary_op(std::move(__init), __f(__i));
    }
  }
  return __init;
}

template <class _ExecutionPolicy,
          class _ForwardIterator1,
          class _ForwardIterator2,
          class _Tp,
          class _BinaryOperation1,
          class _BinaryOperation2>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) _Tp __pstl_transform_reduce(
    __cpu_backend_tag,
    _ForwardIterator1 __first1,
    _ForwardIterator1 __last1,
    _ForwardIterator2 __first2,
    _Tp __init,
    _BinaryOperation1 __reduce,
    _BinaryOperation2 __transform) {
  if constexpr (__is_parallel_execution_policy_v<_ExecutionPolicy> &&
                __has_random_access_iterator_category_or_concept<_ForwardIterator1>::value &&
                __has_random_access_iterator_category_or_concept<_ForwardIterator2>::value) {
    return std::__terminate_on_exception([&] {
      return __par_backend::__parallel_transform_reduce(
          __first1,
          std::move(__last1),
          [__first1, __first2, __transform](_ForwardIterator1 __iter) {
            return __transform(*__iter, *(__first2 + (__iter - __first1)));
          },
          std::move(__init),
          std::move(__reduce),
          [__first1, __first2, __reduce, __transform](
              _ForwardIterator1 __brick_first, _ForwardIterator1 __brick_last, _Tp __brick_init) {
            return std::__pstl_transform_reduce<__remove_parallel_policy_t<_ExecutionPolicy>>(
                __cpu_backend_tag{},
                __brick_first,
                std::move(__brick_last),
                __first2 + (__brick_first - __first1),
                std::move(__brick_init),
                std::move(__reduce),
                std::move(__transform));
          });
    });
  } else if constexpr (__is_unsequenced_execution_policy_v<_ExecutionPolicy> &&
                       __has_random_access_iterator_category_or_concept<_ForwardIterator1>::value &&
                       __has_random_access_iterator_category_or_concept<_ForwardIterator2>::value) {
    return std::__simd_transform_reduce(
        __last1 - __first1, std::move(__init), std::move(__reduce), [&](__iter_diff_t<_ForwardIterator1> __i) {
          return __transform(__first1[__i], __first2[__i]);
        });
  } else {
    return std::transform_reduce(
        std::move(__first1),
        std::move(__last1),
        std::move(__first2),
        std::move(__init),
        std::move(__reduce),
        std::move(__transform));
  }
}

template <class _ExecutionPolicy, class _ForwardIterator, class _Tp, class _BinaryOperation, class _UnaryOperation>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) _Tp __pstl_transform_reduce(
    __cpu_backend_tag,
    _ForwardIterator __first,
    _ForwardIterator __last,
    _Tp __init,
    _BinaryOperation __reduce,
    _UnaryOperation __transform) {
  if constexpr (__is_parallel_execution_policy_v<_ExecutionPolicy> &&
                __has_random_access_iterator_category_or_concept<_ForwardIterator>::value) {
    return std::__terminate_on_exception([&] {
      return __par_backend::__parallel_transform_reduce(
          std::move(__first),
          std::move(__last),
          [__transform](_ForwardIterator __iter) { return __transform(*__iter); },
          std::move(__init),
          __reduce,
          [__transform, __reduce](auto __brick_first, auto __brick_last, _Tp __brick_init) {
            return std::__pstl_transform_reduce<__remove_parallel_policy_t<_ExecutionPolicy>>(
                __cpu_backend_tag{},
                std::move(__brick_first),
                std::move(__brick_last),
                std::move(__brick_init),
                std::move(__reduce),
                std::move(__transform));
          });
    });
  } else if constexpr (__is_unsequenced_execution_policy_v<_ExecutionPolicy> &&
                       __has_random_access_iterator_category_or_concept<_ForwardIterator>::value) {
    return std::__simd_transform_reduce(
        __last - __first,
        std::move(__init),
        std::move(__reduce),
        [=, &__transform](__iter_diff_t<_ForwardIterator> __i) { return __transform(__first[__i]); });
  } else {
    return std::transform_reduce(
        std::move(__first), std::move(__last), std::move(__init), std::move(__reduce), std::move(__transform));
  }
}

}}
# 58 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/cpu_backend.h" 2 3
# 13 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backend.h" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/gpu_backend.h" 1 3
# 14 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/gpu_backend.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/gpu_backends/backend.h" 1 3
# 17 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/gpu_backends/backend.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/gpu_backends/omp_offload.h" 1 3
# 15 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/gpu_backends/omp_offload.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__iterator/wrap_iter.h" 1 3
# 23 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__iterator/wrap_iter.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Iter>
class __wrap_iter
{
public:
    typedef _Iter iterator_type;
    typedef typename iterator_traits<iterator_type>::value_type value_type;
    typedef typename iterator_traits<iterator_type>::difference_type difference_type;
    typedef typename iterator_traits<iterator_type>::pointer pointer;
    typedef typename iterator_traits<iterator_type>::reference reference;
    typedef typename iterator_traits<iterator_type>::iterator_category iterator_category;

    typedef contiguous_iterator_tag iterator_concept;


private:
    iterator_type __i_;
public:
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr __wrap_iter() noexcept
                : __i_()
    {
    }
    template <class _Up, __enable_if_t<is_convertible<_Up, iterator_type>::value, int> = 0>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr __wrap_iter(const __wrap_iter<_Up>& __u) noexcept
            : __i_(__u.base())
    {
    }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr reference operator*() const noexcept
    {
        return *__i_;
    }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr pointer operator->() const noexcept
    {
        return std::__to_address(__i_);
    }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr __wrap_iter& operator++() noexcept
    {
        ++__i_;
        return *this;
    }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr __wrap_iter operator++(int) noexcept
        {__wrap_iter __tmp(*this); ++(*this); return __tmp;}

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr __wrap_iter& operator--() noexcept
    {
        --__i_;
        return *this;
    }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr __wrap_iter operator--(int) noexcept
        {__wrap_iter __tmp(*this); --(*this); return __tmp;}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr __wrap_iter operator+ (difference_type __n) const noexcept
        {__wrap_iter __w(*this); __w += __n; return __w;}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr __wrap_iter& operator+=(difference_type __n) noexcept
    {
        __i_ += __n;
        return *this;
    }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr __wrap_iter operator- (difference_type __n) const noexcept
        {return *this + (-__n);}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr __wrap_iter& operator-=(difference_type __n) noexcept
        {*this += -__n; return *this;}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr reference operator[](difference_type __n) const noexcept
    {
        return __i_[__n];
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr iterator_type base() const noexcept {return __i_;}

private:
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    explicit __wrap_iter(iterator_type __x) noexcept : __i_(__x)
    {
    }

    template <class _Up> friend class __wrap_iter;
    template <class _CharT, class _Traits, class _Alloc> friend class basic_string;
    template <class _Tp, class _Alloc> friend class vector;
    template <class _Tp, size_t> friend class span;
};

template <class _Iter1>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
bool operator==(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter1>& __y) noexcept
{
    return __x.base() == __y.base();
}

template <class _Iter1, class _Iter2>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
bool operator==(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) noexcept
{
    return __x.base() == __y.base();
}

template <class _Iter1>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
bool operator<(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter1>& __y) noexcept
{
    return __x.base() < __y.base();
}

template <class _Iter1, class _Iter2>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
bool operator<(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) noexcept
{
    return __x.base() < __y.base();
}

template <class _Iter1>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
bool operator!=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter1>& __y) noexcept
{
    return !(__x == __y);
}

template <class _Iter1, class _Iter2>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
bool operator!=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) noexcept
{
    return !(__x == __y);
}

template <class _Iter1>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
bool operator>(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter1>& __y) noexcept
{
    return __y < __x;
}

template <class _Iter1, class _Iter2>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
bool operator>(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) noexcept
{
    return __y < __x;
}

template <class _Iter1>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
bool operator>=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter1>& __y) noexcept
{
    return !(__x < __y);
}

template <class _Iter1, class _Iter2>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
bool operator>=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) noexcept
{
    return !(__x < __y);
}

template <class _Iter1>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
bool operator<=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter1>& __y) noexcept
{
    return !(__y < __x);
}

template <class _Iter1, class _Iter2>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
bool operator<=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) noexcept
{
    return !(__y < __x);
}

template <class _Iter1, class _Iter2>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr

auto operator-(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) noexcept
    -> decltype(__x.base() - __y.base())




{
    return __x.base() - __y.base();
}

template <class _Iter1>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
__wrap_iter<_Iter1> operator+(typename __wrap_iter<_Iter1>::difference_type __n, __wrap_iter<_Iter1> __x) noexcept
{
    __x += __n;
    return __x;
}






template <class _It>
struct pointer_traits<__wrap_iter<_It> >
{
    typedef __wrap_iter<_It> pointer;
    typedef typename pointer_traits<_It>::element_type element_type;
    typedef typename pointer_traits<_It>::difference_type difference_type;

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    static element_type *to_address(pointer __w) noexcept {
        return std::__to_address(__w.base());
    }
};

}}
# 16 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/gpu_backends/omp_offload.h" 2 3
# 29 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/gpu_backends/omp_offload.h" 3



# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__undef_macros" 1 3
# 33 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/gpu_backends/omp_offload.h" 2 3



namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

namespace __par_backend {
inline namespace __omp_gpu_backend {


template <typename T1, typename T2, typename T3>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) inline bool __omp_in_ptr_range(T1, T2, T3) {
  return false;
}

template <typename _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) inline bool __omp_in_ptr_range(_Tp* a, _Tp* p, _Tp* b) {
  return std::less_equal<_Tp*>{}(a, p) && std::less<_Tp*>{}(p, b);
}





template <typename _Tp, std::enable_if<std::is_pointer<_Tp>::value >::type* = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) inline _Tp __omp_extract_base_ptr(_Tp p) {
  return p;
}

template <typename _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) inline auto __omp_extract_base_ptr(_Tp p) {
  return p;
}

template <typename _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) inline _Tp __omp_extract_base_ptr(std::__wrap_iter<_Tp> w) {
  std::pointer_traits<std::__wrap_iter<_Tp>> PT;
  return PT.to_address(w);
}







template <class _Iterator, class _DifferenceType, class _Function>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) _Iterator __omp_parallel_for_simd_1(
    _Iterator __first, _DifferenceType __n, _Function __f, [[maybe_unused]] const int __device = 0) noexcept {
#pragma omp target teams distribute parallel for simd map(tofrom : __first[0 : __n]) device(__device)
  for (_DifferenceType __i = 0; __i < __n; ++__i)
    __f(__first[__i]);

  return __first + __n;
}



template <class _Iterator, class _DifferenceType, class _Function>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) _Iterator __parallel_for_simd_1(_Iterator __first, _DifferenceType __n, _Function __f) noexcept {
  __omp_parallel_for_simd_1(__omp_gpu_backend::__omp_extract_base_ptr(__first), __n, __f);
  return __first + __n;
}



template <class _Index, class _DifferenceType, class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) _Index __omp_parallel_for_simd_val_1(
    _Index __first, _DifferenceType __n, const _Tp& __value, [[maybe_unused]] const int __device = 0) noexcept {
#pragma omp target teams distribute parallel for simd map(from : __first[0 : __n]) map(always, to : __value) device(__device)

  for (_DifferenceType __i = 0; __i < __n; ++__i)
    __first[__i] = __value;

  return __first + __n;
}

template <class _Index, class _DifferenceType, class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) _Index
__parallel_for_simd_val_1(_Index __first, _DifferenceType __n, const _Tp& __value) noexcept {
  __omp_parallel_for_simd_val_1(__omp_gpu_backend::__omp_extract_base_ptr(__first), __n, __value);
  return __first + __n;
}





template <class _Iterator1, class _DifferenceType, class _Iterator2, class _Function>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) _Iterator1 __omp_parallel_for_simd_2(
    _Iterator1 __first1,
    _DifferenceType __n,
    _Iterator2 __first2,
    _Function __f,
    [[maybe_unused]] const int __device = 0) noexcept {


  if constexpr (!__libcpp_is_contiguous_iterator<_Iterator1>::value){
#pragma omp target teams distribute parallel for simd map(always,to : __first1) map(from : __first2[0 : __n]) device(__device)

    for (_DifferenceType __i = 0; __i < __n; ++__i)
      __first2[__i] = __f(*(__first1+__i));
    return __first1 + __n;
  }
  else {

    if ((!std::is_same<_Iterator1, _Iterator2>::value) ||
        (std::is_same<_Iterator1, _Iterator2>::value &&
        !__omp_gpu_backend::__omp_in_ptr_range(__first1, __first2, __first1 + __n))) {
#pragma omp target teams distribute parallel for simd map(to : __first1[0 : __n]) map(from : __first2[0 : __n]) device(__device)

      for (_DifferenceType __i = 0; __i < __n; ++__i)
        __first2[__i] = __f(__first1[__i]);
      return __first1 + __n;
    }
#pragma omp target teams distribute parallel for simd map(tofrom : __first1[0 : __n], __first2[0 : __n]) device(__device)

    for (_DifferenceType __i = 0; __i < __n; ++__i)
      __first2[__i] = __f(__first1[__i]);

    return __first1 + __n;
  }
}



template <class _Iterator1, class _DifferenceType, class _Iterator2, class _Function>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) _Iterator1
__parallel_for_simd_2(_Iterator1 __first1, _DifferenceType __n, _Iterator2 __first2, _Function __f) noexcept {
  __omp_parallel_for_simd_2(
      __omp_gpu_backend::__omp_extract_base_ptr(__first1),
      __n,
      __omp_gpu_backend::__omp_extract_base_ptr(__first2),
      __f);
  return __first1 + __n;
}





template <class _Iterator1, class _DifferenceType, class _Iterator2, class _Iterator3, class _Function>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) _Iterator1 __omp_parallel_for_simd_3(
    _Iterator1 __first1,
    _DifferenceType __n,
    _Iterator2 __first2,
    _Iterator3 __first3,
    _Function __f,
    [[maybe_unused]] const int __device = 0) noexcept {






  constexpr bool are_not_same_type =
      !std::is_same<_Iterator1, _Iterator2>::value && !std::is_same<_Iterator1, _Iterator3>::value;
  const bool no_overlap_13 =
      std::is_same<_Iterator1, _Iterator3>::value &&
      !__omp_gpu_backend::__omp_in_ptr_range(__first1, __first3, __first1 + __n);
  const bool no_overlap_23 =
      std::is_same<_Iterator2, _Iterator3>::value &&
      !__omp_gpu_backend::__omp_in_ptr_range(__first2, __first3, __first2 + __n);


  if constexpr (!__libcpp_is_contiguous_iterator<_Iterator1>::value &&
                !__libcpp_is_contiguous_iterator<_Iterator2>::value){
#pragma omp target teams distribute parallel for simd map( always,to : __first1, __first2) map(from:__first3[0 : __n]) device(__device)

    for (_DifferenceType __i = 0; __i < __n; ++__i)
      __first3[__i] = __f(*(__first1+__i), *(__first2+__i));
    return __first1 + __n;
  }
  else if constexpr (!__libcpp_is_contiguous_iterator<_Iterator1>::value ){
    if (are_not_same_type || (no_overlap_13 && no_overlap_23)) {
#pragma omp target teams distribute parallel for simd map(always,to : __first1) map(to:__first2[0 : __n]) map(from:__first3[0 : __n]) device(__device)


      for (_DifferenceType __i = 0; __i < __n; ++__i)
        __first3[__i] = __f(*(__first1+__i), __first2[__i]);
    } else {
#pragma omp target teams distribute parallel for simd map(always,to : __first1) map(tofrom:__first2[0 : __n],__first3[0 : __n]) device(__device)

      for (_DifferenceType __i = 0; __i < __n; ++__i)
        __first3[__i] = __f(*(__first1+__i), __first2[__i]);
    }
    return __first1 + __n;
  }
  else if constexpr (!__libcpp_is_contiguous_iterator<_Iterator2>::value ){
    if (are_not_same_type || (no_overlap_13 && no_overlap_23)) {
#pragma omp target teams distribute parallel for simd map(always,to : __first2) map(to:__first1[0 : __n]) map(from:__first3[0 : __n]) device(__device)


      for (_DifferenceType __i = 0; __i < __n; ++__i)
        __first3[__i] = __f(__first1[__i], *(__first2+__i));
    }
    else {
#pragma omp target teams distribute parallel for simd map(always,to : __first2) map(tofrom:__first1[0 : __n],__first3[0 : __n]) device(__device)

      for (_DifferenceType __i = 0; __i < __n; ++__i)
        __first3[__i] = __f(__first1[__i], *(__first2+__i));
    }
    return __first1 + __n;
  }
  else {
    if (are_not_same_type || (no_overlap_13 && no_overlap_23)) {
#pragma omp target teams distribute parallel for simd map(to : __first1[0 : __n], __first2[0 : __n]) map(from : __first3[0 : __n]) device(__device)

      for (_DifferenceType __i = 0; __i < __n; ++__i)
        __first3[__i] = __f(__first1[__i], __first2[__i]);
      return __first1 + __n;
    }

#pragma omp target teams distribute parallel for simd map( tofrom : __first1[0 : __n], __first2[0 : __n], __first3[0 : __n]) device(__device)

    for (_DifferenceType __i = 0; __i < __n; ++__i)
      __first3[__i] = __f(__first1[__i], __first2[__i]);

    return __first1 + __n;
  }
}



template <class _Iterator1, class _DifferenceType, class _Iterator2, class _Iterator3, class _Function>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) _Iterator1 __parallel_for_simd_3(
    _Iterator1 __first1, _DifferenceType __n, _Iterator2 __first2, _Iterator3 __first3, _Function __f) noexcept {
  __omp_parallel_for_simd_3(
      __omp_gpu_backend::__omp_extract_base_ptr(__first1),
      __n,
      __omp_gpu_backend::__omp_extract_base_ptr(__first2),
      __omp_gpu_backend::__omp_extract_base_ptr(__first3),
      __f);
  return __first1 + __n;
}
# 341 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/gpu_backends/omp_offload.h" 3
template <class _Iterator, class _DifferenceType, typename _Tp, typename _BinaryOperationType, typename _UnaryOperation> __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) _Tp __omp_parallel_for_simd_reduction_1( _Iterator __first, _DifferenceType __n, _Tp __init, std::plus<_BinaryOperationType> __reduce, _UnaryOperation __transform, [[maybe_unused]] const int __device = 0) noexcept { if constexpr (__libcpp_is_contiguous_iterator<_Iterator>::value) {
# 341 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/gpu_backends/omp_offload.h" 3
#pragma omp target teams distribute parallel for simd reduction(+:__init) map(to : __first[0 : __n]) device(__device)
# 341 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/gpu_backends/omp_offload.h" 3
 for (_DifferenceType __i = 0; __i < __n; ++__i) __init = __reduce(__init, __transform(__first[__i])); } else {
# 341 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/gpu_backends/omp_offload.h" 3
#pragma omp target teams distribute parallel for simd reduction(+:__init) map(always,to : __first) device(__device)
# 341 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/gpu_backends/omp_offload.h" 3
 for (_DifferenceType __i = 0; __i < __n; ++__i) __init = __reduce(__init, __transform(*(__first + __i))); } return __init; } template <class _Iterator1, class _Iterator2, class _DifferenceType, typename _Tp, typename _BinaryOperationType, typename _UnaryOperation > __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) _Tp __omp_parallel_for_simd_reduction_2( _Iterator1 __first1, _Iterator2 __first2, _DifferenceType __n, _Tp __init, std::plus<_BinaryOperationType> __reduce, _UnaryOperation __transform, [[maybe_unused]] const int __device = 0) noexcept { if constexpr (__libcpp_is_contiguous_iterator<_Iterator1>::value && __libcpp_is_contiguous_iterator<_Iterator2>::value) {
# 341 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/gpu_backends/omp_offload.h" 3
#pragma omp target teams distribute parallel for simd reduction(+:__init) map(to : __first1[0 : __n], __first2[0 : __n]) device(__device)
# 341 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/gpu_backends/omp_offload.h" 3
 for (_DifferenceType __i = 0; __i < __n; ++__i) __init = __reduce(__init, __transform(__first1[__i], __first2[__i])); } else if constexpr (__libcpp_is_contiguous_iterator<_Iterator1>::value) {
# 341 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/gpu_backends/omp_offload.h" 3
#pragma omp target teams distribute parallel for simd reduction(+:__init) map(to : __first1[0 : __n]) map(always,to:__first2) device(__device)
# 341 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/gpu_backends/omp_offload.h" 3
 for (_DifferenceType __i = 0; __i < __n; ++__i) __init = __reduce(__init, __transform(__first1[__i], *(__first2 + __i))); } else if constexpr (__libcpp_is_contiguous_iterator<_Iterator2>::value) {
# 341 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/gpu_backends/omp_offload.h" 3
#pragma omp target teams distribute parallel for simd reduction(+:__init) map(to : __first2[0 : __n]) map(always,to:__first1) device(__device)
# 341 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/gpu_backends/omp_offload.h" 3
 for (_DifferenceType __i = 0; __i < __n; ++__i) __init = __reduce(__init, __transform(*(__first1 + __i),__first2[__i])); } else {
# 341 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/gpu_backends/omp_offload.h" 3
#pragma omp target teams distribute parallel for simd reduction(+:__init) map(always,to:__first1,__first2) device(__device)
# 341 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/gpu_backends/omp_offload.h" 3
 for (_DifferenceType __i = 0; __i < __n; ++__i) __init = __reduce(__init, __transform(*(__first1 + __i), *(__first2 + __i))); } return __init; }


template <class _Iterator, class _DifferenceType, typename _Tp, typename _BinaryOperationType, typename _UnaryOperation> __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) _Tp __omp_parallel_for_simd_reduction_1( _Iterator __first, _DifferenceType __n, _Tp __init, std::minus<_BinaryOperationType> __reduce, _UnaryOperation __transform, [[maybe_unused]] const int __device = 0) noexcept { if constexpr (__libcpp_is_contiguous_iterator<_Iterator>::value) {
# 344 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/gpu_backends/omp_offload.h" 3
#pragma omp target teams distribute parallel for simd reduction(-:__init) map(to : __first[0 : __n]) device(__device)
# 344 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/gpu_backends/omp_offload.h" 3
 for (_DifferenceType __i = 0; __i < __n; ++__i) __init = __reduce(__init, __transform(__first[__i])); } else {
# 344 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/gpu_backends/omp_offload.h" 3
#pragma omp target teams distribute parallel for simd reduction(-:__init) map(always,to : __first) device(__device)
# 344 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/gpu_backends/omp_offload.h" 3
 for (_DifferenceType __i = 0; __i < __n; ++__i) __init = __reduce(__init, __transform(*(__first + __i))); } return __init; } template <class _Iterator1, class _Iterator2, class _DifferenceType, typename _Tp, typename _BinaryOperationType, typename _UnaryOperation > __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) _Tp __omp_parallel_for_simd_reduction_2( _Iterator1 __first1, _Iterator2 __first2, _DifferenceType __n, _Tp __init, std::minus<_BinaryOperationType> __reduce, _UnaryOperation __transform, [[maybe_unused]] const int __device = 0) noexcept { if constexpr (__libcpp_is_contiguous_iterator<_Iterator1>::value && __libcpp_is_contiguous_iterator<_Iterator2>::value) {
# 344 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/gpu_backends/omp_offload.h" 3
#pragma omp target teams distribute parallel for simd reduction(-:__init) map(to : __first1[0 : __n], __first2[0 : __n]) device(__device)
# 344 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/gpu_backends/omp_offload.h" 3
 for (_DifferenceType __i = 0; __i < __n; ++__i) __init = __reduce(__init, __transform(__first1[__i], __first2[__i])); } else if constexpr (__libcpp_is_contiguous_iterator<_Iterator1>::value) {
# 344 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/gpu_backends/omp_offload.h" 3
#pragma omp target teams distribute parallel for simd reduction(-:__init) map(to : __first1[0 : __n]) map(always,to:__first2) device(__device)
# 344 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/gpu_backends/omp_offload.h" 3
 for (_DifferenceType __i = 0; __i < __n; ++__i) __init = __reduce(__init, __transform(__first1[__i], *(__first2 + __i))); } else if constexpr (__libcpp_is_contiguous_iterator<_Iterator2>::value) {
# 344 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/gpu_backends/omp_offload.h" 3
#pragma omp target teams distribute parallel for simd reduction(-:__init) map(to : __first2[0 : __n]) map(always,to:__first1) device(__device)
# 344 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/gpu_backends/omp_offload.h" 3
 for (_DifferenceType __i = 0; __i < __n; ++__i) __init = __reduce(__init, __transform(*(__first1 + __i),__first2[__i])); } else {
# 344 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/gpu_backends/omp_offload.h" 3
#pragma omp target teams distribute parallel for simd reduction(-:__init) map(always,to:__first1,__first2) device(__device)
# 344 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/gpu_backends/omp_offload.h" 3
 for (_DifferenceType __i = 0; __i < __n; ++__i) __init = __reduce(__init, __transform(*(__first1 + __i), *(__first2 + __i))); } return __init; }


template <class _Iterator, class _DifferenceType, typename _Tp, typename _BinaryOperationType, typename _UnaryOperation> __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) _Tp __omp_parallel_for_simd_reduction_1( _Iterator __first, _DifferenceType __n, _Tp __init, std::multiplies<_BinaryOperationType> __reduce, _UnaryOperation __transform, [[maybe_unused]] const int __device = 0) noexcept { if constexpr (__libcpp_is_contiguous_iterator<_Iterator>::value) {
# 347 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/gpu_backends/omp_offload.h" 3
#pragma omp target teams distribute parallel for simd reduction(*:__init) map(to : __first[0 : __n]) device(__device)
# 347 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/gpu_backends/omp_offload.h" 3
 for (_DifferenceType __i = 0; __i < __n; ++__i) __init = __reduce(__init, __transform(__first[__i])); } else {
# 347 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/gpu_backends/omp_offload.h" 3
#pragma omp target teams distribute parallel for simd reduction(*:__init) map(always,to : __first) device(__device)
# 347 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/gpu_backends/omp_offload.h" 3
 for (_DifferenceType __i = 0; __i < __n; ++__i) __init = __reduce(__init, __transform(*(__first + __i))); } return __init; } template <class _Iterator1, class _Iterator2, class _DifferenceType, typename _Tp, typename _BinaryOperationType, typename _UnaryOperation > __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) _Tp __omp_parallel_for_simd_reduction_2( _Iterator1 __first1, _Iterator2 __first2, _DifferenceType __n, _Tp __init, std::multiplies<_BinaryOperationType> __reduce, _UnaryOperation __transform, [[maybe_unused]] const int __device = 0) noexcept { if constexpr (__libcpp_is_contiguous_iterator<_Iterator1>::value && __libcpp_is_contiguous_iterator<_Iterator2>::value) {
# 347 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/gpu_backends/omp_offload.h" 3
#pragma omp target teams distribute parallel for simd reduction(*:__init) map(to : __first1[0 : __n], __first2[0 : __n]) device(__device)
# 347 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/gpu_backends/omp_offload.h" 3
 for (_DifferenceType __i = 0; __i < __n; ++__i) __init = __reduce(__init, __transform(__first1[__i], __first2[__i])); } else if constexpr (__libcpp_is_contiguous_iterator<_Iterator1>::value) {
# 347 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/gpu_backends/omp_offload.h" 3
#pragma omp target teams distribute parallel for simd reduction(*:__init) map(to : __first1[0 : __n]) map(always,to:__first2) device(__device)
# 347 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/gpu_backends/omp_offload.h" 3
 for (_DifferenceType __i = 0; __i < __n; ++__i) __init = __reduce(__init, __transform(__first1[__i], *(__first2 + __i))); } else if constexpr (__libcpp_is_contiguous_iterator<_Iterator2>::value) {
# 347 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/gpu_backends/omp_offload.h" 3
#pragma omp target teams distribute parallel for simd reduction(*:__init) map(to : __first2[0 : __n]) map(always,to:__first1) device(__device)
# 347 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/gpu_backends/omp_offload.h" 3
 for (_DifferenceType __i = 0; __i < __n; ++__i) __init = __reduce(__init, __transform(*(__first1 + __i),__first2[__i])); } else {
# 347 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/gpu_backends/omp_offload.h" 3
#pragma omp target teams distribute parallel for simd reduction(*:__init) map(always,to:__first1,__first2) device(__device)
# 347 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/gpu_backends/omp_offload.h" 3
 for (_DifferenceType __i = 0; __i < __n; ++__i) __init = __reduce(__init, __transform(*(__first1 + __i), *(__first2 + __i))); } return __init; }


template <class _Iterator, class _DifferenceType, typename _Tp, typename _BinaryOperationType, typename _UnaryOperation> __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) _Tp __omp_parallel_for_simd_reduction_1( _Iterator __first, _DifferenceType __n, _Tp __init, std::logical_and<_BinaryOperationType> __reduce, _UnaryOperation __transform, [[maybe_unused]] const int __device = 0) noexcept { if constexpr (__libcpp_is_contiguous_iterator<_Iterator>::value) {
# 350 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/gpu_backends/omp_offload.h" 3
#pragma omp target teams distribute parallel for simd reduction(&&:__init) map(to : __first[0 : __n]) device(__device)
# 350 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/gpu_backends/omp_offload.h" 3
 for (_DifferenceType __i = 0; __i < __n; ++__i) __init = __reduce(__init, __transform(__first[__i])); } else {
# 350 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/gpu_backends/omp_offload.h" 3
#pragma omp target teams distribute parallel for simd reduction(&&:__init) map(always,to : __first) device(__device)
# 350 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/gpu_backends/omp_offload.h" 3
 for (_DifferenceType __i = 0; __i < __n; ++__i) __init = __reduce(__init, __transform(*(__first + __i))); } return __init; } template <class _Iterator1, class _Iterator2, class _DifferenceType, typename _Tp, typename _BinaryOperationType, typename _UnaryOperation > __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) _Tp __omp_parallel_for_simd_reduction_2( _Iterator1 __first1, _Iterator2 __first2, _DifferenceType __n, _Tp __init, std::logical_and<_BinaryOperationType> __reduce, _UnaryOperation __transform, [[maybe_unused]] const int __device = 0) noexcept { if constexpr (__libcpp_is_contiguous_iterator<_Iterator1>::value && __libcpp_is_contiguous_iterator<_Iterator2>::value) {
# 350 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/gpu_backends/omp_offload.h" 3
#pragma omp target teams distribute parallel for simd reduction(&&:__init) map(to : __first1[0 : __n], __first2[0 : __n]) device(__device)
# 350 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/gpu_backends/omp_offload.h" 3
 for (_DifferenceType __i = 0; __i < __n; ++__i) __init = __reduce(__init, __transform(__first1[__i], __first2[__i])); } else if constexpr (__libcpp_is_contiguous_iterator<_Iterator1>::value) {
# 350 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/gpu_backends/omp_offload.h" 3
#pragma omp target teams distribute parallel for simd reduction(&&:__init) map(to : __first1[0 : __n]) map(always,to:__first2) device(__device)
# 350 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/gpu_backends/omp_offload.h" 3
 for (_DifferenceType __i = 0; __i < __n; ++__i) __init = __reduce(__init, __transform(__first1[__i], *(__first2 + __i))); } else if constexpr (__libcpp_is_contiguous_iterator<_Iterator2>::value) {
# 350 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/gpu_backends/omp_offload.h" 3
#pragma omp target teams distribute parallel for simd reduction(&&:__init) map(to : __first2[0 : __n]) map(always,to:__first1) device(__device)
# 350 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/gpu_backends/omp_offload.h" 3
 for (_DifferenceType __i = 0; __i < __n; ++__i) __init = __reduce(__init, __transform(*(__first1 + __i),__first2[__i])); } else {
# 350 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/gpu_backends/omp_offload.h" 3
#pragma omp target teams distribute parallel for simd reduction(&&:__init) map(always,to:__first1,__first2) device(__device)
# 350 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/gpu_backends/omp_offload.h" 3
 for (_DifferenceType __i = 0; __i < __n; ++__i) __init = __reduce(__init, __transform(*(__first1 + __i), *(__first2 + __i))); } return __init; }


template <class _Iterator, class _DifferenceType, typename _Tp, typename _BinaryOperationType, typename _UnaryOperation> __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) _Tp __omp_parallel_for_simd_reduction_1( _Iterator __first, _DifferenceType __n, _Tp __init, std::logical_or<_BinaryOperationType> __reduce, _UnaryOperation __transform, [[maybe_unused]] const int __device = 0) noexcept { if constexpr (__libcpp_is_contiguous_iterator<_Iterator>::value) {
# 353 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/gpu_backends/omp_offload.h" 3
#pragma omp target teams distribute parallel for simd reduction(||:__init) map(to : __first[0 : __n]) device(__device)
# 353 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/gpu_backends/omp_offload.h" 3
 for (_DifferenceType __i = 0; __i < __n; ++__i) __init = __reduce(__init, __transform(__first[__i])); } else {
# 353 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/gpu_backends/omp_offload.h" 3
#pragma omp target teams distribute parallel for simd reduction(||:__init) map(always,to : __first) device(__device)
# 353 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/gpu_backends/omp_offload.h" 3
 for (_DifferenceType __i = 0; __i < __n; ++__i) __init = __reduce(__init, __transform(*(__first + __i))); } return __init; } template <class _Iterator1, class _Iterator2, class _DifferenceType, typename _Tp, typename _BinaryOperationType, typename _UnaryOperation > __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) _Tp __omp_parallel_for_simd_reduction_2( _Iterator1 __first1, _Iterator2 __first2, _DifferenceType __n, _Tp __init, std::logical_or<_BinaryOperationType> __reduce, _UnaryOperation __transform, [[maybe_unused]] const int __device = 0) noexcept { if constexpr (__libcpp_is_contiguous_iterator<_Iterator1>::value && __libcpp_is_contiguous_iterator<_Iterator2>::value) {
# 353 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/gpu_backends/omp_offload.h" 3
#pragma omp target teams distribute parallel for simd reduction(||:__init) map(to : __first1[0 : __n], __first2[0 : __n]) device(__device)
# 353 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/gpu_backends/omp_offload.h" 3
 for (_DifferenceType __i = 0; __i < __n; ++__i) __init = __reduce(__init, __transform(__first1[__i], __first2[__i])); } else if constexpr (__libcpp_is_contiguous_iterator<_Iterator1>::value) {
# 353 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/gpu_backends/omp_offload.h" 3
#pragma omp target teams distribute parallel for simd reduction(||:__init) map(to : __first1[0 : __n]) map(always,to:__first2) device(__device)
# 353 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/gpu_backends/omp_offload.h" 3
 for (_DifferenceType __i = 0; __i < __n; ++__i) __init = __reduce(__init, __transform(__first1[__i], *(__first2 + __i))); } else if constexpr (__libcpp_is_contiguous_iterator<_Iterator2>::value) {
# 353 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/gpu_backends/omp_offload.h" 3
#pragma omp target teams distribute parallel for simd reduction(||:__init) map(to : __first2[0 : __n]) map(always,to:__first1) device(__device)
# 353 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/gpu_backends/omp_offload.h" 3
 for (_DifferenceType __i = 0; __i < __n; ++__i) __init = __reduce(__init, __transform(*(__first1 + __i),__first2[__i])); } else {
# 353 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/gpu_backends/omp_offload.h" 3
#pragma omp target teams distribute parallel for simd reduction(||:__init) map(always,to:__first1,__first2) device(__device)
# 353 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/gpu_backends/omp_offload.h" 3
 for (_DifferenceType __i = 0; __i < __n; ++__i) __init = __reduce(__init, __transform(*(__first1 + __i), *(__first2 + __i))); } return __init; }


template <class _Iterator, class _DifferenceType, typename _Tp, typename _BinaryOperationType, typename _UnaryOperation> __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) _Tp __omp_parallel_for_simd_reduction_1( _Iterator __first, _DifferenceType __n, _Tp __init, std::bit_and<_BinaryOperationType> __reduce, _UnaryOperation __transform, [[maybe_unused]] const int __device = 0) noexcept { if constexpr (__libcpp_is_contiguous_iterator<_Iterator>::value) {
# 356 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/gpu_backends/omp_offload.h" 3
#pragma omp target teams distribute parallel for simd reduction(&:__init) map(to : __first[0 : __n]) device(__device)
# 356 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/gpu_backends/omp_offload.h" 3
 for (_DifferenceType __i = 0; __i < __n; ++__i) __init = __reduce(__init, __transform(__first[__i])); } else {
# 356 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/gpu_backends/omp_offload.h" 3
#pragma omp target teams distribute parallel for simd reduction(&:__init) map(always,to : __first) device(__device)
# 356 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/gpu_backends/omp_offload.h" 3
 for (_DifferenceType __i = 0; __i < __n; ++__i) __init = __reduce(__init, __transform(*(__first + __i))); } return __init; } template <class _Iterator1, class _Iterator2, class _DifferenceType, typename _Tp, typename _BinaryOperationType, typename _UnaryOperation > __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) _Tp __omp_parallel_for_simd_reduction_2( _Iterator1 __first1, _Iterator2 __first2, _DifferenceType __n, _Tp __init, std::bit_and<_BinaryOperationType> __reduce, _UnaryOperation __transform, [[maybe_unused]] const int __device = 0) noexcept { if constexpr (__libcpp_is_contiguous_iterator<_Iterator1>::value && __libcpp_is_contiguous_iterator<_Iterator2>::value) {
# 356 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/gpu_backends/omp_offload.h" 3
#pragma omp target teams distribute parallel for simd reduction(&:__init) map(to : __first1[0 : __n], __first2[0 : __n]) device(__device)
# 356 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/gpu_backends/omp_offload.h" 3
 for (_DifferenceType __i = 0; __i < __n; ++__i) __init = __reduce(__init, __transform(__first1[__i], __first2[__i])); } else if constexpr (__libcpp_is_contiguous_iterator<_Iterator1>::value) {
# 356 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/gpu_backends/omp_offload.h" 3
#pragma omp target teams distribute parallel for simd reduction(&:__init) map(to : __first1[0 : __n]) map(always,to:__first2) device(__device)
# 356 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/gpu_backends/omp_offload.h" 3
 for (_DifferenceType __i = 0; __i < __n; ++__i) __init = __reduce(__init, __transform(__first1[__i], *(__first2 + __i))); } else if constexpr (__libcpp_is_contiguous_iterator<_Iterator2>::value) {
# 356 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/gpu_backends/omp_offload.h" 3
#pragma omp target teams distribute parallel for simd reduction(&:__init) map(to : __first2[0 : __n]) map(always,to:__first1) device(__device)
# 356 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/gpu_backends/omp_offload.h" 3
 for (_DifferenceType __i = 0; __i < __n; ++__i) __init = __reduce(__init, __transform(*(__first1 + __i),__first2[__i])); } else {
# 356 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/gpu_backends/omp_offload.h" 3
#pragma omp target teams distribute parallel for simd reduction(&:__init) map(always,to:__first1,__first2) device(__device)
# 356 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/gpu_backends/omp_offload.h" 3
 for (_DifferenceType __i = 0; __i < __n; ++__i) __init = __reduce(__init, __transform(*(__first1 + __i), *(__first2 + __i))); } return __init; }


template <class _Iterator, class _DifferenceType, typename _Tp, typename _BinaryOperationType, typename _UnaryOperation> __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) _Tp __omp_parallel_for_simd_reduction_1( _Iterator __first, _DifferenceType __n, _Tp __init, std::bit_or<_BinaryOperationType> __reduce, _UnaryOperation __transform, [[maybe_unused]] const int __device = 0) noexcept { if constexpr (__libcpp_is_contiguous_iterator<_Iterator>::value) {
# 359 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/gpu_backends/omp_offload.h" 3
#pragma omp target teams distribute parallel for simd reduction(|:__init) map(to : __first[0 : __n]) device(__device)
# 359 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/gpu_backends/omp_offload.h" 3
 for (_DifferenceType __i = 0; __i < __n; ++__i) __init = __reduce(__init, __transform(__first[__i])); } else {
# 359 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/gpu_backends/omp_offload.h" 3
#pragma omp target teams distribute parallel for simd reduction(|:__init) map(always,to : __first) device(__device)
# 359 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/gpu_backends/omp_offload.h" 3
 for (_DifferenceType __i = 0; __i < __n; ++__i) __init = __reduce(__init, __transform(*(__first + __i))); } return __init; } template <class _Iterator1, class _Iterator2, class _DifferenceType, typename _Tp, typename _BinaryOperationType, typename _UnaryOperation > __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) _Tp __omp_parallel_for_simd_reduction_2( _Iterator1 __first1, _Iterator2 __first2, _DifferenceType __n, _Tp __init, std::bit_or<_BinaryOperationType> __reduce, _UnaryOperation __transform, [[maybe_unused]] const int __device = 0) noexcept { if constexpr (__libcpp_is_contiguous_iterator<_Iterator1>::value && __libcpp_is_contiguous_iterator<_Iterator2>::value) {
# 359 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/gpu_backends/omp_offload.h" 3
#pragma omp target teams distribute parallel for simd reduction(|:__init) map(to : __first1[0 : __n], __first2[0 : __n]) device(__device)
# 359 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/gpu_backends/omp_offload.h" 3
 for (_DifferenceType __i = 0; __i < __n; ++__i) __init = __reduce(__init, __transform(__first1[__i], __first2[__i])); } else if constexpr (__libcpp_is_contiguous_iterator<_Iterator1>::value) {
# 359 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/gpu_backends/omp_offload.h" 3
#pragma omp target teams distribute parallel for simd reduction(|:__init) map(to : __first1[0 : __n]) map(always,to:__first2) device(__device)
# 359 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/gpu_backends/omp_offload.h" 3
 for (_DifferenceType __i = 0; __i < __n; ++__i) __init = __reduce(__init, __transform(__first1[__i], *(__first2 + __i))); } else if constexpr (__libcpp_is_contiguous_iterator<_Iterator2>::value) {
# 359 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/gpu_backends/omp_offload.h" 3
#pragma omp target teams distribute parallel for simd reduction(|:__init) map(to : __first2[0 : __n]) map(always,to:__first1) device(__device)
# 359 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/gpu_backends/omp_offload.h" 3
 for (_DifferenceType __i = 0; __i < __n; ++__i) __init = __reduce(__init, __transform(*(__first1 + __i),__first2[__i])); } else {
# 359 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/gpu_backends/omp_offload.h" 3
#pragma omp target teams distribute parallel for simd reduction(|:__init) map(always,to:__first1,__first2) device(__device)
# 359 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/gpu_backends/omp_offload.h" 3
 for (_DifferenceType __i = 0; __i < __n; ++__i) __init = __reduce(__init, __transform(*(__first1 + __i), *(__first2 + __i))); } return __init; }


template <class _Iterator, class _DifferenceType, typename _Tp, typename _BinaryOperationType, typename _UnaryOperation> __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) _Tp __omp_parallel_for_simd_reduction_1( _Iterator __first, _DifferenceType __n, _Tp __init, std::bit_xor<_BinaryOperationType> __reduce, _UnaryOperation __transform, [[maybe_unused]] const int __device = 0) noexcept { if constexpr (__libcpp_is_contiguous_iterator<_Iterator>::value) {
# 362 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/gpu_backends/omp_offload.h" 3
#pragma omp target teams distribute parallel for simd reduction(^:__init) map(to : __first[0 : __n]) device(__device)
# 362 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/gpu_backends/omp_offload.h" 3
 for (_DifferenceType __i = 0; __i < __n; ++__i) __init = __reduce(__init, __transform(__first[__i])); } else {
# 362 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/gpu_backends/omp_offload.h" 3
#pragma omp target teams distribute parallel for simd reduction(^:__init) map(always,to : __first) device(__device)
# 362 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/gpu_backends/omp_offload.h" 3
 for (_DifferenceType __i = 0; __i < __n; ++__i) __init = __reduce(__init, __transform(*(__first + __i))); } return __init; } template <class _Iterator1, class _Iterator2, class _DifferenceType, typename _Tp, typename _BinaryOperationType, typename _UnaryOperation > __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) _Tp __omp_parallel_for_simd_reduction_2( _Iterator1 __first1, _Iterator2 __first2, _DifferenceType __n, _Tp __init, std::bit_xor<_BinaryOperationType> __reduce, _UnaryOperation __transform, [[maybe_unused]] const int __device = 0) noexcept { if constexpr (__libcpp_is_contiguous_iterator<_Iterator1>::value && __libcpp_is_contiguous_iterator<_Iterator2>::value) {
# 362 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/gpu_backends/omp_offload.h" 3
#pragma omp target teams distribute parallel for simd reduction(^:__init) map(to : __first1[0 : __n], __first2[0 : __n]) device(__device)
# 362 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/gpu_backends/omp_offload.h" 3
 for (_DifferenceType __i = 0; __i < __n; ++__i) __init = __reduce(__init, __transform(__first1[__i], __first2[__i])); } else if constexpr (__libcpp_is_contiguous_iterator<_Iterator1>::value) {
# 362 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/gpu_backends/omp_offload.h" 3
#pragma omp target teams distribute parallel for simd reduction(^:__init) map(to : __first1[0 : __n]) map(always,to:__first2) device(__device)
# 362 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/gpu_backends/omp_offload.h" 3
 for (_DifferenceType __i = 0; __i < __n; ++__i) __init = __reduce(__init, __transform(__first1[__i], *(__first2 + __i))); } else if constexpr (__libcpp_is_contiguous_iterator<_Iterator2>::value) {
# 362 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/gpu_backends/omp_offload.h" 3
#pragma omp target teams distribute parallel for simd reduction(^:__init) map(to : __first2[0 : __n]) map(always,to:__first1) device(__device)
# 362 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/gpu_backends/omp_offload.h" 3
 for (_DifferenceType __i = 0; __i < __n; ++__i) __init = __reduce(__init, __transform(*(__first1 + __i),__first2[__i])); } else {
# 362 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/gpu_backends/omp_offload.h" 3
#pragma omp target teams distribute parallel for simd reduction(^:__init) map(always,to:__first1,__first2) device(__device)
# 362 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/gpu_backends/omp_offload.h" 3
 for (_DifferenceType __i = 0; __i < __n; ++__i) __init = __reduce(__init, __transform(*(__first1 + __i), *(__first2 + __i))); } return __init; }



template <class _Iterator, class _DifferenceType, typename _Tp, typename _BinaryOperation, typename _UnaryOperation >
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) _Tp __parallel_for_simd_reduction_1(
    _Iterator __first,
    _DifferenceType __n,
    _Tp __init,
    _BinaryOperation __reduce,
    _UnaryOperation __transform,
    [[maybe_unused]] const int __device = 0) noexcept {
  return __omp_parallel_for_simd_reduction_1(
      __omp_gpu_backend::__omp_extract_base_ptr(__first), __n, __init, __reduce, __transform);
}

template <class _Iterator1,
          class _Iterator2,
          class _DifferenceType,
          typename _Tp,
          typename _BinaryOperation,
          typename _UnaryOperation >
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) _Tp __parallel_for_simd_reduction_2(
    _Iterator1 __first1,
    _Iterator2 __first2,
    _DifferenceType __n,
    _Tp __init,
    _BinaryOperation __reduce,
    _UnaryOperation __transform,
    [[maybe_unused]] const int __device = 0) noexcept {
  return __omp_parallel_for_simd_reduction_2(
      __omp_gpu_backend::__omp_extract_base_ptr(__first1),
      __omp_gpu_backend::__omp_extract_base_ptr(__first2),
      __n,
      __init,
      __reduce,
      __transform);
}

}
}

}}
# 18 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/gpu_backends/backend.h" 2 3
# 25 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/gpu_backends/backend.h" 3




namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

struct __gpu_backend_tag {};

}}
# 15 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/gpu_backend.h" 2 3


# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/gpu_backends/any_of.h" 1 3
# 28 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/gpu_backends/any_of.h" 3
namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _ExecutionPolicy, class _ForwardIterator, class _Predicate>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) bool
__pstl_any_of(__gpu_backend_tag, _ForwardIterator __first, _ForwardIterator __last, _Predicate __pred) {

  return std::__pstl_any_of<_ExecutionPolicy>(__cpu_backend_tag{}, __first, __last, __pred);
}

}}
# 18 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/gpu_backend.h" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/gpu_backends/fill.h" 1 3
# 20 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/gpu_backends/fill.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/llvm_libc_wrappers/stdio.h" 1 3
# 16 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/llvm_libc_wrappers/stdio.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/stdio.h" 1 3
# 105 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/stdio.h" 3



# 1 "/usr/include/stdio.h" 1 3 4
# 27 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/bits/libc-header-start.h" 1 3 4
# 28 "/usr/include/stdio.h" 2 3 4

extern "C" {



# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/stddef.h" 1 3 4
# 15 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/stddef.h" 3


# 1 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/stddef.h" 1 3
# 59 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/stddef.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/__stddef_size_t.h" 1 3
# 15 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/__stddef_size_t.h" 3
typedef long unsigned int size_t;
# 60 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/stddef.h" 2 3
# 74 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/stddef.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/__stddef_null.h" 1 3
# 75 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/stddef.h" 2 3
# 18 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/stddef.h" 2 3
# 34 "/usr/include/stdio.h" 2 3 4


# 1 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/stdarg.h" 1 3 4
# 37 "/usr/include/stdio.h" 2 3 4


# 1 "/usr/include/bits/types/__fpos_t.h" 1 3 4
# 10 "/usr/include/bits/types/__fpos_t.h" 3 4
typedef struct _G_fpos_t
{
  __off_t __pos;
  __mbstate_t __state;
} __fpos_t;
# 40 "/usr/include/stdio.h" 2 3 4
# 1 "/usr/include/bits/types/__fpos64_t.h" 1 3 4
# 10 "/usr/include/bits/types/__fpos64_t.h" 3 4
typedef struct _G_fpos64_t
{
  __off64_t __pos;
  __mbstate_t __state;
} __fpos64_t;
# 41 "/usr/include/stdio.h" 2 3 4


# 1 "/usr/include/bits/types/struct_FILE.h" 1 3 4
# 35 "/usr/include/bits/types/struct_FILE.h" 3 4
struct _IO_FILE;
struct _IO_marker;
struct _IO_codecvt;
struct _IO_wide_data;




typedef void _IO_lock_t;





struct _IO_FILE
{
  int _flags;


  char *_IO_read_ptr;
  char *_IO_read_end;
  char *_IO_read_base;
  char *_IO_write_base;
  char *_IO_write_ptr;
  char *_IO_write_end;
  char *_IO_buf_base;
  char *_IO_buf_end;


  char *_IO_save_base;
  char *_IO_backup_base;
  char *_IO_save_end;

  struct _IO_marker *_markers;

  struct _IO_FILE *_chain;

  int _fileno;
  int _flags2;
  __off_t _old_offset;


  unsigned short _cur_column;
  signed char _vtable_offset;
  char _shortbuf[1];

  _IO_lock_t *_lock;







  __off64_t _offset;

  struct _IO_codecvt *_codecvt;
  struct _IO_wide_data *_wide_data;
  struct _IO_FILE *_freeres_list;
  void *_freeres_buf;
  size_t __pad5;
  int _mode;

  char _unused2[15 * sizeof (int) - 4 * sizeof (void *) - sizeof (size_t)];
};
# 44 "/usr/include/stdio.h" 2 3 4


# 1 "/usr/include/bits/types/cookie_io_functions_t.h" 1 3 4
# 27 "/usr/include/bits/types/cookie_io_functions_t.h" 3 4
typedef __ssize_t cookie_read_function_t (void *__cookie, char *__buf,
                                          size_t __nbytes);







typedef __ssize_t cookie_write_function_t (void *__cookie, const char *__buf,
                                           size_t __nbytes);







typedef int cookie_seek_function_t (void *__cookie, __off64_t *__pos, int __w);


typedef int cookie_close_function_t (void *__cookie);






typedef struct _IO_cookie_io_functions_t
{
  cookie_read_function_t *read;
  cookie_write_function_t *write;
  cookie_seek_function_t *seek;
  cookie_close_function_t *close;
} cookie_io_functions_t;
# 47 "/usr/include/stdio.h" 2 3 4





typedef __gnuc_va_list va_list;
# 84 "/usr/include/stdio.h" 3 4
typedef __fpos_t fpos_t;




typedef __fpos64_t fpos64_t;
# 133 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/bits/stdio_lim.h" 1 3 4
# 134 "/usr/include/stdio.h" 2 3 4



extern FILE *stdin;
extern FILE *stdout;
extern FILE *stderr;






extern int remove (const char *__filename) throw ();

extern int rename (const char *__old, const char *__new) throw ();



extern int renameat (int __oldfd, const char *__old, int __newfd,
       const char *__new) throw ();
# 164 "/usr/include/stdio.h" 3 4
extern int renameat2 (int __oldfd, const char *__old, int __newfd,
        const char *__new, unsigned int __flags) throw ();







extern FILE *tmpfile (void) ;
# 183 "/usr/include/stdio.h" 3 4
extern FILE *tmpfile64 (void) ;



extern char *tmpnam (char *__s) throw () ;




extern char *tmpnam_r (char *__s) throw () ;
# 204 "/usr/include/stdio.h" 3 4
extern char *tempnam (const char *__dir, const char *__pfx)
     throw () __attribute__ ((__malloc__)) ;







extern int fclose (FILE *__stream);




extern int fflush (FILE *__stream);
# 227 "/usr/include/stdio.h" 3 4
extern int fflush_unlocked (FILE *__stream);
# 237 "/usr/include/stdio.h" 3 4
extern int fcloseall (void);
# 246 "/usr/include/stdio.h" 3 4
extern FILE *fopen (const char *__restrict __filename,
      const char *__restrict __modes) ;




extern FILE *freopen (const char *__restrict __filename,
        const char *__restrict __modes,
        FILE *__restrict __stream) ;
# 270 "/usr/include/stdio.h" 3 4
extern FILE *fopen64 (const char *__restrict __filename,
        const char *__restrict __modes) ;
extern FILE *freopen64 (const char *__restrict __filename,
   const char *__restrict __modes,
   FILE *__restrict __stream) ;




extern FILE *fdopen (int __fd, const char *__modes) throw () ;





extern FILE *fopencookie (void *__restrict __magic_cookie,
     const char *__restrict __modes,
     cookie_io_functions_t __io_funcs) throw () ;




extern FILE *fmemopen (void *__s, size_t __len, const char *__modes)
  throw () ;




extern FILE *open_memstream (char **__bufloc, size_t *__sizeloc) throw () ;





extern void setbuf (FILE *__restrict __stream, char *__restrict __buf) throw ();



extern int setvbuf (FILE *__restrict __stream, char *__restrict __buf,
      int __modes, size_t __n) throw ();




extern void setbuffer (FILE *__restrict __stream, char *__restrict __buf,
         size_t __size) throw ();


extern void setlinebuf (FILE *__stream) throw ();







extern int fprintf (FILE *__restrict __stream,
      const char *__restrict __format, ...);




extern int printf (const char *__restrict __format, ...);

extern int sprintf (char *__restrict __s,
      const char *__restrict __format, ...) throw ();





extern int vfprintf (FILE *__restrict __s, const char *__restrict __format,
       __gnuc_va_list __arg);




extern int vprintf (const char *__restrict __format, __gnuc_va_list __arg);

extern int vsprintf (char *__restrict __s, const char *__restrict __format,
       __gnuc_va_list __arg) throw ();



extern int snprintf (char *__restrict __s, size_t __maxlen,
       const char *__restrict __format, ...)
     throw () __attribute__ ((__format__ (__printf__, 3, 4)));

extern int vsnprintf (char *__restrict __s, size_t __maxlen,
        const char *__restrict __format, __gnuc_va_list __arg)
     throw () __attribute__ ((__format__ (__printf__, 3, 0)));





extern int vasprintf (char **__restrict __ptr, const char *__restrict __f,
        __gnuc_va_list __arg)
     throw () __attribute__ ((__format__ (__printf__, 2, 0))) ;
extern int __asprintf (char **__restrict __ptr,
         const char *__restrict __fmt, ...)
     throw () __attribute__ ((__format__ (__printf__, 2, 3))) ;
extern int asprintf (char **__restrict __ptr,
       const char *__restrict __fmt, ...)
     throw () __attribute__ ((__format__ (__printf__, 2, 3))) ;




extern int vdprintf (int __fd, const char *__restrict __fmt,
       __gnuc_va_list __arg)
     __attribute__ ((__format__ (__printf__, 2, 0)));
extern int dprintf (int __fd, const char *__restrict __fmt, ...)
     __attribute__ ((__format__ (__printf__, 2, 3)));







extern int fscanf (FILE *__restrict __stream,
     const char *__restrict __format, ...) ;




extern int scanf (const char *__restrict __format, ...) ;

extern int sscanf (const char *__restrict __s,
     const char *__restrict __format, ...) throw ();
# 434 "/usr/include/stdio.h" 3 4
extern int vfscanf (FILE *__restrict __s, const char *__restrict __format,
      __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 2, 0))) ;





extern int vscanf (const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 1, 0))) ;


extern int vsscanf (const char *__restrict __s,
      const char *__restrict __format, __gnuc_va_list __arg)
     throw () __attribute__ ((__format__ (__scanf__, 2, 0)));
# 491 "/usr/include/stdio.h" 3 4
extern int fgetc (FILE *__stream);
extern int getc (FILE *__stream);





extern int getchar (void);






extern int getc_unlocked (FILE *__stream);
extern int getchar_unlocked (void);
# 516 "/usr/include/stdio.h" 3 4
extern int fgetc_unlocked (FILE *__stream);
# 527 "/usr/include/stdio.h" 3 4
extern int fputc (int __c, FILE *__stream);
extern int putc (int __c, FILE *__stream);





extern int putchar (int __c);
# 543 "/usr/include/stdio.h" 3 4
extern int fputc_unlocked (int __c, FILE *__stream);







extern int putc_unlocked (int __c, FILE *__stream);
extern int putchar_unlocked (int __c);






extern int getw (FILE *__stream);


extern int putw (int __w, FILE *__stream);







extern char *fgets (char *__restrict __s, int __n, FILE *__restrict __stream)
          ;
# 593 "/usr/include/stdio.h" 3 4
extern char *fgets_unlocked (char *__restrict __s, int __n,
        FILE *__restrict __stream) ;
# 609 "/usr/include/stdio.h" 3 4
extern __ssize_t __getdelim (char **__restrict __lineptr,
                             size_t *__restrict __n, int __delimiter,
                             FILE *__restrict __stream) ;
extern __ssize_t getdelim (char **__restrict __lineptr,
                           size_t *__restrict __n, int __delimiter,
                           FILE *__restrict __stream) ;







extern __ssize_t getline (char **__restrict __lineptr,
                          size_t *__restrict __n,
                          FILE *__restrict __stream) ;







extern int fputs (const char *__restrict __s, FILE *__restrict __stream);





extern int puts (const char *__s);






extern int ungetc (int __c, FILE *__stream);






extern size_t fread (void *__restrict __ptr, size_t __size,
       size_t __n, FILE *__restrict __stream) ;




extern size_t fwrite (const void *__restrict __ptr, size_t __size,
        size_t __n, FILE *__restrict __s);
# 668 "/usr/include/stdio.h" 3 4
extern int fputs_unlocked (const char *__restrict __s,
      FILE *__restrict __stream);
# 679 "/usr/include/stdio.h" 3 4
extern size_t fread_unlocked (void *__restrict __ptr, size_t __size,
         size_t __n, FILE *__restrict __stream) ;
extern size_t fwrite_unlocked (const void *__restrict __ptr, size_t __size,
          size_t __n, FILE *__restrict __stream);







extern int fseek (FILE *__stream, long int __off, int __whence);




extern long int ftell (FILE *__stream) ;




extern void rewind (FILE *__stream);
# 713 "/usr/include/stdio.h" 3 4
extern int fseeko (FILE *__stream, __off_t __off, int __whence);




extern __off_t ftello (FILE *__stream) ;
# 737 "/usr/include/stdio.h" 3 4
extern int fgetpos (FILE *__restrict __stream, fpos_t *__restrict __pos);




extern int fsetpos (FILE *__stream, const fpos_t *__pos);
# 756 "/usr/include/stdio.h" 3 4
extern int fseeko64 (FILE *__stream, __off64_t __off, int __whence);
extern __off64_t ftello64 (FILE *__stream) ;
extern int fgetpos64 (FILE *__restrict __stream, fpos64_t *__restrict __pos);
extern int fsetpos64 (FILE *__stream, const fpos64_t *__pos);



extern void clearerr (FILE *__stream) throw ();

extern int feof (FILE *__stream) throw () ;

extern int ferror (FILE *__stream) throw () ;



extern void clearerr_unlocked (FILE *__stream) throw ();
extern int feof_unlocked (FILE *__stream) throw () ;
extern int ferror_unlocked (FILE *__stream) throw () ;







extern void perror (const char *__s);





# 1 "/usr/include/bits/sys_errlist.h" 1 3 4
# 26 "/usr/include/bits/sys_errlist.h" 3 4
extern int sys_nerr;
extern const char *const sys_errlist[];


extern int _sys_nerr;
extern const char *const _sys_errlist[];
# 788 "/usr/include/stdio.h" 2 3 4




extern int fileno (FILE *__stream) throw () ;




extern int fileno_unlocked (FILE *__stream) throw () ;
# 806 "/usr/include/stdio.h" 3 4
extern FILE *popen (const char *__command, const char *__modes) ;





extern int pclose (FILE *__stream);





extern char *ctermid (char *__s) throw ();





extern char *cuserid (char *__s);




struct obstack;


extern int obstack_printf (struct obstack *__restrict __obstack,
      const char *__restrict __format, ...)
     throw () __attribute__ ((__format__ (__printf__, 2, 3)));
extern int obstack_vprintf (struct obstack *__restrict __obstack,
       const char *__restrict __format,
       __gnuc_va_list __args)
     throw () __attribute__ ((__format__ (__printf__, 2, 0)));







extern void flockfile (FILE *__stream) throw ();



extern int ftrylockfile (FILE *__stream) throw () ;


extern void funlockfile (FILE *__stream) throw ();
# 864 "/usr/include/stdio.h" 3 4
extern int __uflow (FILE *);
extern int __overflow (FILE *, int);




# 1 "/usr/include/bits/stdio.h" 1 3 4
# 38 "/usr/include/bits/stdio.h" 3 4
extern __inline __attribute__ ((__gnu_inline__)) int
vprintf (const char *__restrict __fmt, __gnuc_va_list __arg)
{
  return vfprintf (stdout, __fmt, __arg);
}



extern __inline __attribute__ ((__gnu_inline__)) int
getchar (void)
{
  return getc (stdin);
}




extern __inline __attribute__ ((__gnu_inline__)) int
fgetc_unlocked (FILE *__fp)
{
  return (__builtin_expect (((__fp)->_IO_read_ptr >= (__fp)->_IO_read_end), 0) ? __uflow (__fp) : *(unsigned char *) (__fp)->_IO_read_ptr++);
}





extern __inline __attribute__ ((__gnu_inline__)) int
getc_unlocked (FILE *__fp)
{
  return (__builtin_expect (((__fp)->_IO_read_ptr >= (__fp)->_IO_read_end), 0) ? __uflow (__fp) : *(unsigned char *) (__fp)->_IO_read_ptr++);
}


extern __inline __attribute__ ((__gnu_inline__)) int
getchar_unlocked (void)
{
  return (__builtin_expect (((stdin)->_IO_read_ptr >= (stdin)->_IO_read_end), 0) ? __uflow (stdin) : *(unsigned char *) (stdin)->_IO_read_ptr++);
}




extern __inline __attribute__ ((__gnu_inline__)) int
putchar (int __c)
{
  return putc (__c, stdout);
}




extern __inline __attribute__ ((__gnu_inline__)) int
fputc_unlocked (int __c, FILE *__stream)
{
  return (__builtin_expect (((__stream)->_IO_write_ptr >= (__stream)->_IO_write_end), 0) ? __overflow (__stream, (unsigned char) (__c)) : (unsigned char) (*(__stream)->_IO_write_ptr++ = (__c)));
}





extern __inline __attribute__ ((__gnu_inline__)) int
putc_unlocked (int __c, FILE *__stream)
{
  return (__builtin_expect (((__stream)->_IO_write_ptr >= (__stream)->_IO_write_end), 0) ? __overflow (__stream, (unsigned char) (__c)) : (unsigned char) (*(__stream)->_IO_write_ptr++ = (__c)));
}


extern __inline __attribute__ ((__gnu_inline__)) int
putchar_unlocked (int __c)
{
  return (__builtin_expect (((stdout)->_IO_write_ptr >= (stdout)->_IO_write_end), 0) ? __overflow (stdout, (unsigned char) (__c)) : (unsigned char) (*(stdout)->_IO_write_ptr++ = (__c)));
}





extern __inline __attribute__ ((__gnu_inline__)) __ssize_t
getline (char **__lineptr, size_t *__n, FILE *__stream)
{
  return __getdelim (__lineptr, __n, '\n', __stream);
}





extern __inline __attribute__ ((__gnu_inline__)) int
 feof_unlocked (FILE *__stream) throw ()
{
  return (((__stream)->_flags & 0x0010) != 0);
}


extern __inline __attribute__ ((__gnu_inline__)) int
 ferror_unlocked (FILE *__stream) throw ()
{
  return (((__stream)->_flags & 0x0020) != 0);
}
# 871 "/usr/include/stdio.h" 2 3 4








}
# 109 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/stdio.h" 2 3
# 17 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/llvm_libc_wrappers/stdio.h" 2 3
# 21 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/gpu_backends/fill.h" 2 3
# 24 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/gpu_backends/fill.h" 3




namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _ExecutionPolicy, class _ForwardIterator, class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) void
__pstl_fill(__gpu_backend_tag, _ForwardIterator __first, _ForwardIterator __last, const _Tp& __value) {



  if constexpr (__is_unsequenced_execution_policy_v<_ExecutionPolicy> &&
                __has_random_access_iterator_category_or_concept<_ForwardIterator>::value &&
                __libcpp_is_contiguous_iterator<_ForwardIterator>::value) {
    std::__par_backend::__parallel_for_simd_val_1(__first, __last - __first, __value);
  }

  else {
    std::__pstl_fill<_ExecutionPolicy>(__cpu_backend_tag{}, __first, __last, __value);
  }
}

}}
# 19 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/gpu_backend.h" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/gpu_backends/find_if.h" 1 3
# 27 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/gpu_backends/find_if.h" 3




namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _ExecutionPolicy, class _ForwardIterator, class _Predicate>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) _ForwardIterator
__pstl_find_if(__gpu_backend_tag, _ForwardIterator __first, _ForwardIterator __last, _Predicate __pred) {

  return std::__pstl_find_if<_ExecutionPolicy>(__cpu_backend_tag{}, __first, __last, __pred);
}

}}
# 20 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/gpu_backend.h" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/gpu_backends/for_each.h" 1 3
# 23 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/gpu_backends/for_each.h" 3




namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _ExecutionPolicy, class _ForwardIterator, class _Functor>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) void
__pstl_for_each(__gpu_backend_tag, _ForwardIterator __first, _ForwardIterator __last, _Functor __func) {



  if constexpr (__is_unsequenced_execution_policy_v<_ExecutionPolicy> &&
                __has_random_access_iterator_category_or_concept<_ForwardIterator>::value &&
                __libcpp_is_contiguous_iterator<_ForwardIterator>::value) {
    std::__par_backend::__parallel_for_simd_1(__first, __last - __first, __func);
  }

  else {
    std::__pstl_for_each<_ExecutionPolicy>(__cpu_backend_tag{}, __first, __last, __func);
  }
}

}}
# 21 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/gpu_backend.h" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/gpu_backends/merge.h" 1 3
# 23 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/gpu_backends/merge.h" 3




namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _ExecutionPolicy,
          class _ForwardIterator1,
          class _ForwardIterator2,
          class _ForwardOutIterator,
          class _Comp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) _ForwardOutIterator __pstl_merge(
    __gpu_backend_tag,
    _ForwardIterator1 __first1,
    _ForwardIterator1 __last1,
    _ForwardIterator2 __first2,
    _ForwardIterator2 __last2,
    _ForwardOutIterator __result,
    _Comp __comp) {

  return std::__pstl_merge<_ExecutionPolicy>(
      __cpu_backend_tag{}, __first1, __last1, __first2, __last2, __result, __comp);
}

}}
# 22 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/gpu_backend.h" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/gpu_backends/stable_sort.h" 1 3
# 21 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/gpu_backends/stable_sort.h" 3




namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _ExecutionPolicy, class _RandomAccessIterator, class _Comp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) void
__pstl_stable_sort(__gpu_backend_tag, _RandomAccessIterator __first, _RandomAccessIterator __last, _Comp __comp) {

  __pstl_stable_sort<_ExecutionPolicy>(__cpu_backend_tag{}, __first, __last, __comp);
}

}}
# 23 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/gpu_backend.h" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/gpu_backends/transform.h" 1 3
# 25 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/gpu_backends/transform.h" 3




namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _ExecutionPolicy, class _ForwardIterator, class _ForwardOutIterator, class _UnaryOperation>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) _ForwardOutIterator __pstl_transform(
    __gpu_backend_tag,
    _ForwardIterator __first,
    _ForwardIterator __last,
    _ForwardOutIterator __result,
    _UnaryOperation __op) {
  if constexpr (__is_unsequenced_execution_policy_v<_ExecutionPolicy> &&
                __has_random_access_iterator_category_or_concept<_ForwardIterator>::value &&
                __has_random_access_iterator_category_or_concept<_ForwardOutIterator>::value &&
                __libcpp_is_contiguous_iterator<_ForwardOutIterator>::value) {
    std::__par_backend::__parallel_for_simd_2(__first, __last - __first, __result, __op);
    return __result + (__last - __first);
  }

  return std::__pstl_transform<_ExecutionPolicy>(__cpu_backend_tag{}, __first, __last, __result, __op);
}

template <class _ExecutionPolicy,
          class _ForwardIterator1,
          class _ForwardIterator2,
          class _ForwardOutIterator,
          class _BinaryOperation,
          enable_if_t<is_execution_policy_v<__remove_cvref_t<_ExecutionPolicy>>, int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) _ForwardOutIterator __pstl_transform(
    __gpu_backend_tag,
    _ForwardIterator1 __first1,
    _ForwardIterator1 __last1,
    _ForwardIterator2 __first2,
    _ForwardOutIterator __result,
    _BinaryOperation __op) {
  if constexpr (__is_unsequenced_execution_policy_v<_ExecutionPolicy> &&
                __has_random_access_iterator_category_or_concept<_ForwardIterator1>::value &&
                __has_random_access_iterator_category_or_concept<_ForwardIterator2>::value &&
                __has_random_access_iterator_category_or_concept<_ForwardOutIterator>::value &&
                __libcpp_is_contiguous_iterator<_ForwardOutIterator>::value) {
    std::__par_backend::__parallel_for_simd_3(__first1, __last1 - __first1, __first2, __result, __op);
    return __result + (__last1 - __first1);
  }

  return std::__pstl_transform<_ExecutionPolicy>(__cpu_backend_tag{}, __first1, __last1, __first2, __result, __op);
}

}}
# 24 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/gpu_backend.h" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/gpu_backends/transform_reduce.h" 1 3
# 29 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/gpu_backends/transform_reduce.h" 3




template <class _T1, class _T2, class _T3>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) struct __is_supported_reduction : std::false_type {};
# 43 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/gpu_backends/transform_reduce.h" 3
template <class _Tp> __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) struct __is_supported_reduction<std::plus<_Tp>, _Tp, _Tp> : std::true_type {}; template <class _Tp, class _Up> __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) struct __is_supported_reduction<std::plus<>, _Tp, _Up> : std::true_type {};
template <class _Tp> __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) struct __is_supported_reduction<std::minus<_Tp>, _Tp, _Tp> : std::true_type {}; template <class _Tp, class _Up> __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) struct __is_supported_reduction<std::minus<>, _Tp, _Up> : std::true_type {};
template <class _Tp> __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) struct __is_supported_reduction<std::multiplies<_Tp>, _Tp, _Tp> : std::true_type {}; template <class _Tp, class _Up> __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) struct __is_supported_reduction<std::multiplies<>, _Tp, _Up> : std::true_type {};
template <class _Tp> __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) struct __is_supported_reduction<std::logical_and<_Tp>, _Tp, _Tp> : std::true_type {}; template <class _Tp, class _Up> __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) struct __is_supported_reduction<std::logical_and<>, _Tp, _Up> : std::true_type {};
template <class _Tp> __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) struct __is_supported_reduction<std::logical_or<_Tp>, _Tp, _Tp> : std::true_type {}; template <class _Tp, class _Up> __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) struct __is_supported_reduction<std::logical_or<>, _Tp, _Up> : std::true_type {};
template <class _Tp> __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) struct __is_supported_reduction<std::bit_and<_Tp>, _Tp, _Tp> : std::true_type {}; template <class _Tp, class _Up> __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) struct __is_supported_reduction<std::bit_and<>, _Tp, _Up> : std::true_type {};
template <class _Tp> __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) struct __is_supported_reduction<std::bit_or<_Tp>, _Tp, _Tp> : std::true_type {}; template <class _Tp, class _Up> __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) struct __is_supported_reduction<std::bit_or<>, _Tp, _Up> : std::true_type {};
template <class _Tp> __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) struct __is_supported_reduction<std::bit_xor<_Tp>, _Tp, _Tp> : std::true_type {}; template <class _Tp, class _Up> __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) struct __is_supported_reduction<std::bit_xor<>, _Tp, _Up> : std::true_type {};

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {





template <class _ExecutionPolicy,
          class _ForwardIterator1,
          class _ForwardIterator2,
          class _Tp,
          class _BinaryOperation1,
          class _BinaryOperation2>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) _Tp __pstl_transform_reduce(
    __gpu_backend_tag,
    _ForwardIterator1 __first1,
    _ForwardIterator1 __last1,
    _ForwardIterator2 __first2,
    _Tp __init,
    _BinaryOperation1 __reduce,
    _BinaryOperation2 __transform) {
  if constexpr (__is_unsequenced_execution_policy_v<_ExecutionPolicy> &&
                __has_random_access_iterator_category_or_concept<_ForwardIterator1>::value &&
                __has_random_access_iterator_category_or_concept<_ForwardIterator2>::value &&
                is_arithmetic_v<_Tp> &&
                (__is_trivial_plus_operation<_BinaryOperation1, _Tp, _Tp>::value ||
                 __is_supported_reduction<_BinaryOperation1, _Tp, _Tp>::value)) {
    return std::__par_backend::__parallel_for_simd_reduction_2(
        __first1, __first2, __last1 - __first1, __init, __reduce, __transform);
  }
  return std::__pstl_transform_reduce<_ExecutionPolicy>(
      __cpu_backend_tag{}, __first1, __last1, __first2, std::move(__init), __reduce, __transform);
}





template <class _ExecutionPolicy, class _ForwardIterator, class _Tp, class _BinaryOperation, class _UnaryOperation>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) _Tp __pstl_transform_reduce(
    __gpu_backend_tag,
    _ForwardIterator __first,
    _ForwardIterator __last,
    _Tp __init,
    _BinaryOperation __reduce,
    _UnaryOperation __transform) {
  if constexpr (__is_unsequenced_execution_policy_v<_ExecutionPolicy> &&
                __has_random_access_iterator_category_or_concept<_ForwardIterator>::value &&
                is_arithmetic_v<_Tp> &&
                (__is_trivial_plus_operation<_BinaryOperation, _Tp, _Tp>::value ||
                 __is_supported_reduction<_BinaryOperation, _Tp, _Tp>::value)) {
    return std::__par_backend::__parallel_for_simd_reduction_1(
        __first, __last - __first, __init, __reduce, __transform);
  }
  return std::__pstl_transform_reduce<_ExecutionPolicy>(
      __cpu_backend_tag{}, __first, __last, std::move(__init), __reduce, __transform);
}

}}
# 25 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backends/gpu_backend.h" 2 3
# 14 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backend.h" 2 3

# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/execution" 1 3
# 44 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/execution" 3




namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

namespace execution {
struct sequenced_policy {
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr explicit sequenced_policy(__disable_user_instantiations_tag) {}
  sequenced_policy(const sequenced_policy&) = delete;
  sequenced_policy& operator=(const sequenced_policy&) = delete;
};

inline constexpr sequenced_policy seq{__disable_user_instantiations_tag{}};

struct parallel_policy {
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr explicit parallel_policy(__disable_user_instantiations_tag) {}
  parallel_policy(const parallel_policy&) = delete;
  parallel_policy& operator=(const parallel_policy&) = delete;
};

inline constexpr parallel_policy par{__disable_user_instantiations_tag{}};

struct parallel_unsequenced_policy {
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr explicit parallel_unsequenced_policy(__disable_user_instantiations_tag) {}
  parallel_unsequenced_policy(const parallel_unsequenced_policy&) = delete;
  parallel_unsequenced_policy& operator=(const parallel_unsequenced_policy&) = delete;
};

inline constexpr parallel_unsequenced_policy par_unseq{__disable_user_instantiations_tag{}};

struct __unsequenced_policy {
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr explicit __unsequenced_policy(__disable_user_instantiations_tag) {}
  __unsequenced_policy(const __unsequenced_policy&) = delete;
  __unsequenced_policy& operator=(const __unsequenced_policy&) = delete;
};

constexpr __unsequenced_policy __unseq{__disable_user_instantiations_tag{}};



struct unsequenced_policy {
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr explicit unsequenced_policy(__disable_user_instantiations_tag) {}
  unsequenced_policy(const unsequenced_policy&) = delete;
  unsequenced_policy& operator=(const unsequenced_policy&) = delete;
};

inline constexpr unsequenced_policy unseq{__disable_user_instantiations_tag{}};



}

template <>
inline constexpr bool is_execution_policy_v<execution::sequenced_policy> = true;

template <>
inline constexpr bool is_execution_policy_v<execution::parallel_policy> = true;

template <>
inline constexpr bool is_execution_policy_v<execution::parallel_unsequenced_policy> = true;

template <>
inline constexpr bool is_execution_policy_v<execution::__unsequenced_policy> = true;

template <>
inline constexpr bool __is_parallel_execution_policy_impl<execution::parallel_policy> = true;

template <>
inline constexpr bool __is_parallel_execution_policy_impl<execution::parallel_unsequenced_policy> = true;

template <>
inline constexpr bool __is_unsequenced_execution_policy_impl<execution::__unsequenced_policy> = true;

template <>
inline constexpr bool __is_unsequenced_execution_policy_impl<execution::parallel_unsequenced_policy> = true;


template <>
inline constexpr bool is_execution_policy_v<execution::unsequenced_policy> = true;

template <>
inline constexpr bool __is_unsequenced_execution_policy_impl<execution::unsequenced_policy> = true;



template <class _Tp>
struct is_execution_policy : bool_constant<is_execution_policy_v<_Tp>> {};

template <class _ExecutionPolicy>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) auto __remove_parallel_policy(const _ExecutionPolicy&) {
  if constexpr (is_same_v<_ExecutionPolicy, execution::parallel_policy>) {
    return execution::sequenced_policy(execution::__disable_user_instantiations_tag{});
  } else if constexpr (is_same_v<_ExecutionPolicy, execution::parallel_unsequenced_policy>) {
    return execution::__unsequenced_policy{execution::__disable_user_instantiations_tag{}};
  }
}

}}
# 16 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backend.h" 2 3
# 19 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backend.h" 3




namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 161 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backend.h" 3
template <class _ExecutionPolicy>
struct __select_backend;

template <>
struct __select_backend<std::execution::sequenced_policy> {
  using type = __cpu_backend_tag;
};


template <>
struct __select_backend<std::execution::unsequenced_policy> {
  using type = __cpu_backend_tag;
};




template <>
struct __select_backend<std::execution::parallel_policy> {
  using type = __cpu_backend_tag;
};


template <>
struct __select_backend<std::execution::parallel_unsequenced_policy> {
  using type = __gpu_backend_tag;
};
# 202 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_backend.h" 3
}}
# 15 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_find.h" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_frontend_dispatch.h" 1 3
# 18 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_frontend_dispatch.h" 3




namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 31 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_frontend_dispatch.h" 3
template <class _SpecializedImpl, class _GenericImpl, class... _Args>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) decltype(auto)
__pstl_frontend_dispatch(_SpecializedImpl __specialized_impl, _GenericImpl __generic_impl, _Args&&... __args) {
  if constexpr (__is_callable<_SpecializedImpl, _Args...>::value) {
    return __specialized_impl(std::forward<_Args>(__args)...);
  } else {
    return __generic_impl(std::forward<_Args>(__args)...);
  }
}

}}
# 16 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_find.h" 2 3

# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__iterator/cpp17_iterator_concepts.h" 1 3
# 30 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__iterator/cpp17_iterator_concepts.h" 3




namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Tp>
concept __cpp17_move_constructible = is_move_constructible_v<_Tp>;

template <class _Tp>
concept __cpp17_copy_constructible = __cpp17_move_constructible<_Tp> && is_copy_constructible_v<_Tp>;

template <class _Tp>
concept __cpp17_move_assignable = requires(_Tp __lhs, _Tp __rhs) {
  { __lhs = std::move(__rhs) } -> same_as<_Tp&>;
};

template <class _Tp>
concept __cpp17_copy_assignable = __cpp17_move_assignable<_Tp> && requires(_Tp __lhs, _Tp __rhs) {
  { __lhs = __rhs } -> same_as<_Tp&>;
  { __lhs = std::as_const(__rhs) } -> same_as<_Tp&>;
};

template <class _Tp>
concept __cpp17_destructible = requires(_Tp __v) { __v.~_Tp(); };

template <class _Tp>
concept __cpp17_equality_comparable = requires(_Tp __lhs, _Tp __rhs) {
  { __lhs == __rhs } -> __boolean_testable;
  { std::as_const(__lhs) == __rhs } -> __boolean_testable;
  { __lhs == std::as_const(__rhs) } -> __boolean_testable;
  { std::as_const(__lhs) == std::as_const(__rhs) } -> __boolean_testable;
};

template <class _Tp>
concept __cpp17_default_constructible = is_default_constructible_v<_Tp>;

template <class _Iter>
concept __cpp17_iterator =
    __cpp17_copy_constructible<_Iter> && __cpp17_copy_assignable<_Iter> && __cpp17_destructible<_Iter> &&
    (is_signed_v<__iter_diff_t<_Iter>> || is_void_v<__iter_diff_t<_Iter>>)&&requires(_Iter __iter) {
      { *__iter };
      { ++__iter } -> same_as<_Iter&>;
    };

template <class _Iter>
concept __cpp17_input_iterator =
    __cpp17_iterator<_Iter> && __cpp17_equality_comparable<_Iter> && requires(_Iter __lhs, _Iter __rhs) {
      { __lhs != __rhs } -> __boolean_testable;
      { std::as_const(__lhs) != __rhs } -> __boolean_testable;
      { __lhs != std::as_const(__rhs) } -> __boolean_testable;
      { std::as_const(__lhs) != std::as_const(__rhs) } -> __boolean_testable;

      { *__lhs } -> same_as<__iter_reference<_Iter>>;
      { *std::as_const(__lhs) } -> same_as<__iter_reference<_Iter>>;

      { ++__lhs } -> same_as<_Iter&>;
      { (void)__lhs++ };
      { *__lhs++ };
    };

template <class _Iter, class _WriteTo>
concept __cpp17_output_iterator = __cpp17_iterator<_Iter> && requires(_Iter __iter, _WriteTo __write) {
  { *__iter = std::forward<_WriteTo>(__write) };
  { ++__iter } -> same_as<_Iter&>;
  { __iter++ } -> convertible_to<const _Iter&>;
  { *__iter++ = std::forward<_WriteTo>(__write) };
};

template <class _Iter>
concept __cpp17_forward_iterator =
    __cpp17_input_iterator<_Iter> && __cpp17_default_constructible<_Iter> && requires(_Iter __iter) {
      { __iter++ } -> convertible_to<const _Iter&>;
      { *__iter++ } -> same_as<__iter_reference<_Iter>>;
    };

template <class _Iter>
concept __cpp17_bidirectional_iterator = __cpp17_forward_iterator<_Iter> && requires(_Iter __iter) {
  { --__iter } -> same_as<_Iter&>;
  { __iter-- } -> convertible_to<const _Iter&>;
  { *__iter-- } -> same_as<__iter_reference<_Iter>>;
};

template <class _Iter>
concept __cpp17_random_access_iterator =
    __cpp17_bidirectional_iterator<_Iter> && requires(_Iter __iter, __iter_diff_t<_Iter> __n) {
      { __iter += __n } -> same_as<_Iter&>;

      { __iter + __n } -> same_as<_Iter>;
      { __n + __iter } -> same_as<_Iter>;
      { std::as_const(__iter) + __n } -> same_as<_Iter>;
      { __n + std::as_const(__iter) } -> same_as<_Iter>;

      { __iter -= __n } -> same_as<_Iter&>;
      { __iter - __n } -> same_as<_Iter>;
      { std::as_const(__iter) - __n } -> same_as<_Iter>;

      { __iter - __iter } -> same_as<__iter_diff_t<_Iter>>;
      { std::as_const(__iter) - __iter } -> same_as<__iter_diff_t<_Iter>>;
      { __iter - std::as_const(__iter) } -> same_as<__iter_diff_t<_Iter>>;
      { std::as_const(__iter) - std::as_const(__iter) } -> same_as<__iter_diff_t<_Iter>>;

      { __iter[__n] } -> convertible_to<__iter_reference<_Iter>>;
      { std::as_const(__iter)[__n] } -> convertible_to<__iter_reference<_Iter>>;

      { __iter < __iter } -> __boolean_testable;
      { std::as_const(__iter) < __iter } -> __boolean_testable;
      { __iter < std::as_const(__iter) } -> __boolean_testable;
      { std::as_const(__iter) < std::as_const(__iter) } -> __boolean_testable;

      { __iter > __iter } -> __boolean_testable;
      { std::as_const(__iter) > __iter } -> __boolean_testable;
      { __iter > std::as_const(__iter) } -> __boolean_testable;
      { std::as_const(__iter) > std::as_const(__iter) } -> __boolean_testable;

      { __iter >= __iter } -> __boolean_testable;
      { std::as_const(__iter) >= __iter } -> __boolean_testable;
      { __iter >= std::as_const(__iter) } -> __boolean_testable;
      { std::as_const(__iter) >= std::as_const(__iter) } -> __boolean_testable;

      { __iter <= __iter } -> __boolean_testable;
      { std::as_const(__iter) <= __iter } -> __boolean_testable;
      { __iter <= std::as_const(__iter) } -> __boolean_testable;
      { std::as_const(__iter) <= std::as_const(__iter) } -> __boolean_testable;
    };

}}
# 18 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_find.h" 2 3
# 26 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_find.h" 3




namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _ExecutionPolicy,
          class _ForwardIterator,
          class _Predicate,
          class _RawPolicy = __remove_cvref_t<_ExecutionPolicy>,
          enable_if_t<is_execution_policy_v<_RawPolicy>, int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) _ForwardIterator
find_if(_ExecutionPolicy&&, _ForwardIterator __first, _ForwardIterator __last, _Predicate __pred) {
  static_assert(::std::__cpp17_forward_iterator<_ForwardIterator>);;
  using _Backend = typename __select_backend<_RawPolicy>::type;
  return std::__pstl_find_if<_RawPolicy>(_Backend{}, std::move(__first), std::move(__last), std::move(__pred));
}

template <class>
void __pstl_find_if_not();

template <class _ExecutionPolicy,
          class _ForwardIterator,
          class _Predicate,
          class _RawPolicy = __remove_cvref_t<_ExecutionPolicy>,
          enable_if_t<is_execution_policy_v<_RawPolicy>, int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) _ForwardIterator
find_if_not(_ExecutionPolicy&& __policy, _ForwardIterator __first, _ForwardIterator __last, _Predicate __pred) {
  static_assert(::std::__cpp17_forward_iterator<_ForwardIterator>);;
  return std::__pstl_frontend_dispatch(
      [](auto&&... __args) -> decltype(std::__pstl_find_if_not<_RawPolicy>(typename __select_backend<_RawPolicy>::type{}, std::forward<decltype(__args)>(__args)...)) { return std::__pstl_find_if_not<_RawPolicy>( typename __select_backend<_RawPolicy>::type{}, std::forward<decltype(__args)>(__args)...); },
      [&](_ForwardIterator __g_first, _ForwardIterator __g_last, _Predicate __g_pred) {
        return std::find_if(__policy, __g_first, __g_last, [&](__iter_reference<_ForwardIterator> __value) {
          return !__g_pred(__value);
        });
      },
      std::move(__first),
      std::move(__last),
      std::move(__pred));
}

template <class>
void __pstl_find();

template <class _ExecutionPolicy,
          class _ForwardIterator,
          class _Tp,
          class _RawPolicy = __remove_cvref_t<_ExecutionPolicy>,
          enable_if_t<is_execution_policy_v<_RawPolicy>, int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) _ForwardIterator
find(_ExecutionPolicy&& __policy, _ForwardIterator __first, _ForwardIterator __last, const _Tp& __value) {
  static_assert(::std::__cpp17_forward_iterator<_ForwardIterator>);;
  return std::__pstl_frontend_dispatch(
      [](auto&&... __args) -> decltype(std::__pstl_find<_RawPolicy>(typename __select_backend<_RawPolicy>::type{}, std::forward<decltype(__args)>(__args)...)) { return std::__pstl_find<_RawPolicy>( typename __select_backend<_RawPolicy>::type{}, std::forward<decltype(__args)>(__args)...); },
      [&](_ForwardIterator __g_first, _ForwardIterator __g_last, const _Tp& __g_value) {
        return std::find_if(__policy, __g_first, __g_last, [&](__iter_reference<_ForwardIterator> __element) {
          return __element == __g_value;
        });
      },
      std::move(__first),
      std::move(__last),
      __value);
}

}}
# 13 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_any_all_none_of.h" 2 3
# 24 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_any_all_none_of.h" 3




namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class>
void __pstl_any_of();

template <class _ExecutionPolicy,
          class _ForwardIterator,
          class _Predicate,
          class _RawPolicy = __remove_cvref_t<_ExecutionPolicy>,
          enable_if_t<is_execution_policy_v<_RawPolicy>, int> = 0>
[[__nodiscard__]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) bool
any_of(_ExecutionPolicy&& __policy, _ForwardIterator __first, _ForwardIterator __last, _Predicate __pred) {
  static_assert(::std::__cpp17_forward_iterator<_ForwardIterator>);;
  return std::__pstl_frontend_dispatch(
      [](auto&&... __args) -> decltype(std::__pstl_any_of<_RawPolicy>(typename __select_backend<_RawPolicy>::type{}, std::forward<decltype(__args)>(__args)...)) { return std::__pstl_any_of<_RawPolicy>( typename __select_backend<_RawPolicy>::type{}, std::forward<decltype(__args)>(__args)...); },
      [&](_ForwardIterator __g_first, _ForwardIterator __g_last, _Predicate __g_pred) {
        return std::find_if(__policy, __g_first, __g_last, __g_pred) != __g_last;
      },
      std::move(__first),
      std::move(__last),
      std::move(__pred));
}

template <class>
void __pstl_all_of();

template <class _ExecutionPolicy,
          class _ForwardIterator,
          class _Pred,
          class _RawPolicy = __remove_cvref_t<_ExecutionPolicy>,
          enable_if_t<is_execution_policy_v<_RawPolicy>, int> = 0>
[[__nodiscard__]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) bool
all_of(_ExecutionPolicy&& __policy, _ForwardIterator __first, _ForwardIterator __last, _Pred __pred) {
  static_assert(::std::__cpp17_forward_iterator<_ForwardIterator>);;
  return std::__pstl_frontend_dispatch(
      [](auto&&... __args) -> decltype(std::__pstl_all_of<_RawPolicy>(typename __select_backend<_RawPolicy>::type{}, std::forward<decltype(__args)>(__args)...)) { return std::__pstl_all_of<_RawPolicy>( typename __select_backend<_RawPolicy>::type{}, std::forward<decltype(__args)>(__args)...); },
      [&](_ForwardIterator __g_first, _ForwardIterator __g_last, _Pred __g_pred) {
        return !std::any_of(__policy, __g_first, __g_last, [&](__iter_reference<_ForwardIterator> __value) {
          return !__g_pred(__value);
        });
      },
      std::move(__first),
      std::move(__last),
      std::move(__pred));
}

template <class>
void __pstl_none_of();

template <class _ExecutionPolicy,
          class _ForwardIterator,
          class _Pred,
          class _RawPolicy = __remove_cvref_t<_ExecutionPolicy>,
          enable_if_t<is_execution_policy_v<_RawPolicy>, int> = 0>
[[__nodiscard__]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) bool
none_of(_ExecutionPolicy&& __policy, _ForwardIterator __first, _ForwardIterator __last, _Pred __pred) {
  static_assert(::std::__cpp17_forward_iterator<_ForwardIterator>);;
  return std::__pstl_frontend_dispatch(
      [](auto&&... __args) -> decltype(std::__pstl_none_of<_RawPolicy>(typename __select_backend<_RawPolicy>::type{}, std::forward<decltype(__args)>(__args)...)) { return std::__pstl_none_of<_RawPolicy>( typename __select_backend<_RawPolicy>::type{}, std::forward<decltype(__args)>(__args)...); },
      [&](_ForwardIterator __g_first, _ForwardIterator __g_last, _Pred __g_pred) {
        return !std::any_of(__policy, __g_first, __g_last, __g_pred);
      },
      std::move(__first),
      std::move(__last),
      std::move(__pred));
}

}}
# 1828 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/algorithm" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_copy.h" 1 3
# 15 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_copy.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_transform.h" 1 3
# 23 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_transform.h" 3




namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _ExecutionPolicy,
          class _ForwardIterator,
          class _ForwardOutIterator,
          class _UnaryOperation,
          class _RawPolicy = __remove_cvref_t<_ExecutionPolicy>,
          enable_if_t<is_execution_policy_v<_RawPolicy>, int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) _ForwardOutIterator transform(
    _ExecutionPolicy&&,
    _ForwardIterator __first,
    _ForwardIterator __last,
    _ForwardOutIterator __result,
    _UnaryOperation __op) {
  static_assert(::std::__cpp17_forward_iterator<_ForwardIterator>);;
  static_assert(::std::__cpp17_forward_iterator<_ForwardOutIterator>);;
  static_assert(::std::__cpp17_output_iterator<_ForwardOutIterator, decltype(__op(*__first))>);;
  using _Backend = typename __select_backend<_RawPolicy>::type;
  return std::__pstl_transform<_RawPolicy>(
      _Backend{}, std::move(__first), std::move(__last), std::move(__result), std::move(__op));
}

template <class _ExecutionPolicy,
          class _ForwardIterator1,
          class _ForwardIterator2,
          class _ForwardOutIterator,
          class _BinaryOperation,
          class _RawPolicy = __remove_cvref_t<_ExecutionPolicy>,
          enable_if_t<is_execution_policy_v<_RawPolicy>, int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) _ForwardOutIterator transform(
    _ExecutionPolicy&&,
    _ForwardIterator1 __first1,
    _ForwardIterator1 __last1,
    _ForwardIterator2 __first2,
    _ForwardOutIterator __result,
    _BinaryOperation __op) {
  static_assert(::std::__cpp17_forward_iterator<_ForwardIterator1>);;
  static_assert(::std::__cpp17_forward_iterator<_ForwardIterator2>);;
  static_assert(::std::__cpp17_forward_iterator<_ForwardOutIterator>);;
  static_assert(::std::__cpp17_output_iterator<_ForwardOutIterator, decltype(__op(*__first1, *__first2))>);;
  using _Backend = typename __select_backend<_RawPolicy>::type;
  return std::__pstl_transform<_RawPolicy>(
      _Backend{}, std::move(__first1), std::move(__last1), std::move(__first2), std::move(__result), std::move(__op));
}

}}
# 16 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_copy.h" 2 3
# 28 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_copy.h" 3




namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {



template <class>
void __pstl_copy();

template <class _ExecutionPolicy,
          class _ForwardIterator,
          class _ForwardOutIterator,
          class _RawPolicy = __remove_cvref_t<_ExecutionPolicy>,
          enable_if_t<is_execution_policy_v<_RawPolicy>, int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) _ForwardOutIterator
copy(_ExecutionPolicy&& __policy, _ForwardIterator __first, _ForwardIterator __last, _ForwardOutIterator __result) {
  return std::__pstl_frontend_dispatch(
      [](auto&&... __args) -> decltype(std::__pstl_copy<_RawPolicy>(typename __select_backend<_RawPolicy>::type{}, std::forward<decltype(__args)>(__args)...)) { return std::__pstl_copy<_RawPolicy>( typename __select_backend<_RawPolicy>::type{}, std::forward<decltype(__args)>(__args)...); },
      [&__policy](_ForwardIterator __g_first, _ForwardIterator __g_last, _ForwardOutIterator __g_result) {
        return std::transform(__policy, __g_first, __g_last, __g_result, __identity());
      },
      std::move(__first),
      std::move(__last),
      std::move(__result));
}

template <class>
void __pstl_copy_n();

template <class _ExecutionPolicy,
          class _ForwardIterator,
          class _ForwardOutIterator,
          class _Size,
          class _RawPolicy = __remove_cvref_t<_ExecutionPolicy>,
          enable_if_t<is_execution_policy_v<_RawPolicy>, int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) _ForwardOutIterator
copy_n(_ExecutionPolicy&& __policy, _ForwardIterator __first, _Size __n, _ForwardOutIterator __result) {
  return std::__pstl_frontend_dispatch(
      [](auto&&... __args) -> decltype(std::__pstl_copy_n<_RawPolicy>(typename __select_backend<_RawPolicy>::type{}, std::forward<decltype(__args)>(__args)...)) { return std::__pstl_copy_n<_RawPolicy>( typename __select_backend<_RawPolicy>::type{}, std::forward<decltype(__args)>(__args)...); },
      [&__policy](_ForwardIterator __g_first, _Size __g_n, _ForwardOutIterator __g_result) {
        if constexpr (__has_random_access_iterator_category_or_concept<_ForwardIterator>::value)
          return std::copy(__policy, __g_first, __g_first + __g_n, __g_result);
        else
          return std::copy_n(__g_first, __g_n, __g_result);
      },
      std::move(__first),
      __n,
      std::move(__result));
}

}}
# 1829 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/algorithm" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_count.h" 1 3
# 15 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_count.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_for_each.h" 1 3
# 28 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_for_each.h" 3




namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _ExecutionPolicy,
          class _ForwardIterator,
          class _Function,
          class _RawPolicy = __remove_cvref_t<_ExecutionPolicy>,
          enable_if_t<is_execution_policy_v<_RawPolicy>, int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) void
for_each(_ExecutionPolicy&&, _ForwardIterator __first, _ForwardIterator __last, _Function __func) {
  static_assert(::std::__cpp17_forward_iterator<_ForwardIterator>);;
  using _Backend = typename __select_backend<_RawPolicy>::type;
  std::__pstl_for_each<_RawPolicy>(_Backend{}, std::move(__first), std::move(__last), std::move(__func));
}

template <class>
void __pstl_for_each_n();

template <class _ExecutionPolicy,
          class _ForwardIterator,
          class _Size,
          class _Function,
          class _RawPolicy = __remove_cvref_t<_ExecutionPolicy>,
          enable_if_t<is_execution_policy_v<_RawPolicy>, int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) void
for_each_n(_ExecutionPolicy&& __policy, _ForwardIterator __first, _Size __size, _Function __func) {
  static_assert(::std::__cpp17_forward_iterator<_ForwardIterator>);;
  return std::__pstl_frontend_dispatch(
      [](auto&&... __args) -> decltype(std::__pstl_for_each_n<_RawPolicy>(typename __select_backend<_RawPolicy>::type{}, std::forward<decltype(__args)>(__args)...)) { return std::__pstl_for_each_n<_RawPolicy>( typename __select_backend<_RawPolicy>::type{}, std::forward<decltype(__args)>(__args)...); },
      [&](_ForwardIterator __g_first, _Size __g_size, _Function __g_func) {
        if constexpr (__has_random_access_iterator_category_or_concept<_ForwardIterator>::value) {
          std::for_each(__policy, std::move(__g_first), __g_first + __g_size, std::move(__g_func));
        } else {
          std::for_each_n(std::move(__g_first), __g_size, std::move(__g_func));
        }
      },
      __first,
      __size,
      std::move(__func));
}

}}
# 16 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_count.h" 2 3





# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__numeric/pstl_transform_reduce.h" 1 3
# 23 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__numeric/pstl_transform_reduce.h" 3




namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _ExecutionPolicy,
          class _ForwardIterator1,
          class _ForwardIterator2,
          class _Tp,
          class _BinaryOperation1,
          class _BinaryOperation2,
          class _RawPolicy = __remove_cvref_t<_ExecutionPolicy>,
          enable_if_t<is_execution_policy_v<_RawPolicy>, int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) _Tp transform_reduce(
    _ExecutionPolicy&&,
    _ForwardIterator1 __first1,
    _ForwardIterator1 __last1,
    _ForwardIterator2 __first2,
    _Tp __init,
    _BinaryOperation1 __reduce,
    _BinaryOperation2 __transform) {
  using _Backend = typename __select_backend<_RawPolicy>::type;
  return std::__pstl_transform_reduce<_RawPolicy>(
      _Backend{},
      std::move(__first1),
      std::move(__last1),
      std::move(__first2),
      std::move(__init),
      std::move(__reduce),
      std::move(__transform));
}



template <class _ExecutionPolicy,
          class _ForwardIterator1,
          class _ForwardIterator2,
          class _Tp,
          enable_if_t<is_execution_policy_v<__remove_cvref_t<_ExecutionPolicy>>, int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) _Tp transform_reduce(
    _ExecutionPolicy&& __policy,
    _ForwardIterator1 __first1,
    _ForwardIterator1 __last1,
    _ForwardIterator2 __first2,
    _Tp __init) {
  return std::transform_reduce(__policy, __first1, __last1, __first2, __init, plus{}, multiplies{});
}

template <class _ExecutionPolicy,
          class _ForwardIterator,
          class _Tp,
          class _BinaryOperation,
          class _UnaryOperation,
          class _RawPolicy = __remove_cvref_t<_ExecutionPolicy>,
          enable_if_t<is_execution_policy_v<_RawPolicy>, int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) _Tp transform_reduce(
    _ExecutionPolicy&&,
    _ForwardIterator __first,
    _ForwardIterator __last,
    _Tp __init,
    _BinaryOperation __reduce,
    _UnaryOperation __transform) {
  using _Backend = typename __select_backend<_RawPolicy>::type;
  return std::__pstl_transform_reduce<_RawPolicy>(
      _Backend{},
      std::move(__first),
      std::move(__last),
      std::move(__init),
      std::move(__reduce),
      std::move(__transform));
}

}}
# 22 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_count.h" 2 3
# 30 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_count.h" 3




namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class>
void __pstl_count_if();

template <class _ExecutionPolicy,
          class _ForwardIterator,
          class _Predicate,
          class _RawPolicy = __remove_cvref_t<_ExecutionPolicy>,
          enable_if_t<is_execution_policy_v<_RawPolicy>, int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) __iter_diff_t<_ForwardIterator>
count_if(_ExecutionPolicy&& __policy, _ForwardIterator __first, _ForwardIterator __last, _Predicate __pred) {
  using __diff_t = __iter_diff_t<_ForwardIterator>;
  return std::__pstl_frontend_dispatch(
      [](auto&&... __args) -> decltype(std::__pstl_count_if<_RawPolicy>(typename __select_backend<_RawPolicy>::type{}, std::forward<decltype(__args)>(__args)...)) { return std::__pstl_count_if<_RawPolicy>( typename __select_backend<_RawPolicy>::type{}, std::forward<decltype(__args)>(__args)...); },
      [&](_ForwardIterator __g_first, _ForwardIterator __g_last, _Predicate __g_pred) {
        return std::transform_reduce(
            __policy,
            std::move(__g_first),
            std::move(__g_last),
            __diff_t(),
            std::plus{},
            [&](__iter_reference<_ForwardIterator> __element) -> bool { return __g_pred(__element); });
      },
      std::move(__first),
      std::move(__last),
      std::move(__pred));
}

template <class>
void __pstl_count();

template <class _ExecutionPolicy,
          class _ForwardIterator,
          class _Tp,
          class _RawPolicy = __remove_cvref_t<_ExecutionPolicy>,
          enable_if_t<is_execution_policy_v<_RawPolicy>, int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) __iter_diff_t<_ForwardIterator>
count(_ExecutionPolicy&& __policy, _ForwardIterator __first, _ForwardIterator __last, const _Tp& __value) {
  return std::__pstl_frontend_dispatch(
      [](auto&&... __args) -> decltype(std::__pstl_count<_RawPolicy>(typename __select_backend<_RawPolicy>::type{}, std::forward<decltype(__args)>(__args)...)) { return std::__pstl_count<_RawPolicy>( typename __select_backend<_RawPolicy>::type{}, std::forward<decltype(__args)>(__args)...); },
      [&](_ForwardIterator __g_first, _ForwardIterator __g_last, const _Tp& __g_value) {
        return std::count_if(__policy, __g_first, __g_last, [&](__iter_reference<_ForwardIterator> __v) {
          return __v == __g_value;
        });
      },
      std::move(__first),
      std::move(__last),
      __value);
}

}}
# 1830 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/algorithm" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_fill.h" 1 3
# 27 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_fill.h" 3




namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class>
void __pstl_fill();

template <class _ExecutionPolicy,
          class _ForwardIterator,
          class _Tp,
          class _RawPolicy = __remove_cvref_t<_ExecutionPolicy>,
          enable_if_t<is_execution_policy_v<_RawPolicy>, int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) void
fill(_ExecutionPolicy&& __policy, _ForwardIterator __first, _ForwardIterator __last, const _Tp& __value) {
  static_assert(::std::__cpp17_forward_iterator<_ForwardIterator>);;
  std::__pstl_frontend_dispatch(
      [](auto&&... __args) -> decltype(std::__pstl_fill<_RawPolicy>(typename __select_backend<_RawPolicy>::type{}, std::forward<decltype(__args)>(__args)...)) { return std::__pstl_fill<_RawPolicy>( typename __select_backend<_RawPolicy>::type{}, std::forward<decltype(__args)>(__args)...); },
      [&](_ForwardIterator __g_first, _ForwardIterator __g_last, const _Tp& __g_value) {
        std::for_each(__policy, __g_first, __g_last, [&](__iter_reference<_ForwardIterator> __element) {
          __element = __g_value;
        });
      },
      std::move(__first),
      std::move(__last),
      __value);
}

template <class>
void __pstl_fill_n();

template <class _ExecutionPolicy,
          class _ForwardIterator,
          class _SizeT,
          class _Tp,
          class _RawPolicy = __remove_cvref_t<_ExecutionPolicy>,
          enable_if_t<is_execution_policy_v<_RawPolicy>, int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) void
fill_n(_ExecutionPolicy&& __policy, _ForwardIterator __first, _SizeT __n, const _Tp& __value) {
  static_assert(::std::__cpp17_forward_iterator<_ForwardIterator>);;
  std::__pstl_frontend_dispatch(
      [](auto&&... __args) -> decltype(std::__pstl_fill_n<_RawPolicy>(typename __select_backend<_RawPolicy>::type{}, std::forward<decltype(__args)>(__args)...)) { return std::__pstl_fill_n<_RawPolicy>( typename __select_backend<_RawPolicy>::type{}, std::forward<decltype(__args)>(__args)...); },
      [&](_ForwardIterator __g_first, _SizeT __g_n, const _Tp& __g_value) {
        if constexpr (__has_random_access_iterator_category_or_concept<_ForwardIterator>::value)
          std::fill(__policy, __g_first, __g_first + __g_n, __g_value);
        else
          std::fill_n(__g_first, __g_n, __g_value);
      },
      std::move(__first),
      __n,
      __value);
}

}}
# 1831 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/algorithm" 2 3


# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_generate.h" 1 3
# 25 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_generate.h" 3




namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class>
void __pstl_generate();

template <class _ExecutionPolicy,
          class _ForwardIterator,
          class _Generator,
          class _RawPolicy = __remove_cvref_t<_ExecutionPolicy>,
          enable_if_t<is_execution_policy_v<_RawPolicy>, int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) void
generate(_ExecutionPolicy&& __policy, _ForwardIterator __first, _ForwardIterator __last, _Generator __gen) {
  static_assert(::std::__cpp17_forward_iterator<_ForwardIterator>);;
  std::__pstl_frontend_dispatch(
      [](auto&&... __args) -> decltype(std::__pstl_generate<_RawPolicy>(typename __select_backend<_RawPolicy>::type{}, std::forward<decltype(__args)>(__args)...)) { return std::__pstl_generate<_RawPolicy>( typename __select_backend<_RawPolicy>::type{}, std::forward<decltype(__args)>(__args)...); },
      [&__policy](_ForwardIterator __g_first, _ForwardIterator __g_last, _Generator __g_gen) {
        std::for_each(
            __policy, std::move(__g_first), std::move(__g_last), [&](__iter_reference<_ForwardIterator> __element) {
              __element = __g_gen();
            });
      },
      std::move(__first),
      std::move(__last),
      std::move(__gen));
}

template <class>
void __pstl_generate_n();

template <class _ExecutionPolicy,
          class _ForwardIterator,
          class _Size,
          class _Generator,
          class _RawPolicy = __remove_cvref_t<_ExecutionPolicy>,
          enable_if_t<is_execution_policy_v<_RawPolicy>, int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) void
generate_n(_ExecutionPolicy&& __policy, _ForwardIterator __first, _Size __n, _Generator __gen) {
  static_assert(::std::__cpp17_forward_iterator<_ForwardIterator>);;
  std::__pstl_frontend_dispatch(
      [](auto&&... __args) -> decltype(std::__pstl_generate_n<_RawPolicy>(typename __select_backend<_RawPolicy>::type{}, std::forward<decltype(__args)>(__args)...)) { return std::__pstl_generate_n<_RawPolicy>( typename __select_backend<_RawPolicy>::type{}, std::forward<decltype(__args)>(__args)...); },
      [&__policy](_ForwardIterator __g_first, _Size __g_n, _Generator __g_gen) {
        std::for_each_n(__policy, std::move(__g_first), __g_n, [&](__iter_reference<_ForwardIterator> __element) {
          __element = __g_gen();
        });
      },
      std::move(__first),
      __n,
      std::move(__gen));
}

}}
# 1834 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/algorithm" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_is_partitioned.h" 1 3
# 24 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_is_partitioned.h" 3




namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class>
void __pstl_is_partitioned();

template <class _ExecutionPolicy,
          class _ForwardIterator,
          class _Predicate,
          class _RawPolicy = __remove_cvref_t<_ExecutionPolicy>,
          enable_if_t<is_execution_policy_v<_RawPolicy>, int> = 0>
[[__nodiscard__]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) bool
is_partitioned(_ExecutionPolicy&& __policy, _ForwardIterator __first, _ForwardIterator __last, _Predicate __pred) {
  return std::__pstl_frontend_dispatch(
      [](auto&&... __args) -> decltype(std::__pstl_is_partitioned<_RawPolicy>(typename __select_backend<_RawPolicy>::type{}, std::forward<decltype(__args)>(__args)...)) { return std::__pstl_is_partitioned<_RawPolicy>( typename __select_backend<_RawPolicy>::type{}, std::forward<decltype(__args)>(__args)...); },
      [&__policy](_ForwardIterator __g_first, _ForwardIterator __g_last, _Predicate __g_pred) {
        __g_first = std::find_if_not(__policy, __g_first, __g_last, __g_pred);
        if (__g_first == __g_last)
          return true;
        ++__g_first;
        return std::none_of(__policy, __g_first, __g_last, __g_pred);
      },
      std::move(__first),
      std::move(__last),
      std::move(__pred));
}

}}
# 1835 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/algorithm" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_merge.h" 1 3
# 22 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_merge.h" 3




namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _ExecutionPolicy,
          class _ForwardIterator1,
          class _ForwardIterator2,
          class _ForwardOutIterator,
          class _Comp = std::less<>,
          class _RawPolicy = __remove_cvref_t<_ExecutionPolicy>,
          enable_if_t<is_execution_policy_v<_RawPolicy>, int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) _ForwardOutIterator
merge(_ExecutionPolicy&&,
      _ForwardIterator1 __first1,
      _ForwardIterator1 __last1,
      _ForwardIterator2 __first2,
      _ForwardIterator2 __last2,
      _ForwardOutIterator __result,
      _Comp __comp = {}) {
  using _Backend = typename __select_backend<_RawPolicy>::type;
  return std::__pstl_merge<_RawPolicy>(
      _Backend{},
      std::move(__first1),
      std::move(__last1),
      std::move(__first2),
      std::move(__last2),
      std::move(__result),
      std::move(__comp));
}

}}
# 1836 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/algorithm" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_replace.h" 1 3
# 24 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_replace.h" 3




namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class>
void __pstl_replace_if();

template <class _ExecutionPolicy,
          class _ForwardIterator,
          class _Pred,
          class _Tp,
          class _RawPolicy = __remove_cvref_t<_ExecutionPolicy>,
          enable_if_t<is_execution_policy_v<_RawPolicy>, int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) void
replace_if(_ExecutionPolicy&& __policy,
           _ForwardIterator __first,
           _ForwardIterator __last,
           _Pred __pred,
           const _Tp& __new_value) {
  std::__pstl_frontend_dispatch(
      [](auto&&... __args) -> decltype(std::__pstl_replace_if<_RawPolicy>(typename __select_backend<_RawPolicy>::type{}, std::forward<decltype(__args)>(__args)...)) { return std::__pstl_replace_if<_RawPolicy>( typename __select_backend<_RawPolicy>::type{}, std::forward<decltype(__args)>(__args)...); },
      [&__policy](_ForwardIterator __g_first, _ForwardIterator __g_last, _Pred __g_pred, const _Tp& __g_new_value) {
        std::for_each(__policy, __g_first, __g_last, [&](__iter_reference<_ForwardIterator> __element) {
          if (__g_pred(__element))
            __element = __g_new_value;
        });
      },
      std::move(__first),
      std::move(__last),
      std::move(__pred),
      __new_value);
}

template <class>
void __pstl_replace();

template <class _ExecutionPolicy,
          class _ForwardIterator,
          class _Tp,
          class _RawPolicy = __remove_cvref_t<_ExecutionPolicy>,
          enable_if_t<is_execution_policy_v<_RawPolicy>, int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) void
replace(_ExecutionPolicy&& __policy,
        _ForwardIterator __first,
        _ForwardIterator __last,
        const _Tp& __old_value,
        const _Tp& __new_value) {
  std::__pstl_frontend_dispatch(
      [](auto&&... __args) -> decltype(std::__pstl_replace<_RawPolicy>(typename __select_backend<_RawPolicy>::type{}, std::forward<decltype(__args)>(__args)...)) { return std::__pstl_replace<_RawPolicy>( typename __select_backend<_RawPolicy>::type{}, std::forward<decltype(__args)>(__args)...); },
      [&__policy](
          _ForwardIterator __g_first, _ForwardIterator __g_last, const _Tp& __g_old_value, const _Tp& __g_new_value) {
        std::replace_if(
            __policy,
            std::move(__g_first),
            std::move(__g_last),
            [&](__iter_reference<_ForwardIterator> __element) { return __element == __g_old_value; },
            __g_new_value);
      },
      std::move(__first),
      std::move(__last),
      __old_value,
      __new_value);
}

template <class>
void __pstl_replace_copy_if();

template <class _ExecutionPolicy,
          class _ForwardIterator,
          class _ForwardOutIterator,
          class _Pred,
          class _Tp,
          class _RawPolicy = __remove_cvref_t<_ExecutionPolicy>,
          enable_if_t<is_execution_policy_v<_RawPolicy>, int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) void replace_copy_if(
    _ExecutionPolicy&& __policy,
    _ForwardIterator __first,
    _ForwardIterator __last,
    _ForwardOutIterator __result,
    _Pred __pred,
    const _Tp& __new_value) {
  std::__pstl_frontend_dispatch(
      [](auto&&... __args) -> decltype(std::__pstl_replace_copy_if<_RawPolicy>(typename __select_backend<_RawPolicy>::type{}, std::forward<decltype(__args)>(__args)...)) { return std::__pstl_replace_copy_if<_RawPolicy>( typename __select_backend<_RawPolicy>::type{}, std::forward<decltype(__args)>(__args)...); },
      [&__policy](_ForwardIterator __g_first,
                  _ForwardIterator __g_last,
                  _ForwardOutIterator __g_result,
                  _Pred __g_pred,
                  const _Tp& __g_new_value) {
        std::transform(__policy, __g_first, __g_last, __g_result, [&](__iter_reference<_ForwardIterator> __element) {
          return __g_pred(__element) ? __g_new_value : __element;
        });
      },
      std::move(__first),
      std::move(__last),
      std::move(__result),
      std::move(__pred),
      __new_value);
}

template <class>
void __pstl_replace_copy();

template <class _ExecutionPolicy,
          class _ForwardIterator,
          class _ForwardOutIterator,
          class _Tp,
          class _RawPolicy = __remove_cvref_t<_ExecutionPolicy>,
          enable_if_t<is_execution_policy_v<_RawPolicy>, int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) void replace_copy(
    _ExecutionPolicy&& __policy,
    _ForwardIterator __first,
    _ForwardIterator __last,
    _ForwardOutIterator __result,
    const _Tp& __old_value,
    const _Tp& __new_value) {
  std::__pstl_frontend_dispatch(
      [](auto&&... __args) -> decltype(std::__pstl_replace_copy<_RawPolicy>(typename __select_backend<_RawPolicy>::type{}, std::forward<decltype(__args)>(__args)...)) { return std::__pstl_replace_copy<_RawPolicy>( typename __select_backend<_RawPolicy>::type{}, std::forward<decltype(__args)>(__args)...); },
      [&__policy](_ForwardIterator __g_first,
                  _ForwardIterator __g_last,
                  _ForwardOutIterator __g_result,
                  const _Tp& __g_old_value,
                  const _Tp& __g_new_value) {
        return std::replace_copy_if(
            __policy,
            std::move(__g_first),
            std::move(__g_last),
            std::move(__g_result),
            [&](__iter_reference<_ForwardIterator> __element) { return __element == __g_old_value; },
            __g_new_value);
      },
      std::move(__first),
      std::move(__last),
      std::move(__result),
      __old_value,
      __new_value);
}

}}
# 1837 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/algorithm" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_sort.h" 1 3
# 14 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_sort.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_stable_sort.h" 1 3
# 22 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_stable_sort.h" 3




namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _ExecutionPolicy,
          class _RandomAccessIterator,
          class _Comp = less<>,
          class _RawPolicy = __remove_cvref_t<_ExecutionPolicy>,
          enable_if_t<is_execution_policy_v<_RawPolicy>, int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) void
stable_sort(_ExecutionPolicy&&, _RandomAccessIterator __first, _RandomAccessIterator __last, _Comp __comp = {}) {
  using _Backend = typename __select_backend<_RawPolicy>::type;
  std::__pstl_stable_sort<_RawPolicy>(_Backend{}, std::move(__first), std::move(__last), std::move(__comp));
}

}}
# 15 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_sort.h" 2 3
# 24 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/pstl_sort.h" 3




namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class>
void __pstl_sort();

template <class _ExecutionPolicy,
          class _RandomAccessIterator,
          class _Comp,
          class _RawPolicy = __remove_cvref_t<_ExecutionPolicy>,
          enable_if_t<is_execution_policy_v<_RawPolicy>, int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) void
sort(_ExecutionPolicy&& __policy, _RandomAccessIterator __first, _RandomAccessIterator __last, _Comp __comp) {
  std::__pstl_frontend_dispatch(
      [](auto&&... __args) -> decltype(std::__pstl_sort<_RawPolicy>(typename __select_backend<_RawPolicy>::type{}, std::forward<decltype(__args)>(__args)...)) { return std::__pstl_sort<_RawPolicy>( typename __select_backend<_RawPolicy>::type{}, std::forward<decltype(__args)>(__args)...); },
      [&__policy](_RandomAccessIterator __g_first, _RandomAccessIterator __g_last, _Comp __g_comp) {
        std::stable_sort(__policy, std::move(__g_first), std::move(__g_last), std::move(__g_comp));
      },
      std::move(__first),
      std::move(__last),
      std::move(__comp));
}

template <class _ExecutionPolicy,
          class _RandomAccessIterator,
          class _RawPolicy = __remove_cvref_t<_ExecutionPolicy>,
          enable_if_t<is_execution_policy_v<_RawPolicy>, int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) void
sort(_ExecutionPolicy&& __policy, _RandomAccessIterator __first, _RandomAccessIterator __last) {
  std::sort(std::forward<_ExecutionPolicy>(__policy), std::move(__first), std::move(__last), less{});
}

}}
# 1838 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/algorithm" 2 3



# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_adjacent_find.h" 1 3
# 17 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_adjacent_find.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__iterator/projected.h" 1 3
# 20 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__iterator/projected.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {



template <class _It, class _Proj>
struct __projected_impl {
  struct __type {
    using value_type = remove_cvref_t<indirect_result_t<_Proj&, _It>>;
    indirect_result_t<_Proj&, _It> operator*() const;
  };
};

template <weakly_incrementable _It, class _Proj>
struct __projected_impl<_It, _Proj> {
  struct __type {
    using value_type = remove_cvref_t<indirect_result_t<_Proj&, _It>>;
    using difference_type = iter_difference_t<_It>;
    indirect_result_t<_Proj&, _It> operator*() const;
  };
};




template <indirectly_readable _It, indirectly_regular_unary_invocable<_It> _Proj>
using projected = typename __projected_impl<_It, _Proj>::__type;



}}
# 18 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_adjacent_find.h" 2 3
# 25 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_adjacent_find.h" 3



# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__undef_macros" 1 3
# 29 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_adjacent_find.h" 2 3



namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

namespace ranges {
namespace __adjacent_find {
struct __fn {
  template <class _Iter, class _Sent, class _Proj, class _Pred>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr static _Iter
  __adjacent_find_impl(_Iter __first, _Sent __last, _Pred& __pred, _Proj& __proj) {
    if (__first == __last)
      return __first;

    auto __i = __first;
    while (++__i != __last) {
      if (std::invoke(__pred, std::invoke(__proj, *__first), std::invoke(__proj, *__i)))
        return __first;
      __first = __i;
    }
    return __i;
  }

  template <forward_iterator _Iter,
            sentinel_for<_Iter> _Sent,
            class _Proj = identity,
            indirect_binary_predicate<projected<_Iter, _Proj>, projected<_Iter, _Proj>> _Pred = ranges::equal_to>
  [[__nodiscard__]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr _Iter
  operator()(_Iter __first, _Sent __last, _Pred __pred = {}, _Proj __proj = {}) const {
    return __adjacent_find_impl(std::move(__first), std::move(__last), __pred, __proj);
  }

  template <forward_range _Range,
            class _Proj = identity,
            indirect_binary_predicate<projected<iterator_t<_Range>, _Proj>, projected<iterator_t<_Range>, _Proj>>
                _Pred = ranges::equal_to>
  [[__nodiscard__]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr borrowed_iterator_t<_Range>
  operator()(_Range&& __range, _Pred __pred = {}, _Proj __proj = {}) const {
    return __adjacent_find_impl(ranges::begin(__range), ranges::end(__range), __pred, __proj);
  }
};
}

inline namespace __cpo {
inline constexpr auto adjacent_find = __adjacent_find::__fn{};
}
}

}}
# 1842 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/algorithm" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_all_of.h" 1 3
# 23 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_all_of.h" 3




namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

namespace ranges {
namespace __all_of {
struct __fn {
  template <class _Iter, class _Sent, class _Proj, class _Pred>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr static bool __all_of_impl(_Iter __first, _Sent __last, _Pred& __pred, _Proj& __proj) {
    for (; __first != __last; ++__first) {
      if (!std::invoke(__pred, std::invoke(__proj, *__first)))
        return false;
    }
    return true;
  }

  template <input_iterator _Iter,
            sentinel_for<_Iter> _Sent,
            class _Proj = identity,
            indirect_unary_predicate<projected<_Iter, _Proj>> _Pred>
  [[__nodiscard__]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr bool
  operator()(_Iter __first, _Sent __last, _Pred __pred, _Proj __proj = {}) const {
    return __all_of_impl(std::move(__first), std::move(__last), __pred, __proj);
  }

  template <input_range _Range,
            class _Proj = identity,
            indirect_unary_predicate<projected<iterator_t<_Range>, _Proj>> _Pred>
  [[__nodiscard__]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr bool
  operator()(_Range&& __range, _Pred __pred, _Proj __proj = {}) const {
    return __all_of_impl(ranges::begin(__range), ranges::end(__range), __pred, __proj);
  }
};
}

inline namespace __cpo {
inline constexpr auto all_of = __all_of::__fn{};
}
}

}}
# 1843 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/algorithm" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_any_of.h" 1 3
# 23 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_any_of.h" 3




namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

namespace ranges {
namespace __any_of {
struct __fn {
  template <class _Iter, class _Sent, class _Proj, class _Pred>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr static bool __any_of_impl(_Iter __first, _Sent __last, _Pred& __pred, _Proj& __proj) {
    for (; __first != __last; ++__first) {
      if (std::invoke(__pred, std::invoke(__proj, *__first)))
        return true;
    }
    return false;
  }

  template <input_iterator _Iter,
            sentinel_for<_Iter> _Sent,
            class _Proj = identity,
            indirect_unary_predicate<projected<_Iter, _Proj>> _Pred>
  [[__nodiscard__]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr bool
  operator()(_Iter __first, _Sent __last, _Pred __pred = {}, _Proj __proj = {}) const {
    return __any_of_impl(std::move(__first), std::move(__last), __pred, __proj);
  }

  template <input_range _Range,
            class _Proj = identity,
            indirect_unary_predicate<projected<iterator_t<_Range>, _Proj>> _Pred>
  [[__nodiscard__]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr bool
  operator()(_Range&& __range, _Pred __pred, _Proj __proj = {}) const {
    return __any_of_impl(ranges::begin(__range), ranges::end(__range), __pred, __proj);
  }
};
}

inline namespace __cpo {
inline constexpr auto any_of = __any_of::__fn{};
}
}

}}
# 1844 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/algorithm" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_binary_search.h" 1 3
# 25 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_binary_search.h" 3




namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

namespace ranges {
namespace __binary_search {
struct __fn {
  template <forward_iterator _Iter,
            sentinel_for<_Iter> _Sent,
            class _Type,
            class _Proj = identity,
            indirect_strict_weak_order<const _Type*, projected<_Iter, _Proj>> _Comp = ranges::less>
  [[__nodiscard__]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr bool
  operator()(_Iter __first, _Sent __last, const _Type& __value, _Comp __comp = {}, _Proj __proj = {}) const {
    auto __ret = std::__lower_bound<_RangeAlgPolicy>(__first, __last, __value, __comp, __proj);
    return __ret != __last && !std::invoke(__comp, __value, std::invoke(__proj, *__ret));
  }

  template <forward_range _Range,
            class _Type,
            class _Proj = identity,
            indirect_strict_weak_order<const _Type*, projected<iterator_t<_Range>, _Proj>> _Comp = ranges::less>
  [[__nodiscard__]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr bool
  operator()(_Range&& __r, const _Type& __value, _Comp __comp = {}, _Proj __proj = {}) const {
    auto __first = ranges::begin(__r);
    auto __last = ranges::end(__r);
    auto __ret = std::__lower_bound<_RangeAlgPolicy>(__first, __last, __value, __comp, __proj);
    return __ret != __last && !std::invoke(__comp, __value, std::invoke(__proj, *__ret));
  }
};
}

inline namespace __cpo {
inline constexpr auto binary_search = __binary_search::__fn{};
}
}

}}
# 1845 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/algorithm" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_clamp.h" 1 3
# 23 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_clamp.h" 3




namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

namespace ranges {
namespace __clamp {
struct __fn {
  template <class _Type,
            class _Proj = identity,
            indirect_strict_weak_order<projected<const _Type*, _Proj>> _Comp = ranges::less>
  [[__nodiscard__]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr const _Type& operator()(
      const _Type& __value, const _Type& __low, const _Type& __high, _Comp __comp = {}, _Proj __proj = {}) const {
    ((void)0);


    if (std::invoke(__comp, std::invoke(__proj, __value), std::invoke(__proj, __low)))
      return __low;
    else if (std::invoke(__comp, std::invoke(__proj, __high), std::invoke(__proj, __value)))
      return __high;
    else
      return __value;
  }
};
}

inline namespace __cpo {
inline constexpr auto clamp = __clamp::__fn{};
}
}

}}
# 1846 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/algorithm" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_copy.h" 1 3
# 26 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_copy.h" 3




namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

namespace ranges {

template <class _InIter, class _OutIter>
using copy_result = in_out_result<_InIter, _OutIter>;

namespace __copy {
struct __fn {
  template <input_iterator _InIter, sentinel_for<_InIter> _Sent, weakly_incrementable _OutIter>
    requires indirectly_copyable<_InIter, _OutIter>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr copy_result<_InIter, _OutIter>
  operator()(_InIter __first, _Sent __last, _OutIter __result) const {
    auto __ret = std::__copy<_RangeAlgPolicy>(std::move(__first), std::move(__last), std::move(__result));
    return {std::move(__ret.first), std::move(__ret.second)};
  }

  template <input_range _Range, weakly_incrementable _OutIter>
    requires indirectly_copyable<iterator_t<_Range>, _OutIter>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr copy_result<borrowed_iterator_t<_Range>, _OutIter>
  operator()(_Range&& __r, _OutIter __result) const {
    auto __ret = std::__copy<_RangeAlgPolicy>(ranges::begin(__r), ranges::end(__r), std::move(__result));
    return {std::move(__ret.first), std::move(__ret.second)};
  }
};
}

inline namespace __cpo {
inline constexpr auto copy = __copy::__fn{};
}
}

}}
# 1847 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/algorithm" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_copy_backward.h" 1 3
# 24 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_copy_backward.h" 3




namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

namespace ranges {

template <class _Ip, class _Op>
using copy_backward_result = in_out_result<_Ip, _Op>;

namespace __copy_backward {
struct __fn {
  template <bidirectional_iterator _InIter1, sentinel_for<_InIter1> _Sent1, bidirectional_iterator _InIter2>
    requires indirectly_copyable<_InIter1, _InIter2>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr copy_backward_result<_InIter1, _InIter2>
  operator()(_InIter1 __first, _Sent1 __last, _InIter2 __result) const {
    auto __ret = std::__copy_backward<_RangeAlgPolicy>(std::move(__first), std::move(__last), std::move(__result));
    return {std::move(__ret.first), std::move(__ret.second)};
  }

  template <bidirectional_range _Range, bidirectional_iterator _Iter>
    requires indirectly_copyable<iterator_t<_Range>, _Iter>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr copy_backward_result<borrowed_iterator_t<_Range>, _Iter>
  operator()(_Range&& __r, _Iter __result) const {
    auto __ret = std::__copy_backward<_RangeAlgPolicy>(ranges::begin(__r), ranges::end(__r), std::move(__result));
    return {std::move(__ret.first), std::move(__ret.second)};
  }
};
}

inline namespace __cpo {
inline constexpr auto copy_backward = __copy_backward::__fn{};
}
}

}}
# 1848 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/algorithm" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_copy_if.h" 1 3
# 25 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_copy_if.h" 3




namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

namespace ranges {

template <class _Ip, class _Op>
using copy_if_result = in_out_result<_Ip, _Op>;

namespace __copy_if {
struct __fn {
  template <class _InIter, class _Sent, class _OutIter, class _Proj, class _Pred>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) static constexpr copy_if_result<_InIter, _OutIter>
  __copy_if_impl(_InIter __first, _Sent __last, _OutIter __result, _Pred& __pred, _Proj& __proj) {
    for (; __first != __last; ++__first) {
      if (std::invoke(__pred, std::invoke(__proj, *__first))) {
        *__result = *__first;
        ++__result;
      }
    }
    return {std::move(__first), std::move(__result)};
  }

  template <input_iterator _Iter,
            sentinel_for<_Iter> _Sent,
            weakly_incrementable _OutIter,
            class _Proj = identity,
            indirect_unary_predicate<projected<_Iter, _Proj>> _Pred>
    requires indirectly_copyable<_Iter, _OutIter>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr copy_if_result<_Iter, _OutIter>
  operator()(_Iter __first, _Sent __last, _OutIter __result, _Pred __pred, _Proj __proj = {}) const {
    return __copy_if_impl(std::move(__first), std::move(__last), std::move(__result), __pred, __proj);
  }

  template <input_range _Range,
            weakly_incrementable _OutIter,
            class _Proj = identity,
            indirect_unary_predicate<projected<iterator_t<_Range>, _Proj>> _Pred>
    requires indirectly_copyable<iterator_t<_Range>, _OutIter>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr copy_if_result<borrowed_iterator_t<_Range>, _OutIter>
  operator()(_Range&& __r, _OutIter __result, _Pred __pred, _Proj __proj = {}) const {
    return __copy_if_impl(ranges::begin(__r), ranges::end(__r), std::move(__result), __pred, __proj);
  }
};
}

inline namespace __cpo {
inline constexpr auto copy_if = __copy_if::__fn{};
}
}

}}
# 1849 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/algorithm" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_copy_n.h" 1 3
# 20 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_copy_n.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__iterator/unreachable_sentinel.h" 1 3
# 18 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__iterator/unreachable_sentinel.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {



struct unreachable_sentinel_t {
  template<weakly_incrementable _Iter>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
  friend constexpr bool operator==(unreachable_sentinel_t, const _Iter&) noexcept {
    return false;
  }
};

inline constexpr unreachable_sentinel_t unreachable_sentinel{};



}}
# 21 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_copy_n.h" 2 3
# 26 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_copy_n.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {



namespace ranges {

template <class _Ip, class _Op>
using copy_n_result = in_out_result<_Ip, _Op>;

namespace __copy_n {
struct __fn {
  template <class _InIter, class _DiffType, class _OutIter>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr static copy_n_result<_InIter, _OutIter>
  __go(_InIter __first, _DiffType __n, _OutIter __result) {
    while (__n != 0) {
      *__result = *__first;
      ++__first;
      ++__result;
      --__n;
    }
    return {std::move(__first), std::move(__result)};
  }

  template <random_access_iterator _InIter, class _DiffType, random_access_iterator _OutIter>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr static copy_n_result<_InIter, _OutIter>
  __go(_InIter __first, _DiffType __n, _OutIter __result) {
    auto __ret = std::__copy<_RangeAlgPolicy>(__first, __first + __n, __result);
    return {__ret.first, __ret.second};
  }

  template <input_iterator _Ip, weakly_incrementable _Op>
    requires indirectly_copyable<_Ip, _Op>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr copy_n_result<_Ip, _Op>
  operator()(_Ip __first, iter_difference_t<_Ip> __n, _Op __result) const {
    return __go(std::move(__first), __n, std::move(__result));
  }
};
}

inline namespace __cpo {
inline constexpr auto copy_n = __copy_n::__fn{};
}
}



}}
# 1850 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/algorithm" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_count.h" 1 3
# 12 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_count.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_count_if.h" 1 3
# 26 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_count_if.h" 3




namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

namespace ranges {
template <class _Iter, class _Sent, class _Proj, class _Pred>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr iter_difference_t<_Iter>
__count_if_impl(_Iter __first, _Sent __last, _Pred& __pred, _Proj& __proj) {
  iter_difference_t<_Iter> __counter(0);
  for (; __first != __last; ++__first) {
    if (std::invoke(__pred, std::invoke(__proj, *__first)))
      ++__counter;
  }
  return __counter;
}

namespace __count_if {
struct __fn {
  template <input_iterator _Iter,
            sentinel_for<_Iter> _Sent,
            class _Proj = identity,
            indirect_unary_predicate<projected<_Iter, _Proj>> _Predicate>
  [[__nodiscard__]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr iter_difference_t<_Iter>
  operator()(_Iter __first, _Sent __last, _Predicate __pred, _Proj __proj = {}) const {
    return ranges::__count_if_impl(std::move(__first), std::move(__last), __pred, __proj);
  }

  template <input_range _Range,
            class _Proj = identity,
            indirect_unary_predicate<projected<iterator_t<_Range>, _Proj>> _Predicate>
  [[__nodiscard__]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr range_difference_t<_Range>
  operator()(_Range&& __r, _Predicate __pred, _Proj __proj = {}) const {
    return ranges::__count_if_impl(ranges::begin(__r), ranges::end(__r), __pred, __proj);
  }
};
}

inline namespace __cpo {
inline constexpr auto count_if = __count_if::__fn{};
}
}

}}
# 13 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_count.h" 2 3
# 26 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_count.h" 3




namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

namespace ranges {
namespace __count {
struct __fn {
  template <input_iterator _Iter, sentinel_for<_Iter> _Sent, class _Type, class _Proj = identity>
    requires indirect_binary_predicate<ranges::equal_to, projected<_Iter, _Proj>, const _Type*>
  [[__nodiscard__]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr iter_difference_t<_Iter>
  operator()(_Iter __first, _Sent __last, const _Type& __value, _Proj __proj = {}) const {
    auto __pred = [&](auto&& __e) { return __e == __value; };
    return ranges::__count_if_impl(std::move(__first), std::move(__last), __pred, __proj);
  }

  template <input_range _Range, class _Type, class _Proj = identity>
    requires indirect_binary_predicate<ranges::equal_to, projected<iterator_t<_Range>, _Proj>, const _Type*>
  [[__nodiscard__]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr range_difference_t<_Range>
  operator()(_Range&& __r, const _Type& __value, _Proj __proj = {}) const {
    auto __pred = [&](auto&& __e) { return __e == __value; };
    return ranges::__count_if_impl(ranges::begin(__r), ranges::end(__r), __pred, __proj);
  }
};
}

inline namespace __cpo {
inline constexpr auto count = __count::__fn{};
}
}

}}
# 1851 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/algorithm" 2 3

# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_ends_with.h" 1 3
# 12 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_ends_with.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_equal.h" 1 3
# 20 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_equal.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__iterator/indirectly_comparable.h" 1 3
# 20 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__iterator/indirectly_comparable.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {



template <class _I1, class _I2, class _Rp, class _P1 = identity, class _P2 = identity>
concept indirectly_comparable =
  indirect_binary_predicate<_Rp, projected<_I1, _P1>, projected<_I2, _P2>>;



}}
# 21 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_equal.h" 2 3
# 27 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_equal.h" 3




namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

namespace ranges {
namespace __equal {
struct __fn {
  template <input_iterator _Iter1,
            sentinel_for<_Iter1> _Sent1,
            input_iterator _Iter2,
            sentinel_for<_Iter2> _Sent2,
            class _Pred = ranges::equal_to,
            class _Proj1 = identity,
            class _Proj2 = identity>
    requires indirectly_comparable<_Iter1, _Iter2, _Pred, _Proj1, _Proj2>
  [[__nodiscard__]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr bool operator()(
      _Iter1 __first1,
      _Sent1 __last1,
      _Iter2 __first2,
      _Sent2 __last2,
      _Pred __pred = {},
      _Proj1 __proj1 = {},
      _Proj2 __proj2 = {}) const {
    if constexpr (sized_sentinel_for<_Sent1, _Iter1> && sized_sentinel_for<_Sent2, _Iter2>) {
      if (__last1 - __first1 != __last2 - __first2)
        return false;
    }
    auto __unwrapped1 = std::__unwrap_range(std::move(__first1), std::move(__last1));
    auto __unwrapped2 = std::__unwrap_range(std::move(__first2), std::move(__last2));
    return std::__equal_impl(
        std::move(__unwrapped1.first),
        std::move(__unwrapped1.second),
        std::move(__unwrapped2.first),
        std::move(__unwrapped2.second),
        __pred,
        __proj1,
        __proj2);
  }

  template <input_range _Range1,
            input_range _Range2,
            class _Pred = ranges::equal_to,
            class _Proj1 = identity,
            class _Proj2 = identity>
    requires indirectly_comparable<iterator_t<_Range1>, iterator_t<_Range2>, _Pred, _Proj1, _Proj2>
  [[__nodiscard__]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr bool operator()(
      _Range1&& __range1, _Range2&& __range2, _Pred __pred = {}, _Proj1 __proj1 = {}, _Proj2 __proj2 = {}) const {
    if constexpr (sized_range<_Range1> && sized_range<_Range2>) {
      if (ranges::distance(__range1) != ranges::distance(__range2))
        return false;
    }
    auto __unwrapped1 = std::__unwrap_range(ranges::begin(__range1), ranges::end(__range1));
    auto __unwrapped2 = std::__unwrap_range(ranges::begin(__range2), ranges::end(__range2));
    return std::__equal_impl(
        std::move(__unwrapped1.first),
        std::move(__unwrapped1.second),
        std::move(__unwrapped2.first),
        std::move(__unwrapped2.second),
        __pred,
        __proj1,
        __proj2);
    return false;
  }
};
}

inline namespace __cpo {
inline constexpr auto equal = __equal::__fn{};
}
}

}}
# 13 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_ends_with.h" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_starts_with.h" 1 3
# 13 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_starts_with.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_mismatch.h" 1 3
# 26 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_mismatch.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {



namespace ranges {

template <class _I1, class _I2>
using mismatch_result = in_in_result<_I1, _I2>;

namespace __mismatch {
struct __fn {
  template <class _I1, class _S1, class _I2, class _S2, class _Pred, class _Proj1, class _Proj2>
  static __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr mismatch_result<_I1, _I2>
  __go(_I1 __first1, _S1 __last1, _I2 __first2, _S2 __last2, _Pred& __pred, _Proj1& __proj1, _Proj2& __proj2) {
    while (__first1 != __last1 && __first2 != __last2) {
      if (!std::invoke(__pred, std::invoke(__proj1, *__first1), std::invoke(__proj2, *__first2)))
        break;
      ++__first1;
      ++__first2;
    }
    return {std::move(__first1), std::move(__first2)};
  }

  template <input_iterator _I1,
            sentinel_for<_I1> _S1,
            input_iterator _I2,
            sentinel_for<_I2> _S2,
            class _Pred = ranges::equal_to,
            class _Proj1 = identity,
            class _Proj2 = identity>
    requires indirectly_comparable<_I1, _I2, _Pred, _Proj1, _Proj2>
  [[__nodiscard__]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr mismatch_result<_I1, _I2> operator()(
      _I1 __first1, _S1 __last1, _I2 __first2, _S2 __last2, _Pred __pred = {}, _Proj1 __proj1 = {}, _Proj2 __proj2 = {})
      const {
    return __go(std::move(__first1), __last1, std::move(__first2), __last2, __pred, __proj1, __proj2);
  }

  template <input_range _R1,
            input_range _R2,
            class _Pred = ranges::equal_to,
            class _Proj1 = identity,
            class _Proj2 = identity>
    requires indirectly_comparable<iterator_t<_R1>, iterator_t<_R2>, _Pred, _Proj1, _Proj2>
  [[__nodiscard__]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr mismatch_result<borrowed_iterator_t<_R1>,
                                                                        borrowed_iterator_t<_R2>>
  operator()(_R1&& __r1, _R2&& __r2, _Pred __pred = {}, _Proj1 __proj1 = {}, _Proj2 __proj2 = {}) const {
    return __go(
        ranges::begin(__r1), ranges::end(__r1), ranges::begin(__r2), ranges::end(__r2), __pred, __proj1, __proj2);
  }
};
}

inline namespace __cpo {
constexpr inline auto mismatch = __mismatch::__fn{};
}
}



}}
# 14 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_starts_with.h" 2 3
# 25 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_starts_with.h" 3




namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

namespace ranges {
namespace __starts_with {
struct __fn {
  template <input_iterator _Iter1,
            sentinel_for<_Iter1> _Sent1,
            input_iterator _Iter2,
            sentinel_for<_Iter2> _Sent2,
            class _Pred = ranges::equal_to,
            class _Proj1 = identity,
            class _Proj2 = identity>
    requires indirectly_comparable<_Iter1, _Iter2, _Pred, _Proj1, _Proj2>
  [[__nodiscard__]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr bool operator()(
      _Iter1 __first1,
      _Sent1 __last1,
      _Iter2 __first2,
      _Sent2 __last2,
      _Pred __pred = {},
      _Proj1 __proj1 = {},
      _Proj2 __proj2 = {}) const {
    return __mismatch::__fn::__go(
               std::move(__first1),
               std::move(__last1),
               std::move(__first2),
               std::move(__last2),
               __pred,
               __proj1,
               __proj2)
               .in2 == __last2;
  }

  template <input_range _Range1,
            input_range _Range2,
            class _Pred = ranges::equal_to,
            class _Proj1 = identity,
            class _Proj2 = identity>
    requires indirectly_comparable<iterator_t<_Range1>, iterator_t<_Range2>, _Pred, _Proj1, _Proj2>
  [[__nodiscard__]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr bool operator()(
      _Range1&& __range1, _Range2&& __range2, _Pred __pred = {}, _Proj1 __proj1 = {}, _Proj2 __proj2 = {}) const {
    return __mismatch::__fn::__go(
               ranges::begin(__range1),
               ranges::end(__range1),
               ranges::begin(__range2),
               ranges::end(__range2),
               __pred,
               __proj1,
               __proj2)
               .in2 == ranges::end(__range2);
  }
};
}
inline namespace __cpo {
inline constexpr auto starts_with = __starts_with::__fn{};
}
}

}}
# 14 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_ends_with.h" 2 3



# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__functional/reference_wrapper.h" 1 3
# 15 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__functional/reference_wrapper.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__functional/weak_result_type.h" 1 3
# 23 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__functional/weak_result_type.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Tp>
struct __has_result_type
{
private:
    template <class _Up> static false_type __test(...);
    template <class _Up> static true_type __test(typename _Up::result_type* = 0);
public:
    static const bool value = decltype(__test<_Tp>(0))::value;
};



template <class _Tp>
struct __derives_from_unary_function
{
private:
    struct __two {char __lx; char __lxx;};
    static __two __test(...);
    template <class _Ap, class _Rp>
        static __unary_function<_Ap, _Rp>
        __test(const volatile __unary_function<_Ap, _Rp>*);

public:
    static const bool value = !is_same<decltype(__test((_Tp*)0)), __two>::value;
    typedef decltype(__test((_Tp*)0)) type;
};

template <class _Tp>
struct __derives_from_binary_function
{
private:
    struct __two {char __lx; char __lxx;};
    static __two __test(...);
    template <class _A1, class _A2, class _Rp>
        static __binary_function<_A1, _A2, _Rp>
        __test(const volatile __binary_function<_A1, _A2, _Rp>*);

public:
    static const bool value = !is_same<decltype(__test((_Tp*)0)), __two>::value;
    typedef decltype(__test((_Tp*)0)) type;
};

template <class _Tp, bool = __derives_from_unary_function<_Tp>::value>
struct __maybe_derive_from_unary_function
    : public __derives_from_unary_function<_Tp>::type
{
};

template <class _Tp>
struct __maybe_derive_from_unary_function<_Tp, false>
{
};

template <class _Tp, bool = __derives_from_binary_function<_Tp>::value>
struct __maybe_derive_from_binary_function
    : public __derives_from_binary_function<_Tp>::type
{
};

template <class _Tp>
struct __maybe_derive_from_binary_function<_Tp, false>
{
};

template <class _Tp, bool = __has_result_type<_Tp>::value>
struct __weak_result_type_imp
    : public __maybe_derive_from_unary_function<_Tp>,
      public __maybe_derive_from_binary_function<_Tp>
{



};

template <class _Tp>
struct __weak_result_type_imp<_Tp, false>
    : public __maybe_derive_from_unary_function<_Tp>,
      public __maybe_derive_from_binary_function<_Tp>
{
};

template <class _Tp>
struct __weak_result_type
    : public __weak_result_type_imp<_Tp>
{
};



template <class _Rp>
struct __weak_result_type<_Rp ()>
{



};

template <class _Rp>
struct __weak_result_type<_Rp (&)()>
{



};

template <class _Rp>
struct __weak_result_type<_Rp (*)()>
{



};



template <class _Rp, class _A1>
struct __weak_result_type<_Rp (_A1)>
    : public __unary_function<_A1, _Rp>
{
};

template <class _Rp, class _A1>
struct __weak_result_type<_Rp (&)(_A1)>
    : public __unary_function<_A1, _Rp>
{
};

template <class _Rp, class _A1>
struct __weak_result_type<_Rp (*)(_A1)>
    : public __unary_function<_A1, _Rp>
{
};

template <class _Rp, class _Cp>
struct __weak_result_type<_Rp (_Cp::*)()>
    : public __unary_function<_Cp*, _Rp>
{
};

template <class _Rp, class _Cp>
struct __weak_result_type<_Rp (_Cp::*)() const>
    : public __unary_function<const _Cp*, _Rp>
{
};

template <class _Rp, class _Cp>
struct __weak_result_type<_Rp (_Cp::*)() volatile>
    : public __unary_function<volatile _Cp*, _Rp>
{
};

template <class _Rp, class _Cp>
struct __weak_result_type<_Rp (_Cp::*)() const volatile>
    : public __unary_function<const volatile _Cp*, _Rp>
{
};



template <class _Rp, class _A1, class _A2>
struct __weak_result_type<_Rp (_A1, _A2)>
    : public __binary_function<_A1, _A2, _Rp>
{
};

template <class _Rp, class _A1, class _A2>
struct __weak_result_type<_Rp (*)(_A1, _A2)>
    : public __binary_function<_A1, _A2, _Rp>
{
};

template <class _Rp, class _A1, class _A2>
struct __weak_result_type<_Rp (&)(_A1, _A2)>
    : public __binary_function<_A1, _A2, _Rp>
{
};

template <class _Rp, class _Cp, class _A1>
struct __weak_result_type<_Rp (_Cp::*)(_A1)>
    : public __binary_function<_Cp*, _A1, _Rp>
{
};

template <class _Rp, class _Cp, class _A1>
struct __weak_result_type<_Rp (_Cp::*)(_A1) const>
    : public __binary_function<const _Cp*, _A1, _Rp>
{
};

template <class _Rp, class _Cp, class _A1>
struct __weak_result_type<_Rp (_Cp::*)(_A1) volatile>
    : public __binary_function<volatile _Cp*, _A1, _Rp>
{
};

template <class _Rp, class _Cp, class _A1>
struct __weak_result_type<_Rp (_Cp::*)(_A1) const volatile>
    : public __binary_function<const volatile _Cp*, _A1, _Rp>
{
};



template <class _Rp, class _A1, class _A2, class _A3, class ..._A4>
struct __weak_result_type<_Rp (_A1, _A2, _A3, _A4...)>
{



};

template <class _Rp, class _A1, class _A2, class _A3, class ..._A4>
struct __weak_result_type<_Rp (&)(_A1, _A2, _A3, _A4...)>
{



};

template <class _Rp, class _A1, class _A2, class _A3, class ..._A4>
struct __weak_result_type<_Rp (*)(_A1, _A2, _A3, _A4...)>
{



};

template <class _Rp, class _Cp, class _A1, class _A2, class ..._A3>
struct __weak_result_type<_Rp (_Cp::*)(_A1, _A2, _A3...)>
{



};

template <class _Rp, class _Cp, class _A1, class _A2, class ..._A3>
struct __weak_result_type<_Rp (_Cp::*)(_A1, _A2, _A3...) const>
{



};

template <class _Rp, class _Cp, class _A1, class _A2, class ..._A3>
struct __weak_result_type<_Rp (_Cp::*)(_A1, _A2, _A3...) volatile>
{



};

template <class _Rp, class _Cp, class _A1, class _A2, class ..._A3>
struct __weak_result_type<_Rp (_Cp::*)(_A1, _A2, _A3...) const volatile>
{



};

template <class _Tp, class ..._Args>
struct __invoke_return
{
    typedef decltype(std::__invoke(std::declval<_Tp>(), std::declval<_Args>()...)) type;
};

}}
# 16 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__functional/reference_wrapper.h" 2 3
# 24 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__functional/reference_wrapper.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Tp>
class reference_wrapper : public __weak_result_type<_Tp>
{
public:

    typedef _Tp type;
private:
    type* __f_;

    static void __fun(_Tp&) noexcept;
    static void __fun(_Tp&&) = delete;

public:
    template <class _Up, class = __enable_if_t<!__is_same_uncvref<_Up, reference_wrapper>::value, decltype(__fun(std::declval<_Up>())) > >
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    reference_wrapper(_Up&& __u) noexcept(noexcept(__fun(std::declval<_Up>()))) {
        type& __f = static_cast<_Up&&>(__u);
        __f_ = std::addressof(__f);
    }


    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    operator type&() const noexcept {return *__f_;}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    type& get() const noexcept {return *__f_;}


    template <class... _ArgTypes>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    typename __invoke_of<type&, _ArgTypes...>::type
    operator() (_ArgTypes&&... __args) const



        noexcept(is_nothrow_invocable_v<_Tp&, _ArgTypes...>)

    {
        return std::__invoke(get(), std::forward<_ArgTypes>(__args)...);
    }
};


template <class _Tp>
reference_wrapper(_Tp&) -> reference_wrapper<_Tp>;


template <class _Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
reference_wrapper<_Tp>
ref(_Tp& __t) noexcept
{
    return reference_wrapper<_Tp>(__t);
}

template <class _Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
reference_wrapper<_Tp>
ref(reference_wrapper<_Tp> __t) noexcept
{
    return __t;
}

template <class _Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
reference_wrapper<const _Tp>
cref(const _Tp& __t) noexcept
{
    return reference_wrapper<const _Tp>(__t);
}

template <class _Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
reference_wrapper<const _Tp>
cref(reference_wrapper<_Tp> __t) noexcept
{
    return __t;
}

template <class _Tp> void ref(const _Tp&&) = delete;
template <class _Tp> void cref(const _Tp&&) = delete;

}}
# 18 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_ends_with.h" 2 3
# 29 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_ends_with.h" 3




namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

namespace ranges {
namespace __ends_with {
struct __fn {
  template <class _Iter1, class _Sent1, class _Iter2, class _Sent2, class _Pred, class _Proj1, class _Proj2>
  static __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr bool __ends_with_fn_impl_bidirectional(
      _Iter1 __first1,
      _Sent1 __last1,
      _Iter2 __first2,
      _Sent2 __last2,
      _Pred& __pred,
      _Proj1& __proj1,
      _Proj2& __proj2) {
    auto __rbegin1 = std::make_reverse_iterator(__last1);
    auto __rend1 = std::make_reverse_iterator(__first1);
    auto __rbegin2 = std::make_reverse_iterator(__last2);
    auto __rend2 = std::make_reverse_iterator(__first2);
    return ranges::starts_with(
        __rbegin1, __rend1, __rbegin2, __rend2, std::ref(__pred), std::ref(__proj1), std::ref(__proj2));
  }

  template <class _Iter1, class _Sent1, class _Iter2, class _Sent2, class _Pred, class _Proj1, class _Proj2>
  static __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr bool __ends_with_fn_impl(
      _Iter1 __first1,
      _Sent1 __last1,
      _Iter2 __first2,
      _Sent2 __last2,
      _Pred& __pred,
      _Proj1& __proj1,
      _Proj2& __proj2) {
    if constexpr (std::bidirectional_iterator<_Sent1> && std::bidirectional_iterator<_Sent2> &&
                  (!std::random_access_iterator<_Sent1>)&&(!std::random_access_iterator<_Sent2>)) {
      return __ends_with_fn_impl_bidirectional(__first1, __last1, __first2, __last2, __pred, __proj1, __proj2);

    } else {
      auto __n1 = ranges::distance(__first1, __last1);
      auto __n2 = ranges::distance(__first2, __last2);
      if (__n2 == 0)
        return true;
      if (__n2 > __n1)
        return false;

      return __ends_with_fn_impl_with_offset(
          std::move(__first1),
          std::move(__last1),
          std::move(__first2),
          std::move(__last2),
          __pred,
          __proj1,
          __proj2,
          __n1 - __n2);
    }
  }

  template <class _Iter1,
            class _Sent1,
            class _Iter2,
            class _Sent2,
            class _Pred,
            class _Proj1,
            class _Proj2,
            class _Offset>
  static __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr bool __ends_with_fn_impl_with_offset(
      _Iter1 __first1,
      _Sent1 __last1,
      _Iter2 __first2,
      _Sent2 __last2,
      _Pred& __pred,
      _Proj1& __proj1,
      _Proj2& __proj2,
      _Offset __offset) {
    if constexpr (std::bidirectional_iterator<_Sent1> && std::bidirectional_iterator<_Sent2> &&
                  !std::random_access_iterator<_Sent1> && !std::random_access_iterator<_Sent2>) {
      return __ends_with_fn_impl_bidirectional(
          std::move(__first1), std::move(__last1), std::move(__first2), std::move(__last2), __pred, __proj1, __proj2);

    } else {
      ranges::advance(__first1, __offset);
      return ranges::equal(
          std::move(__first1),
          std::move(__last1),
          std::move(__first2),
          std::move(__last2),
          std::ref(__pred),
          std::ref(__proj1),
          std::ref(__proj2));
    }
  }

  template <input_iterator _Iter1,
            sentinel_for<_Iter1> _Sent1,
            input_iterator _Iter2,
            sentinel_for<_Iter2> _Sent2,
            class _Pred = ranges::equal_to,
            class _Proj1 = identity,
            class _Proj2 = identity>
    requires(forward_iterator<_Iter1> || sized_sentinel_for<_Sent1, _Iter1>) &&
            (forward_iterator<_Iter2> || sized_sentinel_for<_Sent2, _Iter2>) &&
            indirectly_comparable<_Iter1, _Iter2, _Pred, _Proj1, _Proj2>
  [[__nodiscard__]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr bool operator()(
      _Iter1 __first1,
      _Sent1 __last1,
      _Iter2 __first2,
      _Sent2 __last2,
      _Pred __pred = {},
      _Proj1 __proj1 = {},
      _Proj2 __proj2 = {}) const {
    return __ends_with_fn_impl(
        std::move(__first1), std::move(__last1), std::move(__first2), std::move(__last2), __pred, __proj1, __proj2);
  }

  template <input_range _Range1,
            input_range _Range2,
            class _Pred = ranges::equal_to,
            class _Proj1 = identity,
            class _Proj2 = identity>
    requires(forward_range<_Range1> || sized_range<_Range1>) && (forward_range<_Range2> || sized_range<_Range2>) &&
            indirectly_comparable<iterator_t<_Range1>, iterator_t<_Range2>, _Pred, _Proj1, _Proj2>
  [[__nodiscard__]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr bool operator()(
      _Range1&& __range1, _Range2&& __range2, _Pred __pred = {}, _Proj1 __proj1 = {}, _Proj2 __proj2 = {}) const {
    if constexpr (sized_range<_Range1> && sized_range<_Range2>) {
      auto __n1 = ranges::size(__range1);
      auto __n2 = ranges::size(__range2);
      if (__n2 == 0)
        return true;
      if (__n2 > __n1)
        return false;
      auto __offset = __n1 - __n2;

      return __ends_with_fn_impl_with_offset(
          ranges::begin(__range1),
          ranges::end(__range1),
          ranges::begin(__range2),
          ranges::end(__range2),
          __pred,
          __proj1,
          __proj2,
          __offset);

    } else {
      return __ends_with_fn_impl(
          ranges::begin(__range1),
          ranges::end(__range1),
          ranges::begin(__range2),
          ranges::end(__range2),
          __pred,
          __proj1,
          __proj2);
    }
  }
};
}

inline namespace __cpo {
inline constexpr auto ends_with = __ends_with::__fn{};
}
}

}}
# 1853 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/algorithm" 2 3

# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_equal_range.h" 1 3
# 31 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_equal_range.h" 3




namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

namespace ranges {
namespace __equal_range {

struct __fn {
  template <forward_iterator _Iter,
            sentinel_for<_Iter> _Sent,
            class _Tp,
            class _Proj = identity,
            indirect_strict_weak_order<const _Tp*, projected<_Iter, _Proj>> _Comp = ranges::less>
  [[__nodiscard__]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr subrange<_Iter>
  operator()(_Iter __first, _Sent __last, const _Tp& __value, _Comp __comp = {}, _Proj __proj = {}) const {
    auto __ret = std::__equal_range<_RangeAlgPolicy>(std::move(__first), std::move(__last), __value, __comp, __proj);
    return {std::move(__ret.first), std::move(__ret.second)};
  }

  template <forward_range _Range,
            class _Tp,
            class _Proj = identity,
            indirect_strict_weak_order<const _Tp*, projected<iterator_t<_Range>, _Proj>> _Comp = ranges::less>
  [[__nodiscard__]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr borrowed_subrange_t<_Range>
  operator()(_Range&& __range, const _Tp& __value, _Comp __comp = {}, _Proj __proj = {}) const {
    auto __ret =
        std::__equal_range<_RangeAlgPolicy>(ranges::begin(__range), ranges::end(__range), __value, __comp, __proj);
    return {std::move(__ret.first), std::move(__ret.second)};
  }
};

}

inline namespace __cpo {
inline constexpr auto equal_range = __equal_range::__fn{};
}
}

}}
# 1855 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/algorithm" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_fill.h" 1 3
# 12 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_fill.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_fill_n.h" 1 3
# 18 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_fill_n.h" 3




namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

namespace ranges {
namespace __fill_n {
struct __fn {
  template <class _Type, output_iterator<const _Type&> _Iter>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr _Iter
  operator()(_Iter __first, iter_difference_t<_Iter> __n, const _Type& __value) const {
    for (; __n != 0; --__n) {
      *__first = __value;
      ++__first;
    }
    return __first;
  }
};
}

inline namespace __cpo {
inline constexpr auto fill_n = __fill_n::__fn{};
}
}

}}
# 13 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_fill.h" 2 3
# 21 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_fill.h" 3




namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

namespace ranges {
namespace __fill {
struct __fn {
  template <class _Type, output_iterator<const _Type&> _Iter, sentinel_for<_Iter> _Sent>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr _Iter operator()(_Iter __first, _Sent __last, const _Type& __value) const {
    if constexpr (random_access_iterator<_Iter> && sized_sentinel_for<_Sent, _Iter>) {
      return ranges::fill_n(__first, __last - __first, __value);
    } else {
      for (; __first != __last; ++__first)
        *__first = __value;
      return __first;
    }
  }

  template <class _Type, output_range<const _Type&> _Range>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr borrowed_iterator_t<_Range> operator()(_Range&& __range, const _Type& __value) const {
    return (*this)(ranges::begin(__range), ranges::end(__range), __value);
  }
};
}

inline namespace __cpo {
inline constexpr auto fill = __fill::__fn{};
}
}

}}
# 1856 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/algorithm" 2 3

# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_find.h" 1 3
# 13 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_find.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_find_if.h" 1 3
# 25 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_find_if.h" 3




namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

namespace ranges {

template <class _Ip, class _Sp, class _Pred, class _Proj>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr _Ip __find_if_impl(_Ip __first, _Sp __last, _Pred& __pred, _Proj& __proj) {
  for (; __first != __last; ++__first) {
    if (std::invoke(__pred, std::invoke(__proj, *__first)))
      break;
  }
  return __first;
}

namespace __find_if {
struct __fn {
  template <input_iterator _Ip,
            sentinel_for<_Ip> _Sp,
            class _Proj = identity,
            indirect_unary_predicate<projected<_Ip, _Proj>> _Pred>
  [[__nodiscard__]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr _Ip
  operator()(_Ip __first, _Sp __last, _Pred __pred, _Proj __proj = {}) const {
    return ranges::__find_if_impl(std::move(__first), std::move(__last), __pred, __proj);
  }

  template <input_range _Rp, class _Proj = identity, indirect_unary_predicate<projected<iterator_t<_Rp>, _Proj>> _Pred>
  [[__nodiscard__]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr borrowed_iterator_t<_Rp>
  operator()(_Rp&& __r, _Pred __pred, _Proj __proj = {}) const {
    return ranges::__find_if_impl(ranges::begin(__r), ranges::end(__r), __pred, __proj);
  }
};
}

inline namespace __cpo {
inline constexpr auto find_if = __find_if::__fn{};
}
}

}}
# 14 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_find.h" 2 3
# 29 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_find.h" 3




namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

namespace ranges {
namespace __find {
struct __fn {
  template <class _Iter, class _Sent, class _Tp, class _Proj>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) static constexpr _Iter
  __find_unwrap(_Iter __first, _Sent __last, const _Tp& __value, _Proj& __proj) {
    if constexpr (forward_iterator<_Iter>) {
      auto [__first_un, __last_un] = std::__unwrap_range(__first, std::move(__last));
      return std::__rewrap_range<_Sent>(
          std::move(__first), std::__find_impl(std::move(__first_un), std::move(__last_un), __value, __proj));
    } else {
      return std::__find_impl(std::move(__first), std::move(__last), __value, __proj);
    }
  }

  template <input_iterator _Ip, sentinel_for<_Ip> _Sp, class _Tp, class _Proj = identity>
    requires indirect_binary_predicate<ranges::equal_to, projected<_Ip, _Proj>, const _Tp*>
  [[__nodiscard__]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr _Ip
  operator()(_Ip __first, _Sp __last, const _Tp& __value, _Proj __proj = {}) const {
    return __find_unwrap(std::move(__first), std::move(__last), __value, __proj);
  }

  template <input_range _Rp, class _Tp, class _Proj = identity>
    requires indirect_binary_predicate<ranges::equal_to, projected<iterator_t<_Rp>, _Proj>, const _Tp*>
  [[__nodiscard__]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr borrowed_iterator_t<_Rp>
  operator()(_Rp&& __r, const _Tp& __value, _Proj __proj = {}) const {
    return __find_unwrap(ranges::begin(__r), ranges::end(__r), __value, __proj);
  }
};
}

inline namespace __cpo {
inline constexpr auto find = __find::__fn{};
}
}

}}
# 1858 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/algorithm" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_find_end.h" 1 3
# 28 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_find_end.h" 3




namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

namespace ranges {
namespace __find_end {
struct __fn {
  template <forward_iterator _Iter1,
            sentinel_for<_Iter1> _Sent1,
            forward_iterator _Iter2,
            sentinel_for<_Iter2> _Sent2,
            class _Pred = ranges::equal_to,
            class _Proj1 = identity,
            class _Proj2 = identity>
    requires indirectly_comparable<_Iter1, _Iter2, _Pred, _Proj1, _Proj2>
  [[__nodiscard__]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr subrange<_Iter1> operator()(
      _Iter1 __first1,
      _Sent1 __last1,
      _Iter2 __first2,
      _Sent2 __last2,
      _Pred __pred = {},
      _Proj1 __proj1 = {},
      _Proj2 __proj2 = {}) const {
    auto __ret = std::__find_end_impl<_RangeAlgPolicy>(
        __first1,
        __last1,
        __first2,
        __last2,
        __pred,
        __proj1,
        __proj2,
        __iterator_concept<_Iter1>(),
        __iterator_concept<_Iter2>());
    return {__ret.first, __ret.second};
  }

  template <forward_range _Range1,
            forward_range _Range2,
            class _Pred = ranges::equal_to,
            class _Proj1 = identity,
            class _Proj2 = identity>
    requires indirectly_comparable<iterator_t<_Range1>, iterator_t<_Range2>, _Pred, _Proj1, _Proj2>
  [[__nodiscard__]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr borrowed_subrange_t<_Range1> operator()(
      _Range1&& __range1, _Range2&& __range2, _Pred __pred = {}, _Proj1 __proj1 = {}, _Proj2 __proj2 = {}) const {
    auto __ret = std::__find_end_impl<_RangeAlgPolicy>(
        ranges::begin(__range1),
        ranges::end(__range1),
        ranges::begin(__range2),
        ranges::end(__range2),
        __pred,
        __proj1,
        __proj2,
        __iterator_concept<iterator_t<_Range1>>(),
        __iterator_concept<iterator_t<_Range2>>());
    return {__ret.first, __ret.second};
  }
};
}

inline namespace __cpo {
inline constexpr auto find_end = __find_end::__fn{};
}
}

}}
# 1859 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/algorithm" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_find_first_of.h" 1 3
# 25 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_find_first_of.h" 3




namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

namespace ranges {
namespace __find_first_of {
struct __fn {
  template <class _Iter1, class _Sent1, class _Iter2, class _Sent2, class _Pred, class _Proj1, class _Proj2>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr static _Iter1 __find_first_of_impl(
      _Iter1 __first1,
      _Sent1 __last1,
      _Iter2 __first2,
      _Sent2 __last2,
      _Pred& __pred,
      _Proj1& __proj1,
      _Proj2& __proj2) {
    for (; __first1 != __last1; ++__first1) {
      for (auto __j = __first2; __j != __last2; ++__j) {
        if (std::invoke(__pred, std::invoke(__proj1, *__first1), std::invoke(__proj2, *__j)))
          return __first1;
      }
    }
    return __first1;
  }

  template <input_iterator _Iter1,
            sentinel_for<_Iter1> _Sent1,
            forward_iterator _Iter2,
            sentinel_for<_Iter2> _Sent2,
            class _Pred = ranges::equal_to,
            class _Proj1 = identity,
            class _Proj2 = identity>
    requires indirectly_comparable<_Iter1, _Iter2, _Pred, _Proj1, _Proj2>
  [[__nodiscard__]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr _Iter1 operator()(
      _Iter1 __first1,
      _Sent1 __last1,
      _Iter2 __first2,
      _Sent2 __last2,
      _Pred __pred = {},
      _Proj1 __proj1 = {},
      _Proj2 __proj2 = {}) const {
    return __find_first_of_impl(
        std::move(__first1), std::move(__last1), std::move(__first2), std::move(__last2), __pred, __proj1, __proj2);
  }

  template <input_range _Range1,
            forward_range _Range2,
            class _Pred = ranges::equal_to,
            class _Proj1 = identity,
            class _Proj2 = identity>
    requires indirectly_comparable<iterator_t<_Range1>, iterator_t<_Range2>, _Pred, _Proj1, _Proj2>
  [[__nodiscard__]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr borrowed_iterator_t<_Range1> operator()(
      _Range1&& __range1, _Range2&& __range2, _Pred __pred = {}, _Proj1 __proj1 = {}, _Proj2 __proj2 = {}) const {
    return __find_first_of_impl(
        ranges::begin(__range1),
        ranges::end(__range1),
        ranges::begin(__range2),
        ranges::end(__range2),
        __pred,
        __proj1,
        __proj2);
  }
};
}

inline namespace __cpo {
inline constexpr auto find_first_of = __find_first_of::__fn{};
}
}

}}
# 1860 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/algorithm" 2 3

# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_find_if_not.h" 1 3
# 27 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_find_if_not.h" 3




namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

namespace ranges {
namespace __find_if_not {
struct __fn {
  template <input_iterator _Ip,
            sentinel_for<_Ip> _Sp,
            class _Proj = identity,
            indirect_unary_predicate<projected<_Ip, _Proj>> _Pred>
  [[__nodiscard__]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr _Ip
  operator()(_Ip __first, _Sp __last, _Pred __pred, _Proj __proj = {}) const {
    auto __pred2 = [&](auto&& __e) { return !std::invoke(__pred, std::forward<decltype(__e)>(__e)); };
    return ranges::__find_if_impl(std::move(__first), std::move(__last), __pred2, __proj);
  }

  template <input_range _Rp, class _Proj = identity, indirect_unary_predicate<projected<iterator_t<_Rp>, _Proj>> _Pred>
  [[__nodiscard__]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr borrowed_iterator_t<_Rp>
  operator()(_Rp&& __r, _Pred __pred, _Proj __proj = {}) const {
    auto __pred2 = [&](auto&& __e) { return !std::invoke(__pred, std::forward<decltype(__e)>(__e)); };
    return ranges::__find_if_impl(ranges::begin(__r), ranges::end(__r), __pred2, __proj);
  }
};
}

inline namespace __cpo {
inline constexpr auto find_if_not = __find_if_not::__fn{};
}
}

}}
# 1862 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/algorithm" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_for_each.h" 1 3
# 25 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_for_each.h" 3




namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

namespace ranges {

template <class _Iter, class _Func>
using for_each_result = in_fun_result<_Iter, _Func>;

namespace __for_each {
struct __fn {
private:
  template <class _Iter, class _Sent, class _Proj, class _Func>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr static for_each_result<_Iter, _Func>
  __for_each_impl(_Iter __first, _Sent __last, _Func& __func, _Proj& __proj) {
    for (; __first != __last; ++__first)
      std::invoke(__func, std::invoke(__proj, *__first));
    return {std::move(__first), std::move(__func)};
  }

public:
  template <input_iterator _Iter,
            sentinel_for<_Iter> _Sent,
            class _Proj = identity,
            indirectly_unary_invocable<projected<_Iter, _Proj>> _Func>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr for_each_result<_Iter, _Func>
  operator()(_Iter __first, _Sent __last, _Func __func, _Proj __proj = {}) const {
    return __for_each_impl(std::move(__first), std::move(__last), __func, __proj);
  }

  template <input_range _Range,
            class _Proj = identity,
            indirectly_unary_invocable<projected<iterator_t<_Range>, _Proj>> _Func>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr for_each_result<borrowed_iterator_t<_Range>, _Func>
  operator()(_Range&& __range, _Func __func, _Proj __proj = {}) const {
    return __for_each_impl(ranges::begin(__range), ranges::end(__range), __func, __proj);
  }
};
}

inline namespace __cpo {
inline constexpr auto for_each = __for_each::__fn{};
}
}

}}
# 1863 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/algorithm" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_for_each_n.h" 1 3
# 25 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_for_each_n.h" 3




namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

namespace ranges {

template <class _Iter, class _Func>
using for_each_n_result = in_fun_result<_Iter, _Func>;

namespace __for_each_n {
struct __fn {
  template <input_iterator _Iter, class _Proj = identity, indirectly_unary_invocable<projected<_Iter, _Proj>> _Func>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr for_each_n_result<_Iter, _Func>
  operator()(_Iter __first, iter_difference_t<_Iter> __count, _Func __func, _Proj __proj = {}) const {
    while (__count-- > 0) {
      std::invoke(__func, std::invoke(__proj, *__first));
      ++__first;
    }
    return {std::move(__first), std::move(__func)};
  }
};
}

inline namespace __cpo {
inline constexpr auto for_each_n = __for_each_n::__fn{};
}
}

}}
# 1864 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/algorithm" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_generate.h" 1 3
# 25 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_generate.h" 3




namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

namespace ranges {
namespace __generate {

struct __fn {
  template <class _OutIter, class _Sent, class _Func>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr static _OutIter __generate_fn_impl(_OutIter __first, _Sent __last, _Func& __gen) {
    for (; __first != __last; ++__first) {
      *__first = __gen();
    }

    return __first;
  }

  template <input_or_output_iterator _OutIter, sentinel_for<_OutIter> _Sent, copy_constructible _Func>
    requires invocable<_Func&> && indirectly_writable<_OutIter, invoke_result_t<_Func&>>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr _OutIter operator()(_OutIter __first, _Sent __last, _Func __gen) const {
    return __generate_fn_impl(std::move(__first), std::move(__last), __gen);
  }

  template <class _Range, copy_constructible _Func>
    requires invocable<_Func&> && output_range<_Range, invoke_result_t<_Func&>>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr borrowed_iterator_t<_Range> operator()(_Range&& __range, _Func __gen) const {
    return __generate_fn_impl(ranges::begin(__range), ranges::end(__range), __gen);
  }
};

}

inline namespace __cpo {
inline constexpr auto generate = __generate::__fn{};
}
}

}}
# 1865 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/algorithm" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_generate_n.h" 1 3
# 26 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_generate_n.h" 3




namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

namespace ranges {
namespace __generate_n {

struct __fn {
  template <input_or_output_iterator _OutIter, copy_constructible _Func>
    requires invocable<_Func&> && indirectly_writable<_OutIter, invoke_result_t<_Func&>>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr _OutIter
  operator()(_OutIter __first, iter_difference_t<_OutIter> __n, _Func __gen) const {
    for (; __n > 0; --__n) {
      *__first = __gen();
      ++__first;
    }

    return __first;
  }
};

}

inline namespace __cpo {
inline constexpr auto generate_n = __generate_n::__fn{};
}
}

}}
# 1866 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/algorithm" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_includes.h" 1 3
# 28 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_includes.h" 3




namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

namespace ranges {
namespace __includes {

struct __fn {
  template <input_iterator _Iter1,
            sentinel_for<_Iter1> _Sent1,
            input_iterator _Iter2,
            sentinel_for<_Iter2> _Sent2,
            class _Proj1 = identity,
            class _Proj2 = identity,
            indirect_strict_weak_order<projected<_Iter1, _Proj1>, projected<_Iter2, _Proj2>> _Comp = ranges::less>
  [[__nodiscard__]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr bool operator()(
      _Iter1 __first1,
      _Sent1 __last1,
      _Iter2 __first2,
      _Sent2 __last2,
      _Comp __comp = {},
      _Proj1 __proj1 = {},
      _Proj2 __proj2 = {}) const {
    return std::__includes(
        std::move(__first1),
        std::move(__last1),
        std::move(__first2),
        std::move(__last2),
        std::move(__comp),
        std::move(__proj1),
        std::move(__proj2));
  }

  template <input_range _Range1,
            input_range _Range2,
            class _Proj1 = identity,
            class _Proj2 = identity,
            indirect_strict_weak_order<projected<iterator_t<_Range1>, _Proj1>, projected<iterator_t<_Range2>, _Proj2>>
                _Comp = ranges::less>
  [[__nodiscard__]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr bool operator()(
      _Range1&& __range1, _Range2&& __range2, _Comp __comp = {}, _Proj1 __proj1 = {}, _Proj2 __proj2 = {}) const {
    return std::__includes(
        ranges::begin(__range1),
        ranges::end(__range1),
        ranges::begin(__range2),
        ranges::end(__range2),
        std::move(__comp),
        std::move(__proj1),
        std::move(__proj2));
  }
};

}

inline namespace __cpo {
inline constexpr auto includes = __includes::__fn{};
}
}

}}
# 1867 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/algorithm" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_inplace_merge.h" 1 3
# 23 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_inplace_merge.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__iterator/sortable.h" 1 3
# 17 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__iterator/sortable.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__iterator/permutable.h" 1 3
# 19 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__iterator/permutable.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {



template <class _Iterator>
concept permutable =
    forward_iterator<_Iterator> &&
    indirectly_movable_storable<_Iterator, _Iterator> &&
    indirectly_swappable<_Iterator, _Iterator>;



}}
# 18 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__iterator/sortable.h" 2 3
# 22 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__iterator/sortable.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {



template <class _Iter, class _Comp = ranges::less, class _Proj = identity>
concept sortable =
  permutable<_Iter> &&
  indirect_strict_weak_order<_Comp, projected<_Iter, _Proj>>;



}}
# 24 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_inplace_merge.h" 2 3
# 32 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_inplace_merge.h" 3




namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

namespace ranges {
namespace __inplace_merge {

struct __fn {
  template <class _Iter, class _Sent, class _Comp, class _Proj>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) static constexpr auto
  __inplace_merge_impl(_Iter __first, _Iter __middle, _Sent __last, _Comp&& __comp, _Proj&& __proj) {
    auto __last_iter = ranges::next(__middle, __last);
    std::__inplace_merge<_RangeAlgPolicy>(
        std::move(__first), std::move(__middle), __last_iter, std::__make_projected(__comp, __proj));
    return __last_iter;
  }

  template <bidirectional_iterator _Iter, sentinel_for<_Iter> _Sent, class _Comp = ranges::less, class _Proj = identity>
    requires sortable<_Iter, _Comp, _Proj>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) _Iter
  operator()(_Iter __first, _Iter __middle, _Sent __last, _Comp __comp = {}, _Proj __proj = {}) const {
    return __inplace_merge_impl(
        std::move(__first), std::move(__middle), std::move(__last), std::move(__comp), std::move(__proj));
  }

  template <bidirectional_range _Range, class _Comp = ranges::less, class _Proj = identity>
    requires sortable<iterator_t<_Range>, _Comp, _Proj>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) borrowed_iterator_t<_Range>
  operator()(_Range&& __range, iterator_t<_Range> __middle, _Comp __comp = {}, _Proj __proj = {}) const {
    return __inplace_merge_impl(
        ranges::begin(__range), std::move(__middle), ranges::end(__range), std::move(__comp), std::move(__proj));
  }
};

}

inline namespace __cpo {
inline constexpr auto inplace_merge = __inplace_merge::__fn{};
}
}

}}
# 1868 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/algorithm" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_is_heap.h" 1 3
# 27 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_is_heap.h" 3




namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

namespace ranges {
namespace __is_heap {

struct __fn {
  template <class _Iter, class _Sent, class _Proj, class _Comp>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr static bool
  __is_heap_fn_impl(_Iter __first, _Sent __last, _Comp& __comp, _Proj& __proj) {
    auto __last_iter = ranges::next(__first, __last);
    auto&& __projected_comp = std::__make_projected(__comp, __proj);

    auto __result = std::__is_heap_until(std::move(__first), std::move(__last_iter), __projected_comp);
    return __result == __last;
  }

  template <random_access_iterator _Iter,
            sentinel_for<_Iter> _Sent,
            class _Proj = identity,
            indirect_strict_weak_order<projected<_Iter, _Proj>> _Comp = ranges::less>
  [[__nodiscard__]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr bool
  operator()(_Iter __first, _Sent __last, _Comp __comp = {}, _Proj __proj = {}) const {
    return __is_heap_fn_impl(std::move(__first), std::move(__last), __comp, __proj);
  }

  template <random_access_range _Range,
            class _Proj = identity,
            indirect_strict_weak_order<projected<iterator_t<_Range>, _Proj>> _Comp = ranges::less>
  [[__nodiscard__]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr bool
  operator()(_Range&& __range, _Comp __comp = {}, _Proj __proj = {}) const {
    return __is_heap_fn_impl(ranges::begin(__range), ranges::end(__range), __comp, __proj);
  }
};

}

inline namespace __cpo {
inline constexpr auto is_heap = __is_heap::__fn{};
}
}

}}
# 1869 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/algorithm" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_is_heap_until.h" 1 3
# 28 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_is_heap_until.h" 3




namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

namespace ranges {
namespace __is_heap_until {

struct __fn {
  template <class _Iter, class _Sent, class _Proj, class _Comp>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr static _Iter
  __is_heap_until_fn_impl(_Iter __first, _Sent __last, _Comp& __comp, _Proj& __proj) {
    auto __last_iter = ranges::next(__first, __last);
    auto&& __projected_comp = std::__make_projected(__comp, __proj);

    return std::__is_heap_until(std::move(__first), std::move(__last_iter), __projected_comp);
  }

  template <random_access_iterator _Iter,
            sentinel_for<_Iter> _Sent,
            class _Proj = identity,
            indirect_strict_weak_order<projected<_Iter, _Proj>> _Comp = ranges::less>
  [[__nodiscard__]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr _Iter
  operator()(_Iter __first, _Sent __last, _Comp __comp = {}, _Proj __proj = {}) const {
    return __is_heap_until_fn_impl(std::move(__first), std::move(__last), __comp, __proj);
  }

  template <random_access_range _Range,
            class _Proj = identity,
            indirect_strict_weak_order<projected<iterator_t<_Range>, _Proj>> _Comp = ranges::less>
  [[__nodiscard__]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr borrowed_iterator_t<_Range>
  operator()(_Range&& __range, _Comp __comp = {}, _Proj __proj = {}) const {
    return __is_heap_until_fn_impl(ranges::begin(__range), ranges::end(__range), __comp, __proj);
  }
};

}

inline namespace __cpo {
inline constexpr auto is_heap_until = __is_heap_until::__fn{};
}
}

}}
# 1870 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/algorithm" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_is_partitioned.h" 1 3
# 24 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_is_partitioned.h" 3




namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

namespace ranges {
namespace __is_partitioned {
struct __fn {
  template <class _Iter, class _Sent, class _Proj, class _Pred>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr static bool
  __is_partitioned_impl(_Iter __first, _Sent __last, _Pred& __pred, _Proj& __proj) {
    for (; __first != __last; ++__first) {
      if (!std::invoke(__pred, std::invoke(__proj, *__first)))
        break;
    }

    if (__first == __last)
      return true;
    ++__first;

    for (; __first != __last; ++__first) {
      if (std::invoke(__pred, std::invoke(__proj, *__first)))
        return false;
    }

    return true;
  }

  template <input_iterator _Iter,
            sentinel_for<_Iter> _Sent,
            class _Proj = identity,
            indirect_unary_predicate<projected<_Iter, _Proj>> _Pred>
  [[__nodiscard__]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr bool
  operator()(_Iter __first, _Sent __last, _Pred __pred, _Proj __proj = {}) const {
    return __is_partitioned_impl(std::move(__first), std::move(__last), __pred, __proj);
  }

  template <input_range _Range,
            class _Proj = identity,
            indirect_unary_predicate<projected<iterator_t<_Range>, _Proj>> _Pred>
  [[__nodiscard__]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr bool
  operator()(_Range&& __range, _Pred __pred, _Proj __proj = {}) const {
    return __is_partitioned_impl(ranges::begin(__range), ranges::end(__range), __pred, __proj);
  }
};
}

inline namespace __cpo {
inline constexpr auto is_partitioned = __is_partitioned::__fn{};
}
}

}}
# 1871 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/algorithm" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_is_permutation.h" 1 3
# 26 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_is_permutation.h" 3




namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

namespace ranges {
namespace __is_permutation {
struct __fn {
  template <class _Iter1, class _Sent1, class _Iter2, class _Sent2, class _Proj1, class _Proj2, class _Pred>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr static bool __is_permutation_func_impl(
      _Iter1 __first1,
      _Sent1 __last1,
      _Iter2 __first2,
      _Sent2 __last2,
      _Pred& __pred,
      _Proj1& __proj1,
      _Proj2& __proj2) {
    return std::__is_permutation<_RangeAlgPolicy>(
        std::move(__first1), std::move(__last1), std::move(__first2), std::move(__last2), __pred, __proj1, __proj2);
  }

  template <
      forward_iterator _Iter1,
      sentinel_for<_Iter1> _Sent1,
      forward_iterator _Iter2,
      sentinel_for<_Iter2> _Sent2,
      class _Proj1 = identity,
      class _Proj2 = identity,
      indirect_equivalence_relation<projected<_Iter1, _Proj1>, projected<_Iter2, _Proj2>> _Pred = ranges::equal_to>
  [[__nodiscard__]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr bool operator()(
      _Iter1 __first1,
      _Sent1 __last1,
      _Iter2 __first2,
      _Sent2 __last2,
      _Pred __pred = {},
      _Proj1 __proj1 = {},
      _Proj2 __proj2 = {}) const {
    return __is_permutation_func_impl(
        std::move(__first1), std::move(__last1), std::move(__first2), std::move(__last2), __pred, __proj1, __proj2);
  }

  template <forward_range _Range1,
            forward_range _Range2,
            class _Proj1 = identity,
            class _Proj2 = identity,
            indirect_equivalence_relation<projected<iterator_t<_Range1>, _Proj1>,
                                          projected<iterator_t<_Range2>, _Proj2>> _Pred = ranges::equal_to>
  [[__nodiscard__]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr bool operator()(
      _Range1&& __range1, _Range2&& __range2, _Pred __pred = {}, _Proj1 __proj1 = {}, _Proj2 __proj2 = {}) const {
    if constexpr (sized_range<_Range1> && sized_range<_Range2>) {
      if (ranges::distance(__range1) != ranges::distance(__range2))
        return false;
    }

    return __is_permutation_func_impl(
        ranges::begin(__range1),
        ranges::end(__range1),
        ranges::begin(__range2),
        ranges::end(__range2),
        __pred,
        __proj1,
        __proj2);
  }
};
}

inline namespace __cpo {
inline constexpr auto is_permutation = __is_permutation::__fn{};
}
}

}}
# 1872 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/algorithm" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_is_sorted.h" 1 3
# 12 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_is_sorted.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_is_sorted_until.h" 1 3
# 25 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_is_sorted_until.h" 3




namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

namespace ranges {

template <class _Iter, class _Sent, class _Proj, class _Comp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr _Iter
__is_sorted_until_impl(_Iter __first, _Sent __last, _Comp& __comp, _Proj& __proj) {
  if (__first == __last)
    return __first;
  auto __i = __first;
  while (++__i != __last) {
    if (std::invoke(__comp, std::invoke(__proj, *__i), std::invoke(__proj, *__first)))
      return __i;
    __first = __i;
  }
  return __i;
}

namespace __is_sorted_until {
struct __fn {
  template <forward_iterator _Iter,
            sentinel_for<_Iter> _Sent,
            class _Proj = identity,
            indirect_strict_weak_order<projected<_Iter, _Proj>> _Comp = ranges::less>
  [[__nodiscard__]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr _Iter
  operator()(_Iter __first, _Sent __last, _Comp __comp = {}, _Proj __proj = {}) const {
    return ranges::__is_sorted_until_impl(std::move(__first), std::move(__last), __comp, __proj);
  }

  template <forward_range _Range,
            class _Proj = identity,
            indirect_strict_weak_order<projected<iterator_t<_Range>, _Proj>> _Comp = ranges::less>
  [[__nodiscard__]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr borrowed_iterator_t<_Range>
  operator()(_Range&& __range, _Comp __comp = {}, _Proj __proj = {}) const {
    return ranges::__is_sorted_until_impl(ranges::begin(__range), ranges::end(__range), __comp, __proj);
  }
};
}

inline namespace __cpo {
inline constexpr auto is_sorted_until = __is_sorted_until::__fn{};
}
}

}}
# 13 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_is_sorted.h" 2 3
# 24 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_is_sorted.h" 3




namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

namespace ranges {
namespace __is_sorted {
struct __fn {
  template <forward_iterator _Iter,
            sentinel_for<_Iter> _Sent,
            class _Proj = identity,
            indirect_strict_weak_order<projected<_Iter, _Proj>> _Comp = ranges::less>
  [[__nodiscard__]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr bool
  operator()(_Iter __first, _Sent __last, _Comp __comp = {}, _Proj __proj = {}) const {
    return ranges::__is_sorted_until_impl(std::move(__first), __last, __comp, __proj) == __last;
  }

  template <forward_range _Range,
            class _Proj = identity,
            indirect_strict_weak_order<projected<iterator_t<_Range>, _Proj>> _Comp = ranges::less>
  [[__nodiscard__]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr bool
  operator()(_Range&& __range, _Comp __comp = {}, _Proj __proj = {}) const {
    auto __last = ranges::end(__range);
    return ranges::__is_sorted_until_impl(ranges::begin(__range), __last, __comp, __proj) == __last;
  }
};
}

inline namespace __cpo {
inline constexpr auto is_sorted = __is_sorted::__fn{};
}
}

}}
# 1873 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/algorithm" 2 3

# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_lexicographical_compare.h" 1 3
# 24 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_lexicographical_compare.h" 3




namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

namespace ranges {
namespace __lexicographical_compare {
struct __fn {
  template <class _Iter1, class _Sent1, class _Iter2, class _Sent2, class _Proj1, class _Proj2, class _Comp>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr static bool __lexicographical_compare_impl(
      _Iter1 __first1,
      _Sent1 __last1,
      _Iter2 __first2,
      _Sent2 __last2,
      _Comp& __comp,
      _Proj1& __proj1,
      _Proj2& __proj2) {
    while (__first2 != __last2) {
      if (__first1 == __last1 || std::invoke(__comp, std::invoke(__proj1, *__first1), std::invoke(__proj2, *__first2)))
        return true;
      if (std::invoke(__comp, std::invoke(__proj2, *__first2), std::invoke(__proj1, *__first1)))
        return false;
      ++__first1;
      ++__first2;
    }
    return false;
  }

  template <input_iterator _Iter1,
            sentinel_for<_Iter1> _Sent1,
            input_iterator _Iter2,
            sentinel_for<_Iter2> _Sent2,
            class _Proj1 = identity,
            class _Proj2 = identity,
            indirect_strict_weak_order<projected<_Iter1, _Proj1>, projected<_Iter2, _Proj2>> _Comp = ranges::less>
  [[__nodiscard__]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr bool operator()(
      _Iter1 __first1,
      _Sent1 __last1,
      _Iter2 __first2,
      _Sent2 __last2,
      _Comp __comp = {},
      _Proj1 __proj1 = {},
      _Proj2 __proj2 = {}) const {
    return __lexicographical_compare_impl(
        std::move(__first1), std::move(__last1), std::move(__first2), std::move(__last2), __comp, __proj1, __proj2);
  }

  template <input_range _Range1,
            input_range _Range2,
            class _Proj1 = identity,
            class _Proj2 = identity,
            indirect_strict_weak_order<projected<iterator_t<_Range1>, _Proj1>, projected<iterator_t<_Range2>, _Proj2>>
                _Comp = ranges::less>
  [[__nodiscard__]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr bool operator()(
      _Range1&& __range1, _Range2&& __range2, _Comp __comp = {}, _Proj1 __proj1 = {}, _Proj2 __proj2 = {}) const {
    return __lexicographical_compare_impl(
        ranges::begin(__range1),
        ranges::end(__range1),
        ranges::begin(__range2),
        ranges::end(__range2),
        __comp,
        __proj1,
        __proj2);
  }
};
}

inline namespace __cpo {
inline constexpr auto lexicographical_compare = __lexicographical_compare::__fn{};
}
}

}}
# 1875 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/algorithm" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_lower_bound.h" 1 3
# 28 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_lower_bound.h" 3




namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

namespace ranges {

namespace __lower_bound {
struct __fn {
  template <forward_iterator _Iter,
            sentinel_for<_Iter> _Sent,
            class _Type,
            class _Proj = identity,
            indirect_strict_weak_order<const _Type*, projected<_Iter, _Proj>> _Comp = ranges::less>
  [[__nodiscard__]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr _Iter
  operator()(_Iter __first, _Sent __last, const _Type& __value, _Comp __comp = {}, _Proj __proj = {}) const {
    return std::__lower_bound<_RangeAlgPolicy>(__first, __last, __value, __comp, __proj);
  }

  template <forward_range _Range,
            class _Type,
            class _Proj = identity,
            indirect_strict_weak_order<const _Type*, projected<iterator_t<_Range>, _Proj>> _Comp = ranges::less>
  [[__nodiscard__]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr borrowed_iterator_t<_Range>
  operator()(_Range&& __r, const _Type& __value, _Comp __comp = {}, _Proj __proj = {}) const {
    return std::__lower_bound<_RangeAlgPolicy>(ranges::begin(__r), ranges::end(__r), __value, __comp, __proj);
  }
};
}

inline namespace __cpo {
inline constexpr auto lower_bound = __lower_bound::__fn{};
}
}

}}
# 1876 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/algorithm" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_make_heap.h" 1 3
# 33 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_make_heap.h" 3




namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

namespace ranges {
namespace __make_heap {

struct __fn {
  template <class _Iter, class _Sent, class _Comp, class _Proj>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr static _Iter
  __make_heap_fn_impl(_Iter __first, _Sent __last, _Comp& __comp, _Proj& __proj) {
    auto __last_iter = ranges::next(__first, __last);

    auto&& __projected_comp = std::__make_projected(__comp, __proj);
    std::__make_heap<_RangeAlgPolicy>(std::move(__first), __last_iter, __projected_comp);

    return __last_iter;
  }

  template <random_access_iterator _Iter, sentinel_for<_Iter> _Sent, class _Comp = ranges::less, class _Proj = identity>
    requires sortable<_Iter, _Comp, _Proj>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr _Iter
  operator()(_Iter __first, _Sent __last, _Comp __comp = {}, _Proj __proj = {}) const {
    return __make_heap_fn_impl(std::move(__first), std::move(__last), __comp, __proj);
  }

  template <random_access_range _Range, class _Comp = ranges::less, class _Proj = identity>
    requires sortable<iterator_t<_Range>, _Comp, _Proj>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr borrowed_iterator_t<_Range>
  operator()(_Range&& __r, _Comp __comp = {}, _Proj __proj = {}) const {
    return __make_heap_fn_impl(ranges::begin(__r), ranges::end(__r), __comp, __proj);
  }
};

}

inline namespace __cpo {
inline constexpr auto make_heap = __make_heap::__fn{};
}
}

}}
# 1877 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/algorithm" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_max.h" 1 3
# 12 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_max.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_min_element.h" 1 3
# 25 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_min_element.h" 3




namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

namespace ranges {


template <class _Ip, class _Sp, class _Proj, class _Comp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr _Ip __min_element_impl(_Ip __first, _Sp __last, _Comp& __comp, _Proj& __proj) {
  if (__first == __last)
    return __first;

  _Ip __i = __first;
  while (++__i != __last)
    if (std::invoke(__comp, std::invoke(__proj, *__i), std::invoke(__proj, *__first)))
      __first = __i;
  return __first;
}

namespace __min_element {
struct __fn {
  template <forward_iterator _Ip,
            sentinel_for<_Ip> _Sp,
            class _Proj = identity,
            indirect_strict_weak_order<projected<_Ip, _Proj>> _Comp = ranges::less>
  [[__nodiscard__]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr _Ip
  operator()(_Ip __first, _Sp __last, _Comp __comp = {}, _Proj __proj = {}) const {
    return ranges::__min_element_impl(__first, __last, __comp, __proj);
  }

  template <forward_range _Rp,
            class _Proj = identity,
            indirect_strict_weak_order<projected<iterator_t<_Rp>, _Proj>> _Comp = ranges::less>
  [[__nodiscard__]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr borrowed_iterator_t<_Rp>
  operator()(_Rp&& __r, _Comp __comp = {}, _Proj __proj = {}) const {
    return ranges::__min_element_impl(ranges::begin(__r), ranges::end(__r), __comp, __proj);
  }
};
}

inline namespace __cpo {
inline constexpr auto min_element = __min_element::__fn{};
}
}

}}
# 13 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_max.h" 2 3
# 29 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_max.h" 3





# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__undef_macros" 1 3
# 35 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_max.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

namespace ranges {
namespace __max {
struct __fn {
  template <class _Tp,
            class _Proj = identity,
            indirect_strict_weak_order<projected<const _Tp*, _Proj>> _Comp = ranges::less>
  [[__nodiscard__]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr const _Tp&
  operator()([[_Clang::__lifetimebound__]] const _Tp& __a,
             [[_Clang::__lifetimebound__]] const _Tp& __b,
             _Comp __comp = {},
             _Proj __proj = {}) const {
    return std::invoke(__comp, std::invoke(__proj, __a), std::invoke(__proj, __b)) ? __b : __a;
  }

  template <copyable _Tp,
            class _Proj = identity,
            indirect_strict_weak_order<projected<const _Tp*, _Proj>> _Comp = ranges::less>
  [[__nodiscard__]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr _Tp
  operator()(initializer_list<_Tp> __il, _Comp __comp = {}, _Proj __proj = {}) const {
    ((void)0);

    auto __comp_lhs_rhs_swapped = [&](auto&& __lhs, auto&& __rhs) { return std::invoke(__comp, __rhs, __lhs); };
    return *ranges::__min_element_impl(__il.begin(), __il.end(), __comp_lhs_rhs_swapped, __proj);
  }

  template <input_range _Rp,
            class _Proj = identity,
            indirect_strict_weak_order<projected<iterator_t<_Rp>, _Proj>> _Comp = ranges::less>
    requires indirectly_copyable_storable<iterator_t<_Rp>, range_value_t<_Rp>*>
  [[__nodiscard__]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr range_value_t<_Rp>
  operator()(_Rp&& __r, _Comp __comp = {}, _Proj __proj = {}) const {
    auto __first = ranges::begin(__r);
    auto __last = ranges::end(__r);

    ((void)0);

    if constexpr (forward_range<_Rp> && !__is_cheap_to_copy<range_value_t<_Rp>>) {
      auto __comp_lhs_rhs_swapped = [&](auto&& __lhs, auto&& __rhs) { return std::invoke(__comp, __rhs, __lhs); };
      return *ranges::__min_element_impl(std::move(__first), std::move(__last), __comp_lhs_rhs_swapped, __proj);
    } else {
      range_value_t<_Rp> __result = *__first;
      while (++__first != __last) {
        if (std::invoke(__comp, std::invoke(__proj, __result), std::invoke(__proj, *__first)))
          __result = *__first;
      }
      return __result;
    }
  }
};
}

inline namespace __cpo {
inline constexpr auto max = __max::__fn{};
}
}

}}
# 1878 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/algorithm" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_max_element.h" 1 3
# 25 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_max_element.h" 3




namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

namespace ranges {
namespace __max_element {
struct __fn {
  template <forward_iterator _Ip,
            sentinel_for<_Ip> _Sp,
            class _Proj = identity,
            indirect_strict_weak_order<projected<_Ip, _Proj>> _Comp = ranges::less>
  [[__nodiscard__]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr _Ip
  operator()(_Ip __first, _Sp __last, _Comp __comp = {}, _Proj __proj = {}) const {
    auto __comp_lhs_rhs_swapped = [&](auto&& __lhs, auto&& __rhs) { return std::invoke(__comp, __rhs, __lhs); };
    return ranges::__min_element_impl(__first, __last, __comp_lhs_rhs_swapped, __proj);
  }

  template <forward_range _Rp,
            class _Proj = identity,
            indirect_strict_weak_order<projected<iterator_t<_Rp>, _Proj>> _Comp = ranges::less>
  [[__nodiscard__]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr borrowed_iterator_t<_Rp>
  operator()(_Rp&& __r, _Comp __comp = {}, _Proj __proj = {}) const {
    auto __comp_lhs_rhs_swapped = [&](auto&& __lhs, auto&& __rhs) { return std::invoke(__comp, __rhs, __lhs); };
    return ranges::__min_element_impl(ranges::begin(__r), ranges::end(__r), __comp_lhs_rhs_swapped, __proj);
  }
};
}

inline namespace __cpo {
inline constexpr auto max_element = __max_element::__fn{};
}
}

}}
# 1879 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/algorithm" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_merge.h" 1 3
# 19 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_merge.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__iterator/mergeable.h" 1 3
# 21 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__iterator/mergeable.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {



template <class _Input1, class _Input2, class _Output,
          class _Comp = ranges::less, class _Proj1 = identity, class _Proj2 = identity>
concept mergeable =
    input_iterator<_Input1> &&
    input_iterator<_Input2> &&
    weakly_incrementable<_Output> &&
    indirectly_copyable<_Input1, _Output> &&
    indirectly_copyable<_Input2, _Output> &&
    indirect_strict_weak_order<_Comp, projected<_Input1, _Proj1>, projected<_Input2, _Proj2>>;



}}
# 20 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_merge.h" 2 3
# 28 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_merge.h" 3




namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

namespace ranges {

template <class _InIter1, class _InIter2, class _OutIter>
using merge_result = in_in_out_result<_InIter1, _InIter2, _OutIter>;

namespace __merge {

template < class _InIter1,
           class _Sent1,
           class _InIter2,
           class _Sent2,
           class _OutIter,
           class _Comp,
           class _Proj1,
           class _Proj2>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr merge_result<__remove_cvref_t<_InIter1>,
                                             __remove_cvref_t<_InIter2>,
                                             __remove_cvref_t<_OutIter>>
__merge_impl(_InIter1&& __first1,
             _Sent1&& __last1,
             _InIter2&& __first2,
             _Sent2&& __last2,
             _OutIter&& __result,
             _Comp&& __comp,
             _Proj1&& __proj1,
             _Proj2&& __proj2) {
  for (; __first1 != __last1 && __first2 != __last2; ++__result) {
    if (std::invoke(__comp, std::invoke(__proj2, *__first2), std::invoke(__proj1, *__first1))) {
      *__result = *__first2;
      ++__first2;
    } else {
      *__result = *__first1;
      ++__first1;
    }
  }
  auto __ret1 = ranges::copy(std::move(__first1), std::move(__last1), std::move(__result));
  auto __ret2 = ranges::copy(std::move(__first2), std::move(__last2), std::move(__ret1.out));
  return {std::move(__ret1.in), std::move(__ret2.in), std::move(__ret2.out)};
}

struct __fn {
  template <input_iterator _InIter1,
            sentinel_for<_InIter1> _Sent1,
            input_iterator _InIter2,
            sentinel_for<_InIter2> _Sent2,
            weakly_incrementable _OutIter,
            class _Comp = less,
            class _Proj1 = identity,
            class _Proj2 = identity>
    requires mergeable<_InIter1, _InIter2, _OutIter, _Comp, _Proj1, _Proj2>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr merge_result<_InIter1, _InIter2, _OutIter> operator()(
      _InIter1 __first1,
      _Sent1 __last1,
      _InIter2 __first2,
      _Sent2 __last2,
      _OutIter __result,
      _Comp __comp = {},
      _Proj1 __proj1 = {},
      _Proj2 __proj2 = {}) const {
    return __merge::__merge_impl(__first1, __last1, __first2, __last2, __result, __comp, __proj1, __proj2);
  }

  template <input_range _Range1,
            input_range _Range2,
            weakly_incrementable _OutIter,
            class _Comp = less,
            class _Proj1 = identity,
            class _Proj2 = identity>
    requires mergeable<iterator_t<_Range1>, iterator_t<_Range2>, _OutIter, _Comp, _Proj1, _Proj2>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr merge_result<borrowed_iterator_t<_Range1>, borrowed_iterator_t<_Range2>, _OutIter>
  operator()(_Range1&& __range1,
             _Range2&& __range2,
             _OutIter __result,
             _Comp __comp = {},
             _Proj1 __proj1 = {},
             _Proj2 __proj2 = {}) const {
    return __merge::__merge_impl(
        ranges::begin(__range1),
        ranges::end(__range1),
        ranges::begin(__range2),
        ranges::end(__range2),
        __result,
        __comp,
        __proj1,
        __proj2);
  }
};

}

inline namespace __cpo {
inline constexpr auto merge = __merge::__fn{};
}
}

}}
# 1880 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/algorithm" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_min.h" 1 3
# 28 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_min.h" 3





# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__undef_macros" 1 3
# 34 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_min.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

namespace ranges {
namespace __min {
struct __fn {
  template <class _Tp,
            class _Proj = identity,
            indirect_strict_weak_order<projected<const _Tp*, _Proj>> _Comp = ranges::less>
  [[__nodiscard__]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr const _Tp&
  operator()([[_Clang::__lifetimebound__]] const _Tp& __a,
             [[_Clang::__lifetimebound__]] const _Tp& __b,
             _Comp __comp = {},
             _Proj __proj = {}) const {
    return std::invoke(__comp, std::invoke(__proj, __b), std::invoke(__proj, __a)) ? __b : __a;
  }

  template <copyable _Tp,
            class _Proj = identity,
            indirect_strict_weak_order<projected<const _Tp*, _Proj>> _Comp = ranges::less>
  [[__nodiscard__]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr _Tp
  operator()(initializer_list<_Tp> __il, _Comp __comp = {}, _Proj __proj = {}) const {
    ((void)0);
    return *ranges::__min_element_impl(__il.begin(), __il.end(), __comp, __proj);
  }

  template <input_range _Rp,
            class _Proj = identity,
            indirect_strict_weak_order<projected<iterator_t<_Rp>, _Proj>> _Comp = ranges::less>
    requires indirectly_copyable_storable<iterator_t<_Rp>, range_value_t<_Rp>*>
  [[__nodiscard__]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr range_value_t<_Rp>
  operator()(_Rp&& __r, _Comp __comp = {}, _Proj __proj = {}) const {
    auto __first = ranges::begin(__r);
    auto __last = ranges::end(__r);
    ((void)0);
    if constexpr (forward_range<_Rp> && !__is_cheap_to_copy<range_value_t<_Rp>>) {
      return *ranges::__min_element_impl(__first, __last, __comp, __proj);
    } else {
      range_value_t<_Rp> __result = *__first;
      while (++__first != __last) {
        if (std::invoke(__comp, std::invoke(__proj, *__first), std::invoke(__proj, __result)))
          __result = *__first;
      }
      return __result;
    }
  }
};
}

inline namespace __cpo {
inline constexpr auto min = __min::__fn{};
}
}

}}
# 1881 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/algorithm" 2 3

# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_minmax.h" 1 3
# 35 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_minmax.h" 3





# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__undef_macros" 1 3
# 41 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_minmax.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

namespace ranges {
template <class _T1>
using minmax_result = min_max_result<_T1>;

namespace __minmax {
struct __fn {
  template <class _Type,
            class _Proj = identity,
            indirect_strict_weak_order<projected<const _Type*, _Proj>> _Comp = ranges::less>
  [[__nodiscard__]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr ranges::minmax_result<const _Type&>
  operator()([[_Clang::__lifetimebound__]] const _Type& __a,
             [[_Clang::__lifetimebound__]] const _Type& __b,
             _Comp __comp = {},
             _Proj __proj = {}) const {
    if (std::invoke(__comp, std::invoke(__proj, __b), std::invoke(__proj, __a)))
      return {__b, __a};
    return {__a, __b};
  }

  template <copyable _Type,
            class _Proj = identity,
            indirect_strict_weak_order<projected<const _Type*, _Proj>> _Comp = ranges::less>
  [[__nodiscard__]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr ranges::minmax_result<_Type>
  operator()(initializer_list<_Type> __il, _Comp __comp = {}, _Proj __proj = {}) const {
    ((void)0);
    auto __iters = std::__minmax_element_impl(__il.begin(), __il.end(), __comp, __proj);
    return ranges::minmax_result<_Type>{*__iters.first, *__iters.second};
  }

  template <input_range _Range,
            class _Proj = identity,
            indirect_strict_weak_order<projected<iterator_t<_Range>, _Proj>> _Comp = ranges::less>
    requires indirectly_copyable_storable<iterator_t<_Range>, range_value_t<_Range>*>
  [[__nodiscard__]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr ranges::minmax_result<range_value_t<_Range>>
  operator()(_Range&& __r, _Comp __comp = {}, _Proj __proj = {}) const {
    auto __first = ranges::begin(__r);
    auto __last = ranges::end(__r);
    using _ValueT = range_value_t<_Range>;

    ((void)0);

    if constexpr (forward_range<_Range>) {



      if constexpr (!same_as<remove_cvref_t<range_reference_t<_Range>>, _ValueT> ||
                    is_rvalue_reference_v<range_reference_t<_Range>>) {
        if (ranges::next(__first) == __last) {


          minmax_result<_ValueT> __result = {*__first, __result.min};
          return __result;
        }
      }
      auto __result = std::__minmax_element_impl(__first, __last, __comp, __proj);
      return {*__result.first, *__result.second};
    } else {


      auto __less = [&](auto&& __a, auto&& __b) -> bool {
        return std::invoke(__comp,
                           std::invoke(__proj, std::forward<decltype(__a)>(__a)),
                           std::invoke(__proj, std::forward<decltype(__b)>(__b)));
      };



      ranges::minmax_result<_ValueT> __result = {*__first, __result.min};
      if (__first == __last || ++__first == __last)
        return __result;

      if (__less(*__first, __result.min))
        __result.min = *__first;
      else
        __result.max = *__first;

      while (++__first != __last) {
        _ValueT __i = *__first;
        if (++__first == __last) {
          if (__less(__i, __result.min))
            __result.min = __i;
          else if (!__less(__i, __result.max))
            __result.max = __i;
          return __result;
        }

        if (__less(*__first, __i)) {
          if (__less(*__first, __result.min))
            __result.min = *__first;
          if (!__less(__i, __result.max))
            __result.max = std::move(__i);
        } else {
          if (__less(__i, __result.min))
            __result.min = std::move(__i);
          if (!__less(*__first, __result.max))
            __result.max = *__first;
        }
      }
      return __result;
    }
  }
};
}

inline namespace __cpo {
inline constexpr auto minmax = __minmax::__fn{};
}
}

}}
# 1883 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/algorithm" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_minmax_element.h" 1 3
# 29 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_minmax_element.h" 3




namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

namespace ranges {

template <class _T1>
using minmax_element_result = min_max_result<_T1>;

namespace __minmax_element {
struct __fn {
  template <forward_iterator _Ip,
            sentinel_for<_Ip> _Sp,
            class _Proj = identity,
            indirect_strict_weak_order<projected<_Ip, _Proj>> _Comp = ranges::less>
  [[__nodiscard__]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr ranges::minmax_element_result<_Ip>
  operator()(_Ip __first, _Sp __last, _Comp __comp = {}, _Proj __proj = {}) const {
    auto __ret = std::__minmax_element_impl(std::move(__first), std::move(__last), __comp, __proj);
    return {__ret.first, __ret.second};
  }

  template <forward_range _Rp,
            class _Proj = identity,
            indirect_strict_weak_order<projected<iterator_t<_Rp>, _Proj>> _Comp = ranges::less>
  [[__nodiscard__]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr ranges::minmax_element_result<borrowed_iterator_t<_Rp>>
  operator()(_Rp&& __r, _Comp __comp = {}, _Proj __proj = {}) const {
    auto __ret = std::__minmax_element_impl(ranges::begin(__r), ranges::end(__r), __comp, __proj);
    return {__ret.first, __ret.second};
  }
};
}

inline namespace __cpo {
inline constexpr auto minmax_element = __minmax_element::__fn{};
}

}

}}
# 1884 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/algorithm" 2 3

# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_move.h" 1 3
# 24 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_move.h" 3




namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

namespace ranges {

template <class _InIter, class _OutIter>
using move_result = in_out_result<_InIter, _OutIter>;

namespace __move {
struct __fn {
  template <class _InIter, class _Sent, class _OutIter>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr static move_result<_InIter, _OutIter>
  __move_impl(_InIter __first, _Sent __last, _OutIter __result) {
    auto __ret = std::__move<_RangeAlgPolicy>(std::move(__first), std::move(__last), std::move(__result));
    return {std::move(__ret.first), std::move(__ret.second)};
  }

  template <input_iterator _InIter, sentinel_for<_InIter> _Sent, weakly_incrementable _OutIter>
    requires indirectly_movable<_InIter, _OutIter>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr move_result<_InIter, _OutIter>
  operator()(_InIter __first, _Sent __last, _OutIter __result) const {
    return __move_impl(std::move(__first), std::move(__last), std::move(__result));
  }

  template <input_range _Range, weakly_incrementable _OutIter>
    requires indirectly_movable<iterator_t<_Range>, _OutIter>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr move_result<borrowed_iterator_t<_Range>, _OutIter>
  operator()(_Range&& __range, _OutIter __result) const {
    return __move_impl(ranges::begin(__range), ranges::end(__range), std::move(__result));
  }
};
}

inline namespace __cpo {
inline constexpr auto move = __move::__fn{};
}
}

}}
# 1886 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/algorithm" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_move_backward.h" 1 3
# 26 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_move_backward.h" 3




namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

namespace ranges {

template <class _InIter, class _OutIter>
using move_backward_result = in_out_result<_InIter, _OutIter>;

namespace __move_backward {
struct __fn {
  template <class _InIter, class _Sent, class _OutIter>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr static move_backward_result<_InIter, _OutIter>
  __move_backward_impl(_InIter __first, _Sent __last, _OutIter __result) {
    auto __ret = std::__move_backward<_RangeAlgPolicy>(std::move(__first), std::move(__last), std::move(__result));
    return {std::move(__ret.first), std::move(__ret.second)};
  }

  template <bidirectional_iterator _InIter, sentinel_for<_InIter> _Sent, bidirectional_iterator _OutIter>
    requires indirectly_movable<_InIter, _OutIter>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr move_backward_result<_InIter, _OutIter>
  operator()(_InIter __first, _Sent __last, _OutIter __result) const {
    return __move_backward_impl(std::move(__first), std::move(__last), std::move(__result));
  }

  template <bidirectional_range _Range, bidirectional_iterator _Iter>
    requires indirectly_movable<iterator_t<_Range>, _Iter>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr move_backward_result<borrowed_iterator_t<_Range>, _Iter>
  operator()(_Range&& __range, _Iter __result) const {
    return __move_backward_impl(ranges::begin(__range), ranges::end(__range), std::move(__result));
  }
};
}

inline namespace __cpo {
inline constexpr auto move_backward = __move_backward::__fn{};
}
}

}}
# 1887 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/algorithm" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_next_permutation.h" 1 3
# 29 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_next_permutation.h" 3




namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

namespace ranges {

template <class _InIter>
using next_permutation_result = in_found_result<_InIter>;

namespace __next_permutation {

struct __fn {
  template <bidirectional_iterator _Iter, sentinel_for<_Iter> _Sent, class _Comp = ranges::less, class _Proj = identity>
    requires sortable<_Iter, _Comp, _Proj>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr next_permutation_result<_Iter>
  operator()(_Iter __first, _Sent __last, _Comp __comp = {}, _Proj __proj = {}) const {
    auto __result = std::__next_permutation<_RangeAlgPolicy>(
        std::move(__first), std::move(__last), std::__make_projected(__comp, __proj));
    return {std::move(__result.first), std::move(__result.second)};
  }

  template <bidirectional_range _Range, class _Comp = ranges::less, class _Proj = identity>
    requires sortable<iterator_t<_Range>, _Comp, _Proj>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr next_permutation_result<borrowed_iterator_t<_Range>>
  operator()(_Range&& __range, _Comp __comp = {}, _Proj __proj = {}) const {
    auto __result = std::__next_permutation<_RangeAlgPolicy>(
        ranges::begin(__range), ranges::end(__range), std::__make_projected(__comp, __proj));
    return {std::move(__result.first), std::move(__result.second)};
  }
};

}

inline namespace __cpo {
constexpr inline auto next_permutation = __next_permutation::__fn{};
}
}

}}
# 1888 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/algorithm" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_none_of.h" 1 3
# 23 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_none_of.h" 3




namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

namespace ranges {
namespace __none_of {
struct __fn {
  template <class _Iter, class _Sent, class _Proj, class _Pred>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr static bool
  __none_of_impl(_Iter __first, _Sent __last, _Pred& __pred, _Proj& __proj) {
    for (; __first != __last; ++__first) {
      if (std::invoke(__pred, std::invoke(__proj, *__first)))
        return false;
    }
    return true;
  }

  template <input_iterator _Iter,
            sentinel_for<_Iter> _Sent,
            class _Proj = identity,
            indirect_unary_predicate<projected<_Iter, _Proj>> _Pred>
  [[__nodiscard__]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr bool
  operator()(_Iter __first, _Sent __last, _Pred __pred = {}, _Proj __proj = {}) const {
    return __none_of_impl(std::move(__first), std::move(__last), __pred, __proj);
  }

  template <input_range _Range,
            class _Proj = identity,
            indirect_unary_predicate<projected<iterator_t<_Range>, _Proj>> _Pred>
  [[__nodiscard__]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr bool
  operator()(_Range&& __range, _Pred __pred, _Proj __proj = {}) const {
    return __none_of_impl(ranges::begin(__range), ranges::end(__range), __pred, __proj);
  }
};
}

inline namespace __cpo {
inline constexpr auto none_of = __none_of::__fn{};
}
}

}}
# 1889 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/algorithm" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_nth_element.h" 1 3
# 32 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_nth_element.h" 3




namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

namespace ranges {
namespace __nth_element {

struct __fn {
  template <class _Iter, class _Sent, class _Comp, class _Proj>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr static _Iter
  __nth_element_fn_impl(_Iter __first, _Iter __nth, _Sent __last, _Comp& __comp, _Proj& __proj) {
    auto __last_iter = ranges::next(__first, __last);

    auto&& __projected_comp = std::__make_projected(__comp, __proj);
    std::__nth_element_impl<_RangeAlgPolicy>(std::move(__first), std::move(__nth), __last_iter, __projected_comp);

    return __last_iter;
  }

  template <random_access_iterator _Iter, sentinel_for<_Iter> _Sent, class _Comp = ranges::less, class _Proj = identity>
    requires sortable<_Iter, _Comp, _Proj>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr _Iter
  operator()(_Iter __first, _Iter __nth, _Sent __last, _Comp __comp = {}, _Proj __proj = {}) const {
    return __nth_element_fn_impl(std::move(__first), std::move(__nth), std::move(__last), __comp, __proj);
  }

  template <random_access_range _Range, class _Comp = ranges::less, class _Proj = identity>
    requires sortable<iterator_t<_Range>, _Comp, _Proj>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr borrowed_iterator_t<_Range>
  operator()(_Range&& __r, iterator_t<_Range> __nth, _Comp __comp = {}, _Proj __proj = {}) const {
    return __nth_element_fn_impl(ranges::begin(__r), std::move(__nth), ranges::end(__r), __comp, __proj);
  }
};

}

inline namespace __cpo {
inline constexpr auto nth_element = __nth_element::__fn{};
}
}

}}
# 1890 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/algorithm" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_partial_sort.h" 1 3
# 34 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_partial_sort.h" 3




namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

namespace ranges {
namespace __partial_sort {

struct __fn {
  template <class _Iter, class _Sent, class _Comp, class _Proj>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr static _Iter
  __partial_sort_fn_impl(_Iter __first, _Iter __middle, _Sent __last, _Comp& __comp, _Proj& __proj) {
    auto&& __projected_comp = std::__make_projected(__comp, __proj);
    return std::__partial_sort<_RangeAlgPolicy>(std::move(__first), std::move(__middle), __last, __projected_comp);
  }

  template <random_access_iterator _Iter, sentinel_for<_Iter> _Sent, class _Comp = ranges::less, class _Proj = identity>
    requires sortable<_Iter, _Comp, _Proj>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr _Iter
  operator()(_Iter __first, _Iter __middle, _Sent __last, _Comp __comp = {}, _Proj __proj = {}) const {
    return __partial_sort_fn_impl(std::move(__first), std::move(__middle), std::move(__last), __comp, __proj);
  }

  template <random_access_range _Range, class _Comp = ranges::less, class _Proj = identity>
    requires sortable<iterator_t<_Range>, _Comp, _Proj>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr borrowed_iterator_t<_Range>
  operator()(_Range&& __r, iterator_t<_Range> __middle, _Comp __comp = {}, _Proj __proj = {}) const {
    return __partial_sort_fn_impl(ranges::begin(__r), std::move(__middle), ranges::end(__r), __comp, __proj);
  }
};

}

inline namespace __cpo {
inline constexpr auto partial_sort = __partial_sort::__fn{};
}
}

}}
# 1891 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/algorithm" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_partial_sort_copy.h" 1 3
# 31 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_partial_sort_copy.h" 3




namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

namespace ranges {

template <class _InIter, class _OutIter>
using partial_sort_copy_result = in_out_result<_InIter, _OutIter>;

namespace __partial_sort_copy {

struct __fn {
  template <input_iterator _Iter1,
            sentinel_for<_Iter1> _Sent1,
            random_access_iterator _Iter2,
            sentinel_for<_Iter2> _Sent2,
            class _Comp = ranges::less,
            class _Proj1 = identity,
            class _Proj2 = identity>
    requires indirectly_copyable<_Iter1, _Iter2> && sortable<_Iter2, _Comp, _Proj2> &&
             indirect_strict_weak_order<_Comp, projected<_Iter1, _Proj1>, projected<_Iter2, _Proj2>>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr partial_sort_copy_result<_Iter1, _Iter2> operator()(
      _Iter1 __first,
      _Sent1 __last,
      _Iter2 __result_first,
      _Sent2 __result_last,
      _Comp __comp = {},
      _Proj1 __proj1 = {},
      _Proj2 __proj2 = {}) const {
    auto __result = std::__partial_sort_copy<_RangeAlgPolicy>(
        std::move(__first),
        std::move(__last),
        std::move(__result_first),
        std::move(__result_last),
        __comp,
        __proj1,
        __proj2);
    return {std::move(__result.first), std::move(__result.second)};
  }

  template <input_range _Range1,
            random_access_range _Range2,
            class _Comp = ranges::less,
            class _Proj1 = identity,
            class _Proj2 = identity>
    requires indirectly_copyable<iterator_t<_Range1>, iterator_t<_Range2>> &&
             sortable<iterator_t<_Range2>, _Comp, _Proj2> &&
             indirect_strict_weak_order<_Comp,
                                        projected<iterator_t<_Range1>, _Proj1>,
                                        projected<iterator_t<_Range2>, _Proj2>>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr partial_sort_copy_result<borrowed_iterator_t<_Range1>, borrowed_iterator_t<_Range2>>
  operator()(
      _Range1&& __range, _Range2&& __result_range, _Comp __comp = {}, _Proj1 __proj1 = {}, _Proj2 __proj2 = {}) const {
    auto __result = std::__partial_sort_copy<_RangeAlgPolicy>(
        ranges::begin(__range),
        ranges::end(__range),
        ranges::begin(__result_range),
        ranges::end(__result_range),
        __comp,
        __proj1,
        __proj2);
    return {std::move(__result.first), std::move(__result.second)};
  }
};

}

inline namespace __cpo {
inline constexpr auto partial_sort_copy = __partial_sort_copy::__fn{};
}
}

}}
# 1892 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/algorithm" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_partition.h" 1 3
# 33 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_partition.h" 3




namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

namespace ranges {
namespace __partition {

struct __fn {
  template <class _Iter, class _Sent, class _Proj, class _Pred>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) static constexpr subrange<__remove_cvref_t<_Iter>>
  __partition_fn_impl(_Iter&& __first, _Sent&& __last, _Pred&& __pred, _Proj&& __proj) {
    auto&& __projected_pred = std::__make_projected(__pred, __proj);
    auto __result = std::__partition<_RangeAlgPolicy>(
        std::move(__first), std::move(__last), __projected_pred, __iterator_concept<_Iter>());

    return {std::move(__result.first), std::move(__result.second)};
  }

  template <permutable _Iter,
            sentinel_for<_Iter> _Sent,
            class _Proj = identity,
            indirect_unary_predicate<projected<_Iter, _Proj>> _Pred>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr subrange<_Iter>
  operator()(_Iter __first, _Sent __last, _Pred __pred, _Proj __proj = {}) const {
    return __partition_fn_impl(__first, __last, __pred, __proj);
  }

  template <forward_range _Range,
            class _Proj = identity,
            indirect_unary_predicate<projected<iterator_t<_Range>, _Proj>> _Pred>
    requires permutable<iterator_t<_Range>>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr borrowed_subrange_t<_Range>
  operator()(_Range&& __range, _Pred __pred, _Proj __proj = {}) const {
    return __partition_fn_impl(ranges::begin(__range), ranges::end(__range), __pred, __proj);
  }
};

}

inline namespace __cpo {
inline constexpr auto partition = __partition::__fn{};
}
}

}}
# 1893 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/algorithm" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_partition_copy.h" 1 3
# 27 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_partition_copy.h" 3




namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

namespace ranges {

template <class _InIter, class _OutIter1, class _OutIter2>
using partition_copy_result = in_out_out_result<_InIter, _OutIter1, _OutIter2>;

namespace __partition_copy {

struct __fn {

  template <class _InIter, class _Sent, class _OutIter1, class _OutIter2, class _Proj, class _Pred>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr static partition_copy_result<__remove_cvref_t<_InIter>,
                                                               __remove_cvref_t<_OutIter1>,
                                                               __remove_cvref_t<_OutIter2> >
  __partition_copy_fn_impl(
      _InIter&& __first,
      _Sent&& __last,
      _OutIter1&& __out_true,
      _OutIter2&& __out_false,
      _Pred& __pred,
      _Proj& __proj) {
    for (; __first != __last; ++__first) {
      if (std::invoke(__pred, std::invoke(__proj, *__first))) {
        *__out_true = *__first;
        ++__out_true;

      } else {
        *__out_false = *__first;
        ++__out_false;
      }
    }

    return {std::move(__first), std::move(__out_true), std::move(__out_false)};
  }

  template <input_iterator _InIter,
            sentinel_for<_InIter> _Sent,
            weakly_incrementable _OutIter1,
            weakly_incrementable _OutIter2,
            class _Proj = identity,
            indirect_unary_predicate<projected<_InIter, _Proj>> _Pred>
    requires indirectly_copyable<_InIter, _OutIter1> && indirectly_copyable<_InIter, _OutIter2>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr partition_copy_result<_InIter, _OutIter1, _OutIter2> operator()(
      _InIter __first, _Sent __last, _OutIter1 __out_true, _OutIter2 __out_false, _Pred __pred, _Proj __proj = {})
      const {
    return __partition_copy_fn_impl(
        std::move(__first), std::move(__last), std::move(__out_true), std::move(__out_false), __pred, __proj);
  }

  template <input_range _Range,
            weakly_incrementable _OutIter1,
            weakly_incrementable _OutIter2,
            class _Proj = identity,
            indirect_unary_predicate<projected<iterator_t<_Range>, _Proj>> _Pred>
    requires indirectly_copyable<iterator_t<_Range>, _OutIter1> && indirectly_copyable<iterator_t<_Range>, _OutIter2>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr partition_copy_result<borrowed_iterator_t<_Range>, _OutIter1, _OutIter2>
  operator()(_Range&& __range, _OutIter1 __out_true, _OutIter2 __out_false, _Pred __pred, _Proj __proj = {}) const {
    return __partition_copy_fn_impl(
        ranges::begin(__range), ranges::end(__range), std::move(__out_true), std::move(__out_false), __pred, __proj);
  }
};

}

inline namespace __cpo {
inline constexpr auto partition_copy = __partition_copy::__fn{};
}
}

}}
# 1894 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/algorithm" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_partition_point.h" 1 3
# 28 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_partition_point.h" 3




namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

namespace ranges {
namespace __partition_point {

struct __fn {

  template <class _Iter, class _Sent, class _Proj, class _Pred>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr static _Iter
  __partition_point_fn_impl(_Iter&& __first, _Sent&& __last, _Pred& __pred, _Proj& __proj) {
    auto __len = ranges::distance(__first, __last);

    while (__len != 0) {
      auto __half_len = std::__half_positive(__len);
      auto __mid = ranges::next(__first, __half_len);

      if (std::invoke(__pred, std::invoke(__proj, *__mid))) {
        __first = ++__mid;
        __len -= __half_len + 1;

      } else {
        __len = __half_len;
      }
    }

    return __first;
  }

  template <forward_iterator _Iter,
            sentinel_for<_Iter> _Sent,
            class _Proj = identity,
            indirect_unary_predicate<projected<_Iter, _Proj>> _Pred>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr _Iter operator()(_Iter __first, _Sent __last, _Pred __pred, _Proj __proj = {}) const {
    return __partition_point_fn_impl(std::move(__first), std::move(__last), __pred, __proj);
  }

  template <forward_range _Range,
            class _Proj = identity,
            indirect_unary_predicate<projected<iterator_t<_Range>, _Proj>> _Pred>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr borrowed_iterator_t<_Range>
  operator()(_Range&& __range, _Pred __pred, _Proj __proj = {}) const {
    return __partition_point_fn_impl(ranges::begin(__range), ranges::end(__range), __pred, __proj);
  }
};

}

inline namespace __cpo {
inline constexpr auto partition_point = __partition_point::__fn{};
}
}

}}
# 1895 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/algorithm" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_pop_heap.h" 1 3
# 33 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_pop_heap.h" 3




namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

namespace ranges {
namespace __pop_heap {

struct __fn {
  template <class _Iter, class _Sent, class _Comp, class _Proj>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr static _Iter
  __pop_heap_fn_impl(_Iter __first, _Sent __last, _Comp& __comp, _Proj& __proj) {
    auto __last_iter = ranges::next(__first, __last);
    auto __len = __last_iter - __first;

    auto&& __projected_comp = std::__make_projected(__comp, __proj);
    std::__pop_heap<_RangeAlgPolicy>(std::move(__first), __last_iter, __projected_comp, __len);

    return __last_iter;
  }

  template <random_access_iterator _Iter, sentinel_for<_Iter> _Sent, class _Comp = ranges::less, class _Proj = identity>
    requires sortable<_Iter, _Comp, _Proj>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr _Iter
  operator()(_Iter __first, _Sent __last, _Comp __comp = {}, _Proj __proj = {}) const {
    return __pop_heap_fn_impl(std::move(__first), std::move(__last), __comp, __proj);
  }

  template <random_access_range _Range, class _Comp = ranges::less, class _Proj = identity>
    requires sortable<iterator_t<_Range>, _Comp, _Proj>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr borrowed_iterator_t<_Range>
  operator()(_Range&& __r, _Comp __comp = {}, _Proj __proj = {}) const {
    return __pop_heap_fn_impl(ranges::begin(__r), ranges::end(__r), __comp, __proj);
  }
};

}

inline namespace __cpo {
inline constexpr auto pop_heap = __pop_heap::__fn{};
}
}

}}
# 1896 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/algorithm" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_prev_permutation.h" 1 3
# 29 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_prev_permutation.h" 3




namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

namespace ranges {

template <class _InIter>
using prev_permutation_result = in_found_result<_InIter>;

namespace __prev_permutation {

struct __fn {
  template <bidirectional_iterator _Iter, sentinel_for<_Iter> _Sent, class _Comp = ranges::less, class _Proj = identity>
    requires sortable<_Iter, _Comp, _Proj>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr prev_permutation_result<_Iter>
  operator()(_Iter __first, _Sent __last, _Comp __comp = {}, _Proj __proj = {}) const {
    auto __result = std::__prev_permutation<_RangeAlgPolicy>(
        std::move(__first), std::move(__last), std::__make_projected(__comp, __proj));
    return {std::move(__result.first), std::move(__result.second)};
  }

  template <bidirectional_range _Range, class _Comp = ranges::less, class _Proj = identity>
    requires sortable<iterator_t<_Range>, _Comp, _Proj>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr prev_permutation_result<borrowed_iterator_t<_Range>>
  operator()(_Range&& __range, _Comp __comp = {}, _Proj __proj = {}) const {
    auto __result = std::__prev_permutation<_RangeAlgPolicy>(
        ranges::begin(__range), ranges::end(__range), std::__make_projected(__comp, __proj));
    return {std::move(__result.first), std::move(__result.second)};
  }
};

}

inline namespace __cpo {
constexpr inline auto prev_permutation = __prev_permutation::__fn{};
}
}

}}
# 1897 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/algorithm" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_push_heap.h" 1 3
# 33 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_push_heap.h" 3




namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

namespace ranges {
namespace __push_heap {

struct __fn {
  template <class _Iter, class _Sent, class _Comp, class _Proj>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr static _Iter
  __push_heap_fn_impl(_Iter __first, _Sent __last, _Comp& __comp, _Proj& __proj) {
    auto __last_iter = ranges::next(__first, __last);

    auto&& __projected_comp = std::__make_projected(__comp, __proj);
    std::__push_heap<_RangeAlgPolicy>(std::move(__first), __last_iter, __projected_comp);

    return __last_iter;
  }

  template <random_access_iterator _Iter, sentinel_for<_Iter> _Sent, class _Comp = ranges::less, class _Proj = identity>
    requires sortable<_Iter, _Comp, _Proj>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr _Iter
  operator()(_Iter __first, _Sent __last, _Comp __comp = {}, _Proj __proj = {}) const {
    return __push_heap_fn_impl(std::move(__first), std::move(__last), __comp, __proj);
  }

  template <random_access_range _Range, class _Comp = ranges::less, class _Proj = identity>
    requires sortable<iterator_t<_Range>, _Comp, _Proj>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr borrowed_iterator_t<_Range>
  operator()(_Range&& __r, _Comp __comp = {}, _Proj __proj = {}) const {
    return __push_heap_fn_impl(ranges::begin(__r), ranges::end(__r), __comp, __proj);
  }
};

}

inline namespace __cpo {
inline constexpr auto push_heap = __push_heap::__fn{};
}
}

}}
# 1898 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/algorithm" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_remove.h" 1 3
# 13 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_remove.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_remove_if.h" 1 3
# 28 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_remove_if.h" 3




namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

namespace ranges {

template <class _Iter, class _Sent, class _Proj, class _Pred>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr subrange<_Iter>
__remove_if_impl(_Iter __first, _Sent __last, _Pred& __pred, _Proj& __proj) {
  auto __new_end = ranges::__find_if_impl(__first, __last, __pred, __proj);
  if (__new_end == __last)
    return {__new_end, __new_end};

  _Iter __i = __new_end;
  while (++__i != __last) {
    if (!std::invoke(__pred, std::invoke(__proj, *__i))) {
      *__new_end = ranges::iter_move(__i);
      ++__new_end;
    }
  }
  return {__new_end, __i};
}

namespace __remove_if {
struct __fn {
  template <permutable _Iter,
            sentinel_for<_Iter> _Sent,
            class _Proj = identity,
            indirect_unary_predicate<projected<_Iter, _Proj>> _Pred>
  [[__nodiscard__]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr subrange<_Iter>
  operator()(_Iter __first, _Sent __last, _Pred __pred, _Proj __proj = {}) const {
    return ranges::__remove_if_impl(std::move(__first), std::move(__last), __pred, __proj);
  }

  template <forward_range _Range,
            class _Proj = identity,
            indirect_unary_predicate<projected<iterator_t<_Range>, _Proj>> _Pred>
    requires permutable<iterator_t<_Range>>
  [[__nodiscard__]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr borrowed_subrange_t<_Range>
  operator()(_Range&& __range, _Pred __pred, _Proj __proj = {}) const {
    return ranges::__remove_if_impl(ranges::begin(__range), ranges::end(__range), __pred, __proj);
  }
};
}

inline namespace __cpo {
inline constexpr auto remove_if = __remove_if::__fn{};
}
}

}}
# 14 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_remove.h" 2 3
# 26 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_remove.h" 3




namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

namespace ranges {
namespace __remove {
struct __fn {
  template <permutable _Iter, sentinel_for<_Iter> _Sent, class _Type, class _Proj = identity>
    requires indirect_binary_predicate<ranges::equal_to, projected<_Iter, _Proj>, const _Type*>
  [[__nodiscard__]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr subrange<_Iter>
  operator()(_Iter __first, _Sent __last, const _Type& __value, _Proj __proj = {}) const {
    auto __pred = [&](auto&& __other) { return __value == __other; };
    return ranges::__remove_if_impl(std::move(__first), std::move(__last), __pred, __proj);
  }

  template <forward_range _Range, class _Type, class _Proj = identity>
    requires permutable<iterator_t<_Range>> &&
             indirect_binary_predicate<ranges::equal_to, projected<iterator_t<_Range>, _Proj>, const _Type*>
  [[__nodiscard__]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr borrowed_subrange_t<_Range>
  operator()(_Range&& __range, const _Type& __value, _Proj __proj = {}) const {
    auto __pred = [&](auto&& __other) { return __value == __other; };
    return ranges::__remove_if_impl(ranges::begin(__range), ranges::end(__range), __pred, __proj);
  }
};
}

inline namespace __cpo {
inline constexpr auto remove = __remove::__fn{};
}
}

}}
# 1899 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/algorithm" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_remove_copy.h" 1 3
# 13 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_remove_copy.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_remove_copy_if.h" 1 3
# 14 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_remove_copy_if.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/remove_copy_if.h" 1 3
# 16 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/remove_copy_if.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _InputIterator, class _OutputIterator, class _Predicate>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
_OutputIterator
remove_copy_if(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _Predicate __pred)
{
    for (; __first != __last; ++__first)
    {
        if (!__pred(*__first))
        {
            *__result = *__first;
            ++__result;
        }
    }
    return __result;
}

}}
# 15 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_remove_copy_if.h" 2 3
# 30 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_remove_copy_if.h" 3




namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

namespace ranges {

template <class _InIter, class _OutIter>
using remove_copy_if_result = in_out_result<_InIter, _OutIter>;

template <class _InIter, class _Sent, class _OutIter, class _Proj, class _Pred>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr in_out_result<_InIter, _OutIter>
__remove_copy_if_impl(_InIter __first, _Sent __last, _OutIter __result, _Pred& __pred, _Proj& __proj) {
  for (; __first != __last; ++__first) {
    if (!std::invoke(__pred, std::invoke(__proj, *__first))) {
      *__result = *__first;
      ++__result;
    }
  }
  return {std::move(__first), std::move(__result)};
}

namespace __remove_copy_if {

struct __fn {
  template <input_iterator _InIter,
            sentinel_for<_InIter> _Sent,
            weakly_incrementable _OutIter,
            class _Proj = identity,
            indirect_unary_predicate<projected<_InIter, _Proj>> _Pred>
    requires indirectly_copyable<_InIter, _OutIter>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr remove_copy_if_result<_InIter, _OutIter>
  operator()(_InIter __first, _Sent __last, _OutIter __result, _Pred __pred, _Proj __proj = {}) const {
    return ranges::__remove_copy_if_impl(std::move(__first), std::move(__last), std::move(__result), __pred, __proj);
  }

  template <input_range _Range,
            weakly_incrementable _OutIter,
            class _Proj = identity,
            indirect_unary_predicate<projected<iterator_t<_Range>, _Proj>> _Pred>
    requires indirectly_copyable<iterator_t<_Range>, _OutIter>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr remove_copy_if_result<borrowed_iterator_t<_Range>, _OutIter>
  operator()(_Range&& __range, _OutIter __result, _Pred __pred, _Proj __proj = {}) const {
    return ranges::__remove_copy_if_impl(
        ranges::begin(__range), ranges::end(__range), std::move(__result), __pred, __proj);
  }
};

}

inline namespace __cpo {
inline constexpr auto remove_copy_if = __remove_copy_if::__fn{};
}
}

}}
# 14 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_remove_copy.h" 2 3
# 27 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_remove_copy.h" 3




namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

namespace ranges {

template <class _InIter, class _OutIter>
using remove_copy_result = in_out_result<_InIter, _OutIter>;

namespace __remove_copy {

struct __fn {
  template <input_iterator _InIter,
            sentinel_for<_InIter> _Sent,
            weakly_incrementable _OutIter,
            class _Type,
            class _Proj = identity>
    requires indirectly_copyable<_InIter, _OutIter> &&
             indirect_binary_predicate<ranges::equal_to, projected<_InIter, _Proj>, const _Type*>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr remove_copy_result<_InIter, _OutIter>
  operator()(_InIter __first, _Sent __last, _OutIter __result, const _Type& __value, _Proj __proj = {}) const {
    auto __pred = [&](auto&& __val) { return __value == __val; };
    return ranges::__remove_copy_if_impl(std::move(__first), std::move(__last), std::move(__result), __pred, __proj);
  }

  template <input_range _Range, weakly_incrementable _OutIter, class _Type, class _Proj = identity>
    requires indirectly_copyable<iterator_t<_Range>, _OutIter> &&
             indirect_binary_predicate<ranges::equal_to, projected<iterator_t<_Range>, _Proj>, const _Type*>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr remove_copy_result<borrowed_iterator_t<_Range>, _OutIter>
  operator()(_Range&& __range, _OutIter __result, const _Type& __value, _Proj __proj = {}) const {
    auto __pred = [&](auto&& __val) { return __value == __val; };
    return ranges::__remove_copy_if_impl(
        ranges::begin(__range), ranges::end(__range), std::move(__result), __pred, __proj);
  }
};

}

inline namespace __cpo {
inline constexpr auto remove_copy = __remove_copy::__fn{};
}
}

}}
# 1900 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/algorithm" 2 3


# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_replace.h" 1 3
# 12 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_replace.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_replace_if.h" 1 3
# 24 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_replace_if.h" 3




namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

namespace ranges {

template <class _Iter, class _Sent, class _Type, class _Proj, class _Pred>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr _Iter
__replace_if_impl(_Iter __first, _Sent __last, _Pred& __pred, const _Type& __new_value, _Proj& __proj) {
  for (; __first != __last; ++__first) {
    if (std::invoke(__pred, std::invoke(__proj, *__first)))
      *__first = __new_value;
  }
  return __first;
}

namespace __replace_if {
struct __fn {
  template <input_iterator _Iter,
            sentinel_for<_Iter> _Sent,
            class _Type,
            class _Proj = identity,
            indirect_unary_predicate<projected<_Iter, _Proj>> _Pred>
    requires indirectly_writable<_Iter, const _Type&>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr _Iter
  operator()(_Iter __first, _Sent __last, _Pred __pred, const _Type& __new_value, _Proj __proj = {}) const {
    return ranges::__replace_if_impl(std::move(__first), std::move(__last), __pred, __new_value, __proj);
  }

  template <input_range _Range,
            class _Type,
            class _Proj = identity,
            indirect_unary_predicate<projected<iterator_t<_Range>, _Proj>> _Pred>
    requires indirectly_writable<iterator_t<_Range>, const _Type&>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr borrowed_iterator_t<_Range>
  operator()(_Range&& __range, _Pred __pred, const _Type& __new_value, _Proj __proj = {}) const {
    return ranges::__replace_if_impl(ranges::begin(__range), ranges::end(__range), __pred, __new_value, __proj);
  }
};
}

inline namespace __cpo {
inline constexpr auto replace_if = __replace_if::__fn{};
}
}

}}
# 13 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_replace.h" 2 3
# 25 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_replace.h" 3




namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

namespace ranges {
namespace __replace {
struct __fn {
  template <input_iterator _Iter, sentinel_for<_Iter> _Sent, class _Type1, class _Type2, class _Proj = identity>
    requires indirectly_writable<_Iter, const _Type2&> &&
             indirect_binary_predicate<ranges::equal_to, projected<_Iter, _Proj>, const _Type1*>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr _Iter operator()(
      _Iter __first, _Sent __last, const _Type1& __old_value, const _Type2& __new_value, _Proj __proj = {}) const {
    auto __pred = [&](const auto& __val) { return __val == __old_value; };
    return ranges::__replace_if_impl(std::move(__first), std::move(__last), __pred, __new_value, __proj);
  }

  template <input_range _Range, class _Type1, class _Type2, class _Proj = identity>
    requires indirectly_writable<iterator_t<_Range>, const _Type2&> &&
             indirect_binary_predicate<ranges::equal_to, projected<iterator_t<_Range>, _Proj>, const _Type1*>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr borrowed_iterator_t<_Range>
  operator()(_Range&& __range, const _Type1& __old_value, const _Type2& __new_value, _Proj __proj = {}) const {
    auto __pred = [&](auto&& __val) { return __val == __old_value; };
    return ranges::__replace_if_impl(ranges::begin(__range), ranges::end(__range), __pred, __new_value, __proj);
  }
};
}

inline namespace __cpo {
inline constexpr auto replace = __replace::__fn{};
}
}

}}
# 1903 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/algorithm" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_replace_copy.h" 1 3
# 13 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_replace_copy.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_replace_copy_if.h" 1 3
# 25 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_replace_copy_if.h" 3




namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

namespace ranges {

template <class _InIter, class _OutIter>
using replace_copy_if_result = in_out_result<_InIter, _OutIter>;

template <class _InIter, class _Sent, class _OutIter, class _Pred, class _Type, class _Proj>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr replace_copy_if_result<_InIter, _OutIter> __replace_copy_if_impl(
    _InIter __first, _Sent __last, _OutIter __result, _Pred& __pred, const _Type& __new_value, _Proj& __proj) {
  while (__first != __last) {
    if (std::invoke(__pred, std::invoke(__proj, *__first)))
      *__result = __new_value;
    else
      *__result = *__first;

    ++__first;
    ++__result;
  }

  return {std::move(__first), std::move(__result)};
}

namespace __replace_copy_if {

struct __fn {
  template <input_iterator _InIter,
            sentinel_for<_InIter> _Sent,
            class _Type,
            output_iterator<const _Type&> _OutIter,
            class _Proj = identity,
            indirect_unary_predicate<projected<_InIter, _Proj>> _Pred>
    requires indirectly_copyable<_InIter, _OutIter>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr replace_copy_if_result<_InIter, _OutIter> operator()(
      _InIter __first, _Sent __last, _OutIter __result, _Pred __pred, const _Type& __new_value, _Proj __proj = {})
      const {
    return ranges::__replace_copy_if_impl(
        std::move(__first), std::move(__last), std::move(__result), __pred, __new_value, __proj);
  }

  template <input_range _Range,
            class _Type,
            output_iterator<const _Type&> _OutIter,
            class _Proj = identity,
            indirect_unary_predicate<projected<iterator_t<_Range>, _Proj>> _Pred>
    requires indirectly_copyable<iterator_t<_Range>, _OutIter>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr replace_copy_if_result<borrowed_iterator_t<_Range>, _OutIter>
  operator()(_Range&& __range, _OutIter __result, _Pred __pred, const _Type& __new_value, _Proj __proj = {}) const {
    return ranges::__replace_copy_if_impl(
        ranges::begin(__range), ranges::end(__range), std::move(__result), __pred, __new_value, __proj);
  }
};

}

inline namespace __cpo {
inline constexpr auto replace_copy_if = __replace_copy_if::__fn{};
}
}

}}
# 14 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_replace_copy.h" 2 3
# 27 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_replace_copy.h" 3




namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

namespace ranges {

template <class _InIter, class _OutIter>
using replace_copy_result = in_out_result<_InIter, _OutIter>;

namespace __replace_copy {

struct __fn {
  template <input_iterator _InIter,
            sentinel_for<_InIter> _Sent,
            class _OldType,
            class _NewType,
            output_iterator<const _NewType&> _OutIter,
            class _Proj = identity>
    requires indirectly_copyable<_InIter, _OutIter> &&
             indirect_binary_predicate<ranges::equal_to, projected<_InIter, _Proj>, const _OldType*>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr replace_copy_result<_InIter, _OutIter>
  operator()(_InIter __first,
             _Sent __last,
             _OutIter __result,
             const _OldType& __old_value,
             const _NewType& __new_value,
             _Proj __proj = {}) const {
    auto __pred = [&](const auto& __value) { return __value == __old_value; };
    return ranges::__replace_copy_if_impl(
        std::move(__first), std::move(__last), std::move(__result), __pred, __new_value, __proj);
  }

  template <input_range _Range,
            class _OldType,
            class _NewType,
            output_iterator<const _NewType&> _OutIter,
            class _Proj = identity>
    requires indirectly_copyable<iterator_t<_Range>, _OutIter> &&
             indirect_binary_predicate<ranges::equal_to, projected<iterator_t<_Range>, _Proj>, const _OldType*>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr replace_copy_result<borrowed_iterator_t<_Range>, _OutIter> operator()(
      _Range&& __range, _OutIter __result, const _OldType& __old_value, const _NewType& __new_value, _Proj __proj = {})
      const {
    auto __pred = [&](const auto& __value) { return __value == __old_value; };
    return ranges::__replace_copy_if_impl(
        ranges::begin(__range), ranges::end(__range), std::move(__result), __pred, __new_value, __proj);
  }
};

}

inline namespace __cpo {
inline constexpr auto replace_copy = __replace_copy::__fn{};
}
}

}}
# 1904 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/algorithm" 2 3


# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_reverse.h" 1 3
# 23 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_reverse.h" 3




namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

namespace ranges {
namespace __reverse {
struct __fn {
  template <bidirectional_iterator _Iter, sentinel_for<_Iter> _Sent>
    requires permutable<_Iter>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr _Iter operator()(_Iter __first, _Sent __last) const {
    if constexpr (random_access_iterator<_Iter>) {
      if (__first == __last)
        return __first;

      auto __end = ranges::next(__first, __last);
      auto __ret = __end;

      while (__first < --__end) {
        ranges::iter_swap(__first, __end);
        ++__first;
      }
      return __ret;
    } else {
      auto __end = ranges::next(__first, __last);
      auto __ret = __end;

      while (__first != __end) {
        if (__first == --__end)
          break;

        ranges::iter_swap(__first, __end);
        ++__first;
      }
      return __ret;
    }
  }

  template <bidirectional_range _Range>
    requires permutable<iterator_t<_Range>>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr borrowed_iterator_t<_Range> operator()(_Range&& __range) const {
    return (*this)(ranges::begin(__range), ranges::end(__range));
  }
};
}

inline namespace __cpo {
inline constexpr auto reverse = __reverse::__fn{};
}
}

}}
# 1907 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/algorithm" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_reverse_copy.h" 1 3
# 26 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_reverse_copy.h" 3




namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

namespace ranges {

template <class _InIter, class _OutIter>
using reverse_copy_result = in_out_result<_InIter, _OutIter>;

namespace __reverse_copy {
struct __fn {
  template <bidirectional_iterator _InIter, sentinel_for<_InIter> _Sent, weakly_incrementable _OutIter>
    requires indirectly_copyable<_InIter, _OutIter>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr reverse_copy_result<_InIter, _OutIter>
  operator()(_InIter __first, _Sent __last, _OutIter __result) const {
    return (*this)(subrange(std::move(__first), std::move(__last)), std::move(__result));
  }

  template <bidirectional_range _Range, weakly_incrementable _OutIter>
    requires indirectly_copyable<iterator_t<_Range>, _OutIter>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr reverse_copy_result<borrowed_iterator_t<_Range>, _OutIter>
  operator()(_Range&& __range, _OutIter __result) const {
    auto __ret = ranges::copy(std::__reverse_range(__range), std::move(__result));
    return {ranges::next(ranges::begin(__range), ranges::end(__range)), std::move(__ret.out)};
  }
};
}

inline namespace __cpo {
inline constexpr auto reverse_copy = __reverse_copy::__fn{};
}
}

}}
# 1908 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/algorithm" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_rotate.h" 1 3
# 26 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_rotate.h" 3




namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

namespace ranges {
namespace __rotate {

struct __fn {
  template <class _Iter, class _Sent>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr static subrange<_Iter> __rotate_fn_impl(_Iter __first, _Iter __middle, _Sent __last) {
    auto __ret = std::__rotate<_RangeAlgPolicy>(std::move(__first), std::move(__middle), std::move(__last));
    return {std::move(__ret.first), std::move(__ret.second)};
  }

  template <permutable _Iter, sentinel_for<_Iter> _Sent>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr subrange<_Iter> operator()(_Iter __first, _Iter __middle, _Sent __last) const {
    return __rotate_fn_impl(std::move(__first), std::move(__middle), std::move(__last));
  }

  template <forward_range _Range>
    requires permutable<iterator_t<_Range>>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr borrowed_subrange_t<_Range>
  operator()(_Range&& __range, iterator_t<_Range> __middle) const {
    return __rotate_fn_impl(ranges::begin(__range), std::move(__middle), ranges::end(__range));
  }
};

}

inline namespace __cpo {
inline constexpr auto rotate = __rotate::__fn{};
}
}

}}
# 1909 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/algorithm" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_rotate_copy.h" 1 3
# 24 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_rotate_copy.h" 3




namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

namespace ranges {

template <class _InIter, class _OutIter>
using rotate_copy_result = in_out_result<_InIter, _OutIter>;

namespace __rotate_copy {
struct __fn {
  template <bidirectional_iterator _InIter, sentinel_for<_InIter> _Sent, weakly_incrementable _OutIter>
    requires indirectly_copyable<_InIter, _OutIter>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr rotate_copy_result<_InIter, _OutIter>
  operator()(_InIter __first, _InIter __middle, _Sent __last, _OutIter __result) const {
    auto __res1 = ranges::copy(__middle, __last, std::move(__result));
    auto __res2 = ranges::copy(__first, __middle, std::move(__res1.out));
    return {std::move(__res1.in), std::move(__res2.out)};
  }

  template <bidirectional_range _Range, weakly_incrementable _OutIter>
    requires indirectly_copyable<iterator_t<_Range>, _OutIter>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr rotate_copy_result<borrowed_iterator_t<_Range>, _OutIter>
  operator()(_Range&& __range, iterator_t<_Range> __middle, _OutIter __result) const {
    return (*this)(ranges::begin(__range), std::move(__middle), ranges::end(__range), std::move(__result));
  }
};
}

inline namespace __cpo {
inline constexpr auto rotate_copy = __rotate_copy::__fn{};
}
}

}}
# 1910 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/algorithm" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_sample.h" 1 3
# 13 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_sample.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/sample.h" 1 3
# 18 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/sample.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__random/uniform_int_distribution.h" 1 3
# 14 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__random/uniform_int_distribution.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__random/is_valid.h" 1 3
# 22 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__random/is_valid.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {







template<class> struct __libcpp_random_is_valid_inttype : false_type {};
template<> struct __libcpp_random_is_valid_inttype<int8_t> : true_type {};
template<> struct __libcpp_random_is_valid_inttype<short> : true_type {};
template<> struct __libcpp_random_is_valid_inttype<int> : true_type {};
template<> struct __libcpp_random_is_valid_inttype<long> : true_type {};
template<> struct __libcpp_random_is_valid_inttype<long long> : true_type {};
template<> struct __libcpp_random_is_valid_inttype<uint8_t> : true_type {};
template<> struct __libcpp_random_is_valid_inttype<unsigned short> : true_type {};
template<> struct __libcpp_random_is_valid_inttype<unsigned int> : true_type {};
template<> struct __libcpp_random_is_valid_inttype<unsigned long> : true_type {};
template<> struct __libcpp_random_is_valid_inttype<unsigned long long> : true_type {};


template<> struct __libcpp_random_is_valid_inttype<__int128_t> : true_type {};
template<> struct __libcpp_random_is_valid_inttype<__uint128_t> : true_type {};
# 57 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__random/is_valid.h" 3
template<class, class = void> struct __libcpp_random_is_valid_urng : false_type {};
template<class _Gp> struct __libcpp_random_is_valid_urng<_Gp, __enable_if_t<
    is_unsigned<typename _Gp::result_type>::value &&
    _IsSame<decltype(std::declval<_Gp&>()()), typename _Gp::result_type>::value
> > : true_type {};

}}
# 15 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__random/uniform_int_distribution.h" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__random/log2.h" 1 3
# 18 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__random/log2.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _UIntType, _UIntType _Xp, size_t _Rp>
struct __log2_imp;

template <unsigned long long _Xp, size_t _Rp>
struct __log2_imp<unsigned long long, _Xp, _Rp>
{
    static const size_t value = _Xp & ((unsigned long long)(1) << _Rp) ? _Rp
                                           : __log2_imp<unsigned long long, _Xp, _Rp - 1>::value;
};

template <unsigned long long _Xp>
struct __log2_imp<unsigned long long, _Xp, 0>
{
    static const size_t value = 0;
};

template <size_t _Rp>
struct __log2_imp<unsigned long long, 0, _Rp>
{
    static const size_t value = _Rp + 1;
};



template <__uint128_t _Xp, size_t _Rp>
struct __log2_imp<__uint128_t, _Xp, _Rp>
{
    static const size_t value = (_Xp >> 64)
        ? (64 + __log2_imp<unsigned long long, (_Xp >> 64), 63>::value)
        : __log2_imp<unsigned long long, _Xp, 63>::value;
};



template <class _UIntType, _UIntType _Xp>
struct __log2
{
    static const size_t value = __log2_imp<

        __conditional_t<sizeof(_UIntType) <= sizeof(unsigned long long), unsigned long long, __uint128_t>,



        _Xp,
        sizeof(_UIntType) * 8 - 1>::value;
};

}}
# 16 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__random/uniform_int_distribution.h" 2 3




# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/iosfwd" 1 3
# 99 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/iosfwd" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__fwd/fstream.h" 1 3
# 13 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__fwd/fstream.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__fwd/string.h" 1 3
# 14 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__fwd/string.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__fwd/memory_resource.h" 1 3
# 17 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__fwd/memory_resource.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

namespace pmr {
template <class _ValueType>
class polymorphic_allocator;
}

}}
# 15 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__fwd/string.h" 2 3
# 18 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__fwd/string.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _CharT>
struct char_traits;
template <>
struct char_traits<char>;


template <>
struct char_traits<char8_t>;


template <>
struct char_traits<char16_t>;
template <>
struct char_traits<char32_t>;


template <>
struct char_traits<wchar_t>;


template <class _Tp>
class allocator;

template <class _CharT, class _Traits = char_traits<_CharT>, class _Allocator = allocator<_CharT> >
class basic_string;

using string = basic_string<char>;


using wstring = basic_string<wchar_t>;



using u8string = basic_string<char8_t>;


using u16string = basic_string<char16_t>;
using u32string = basic_string<char32_t>;



namespace pmr {
template <class _CharT, class _Traits = char_traits<_CharT>>
using basic_string = std::basic_string<_CharT, _Traits, polymorphic_allocator<_CharT>>;

using string = basic_string<char>;


using wstring = basic_string<wchar_t>;



using u8string = basic_string<char8_t>;


using u16string = basic_string<char16_t>;
using u32string = basic_string<char32_t>;
}




template <class _CharT, class _Traits, class _Allocator>
class __attribute__((__preferred_name__(string)))

      __attribute__((__preferred_name__(wstring)))


      __attribute__((__preferred_name__(u8string)))

      __attribute__((__preferred_name__(u16string)))
      __attribute__((__preferred_name__(u32string)))

      __attribute__((__preferred_name__(pmr::string)))

      __attribute__((__preferred_name__(pmr::wstring)))


      __attribute__((__preferred_name__(pmr::u8string)))

      __attribute__((__preferred_name__(pmr::u16string)))
      __attribute__((__preferred_name__(pmr::u32string)))

      basic_string;


}}
# 14 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__fwd/fstream.h" 2 3
# 17 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__fwd/fstream.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _CharT, class _Traits = char_traits<_CharT> >
class basic_filebuf;
template <class _CharT, class _Traits = char_traits<_CharT> >
class basic_ifstream;
template <class _CharT, class _Traits = char_traits<_CharT> >
class basic_ofstream;
template <class _CharT, class _Traits = char_traits<_CharT> >
class basic_fstream;

using filebuf = basic_filebuf<char>;
using ifstream = basic_ifstream<char>;
using ofstream = basic_ofstream<char>;
using fstream = basic_fstream<char>;


using wfilebuf = basic_filebuf<wchar_t>;
using wifstream = basic_ifstream<wchar_t>;
using wofstream = basic_ofstream<wchar_t>;
using wfstream = basic_fstream<wchar_t>;


template <class _CharT, class _Traits>
class __attribute__((__preferred_name__(filebuf))) __attribute__((__preferred_name__(wfilebuf))) basic_filebuf;
template <class _CharT, class _Traits>
class __attribute__((__preferred_name__(ifstream))) __attribute__((__preferred_name__(wifstream))) basic_ifstream;
template <class _CharT, class _Traits>
class __attribute__((__preferred_name__(ofstream))) __attribute__((__preferred_name__(wofstream))) basic_ofstream;
template <class _CharT, class _Traits>
class __attribute__((__preferred_name__(fstream))) __attribute__((__preferred_name__(wfstream))) basic_fstream;

}}
# 100 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/iosfwd" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__fwd/ios.h" 1 3
# 17 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__fwd/ios.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _CharT, class _Traits = char_traits<_CharT> >
class basic_ios;

using ios = basic_ios<char>;

using wios = basic_ios<wchar_t>;


template <class _CharT, class _Traits>
class __attribute__((__preferred_name__(ios))) __attribute__((__preferred_name__(wios))) basic_ios;





using streamoff = long long;


}}
# 101 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/iosfwd" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__fwd/istream.h" 1 3
# 17 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__fwd/istream.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _CharT, class _Traits = char_traits<_CharT> >
class basic_istream;

template <class _CharT, class _Traits = char_traits<_CharT> >
class basic_iostream;

using istream = basic_istream<char>;
using iostream = basic_iostream<char>;


using wistream = basic_istream<wchar_t>;
using wiostream = basic_iostream<wchar_t>;


template <class _CharT, class _Traits>
class __attribute__((__preferred_name__(istream))) __attribute__((__preferred_name__(wistream))) basic_istream;

template <class _CharT, class _Traits>
class __attribute__((__preferred_name__(iostream))) __attribute__((__preferred_name__(wiostream))) basic_iostream;

}}
# 102 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/iosfwd" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__fwd/ostream.h" 1 3
# 17 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__fwd/ostream.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _CharT, class _Traits = char_traits<_CharT> >
class basic_ostream;

using ostream = basic_ostream<char>;


using wostream = basic_ostream<wchar_t>;


template <class _CharT, class _Traits>
class __attribute__((__preferred_name__(ostream))) __attribute__((__preferred_name__(wostream))) basic_ostream;

}}
# 103 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/iosfwd" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__fwd/sstream.h" 1 3
# 17 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__fwd/sstream.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _CharT, class _Traits = char_traits<_CharT>, class _Allocator = allocator<_CharT> >
class basic_stringbuf;

template <class _CharT, class _Traits = char_traits<_CharT>, class _Allocator = allocator<_CharT> >
class basic_istringstream;
template <class _CharT, class _Traits = char_traits<_CharT>, class _Allocator = allocator<_CharT> >
class basic_ostringstream;
template <class _CharT, class _Traits = char_traits<_CharT>, class _Allocator = allocator<_CharT> >
class basic_stringstream;

using stringbuf = basic_stringbuf<char>;
using istringstream = basic_istringstream<char>;
using ostringstream = basic_ostringstream<char>;
using stringstream = basic_stringstream<char>;


using wstringbuf = basic_stringbuf<wchar_t>;
using wistringstream = basic_istringstream<wchar_t>;
using wostringstream = basic_ostringstream<wchar_t>;
using wstringstream = basic_stringstream<wchar_t>;


template <class _CharT, class _Traits, class _Allocator>
class __attribute__((__preferred_name__(stringbuf))) __attribute__((__preferred_name__(wstringbuf))) basic_stringbuf;
template <class _CharT, class _Traits, class _Allocator>
class __attribute__((__preferred_name__(istringstream)))
    __attribute__((__preferred_name__(wistringstream))) basic_istringstream;
template <class _CharT, class _Traits, class _Allocator>
class __attribute__((__preferred_name__(ostringstream)))
    __attribute__((__preferred_name__(wostringstream))) basic_ostringstream;
template <class _CharT, class _Traits, class _Allocator>
class __attribute__((__preferred_name__(stringstream)))
    __attribute__((__preferred_name__(wstringstream))) basic_stringstream;

}}
# 104 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/iosfwd" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__fwd/streambuf.h" 1 3
# 17 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__fwd/streambuf.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _CharT, class _Traits = char_traits<_CharT> >
class basic_streambuf;

using streambuf = basic_streambuf<char>;


using wstreambuf = basic_streambuf<wchar_t>;


template <class _CharT, class _Traits>
class __attribute__((__preferred_name__(streambuf))) __attribute__((__preferred_name__(wstreambuf))) basic_streambuf;

}}
# 105 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/iosfwd" 2 3

# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__std_mbstate_t.h" 1 3
# 14 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__std_mbstate_t.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__mbstate_t.h" 1 3
# 17 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__mbstate_t.h" 3
# 15 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__std_mbstate_t.h" 2 3
# 18 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__std_mbstate_t.h" 3





namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

using ::mbstate_t __attribute__((__using_if_exists__));

}}
# 107 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/iosfwd" 2 3
# 111 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/iosfwd" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

class __attribute__((__visibility__("default"))) ios_base;

template <class _CharT, class _Traits = char_traits<_CharT> >
    class istreambuf_iterator;
template <class _CharT, class _Traits = char_traits<_CharT> >
    class ostreambuf_iterator;

template <class _State> class fpos;
typedef fpos<mbstate_t> streampos;

typedef fpos<mbstate_t> wstreampos;


typedef fpos<mbstate_t> u8streampos;

typedef fpos<mbstate_t> u16streampos;
typedef fpos<mbstate_t> u32streampos;


template <class _Tp, class _Alloc = allocator<_Tp> >
class vector;

template <class _CharT, class _Traits>
class __save_flags
{
    typedef basic_ios<_CharT, _Traits> __stream_type;
    typedef typename __stream_type::fmtflags fmtflags;

    __stream_type& __stream_;
    fmtflags __fmtflags_;
    _CharT __fill_;

    __save_flags(const __save_flags&);
    __save_flags& operator=(const __save_flags&);
public:
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    explicit __save_flags(__stream_type& __stream)
        : __stream_(__stream),
          __fmtflags_(__stream.flags()),
          __fill_(__stream.fill())
        {}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    ~__save_flags()
    {
        __stream_.flags(__fmtflags_);
        __stream_.fill(__fill_);
    }
};

}}
# 21 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__random/uniform_int_distribution.h" 2 3
# 25 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__random/uniform_int_distribution.h" 3



# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__undef_macros" 1 3
# 29 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__random/uniform_int_distribution.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template<class _Engine, class _UIntType>
class __independent_bits_engine
{
public:

    typedef _UIntType result_type;

private:
    typedef typename _Engine::result_type _Engine_result_type;
    typedef __conditional_t<sizeof(_Engine_result_type) <= sizeof(result_type), result_type, _Engine_result_type>
        _Working_result_type;

    _Engine& __e_;
    size_t __w_;
    size_t __w0_;
    size_t __n_;
    size_t __n0_;
    _Working_result_type __y0_;
    _Working_result_type __y1_;
    _Engine_result_type __mask0_;
    _Engine_result_type __mask1_;





    static constexpr const _Working_result_type _Rp = _Engine::max() - _Engine::min()
                                                      + _Working_result_type(1);

    static constexpr const size_t __m = __log2<_Working_result_type, _Rp>::value;
    static constexpr const size_t _WDt = numeric_limits<_Working_result_type>::digits;
    static constexpr const size_t _EDt = numeric_limits<_Engine_result_type>::digits;

public:

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) __independent_bits_engine(_Engine& __e, size_t __w);


    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) result_type operator()() {return __eval(integral_constant<bool, _Rp != 0>());}

private:
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) result_type __eval(false_type);
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) result_type __eval(true_type);
};

template<class _Engine, class _UIntType>
__independent_bits_engine<_Engine, _UIntType>
    ::__independent_bits_engine(_Engine& __e, size_t __w)
        : __e_(__e),
          __w_(__w)
{
    __n_ = __w_ / __m + (__w_ % __m != 0);
    __w0_ = __w_ / __n_;
    if (_Rp == 0)
        __y0_ = _Rp;
    else if (__w0_ < _WDt)
        __y0_ = (_Rp >> __w0_) << __w0_;
    else
        __y0_ = 0;
    if (_Rp - __y0_ > __y0_ / __n_)
    {
        ++__n_;
        __w0_ = __w_ / __n_;
        if (__w0_ < _WDt)
            __y0_ = (_Rp >> __w0_) << __w0_;
        else
            __y0_ = 0;
    }
    __n0_ = __n_ - __w_ % __n_;
    if (__w0_ < _WDt - 1)
        __y1_ = (_Rp >> (__w0_ + 1)) << (__w0_ + 1);
    else
        __y1_ = 0;
    __mask0_ = __w0_ > 0 ? _Engine_result_type(~0) >> (_EDt - __w0_) :
                          _Engine_result_type(0);
    __mask1_ = __w0_ < _EDt - 1 ?
                               _Engine_result_type(~0) >> (_EDt - (__w0_ + 1)) :
                               _Engine_result_type(~0);
}

template<class _Engine, class _UIntType>
inline
_UIntType
__independent_bits_engine<_Engine, _UIntType>::__eval(false_type)
{
    return static_cast<result_type>(__e_() & __mask0_);
}

template<class _Engine, class _UIntType>
_UIntType
__independent_bits_engine<_Engine, _UIntType>::__eval(true_type)
{
    const size_t __w_rt = numeric_limits<result_type>::digits;
    result_type __sp = 0;
    for (size_t __k = 0; __k < __n0_; ++__k)
    {
        _Engine_result_type __u;
        do
        {
            __u = __e_() - _Engine::min();
        } while (__u >= __y0_);
        if (__w0_ < __w_rt)
            __sp <<= __w0_;
        else
            __sp = 0;
        __sp += __u & __mask0_;
    }
    for (size_t __k = __n0_; __k < __n_; ++__k)
    {
        _Engine_result_type __u;
        do
        {
            __u = __e_() - _Engine::min();
        } while (__u >= __y1_);
        if (__w0_ < __w_rt - 1)
            __sp <<= __w0_ + 1;
        else
            __sp = 0;
        __sp += __u & __mask1_;
    }
    return __sp;
}

template<class _IntType = int>
class uniform_int_distribution
{
    static_assert(__libcpp_random_is_valid_inttype<_IntType>::value, "IntType must be a supported integer type");
public:

    typedef _IntType result_type;

    class param_type
    {
        result_type __a_;
        result_type __b_;
    public:
        typedef uniform_int_distribution distribution_type;

        __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) explicit param_type(result_type __a = 0,
                            result_type __b = numeric_limits<result_type>::max())
            : __a_(__a), __b_(__b) {}

        __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) result_type a() const {return __a_;}
        __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) result_type b() const {return __b_;}

        __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
        friend bool operator==(const param_type& __x, const param_type& __y)
            {return __x.__a_ == __y.__a_ && __x.__b_ == __y.__b_;}
        __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
        friend bool operator!=(const param_type& __x, const param_type& __y)
            {return !(__x == __y);}
    };

private:
    param_type __p_;

public:


    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) uniform_int_distribution() : uniform_int_distribution(0) {}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) explicit uniform_int_distribution(
        result_type __a, result_type __b = numeric_limits<result_type>::max())
        : __p_(param_type(__a, __b)) {}






    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) explicit uniform_int_distribution(const param_type& __p) : __p_(__p) {}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) void reset() {}


    template<class _URNG>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) result_type operator()(_URNG& __g)
        {return (*this)(__g, __p_);}
    template<class _URNG>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) result_type operator()(_URNG& __g, const param_type& __p);


    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) result_type a() const {return __p_.a();}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) result_type b() const {return __p_.b();}

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) param_type param() const {return __p_;}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) void param(const param_type& __p) {__p_ = __p;}

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) result_type min() const {return a();}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) result_type max() const {return b();}

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    friend bool operator==(const uniform_int_distribution& __x,
                           const uniform_int_distribution& __y)
        {return __x.__p_ == __y.__p_;}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    friend bool operator!=(const uniform_int_distribution& __x,
                           const uniform_int_distribution& __y)
            {return !(__x == __y);}
};

template<class _IntType>
template<class _URNG>
typename uniform_int_distribution<_IntType>::result_type
uniform_int_distribution<_IntType>::operator()(_URNG& __g, const param_type& __p)
__attribute__((__no_sanitize__("unsigned-integer-overflow")))
{
    static_assert(__libcpp_random_is_valid_urng<_URNG>::value, "");
    typedef __conditional_t<sizeof(result_type) <= sizeof(uint32_t), uint32_t, __make_unsigned_t<result_type> >
        _UIntType;
    const _UIntType __rp = _UIntType(__p.b()) - _UIntType(__p.a()) + _UIntType(1);
    if (__rp == 1)
        return __p.a();
    const size_t __dt = numeric_limits<_UIntType>::digits;
    typedef __independent_bits_engine<_URNG, _UIntType> _Eng;
    if (__rp == 0)
        return static_cast<result_type>(_Eng(__g, __dt)());
    size_t __w = __dt - std::__countl_zero(__rp) - 1;
    if ((__rp & (numeric_limits<_UIntType>::max() >> (__dt - __w))) != 0)
        ++__w;
    _Eng __e(__g, __w);
    _UIntType __u;
    do
    {
        __u = __e();
    } while (__u >= __rp);
    return static_cast<result_type>(__u + __p.a());
}

template <class _CharT, class _Traits, class _IT>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os,
           const uniform_int_distribution<_IT>& __x)
{
    __save_flags<_CharT, _Traits> __lx(__os);
    typedef basic_ostream<_CharT, _Traits> _Ostream;
    __os.flags(_Ostream::dec | _Ostream::left);
    _CharT __sp = __os.widen(' ');
    __os.fill(__sp);
    return __os << __x.a() << __sp << __x.b();
}

template <class _CharT, class _Traits, class _IT>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) basic_istream<_CharT, _Traits>&
operator>>(basic_istream<_CharT, _Traits>& __is,
           uniform_int_distribution<_IT>& __x)
{
    typedef uniform_int_distribution<_IT> _Eng;
    typedef typename _Eng::result_type result_type;
    typedef typename _Eng::param_type param_type;
    __save_flags<_CharT, _Traits> __lx(__is);
    typedef basic_istream<_CharT, _Traits> _Istream;
    __is.flags(_Istream::dec | _Istream::skipws);
    result_type __a;
    result_type __b;
    __is >> __a >> __b;
    if (!__is.fail())
        __x.param(param_type(__a, __b));
    return __is;
}

}}
# 19 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/sample.h" 2 3
# 24 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/sample.h" 3



# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__undef_macros" 1 3
# 28 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/sample.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _AlgPolicy,
          class _PopulationIterator, class _PopulationSentinel, class _SampleIterator, class _Distance,
          class _UniformRandomNumberGenerator>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
_SampleIterator __sample(_PopulationIterator __first,
                         _PopulationSentinel __last, _SampleIterator __output_iter,
                         _Distance __n,
                         _UniformRandomNumberGenerator& __g,
                         input_iterator_tag) {

  _Distance __k = 0;
  for (; __first != __last && __k < __n; ++__first, (void) ++__k)
    __output_iter[__k] = *__first;
  _Distance __sz = __k;
  for (; __first != __last; ++__first, (void) ++__k) {
    _Distance __r = uniform_int_distribution<_Distance>(0, __k)(__g);
    if (__r < __sz)
      __output_iter[__r] = *__first;
  }
  return __output_iter + std::min(__n, __k);
}

template <class _AlgPolicy,
          class _PopulationIterator, class _PopulationSentinel, class _SampleIterator, class _Distance,
          class _UniformRandomNumberGenerator>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
_SampleIterator __sample(_PopulationIterator __first,
                         _PopulationSentinel __last, _SampleIterator __output_iter,
                         _Distance __n,
                         _UniformRandomNumberGenerator& __g,
                         forward_iterator_tag) {
  _Distance __unsampled_sz = _IterOps<_AlgPolicy>::distance(__first, __last);
  for (__n = std::min(__n, __unsampled_sz); __n != 0; ++__first) {
    _Distance __r = uniform_int_distribution<_Distance>(0, --__unsampled_sz)(__g);
    if (__r < __n) {
      *__output_iter++ = *__first;
      --__n;
    }
  }
  return __output_iter;
}

template <class _AlgPolicy,
          class _PopulationIterator, class _PopulationSentinel, class _SampleIterator, class _Distance,
          class _UniformRandomNumberGenerator>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
_SampleIterator __sample(_PopulationIterator __first,
                         _PopulationSentinel __last, _SampleIterator __output_iter,
                         _Distance __n, _UniformRandomNumberGenerator& __g) {
  ((void)0);

  using _PopIterCategory = typename _IterOps<_AlgPolicy>::template __iterator_category<_PopulationIterator>;
  using _Difference = typename _IterOps<_AlgPolicy>::template __difference_type<_PopulationIterator>;
  using _CommonType = typename common_type<_Distance, _Difference>::type;

  return std::__sample<_AlgPolicy>(
      std::move(__first), std::move(__last), std::move(__output_iter), _CommonType(__n),
      __g, _PopIterCategory());
}


template <class _PopulationIterator, class _SampleIterator, class _Distance,
          class _UniformRandomNumberGenerator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
_SampleIterator sample(_PopulationIterator __first,
                       _PopulationIterator __last, _SampleIterator __output_iter,
                       _Distance __n, _UniformRandomNumberGenerator&& __g) {
  static_assert(__has_forward_iterator_category<_PopulationIterator>::value ||
                __has_random_access_iterator_category<_SampleIterator>::value,
                "SampleIterator must meet the requirements of RandomAccessIterator");

  return std::__sample<_ClassicAlgPolicy>(
      std::move(__first), std::move(__last), std::move(__output_iter), __n, __g);
}



}}
# 14 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_sample.h" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/uniform_random_bit_generator_adaptor.h" 1 3
# 18 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/uniform_random_bit_generator_adaptor.h" 3





# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__undef_macros" 1 3
# 24 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/uniform_random_bit_generator_adaptor.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 35 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/uniform_random_bit_generator_adaptor.h" 3
template <class _Gen>
class _ClassicGenAdaptor {
private:

  _Gen& __gen_;

public:
  using result_type = invoke_result_t<_Gen&>;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
  static constexpr auto min() { return __remove_cvref_t<_Gen>::min(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
  static constexpr auto max() { return __remove_cvref_t<_Gen>::max(); }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
  constexpr explicit _ClassicGenAdaptor(_Gen& __g) : __gen_(__g) {}

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
  constexpr auto operator()() const { return __gen_(); }
};

}}
# 15 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_sample.h" 2 3




# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__random/uniform_random_bit_generator.h" 1 3
# 21 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__random/uniform_random_bit_generator.h" 3



# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__undef_macros" 1 3
# 25 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__random/uniform_random_bit_generator.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {




template<class _Gen>
concept uniform_random_bit_generator =
  invocable<_Gen&> && unsigned_integral<invoke_result_t<_Gen&>> &&
  requires {
    { _Gen::min() } -> same_as<invoke_result_t<_Gen&>>;
    { _Gen::max() } -> same_as<invoke_result_t<_Gen&>>;
    requires bool_constant<(_Gen::min() < _Gen::max())>::value;
  };



}}
# 20 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_sample.h" 2 3
# 28 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_sample.h" 3




namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

namespace ranges {
namespace __sample {

struct __fn {
  template <input_iterator _Iter, sentinel_for<_Iter> _Sent, weakly_incrementable _OutIter, class _Gen>
    requires(forward_iterator<_Iter> || random_access_iterator<_OutIter>) && indirectly_copyable<_Iter, _OutIter> &&
            uniform_random_bit_generator<remove_reference_t<_Gen>>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) _OutIter
  operator()(_Iter __first, _Sent __last, _OutIter __out_first, iter_difference_t<_Iter> __n, _Gen&& __gen) const {
    _ClassicGenAdaptor<_Gen> __adapted_gen(__gen);
    return std::__sample<_RangeAlgPolicy>(
        std::move(__first), std::move(__last), std::move(__out_first), __n, __adapted_gen);
  }

  template <input_range _Range, weakly_incrementable _OutIter, class _Gen>
    requires(forward_range<_Range> || random_access_iterator<_OutIter>) &&
            indirectly_copyable<iterator_t<_Range>, _OutIter> && uniform_random_bit_generator<remove_reference_t<_Gen>>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) _OutIter
  operator()(_Range&& __range, _OutIter __out_first, range_difference_t<_Range> __n, _Gen&& __gen) const {
    return (*this)(
        ranges::begin(__range), ranges::end(__range), std::move(__out_first), __n, std::forward<_Gen>(__gen));
  }
};

}

inline namespace __cpo {
inline constexpr auto sample = __sample::__fn{};
}
}

}}
# 1911 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/algorithm" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_search.h" 1 3
# 29 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_search.h" 3




namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

namespace ranges {
namespace __search {
struct __fn {
  template <class _Iter1, class _Sent1, class _Iter2, class _Sent2, class _Pred, class _Proj1, class _Proj2>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) static constexpr subrange<_Iter1> __ranges_search_impl(
      _Iter1 __first1,
      _Sent1 __last1,
      _Iter2 __first2,
      _Sent2 __last2,
      _Pred& __pred,
      _Proj1& __proj1,
      _Proj2& __proj2) {
    if constexpr (sized_sentinel_for<_Sent2, _Iter2>) {
      auto __size2 = ranges::distance(__first2, __last2);
      if (__size2 == 0)
        return {__first1, __first1};

      if constexpr (sized_sentinel_for<_Sent1, _Iter1>) {
        auto __size1 = ranges::distance(__first1, __last1);
        if (__size1 < __size2) {
          ranges::advance(__first1, __last1);
          return {__first1, __first1};
        }

        if constexpr (random_access_iterator<_Iter1> && random_access_iterator<_Iter2>) {
          auto __ret = std::__search_random_access_impl<_RangeAlgPolicy>(
              __first1, __last1, __first2, __last2, __pred, __proj1, __proj2, __size1, __size2);
          return {__ret.first, __ret.second};
        }
      }
    }

    auto __ret =
        std::__search_forward_impl<_RangeAlgPolicy>(__first1, __last1, __first2, __last2, __pred, __proj1, __proj2);
    return {__ret.first, __ret.second};
  }

  template <forward_iterator _Iter1,
            sentinel_for<_Iter1> _Sent1,
            forward_iterator _Iter2,
            sentinel_for<_Iter2> _Sent2,
            class _Pred = ranges::equal_to,
            class _Proj1 = identity,
            class _Proj2 = identity>
    requires indirectly_comparable<_Iter1, _Iter2, _Pred, _Proj1, _Proj2>
  [[__nodiscard__]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr subrange<_Iter1> operator()(
      _Iter1 __first1,
      _Sent1 __last1,
      _Iter2 __first2,
      _Sent2 __last2,
      _Pred __pred = {},
      _Proj1 __proj1 = {},
      _Proj2 __proj2 = {}) const {
    return __ranges_search_impl(__first1, __last1, __first2, __last2, __pred, __proj1, __proj2);
  }

  template <forward_range _Range1,
            forward_range _Range2,
            class _Pred = ranges::equal_to,
            class _Proj1 = identity,
            class _Proj2 = identity>
    requires indirectly_comparable<iterator_t<_Range1>, iterator_t<_Range2>, _Pred, _Proj1, _Proj2>
  [[__nodiscard__]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr borrowed_subrange_t<_Range1> operator()(
      _Range1&& __range1, _Range2&& __range2, _Pred __pred = {}, _Proj1 __proj1 = {}, _Proj2 __proj2 = {}) const {
    auto __first1 = ranges::begin(__range1);
    if constexpr (sized_range<_Range2>) {
      auto __size2 = ranges::size(__range2);
      if (__size2 == 0)
        return {__first1, __first1};
      if constexpr (sized_range<_Range1>) {
        auto __size1 = ranges::size(__range1);
        if (__size1 < __size2) {
          ranges::advance(__first1, ranges::end(__range1));
          return {__first1, __first1};
        }
      }
    }

    return __ranges_search_impl(
        ranges::begin(__range1),
        ranges::end(__range1),
        ranges::begin(__range2),
        ranges::end(__range2),
        __pred,
        __proj1,
        __proj2);
  }
};
}

inline namespace __cpo {
inline constexpr auto search = __search::__fn{};
}
}

}}
# 1912 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/algorithm" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_search_n.h" 1 3
# 13 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_search_n.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/search_n.h" 1 3
# 29 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/search_n.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _AlgPolicy, class _Pred, class _Iter, class _Sent, class _SizeT, class _Type, class _Proj>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
pair<_Iter, _Iter> __search_n_forward_impl(_Iter __first, _Sent __last,
                                           _SizeT __count,
                                           const _Type& __value,
                                           _Pred& __pred,
                                           _Proj& __proj) {
  if (__count <= 0)
    return std::make_pair(__first, __first);
  while (true) {

    while (true) {
      if (__first == __last) {
        _IterOps<_AlgPolicy>::__advance_to(__first, __last);
        return std::make_pair(__first, __first);
      }
      if (std::__invoke(__pred, std::__invoke(__proj, *__first), __value))
        break;
      ++__first;
    }

    _Iter __m = __first;
    _SizeT __c(0);
    while (true) {
      if (++__c == __count)
        return std::make_pair(__first, ++__m);
      if (++__m == __last) {
        _IterOps<_AlgPolicy>::__advance_to(__first, __last);
        return std::make_pair(__first, __first);
      }


      if (!std::__invoke(__pred, std::__invoke(__proj, *__m), __value))
      {
        __first = __m;
        ++__first;
        break;
      }
    }
  }
}

template <class _AlgPolicy, class _Pred, class _Iter, class _Sent, class _SizeT, class _Type, class _Proj, class _DiffT>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
std::pair<_Iter, _Iter> __search_n_random_access_impl(_Iter __first, _Sent __last,
                                                      _SizeT __count,
                                                      const _Type& __value,
                                                      _Pred& __pred,
                                                      _Proj& __proj,
                                                      _DiffT __size1) {
  using difference_type = typename iterator_traits<_Iter>::difference_type;
  if (__count == 0)
    return std::make_pair(__first, __first);
  if (__size1 < static_cast<_DiffT>(__count)) {
    _IterOps<_AlgPolicy>::__advance_to(__first, __last);
    return std::make_pair(__first, __first);
  }

  const auto __s = __first + __size1 - difference_type(__count - 1);
  while (true) {

    while (true) {
      if (__first >= __s) {
        _IterOps<_AlgPolicy>::__advance_to(__first, __last);
        return std::make_pair(__first, __first);
      }
      if (std::__invoke(__pred, std::__invoke(__proj, *__first), __value))
        break;
      ++__first;
    }

    auto __m = __first;
    _SizeT __c(0);
    while (true) {
      if (++__c == __count)
        return std::make_pair(__first, __first + _DiffT(__count));
      ++__m;


      if (!std::__invoke(__pred, std::__invoke(__proj, *__m), __value))
      {
        __first = __m;
        ++__first;
        break;
      }
    }
  }
}

template <class _Iter, class _Sent,
          class _DiffT,
          class _Type,
          class _Pred,
          class _Proj>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
pair<_Iter, _Iter> __search_n_impl(_Iter __first, _Sent __last,
                                   _DiffT __count,
                                   const _Type& __value,
                                   _Pred& __pred,
                                   _Proj& __proj,
                                   __enable_if_t<__has_random_access_iterator_category<_Iter>::value>* = nullptr) {
  return std::__search_n_random_access_impl<_ClassicAlgPolicy>(__first, __last,
                                                               __count,
                                                               __value,
                                                               __pred,
                                                               __proj,
                                                               __last - __first);
}

template <class _Iter1, class _Sent1,
          class _DiffT,
          class _Type,
          class _Pred,
          class _Proj>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
pair<_Iter1, _Iter1> __search_n_impl(_Iter1 __first, _Sent1 __last,
                                     _DiffT __count,
                                     const _Type& __value,
                                     _Pred& __pred,
                                     _Proj& __proj,
                                     __enable_if_t<__has_forward_iterator_category<_Iter1>::value
                                               && !__has_random_access_iterator_category<_Iter1>::value>* = nullptr) {
  return std::__search_n_forward_impl<_ClassicAlgPolicy>(__first, __last,
                                                         __count,
                                                         __value,
                                                         __pred,
                                                         __proj);
}

template <class _ForwardIterator, class _Size, class _Tp, class _BinaryPredicate>
[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
_ForwardIterator search_n(_ForwardIterator __first, _ForwardIterator __last,
                          _Size __count,
                          const _Tp& __value,
                          _BinaryPredicate __pred) {
  static_assert(__is_callable<_BinaryPredicate, decltype(*__first), const _Tp&>::value,
                "BinaryPredicate has to be callable");
  auto __proj = __identity();
  return std::__search_n_impl(__first, __last, std::__convert_to_integral(__count), __value, __pred, __proj).first;
}

template <class _ForwardIterator, class _Size, class _Tp>
[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
_ForwardIterator search_n(_ForwardIterator __first, _ForwardIterator __last, _Size __count, const _Tp& __value) {
  return std::search_n(__first, __last, std::__convert_to_integral(__count), __value, __equal_to());
}

}}
# 14 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_search_n.h" 2 3
# 32 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_search_n.h" 3




namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

namespace ranges {
namespace __search_n {
struct __fn {
  template <class _Iter1, class _Sent1, class _SizeT, class _Type, class _Pred, class _Proj>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) static constexpr subrange<_Iter1> __ranges_search_n_impl(
      _Iter1 __first, _Sent1 __last, _SizeT __count, const _Type& __value, _Pred& __pred, _Proj& __proj) {
    if (__count == 0)
      return {__first, __first};

    if constexpr (sized_sentinel_for<_Sent1, _Iter1>) {
      auto __size = ranges::distance(__first, __last);
      if (__size < __count) {
        ranges::advance(__first, __last);
        return {__first, __first};
      }

      if constexpr (random_access_iterator<_Iter1>) {
        auto __ret = std::__search_n_random_access_impl<_RangeAlgPolicy>(
            __first, __last, __count, __value, __pred, __proj, __size);
        return {std::move(__ret.first), std::move(__ret.second)};
      }
    }

    auto __ret = std::__search_n_forward_impl<_RangeAlgPolicy>(__first, __last, __count, __value, __pred, __proj);
    return {std::move(__ret.first), std::move(__ret.second)};
  }

  template <forward_iterator _Iter,
            sentinel_for<_Iter> _Sent,
            class _Type,
            class _Pred = ranges::equal_to,
            class _Proj = identity>
    requires indirectly_comparable<_Iter, const _Type*, _Pred, _Proj>
  [[__nodiscard__]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr subrange<_Iter>
  operator()(_Iter __first,
             _Sent __last,
             iter_difference_t<_Iter> __count,
             const _Type& __value,
             _Pred __pred = {},
             _Proj __proj = _Proj{}) const {
    return __ranges_search_n_impl(__first, __last, __count, __value, __pred, __proj);
  }

  template <forward_range _Range, class _Type, class _Pred = ranges::equal_to, class _Proj = identity>
    requires indirectly_comparable<iterator_t<_Range>, const _Type*, _Pred, _Proj>
  [[__nodiscard__]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr borrowed_subrange_t<_Range> operator()(
      _Range&& __range, range_difference_t<_Range> __count, const _Type& __value, _Pred __pred = {}, _Proj __proj = {})
      const {
    auto __first = ranges::begin(__range);
    if (__count <= 0)
      return {__first, __first};
    if constexpr (sized_range<_Range>) {
      auto __size1 = ranges::size(__range);
      if (__size1 < static_cast<range_size_t<_Range>>(__count)) {
        ranges::advance(__first, ranges::end(__range));
        return {__first, __first};
      }
    }

    return __ranges_search_n_impl(ranges::begin(__range), ranges::end(__range), __count, __value, __pred, __proj);
  }
};
}

inline namespace __cpo {
inline constexpr auto search_n = __search_n::__fn{};
}
}

}}
# 1913 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/algorithm" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_set_difference.h" 1 3
# 15 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_set_difference.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/set_difference.h" 1 3
# 26 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/set_difference.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _AlgPolicy, class _Comp, class _InIter1, class _Sent1, class _InIter2, class _Sent2, class _OutIter>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr pair<__remove_cvref_t<_InIter1>, __remove_cvref_t<_OutIter> >
__set_difference(
    _InIter1&& __first1, _Sent1&& __last1, _InIter2&& __first2, _Sent2&& __last2, _OutIter&& __result, _Comp&& __comp) {
  while (__first1 != __last1 && __first2 != __last2) {
    if (__comp(*__first1, *__first2)) {
      *__result = *__first1;
      ++__first1;
      ++__result;
    } else if (__comp(*__first2, *__first1)) {
      ++__first2;
    } else {
      ++__first1;
      ++__first2;
    }
  }
  return std::__copy<_AlgPolicy>(std::move(__first1), std::move(__last1), std::move(__result));
}

template <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _Compare>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr _OutputIterator set_difference(
    _InputIterator1 __first1,
    _InputIterator1 __last1,
    _InputIterator2 __first2,
    _InputIterator2 __last2,
    _OutputIterator __result,
    _Compare __comp) {
  return std::__set_difference<_ClassicAlgPolicy, __comp_ref_type<_Compare> >(
      __first1, __last1, __first2, __last2, __result, __comp)
      .second;
}

template <class _InputIterator1, class _InputIterator2, class _OutputIterator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr _OutputIterator set_difference(
    _InputIterator1 __first1,
    _InputIterator1 __last1,
    _InputIterator2 __first2,
    _InputIterator2 __last2,
    _OutputIterator __result) {
  return std::__set_difference<_ClassicAlgPolicy>(__first1, __last1, __first2, __last2, __result, __less<>()).second;
}

}}
# 16 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_set_difference.h" 2 3
# 31 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_set_difference.h" 3




namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

namespace ranges {

template <class _InIter, class _OutIter>
using set_difference_result = in_out_result<_InIter, _OutIter>;

namespace __set_difference {

struct __fn {
  template <input_iterator _InIter1,
            sentinel_for<_InIter1> _Sent1,
            input_iterator _InIter2,
            sentinel_for<_InIter2> _Sent2,
            weakly_incrementable _OutIter,
            class _Comp = less,
            class _Proj1 = identity,
            class _Proj2 = identity>
    requires mergeable<_InIter1, _InIter2, _OutIter, _Comp, _Proj1, _Proj2>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr set_difference_result<_InIter1, _OutIter> operator()(
      _InIter1 __first1,
      _Sent1 __last1,
      _InIter2 __first2,
      _Sent2 __last2,
      _OutIter __result,
      _Comp __comp = {},
      _Proj1 __proj1 = {},
      _Proj2 __proj2 = {}) const {
    auto __ret = std::__set_difference<_RangeAlgPolicy>(
        __first1, __last1, __first2, __last2, __result, ranges::__make_projected_comp(__comp, __proj1, __proj2));
    return {std::move(__ret.first), std::move(__ret.second)};
  }

  template <input_range _Range1,
            input_range _Range2,
            weakly_incrementable _OutIter,
            class _Comp = less,
            class _Proj1 = identity,
            class _Proj2 = identity>
    requires mergeable<iterator_t<_Range1>, iterator_t<_Range2>, _OutIter, _Comp, _Proj1, _Proj2>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr set_difference_result<borrowed_iterator_t<_Range1>, _OutIter>
  operator()(_Range1&& __range1,
             _Range2&& __range2,
             _OutIter __result,
             _Comp __comp = {},
             _Proj1 __proj1 = {},
             _Proj2 __proj2 = {}) const {
    auto __ret = std::__set_difference<_RangeAlgPolicy>(
        ranges::begin(__range1),
        ranges::end(__range1),
        ranges::begin(__range2),
        ranges::end(__range2),
        __result,
        ranges::__make_projected_comp(__comp, __proj1, __proj2));
    return {std::move(__ret.first), std::move(__ret.second)};
  }
};

}

inline namespace __cpo {
inline constexpr auto set_difference = __set_difference::__fn{};
}
}

}}
# 1914 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/algorithm" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_set_intersection.h" 1 3
# 15 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_set_intersection.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/set_intersection.h" 1 3
# 22 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/set_intersection.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _InIter1, class _InIter2, class _OutIter>
struct __set_intersection_result {
  _InIter1 __in1_;
  _InIter2 __in2_;
  _OutIter __out_;


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
  __set_intersection_result(_InIter1&& __in_iter1, _InIter2&& __in_iter2, _OutIter&& __out_iter)
      : __in1_(std::move(__in_iter1)), __in2_(std::move(__in_iter2)), __out_(std::move(__out_iter)) {}
};

template <class _AlgPolicy, class _Compare, class _InIter1, class _Sent1, class _InIter2, class _Sent2, class _OutIter>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr __set_intersection_result<_InIter1, _InIter2, _OutIter>
__set_intersection(
    _InIter1 __first1, _Sent1 __last1, _InIter2 __first2, _Sent2 __last2, _OutIter __result, _Compare&& __comp) {
  while (__first1 != __last1 && __first2 != __last2) {
    if (__comp(*__first1, *__first2))
      ++__first1;
    else {
      if (!__comp(*__first2, *__first1)) {
        *__result = *__first1;
        ++__result;
        ++__first1;
      }
      ++__first2;
    }
  }

  return __set_intersection_result<_InIter1, _InIter2, _OutIter>(
      _IterOps<_AlgPolicy>::next(std::move(__first1), std::move(__last1)),
      _IterOps<_AlgPolicy>::next(std::move(__first2), std::move(__last2)),
      std::move(__result));
}

template <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _Compare>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr _OutputIterator set_intersection(
    _InputIterator1 __first1,
    _InputIterator1 __last1,
    _InputIterator2 __first2,
    _InputIterator2 __last2,
    _OutputIterator __result,
    _Compare __comp) {
  return std::__set_intersection<_ClassicAlgPolicy, __comp_ref_type<_Compare> >(
             std::move(__first1),
             std::move(__last1),
             std::move(__first2),
             std::move(__last2),
             std::move(__result),
             __comp)
      .__out_;
}

template <class _InputIterator1, class _InputIterator2, class _OutputIterator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr _OutputIterator set_intersection(
    _InputIterator1 __first1,
    _InputIterator1 __last1,
    _InputIterator2 __first2,
    _InputIterator2 __last2,
    _OutputIterator __result) {
  return std::__set_intersection<_ClassicAlgPolicy>(
             std::move(__first1),
             std::move(__last1),
             std::move(__first2),
             std::move(__last2),
             std::move(__result),
             __less<>())
      .__out_;
}

}}
# 16 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_set_intersection.h" 2 3
# 29 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_set_intersection.h" 3




namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

namespace ranges {

template <class _InIter1, class _InIter2, class _OutIter>
using set_intersection_result = in_in_out_result<_InIter1, _InIter2, _OutIter>;

namespace __set_intersection {

struct __fn {
  template <input_iterator _InIter1,
            sentinel_for<_InIter1> _Sent1,
            input_iterator _InIter2,
            sentinel_for<_InIter2> _Sent2,
            weakly_incrementable _OutIter,
            class _Comp = less,
            class _Proj1 = identity,
            class _Proj2 = identity>
    requires mergeable<_InIter1, _InIter2, _OutIter, _Comp, _Proj1, _Proj2>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr set_intersection_result<_InIter1, _InIter2, _OutIter> operator()(
      _InIter1 __first1,
      _Sent1 __last1,
      _InIter2 __first2,
      _Sent2 __last2,
      _OutIter __result,
      _Comp __comp = {},
      _Proj1 __proj1 = {},
      _Proj2 __proj2 = {}) const {
    auto __ret = std::__set_intersection<_RangeAlgPolicy>(
        std::move(__first1),
        std::move(__last1),
        std::move(__first2),
        std::move(__last2),
        std::move(__result),
        ranges::__make_projected_comp(__comp, __proj1, __proj2));
    return {std::move(__ret.__in1_), std::move(__ret.__in2_), std::move(__ret.__out_)};
  }

  template <input_range _Range1,
            input_range _Range2,
            weakly_incrementable _OutIter,
            class _Comp = less,
            class _Proj1 = identity,
            class _Proj2 = identity>
    requires mergeable<iterator_t<_Range1>, iterator_t<_Range2>, _OutIter, _Comp, _Proj1, _Proj2>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr set_intersection_result<borrowed_iterator_t<_Range1>,
                                                          borrowed_iterator_t<_Range2>,
                                                          _OutIter>
  operator()(_Range1&& __range1,
             _Range2&& __range2,
             _OutIter __result,
             _Comp __comp = {},
             _Proj1 __proj1 = {},
             _Proj2 __proj2 = {}) const {
    auto __ret = std::__set_intersection<_RangeAlgPolicy>(
        ranges::begin(__range1),
        ranges::end(__range1),
        ranges::begin(__range2),
        ranges::end(__range2),
        std::move(__result),
        ranges::__make_projected_comp(__comp, __proj1, __proj2));
    return {std::move(__ret.__in1_), std::move(__ret.__in2_), std::move(__ret.__out_)};
  }
};

}

inline namespace __cpo {
inline constexpr auto set_intersection = __set_intersection::__fn{};
}
}

}}
# 1915 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/algorithm" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_set_symmetric_difference.h" 1 3
# 15 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_set_symmetric_difference.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/set_symmetric_difference.h" 1 3
# 23 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/set_symmetric_difference.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _InIter1, class _InIter2, class _OutIter>
struct __set_symmetric_difference_result {
  _InIter1 __in1_;
  _InIter2 __in2_;
  _OutIter __out_;


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
  __set_symmetric_difference_result(_InIter1&& __in_iter1, _InIter2&& __in_iter2, _OutIter&& __out_iter)
      : __in1_(std::move(__in_iter1)), __in2_(std::move(__in_iter2)), __out_(std::move(__out_iter)) {}
};

template <class _AlgPolicy, class _Compare, class _InIter1, class _Sent1, class _InIter2, class _Sent2, class _OutIter>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr __set_symmetric_difference_result<_InIter1, _InIter2, _OutIter>
__set_symmetric_difference(
    _InIter1 __first1, _Sent1 __last1, _InIter2 __first2, _Sent2 __last2, _OutIter __result, _Compare&& __comp) {
  while (__first1 != __last1) {
    if (__first2 == __last2) {
      auto __ret1 = std::__copy<_AlgPolicy>(std::move(__first1), std::move(__last1), std::move(__result));
      return __set_symmetric_difference_result<_InIter1, _InIter2, _OutIter>(
          std::move(__ret1.first), std::move(__first2), std::move((__ret1.second)));
    }
    if (__comp(*__first1, *__first2)) {
      *__result = *__first1;
      ++__result;
      ++__first1;
    } else {
      if (__comp(*__first2, *__first1)) {
        *__result = *__first2;
        ++__result;
      } else {
        ++__first1;
      }
      ++__first2;
    }
  }
  auto __ret2 = std::__copy<_AlgPolicy>(std::move(__first2), std::move(__last2), std::move(__result));
  return __set_symmetric_difference_result<_InIter1, _InIter2, _OutIter>(
      std::move(__first1), std::move(__ret2.first), std::move((__ret2.second)));
}

template <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _Compare>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr _OutputIterator set_symmetric_difference(
    _InputIterator1 __first1,
    _InputIterator1 __last1,
    _InputIterator2 __first2,
    _InputIterator2 __last2,
    _OutputIterator __result,
    _Compare __comp) {
  return std::__set_symmetric_difference<_ClassicAlgPolicy, __comp_ref_type<_Compare> >(
             std::move(__first1),
             std::move(__last1),
             std::move(__first2),
             std::move(__last2),
             std::move(__result),
             __comp)
      .__out_;
}

template <class _InputIterator1, class _InputIterator2, class _OutputIterator>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr _OutputIterator set_symmetric_difference(
    _InputIterator1 __first1,
    _InputIterator1 __last1,
    _InputIterator2 __first2,
    _InputIterator2 __last2,
    _OutputIterator __result) {
  return std::set_symmetric_difference(
      std::move(__first1),
      std::move(__last1),
      std::move(__first2),
      std::move(__last2),
      std::move(__result),
      __less<>());
}

}}
# 16 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_set_symmetric_difference.h" 2 3
# 29 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_set_symmetric_difference.h" 3




namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

namespace ranges {

template <class _InIter1, class _InIter2, class _OutIter>
using set_symmetric_difference_result = in_in_out_result<_InIter1, _InIter2, _OutIter>;

namespace __set_symmetric_difference {

struct __fn {
  template <input_iterator _InIter1,
            sentinel_for<_InIter1> _Sent1,
            input_iterator _InIter2,
            sentinel_for<_InIter2> _Sent2,
            weakly_incrementable _OutIter,
            class _Comp = ranges::less,
            class _Proj1 = identity,
            class _Proj2 = identity>
    requires mergeable<_InIter1, _InIter2, _OutIter, _Comp, _Proj1, _Proj2>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr set_symmetric_difference_result<_InIter1, _InIter2, _OutIter> operator()(
      _InIter1 __first1,
      _Sent1 __last1,
      _InIter2 __first2,
      _Sent2 __last2,
      _OutIter __result,
      _Comp __comp = {},
      _Proj1 __proj1 = {},
      _Proj2 __proj2 = {}) const {
    auto __ret = std::__set_symmetric_difference<_RangeAlgPolicy>(
        std::move(__first1),
        std::move(__last1),
        std::move(__first2),
        std::move(__last2),
        std::move(__result),
        ranges::__make_projected_comp(__comp, __proj1, __proj2));
    return {std::move(__ret.__in1_), std::move(__ret.__in2_), std::move(__ret.__out_)};
  }

  template <input_range _Range1,
            input_range _Range2,
            weakly_incrementable _OutIter,
            class _Comp = ranges::less,
            class _Proj1 = identity,
            class _Proj2 = identity>
    requires mergeable<iterator_t<_Range1>, iterator_t<_Range2>, _OutIter, _Comp, _Proj1, _Proj2>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr set_symmetric_difference_result<borrowed_iterator_t<_Range1>,
                                                                  borrowed_iterator_t<_Range2>,
                                                                  _OutIter>
  operator()(_Range1&& __range1,
             _Range2&& __range2,
             _OutIter __result,
             _Comp __comp = {},
             _Proj1 __proj1 = {},
             _Proj2 __proj2 = {}) const {
    auto __ret = std::__set_symmetric_difference<_RangeAlgPolicy>(
        ranges::begin(__range1),
        ranges::end(__range1),
        ranges::begin(__range2),
        ranges::end(__range2),
        std::move(__result),
        ranges::__make_projected_comp(__comp, __proj1, __proj2));
    return {std::move(__ret.__in1_), std::move(__ret.__in2_), std::move(__ret.__out_)};
  }
};

}

inline namespace __cpo {
inline constexpr auto set_symmetric_difference = __set_symmetric_difference::__fn{};
}
}

}}
# 1916 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/algorithm" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_set_union.h" 1 3
# 15 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_set_union.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/set_union.h" 1 3
# 23 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/set_union.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _InIter1, class _InIter2, class _OutIter>
struct __set_union_result {
  _InIter1 __in1_;
  _InIter2 __in2_;
  _OutIter __out_;


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
  __set_union_result(_InIter1&& __in_iter1, _InIter2&& __in_iter2, _OutIter&& __out_iter)
      : __in1_(std::move(__in_iter1)), __in2_(std::move(__in_iter2)), __out_(std::move(__out_iter)) {}
};

template <class _AlgPolicy, class _Compare, class _InIter1, class _Sent1, class _InIter2, class _Sent2, class _OutIter>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr __set_union_result<_InIter1, _InIter2, _OutIter> __set_union(
    _InIter1 __first1, _Sent1 __last1, _InIter2 __first2, _Sent2 __last2, _OutIter __result, _Compare&& __comp) {
  for (; __first1 != __last1; ++__result) {
    if (__first2 == __last2) {
      auto __ret1 = std::__copy<_AlgPolicy>(std::move(__first1), std::move(__last1), std::move(__result));
      return __set_union_result<_InIter1, _InIter2, _OutIter>(
          std::move(__ret1.first), std::move(__first2), std::move((__ret1.second)));
    }
    if (__comp(*__first2, *__first1)) {
      *__result = *__first2;
      ++__first2;
    } else {
      if (!__comp(*__first1, *__first2)) {
        ++__first2;
      }
      *__result = *__first1;
      ++__first1;
    }
  }
  auto __ret2 = std::__copy<_AlgPolicy>(std::move(__first2), std::move(__last2), std::move(__result));
  return __set_union_result<_InIter1, _InIter2, _OutIter>(
      std::move(__first1), std::move(__ret2.first), std::move((__ret2.second)));
}

template <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _Compare>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr _OutputIterator set_union(
    _InputIterator1 __first1,
    _InputIterator1 __last1,
    _InputIterator2 __first2,
    _InputIterator2 __last2,
    _OutputIterator __result,
    _Compare __comp) {
  return std::__set_union<_ClassicAlgPolicy, __comp_ref_type<_Compare> >(
             std::move(__first1),
             std::move(__last1),
             std::move(__first2),
             std::move(__last2),
             std::move(__result),
             __comp)
      .__out_;
}

template <class _InputIterator1, class _InputIterator2, class _OutputIterator>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr _OutputIterator set_union(
    _InputIterator1 __first1,
    _InputIterator1 __last1,
    _InputIterator2 __first2,
    _InputIterator2 __last2,
    _OutputIterator __result) {
  return std::set_union(
      std::move(__first1),
      std::move(__last1),
      std::move(__first2),
      std::move(__last2),
      std::move(__result),
      __less<>());
}

}}
# 16 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_set_union.h" 2 3
# 32 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_set_union.h" 3




namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

namespace ranges {

template <class _InIter1, class _InIter2, class _OutIter>
using set_union_result = in_in_out_result<_InIter1, _InIter2, _OutIter>;

namespace __set_union {

struct __fn {
  template <input_iterator _InIter1,
            sentinel_for<_InIter1> _Sent1,
            input_iterator _InIter2,
            sentinel_for<_InIter2> _Sent2,
            weakly_incrementable _OutIter,
            class _Comp = ranges::less,
            class _Proj1 = identity,
            class _Proj2 = identity>
    requires mergeable<_InIter1, _InIter2, _OutIter, _Comp, _Proj1, _Proj2>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr set_union_result<_InIter1, _InIter2, _OutIter> operator()(
      _InIter1 __first1,
      _Sent1 __last1,
      _InIter2 __first2,
      _Sent2 __last2,
      _OutIter __result,
      _Comp __comp = {},
      _Proj1 __proj1 = {},
      _Proj2 __proj2 = {}) const {
    auto __ret = std::__set_union<_RangeAlgPolicy>(
        std::move(__first1),
        std::move(__last1),
        std::move(__first2),
        std::move(__last2),
        std::move(__result),
        ranges::__make_projected_comp(__comp, __proj1, __proj2));
    return {std::move(__ret.__in1_), std::move(__ret.__in2_), std::move(__ret.__out_)};
  }

  template <input_range _Range1,
            input_range _Range2,
            weakly_incrementable _OutIter,
            class _Comp = ranges::less,
            class _Proj1 = identity,
            class _Proj2 = identity>
    requires mergeable<iterator_t<_Range1>, iterator_t<_Range2>, _OutIter, _Comp, _Proj1, _Proj2>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr set_union_result<borrowed_iterator_t<_Range1>, borrowed_iterator_t<_Range2>, _OutIter>
  operator()(_Range1&& __range1,
             _Range2&& __range2,
             _OutIter __result,
             _Comp __comp = {},
             _Proj1 __proj1 = {},
             _Proj2 __proj2 = {}) const {
    auto __ret = std::__set_union<_RangeAlgPolicy>(
        ranges::begin(__range1),
        ranges::end(__range1),
        ranges::begin(__range2),
        ranges::end(__range2),
        std::move(__result),
        ranges::__make_projected_comp(__comp, __proj1, __proj2));
    return {std::move(__ret.__in1_), std::move(__ret.__in2_), std::move(__ret.__out_)};
  }
};

}

inline namespace __cpo {
inline constexpr auto set_union = __set_union::__fn{};
}
}

}}
# 1917 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/algorithm" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_shuffle.h" 1 3
# 13 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_shuffle.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/shuffle.h" 1 3
# 24 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/shuffle.h" 3



# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__undef_macros" 1 3
# 28 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/shuffle.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

class __attribute__((__visibility__("default"))) __libcpp_debug_randomizer {
public:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) __libcpp_debug_randomizer() {
    __state_ = __seed();
    __inc_ = __state_ + 0xda3e39cb94b95bdbULL;
    __inc_ = (__inc_ << 1) | 1;
  }
  typedef uint_fast32_t result_type;

  static const result_type _Min = 0;
  static const result_type _Max = 0xFFFFFFFF;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) result_type operator()() {
    uint_fast64_t __oldstate = __state_;
    __state_ = __oldstate * 6364136223846793005ULL + __inc_;
    return __oldstate >> 32;
  }

  static __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr result_type min() { return _Min; }
  static __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr result_type max() { return _Max; }

private:
  uint_fast64_t __state_;
  uint_fast64_t __inc_;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) static uint_fast64_t __seed() {



    static char __x;
    return reinterpret_cast<uintptr_t>(&__x);

  }
};
# 139 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/shuffle.h" 3
template <class _AlgPolicy, class _RandomAccessIterator, class _Sentinel, class _UniformRandomNumberGenerator>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) _RandomAccessIterator __shuffle(
    _RandomAccessIterator __first, _Sentinel __last_sentinel, _UniformRandomNumberGenerator&& __g) {
    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
    typedef uniform_int_distribution<ptrdiff_t> _Dp;
    typedef typename _Dp::param_type _Pp;

    auto __original_last = _IterOps<_AlgPolicy>::next(__first, __last_sentinel);
    auto __last = __original_last;
    difference_type __d = __last - __first;
    if (__d > 1)
    {
        _Dp __uid;
        for (--__last, (void) --__d; __first < __last; ++__first, (void) --__d)
        {
            difference_type __i = __uid(__g, _Pp(0, __d));
            if (__i != difference_type(0))
                _IterOps<_AlgPolicy>::iter_swap(__first, __first + __i);
        }
    }

    return __original_last;
}

template <class _RandomAccessIterator, class _UniformRandomNumberGenerator>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) void
shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last, _UniformRandomNumberGenerator&& __g) {
  (void)std::__shuffle<_ClassicAlgPolicy>(
      std::move(__first), std::move(__last), std::forward<_UniformRandomNumberGenerator>(__g));
}

}}
# 14 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_shuffle.h" 2 3
# 32 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_shuffle.h" 3




namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

namespace ranges {
namespace __shuffle {

struct __fn {
  template <random_access_iterator _Iter, sentinel_for<_Iter> _Sent, class _Gen>
    requires permutable<_Iter> && uniform_random_bit_generator<remove_reference_t<_Gen>>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) _Iter operator()(_Iter __first, _Sent __last, _Gen&& __gen) const {
    _ClassicGenAdaptor<_Gen> __adapted_gen(__gen);
    return std::__shuffle<_RangeAlgPolicy>(std::move(__first), std::move(__last), __adapted_gen);
  }

  template <random_access_range _Range, class _Gen>
    requires permutable<iterator_t<_Range>> && uniform_random_bit_generator<remove_reference_t<_Gen>>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) borrowed_iterator_t<_Range> operator()(_Range&& __range, _Gen&& __gen) const {
    return (*this)(ranges::begin(__range), ranges::end(__range), std::forward<_Gen>(__gen));
  }
};

}

inline namespace __cpo {
inline constexpr auto shuffle = __shuffle::__fn{};
}
}

}}
# 1918 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/algorithm" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_sort.h" 1 3
# 32 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_sort.h" 3




namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

namespace ranges {
namespace __sort {

struct __fn {
  template <class _Iter, class _Sent, class _Comp, class _Proj>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr static _Iter
  __sort_fn_impl(_Iter __first, _Sent __last, _Comp& __comp, _Proj& __proj) {
    auto __last_iter = ranges::next(__first, __last);

    auto&& __projected_comp = std::__make_projected(__comp, __proj);
    std::__sort_impl<_RangeAlgPolicy>(std::move(__first), __last_iter, __projected_comp);

    return __last_iter;
  }

  template <random_access_iterator _Iter, sentinel_for<_Iter> _Sent, class _Comp = ranges::less, class _Proj = identity>
    requires sortable<_Iter, _Comp, _Proj>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr _Iter
  operator()(_Iter __first, _Sent __last, _Comp __comp = {}, _Proj __proj = {}) const {
    return __sort_fn_impl(std::move(__first), std::move(__last), __comp, __proj);
  }

  template <random_access_range _Range, class _Comp = ranges::less, class _Proj = identity>
    requires sortable<iterator_t<_Range>, _Comp, _Proj>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr borrowed_iterator_t<_Range>
  operator()(_Range&& __r, _Comp __comp = {}, _Proj __proj = {}) const {
    return __sort_fn_impl(ranges::begin(__r), ranges::end(__r), __comp, __proj);
  }
};

}

inline namespace __cpo {
inline constexpr auto sort = __sort::__fn{};
}
}

}}
# 1919 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/algorithm" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_sort_heap.h" 1 3
# 33 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_sort_heap.h" 3




namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

namespace ranges {
namespace __sort_heap {

struct __fn {
  template <class _Iter, class _Sent, class _Comp, class _Proj>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr static _Iter
  __sort_heap_fn_impl(_Iter __first, _Sent __last, _Comp& __comp, _Proj& __proj) {
    auto __last_iter = ranges::next(__first, __last);

    auto&& __projected_comp = std::__make_projected(__comp, __proj);
    std::__sort_heap<_RangeAlgPolicy>(std::move(__first), __last_iter, __projected_comp);

    return __last_iter;
  }

  template <random_access_iterator _Iter, sentinel_for<_Iter> _Sent, class _Comp = ranges::less, class _Proj = identity>
    requires sortable<_Iter, _Comp, _Proj>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr _Iter
  operator()(_Iter __first, _Sent __last, _Comp __comp = {}, _Proj __proj = {}) const {
    return __sort_heap_fn_impl(std::move(__first), std::move(__last), __comp, __proj);
  }

  template <random_access_range _Range, class _Comp = ranges::less, class _Proj = identity>
    requires sortable<iterator_t<_Range>, _Comp, _Proj>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr borrowed_iterator_t<_Range>
  operator()(_Range&& __r, _Comp __comp = {}, _Proj __proj = {}) const {
    return __sort_heap_fn_impl(ranges::begin(__r), ranges::end(__r), __comp, __proj);
  }
};

}

inline namespace __cpo {
inline constexpr auto sort_heap = __sort_heap::__fn{};
}
}

}}
# 1920 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/algorithm" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_stable_partition.h" 1 3
# 15 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_stable_partition.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/stable_partition.h" 1 3
# 27 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/stable_partition.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _AlgPolicy, class _Predicate, class _ForwardIterator, class _Distance, class _Pair>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) _ForwardIterator
__stable_partition_impl(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred,
                   _Distance __len, _Pair __p, forward_iterator_tag __fit)
{
    using _Ops = _IterOps<_AlgPolicy>;



    if (__len == 1)
        return __first;
    if (__len == 2)
    {
        _ForwardIterator __m = __first;
        if (__pred(*++__m))
        {
            _Ops::iter_swap(__first, __m);
            return __m;
        }
        return __first;
    }
    if (__len <= __p.second)
    {
        typedef typename iterator_traits<_ForwardIterator>::value_type value_type;
        __destruct_n __d(0);
        unique_ptr<value_type, __destruct_n&> __h(__p.first, __d);


        value_type* __t = __p.first;
        ::new ((void*)__t) value_type(_Ops::__iter_move(__first));
        __d.template __incr<value_type>();
        ++__t;
        _ForwardIterator __i = __first;
        while (++__i != __last)
        {
            if (__pred(*__i))
            {
                *__first = _Ops::__iter_move(__i);
                ++__first;
            }
            else
            {
                ::new ((void*)__t) value_type(_Ops::__iter_move(__i));
                __d.template __incr<value_type>();
                ++__t;
            }
        }


        __i = __first;
        for (value_type* __t2 = __p.first; __t2 < __t; ++__t2, (void) ++__i)
            *__i = _Ops::__iter_move(__t2);

        return __first;
    }


    _ForwardIterator __m = __first;
    _Distance __len2 = __len / 2;
    _Ops::advance(__m, __len2);



    _ForwardIterator __first_false = std::__stable_partition_impl<_AlgPolicy, _Predicate&>(
        __first, __m, __pred, __len2, __p, __fit);



    _ForwardIterator __m1 = __m;
    _ForwardIterator __second_false = __last;
    _Distance __len_half = __len - __len2;
    while (__pred(*__m1))
    {
        if (++__m1 == __last)
            goto __second_half_done;
        --__len_half;
    }


    __second_false = std::__stable_partition_impl<_AlgPolicy, _Predicate&>(
        __m1, __last, __pred, __len_half, __p, __fit);
__second_half_done:


    return std::__rotate<_AlgPolicy>(__first_false, __m, __second_false).first;


}

template <class _AlgPolicy, class _Predicate, class _ForwardIterator>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) _ForwardIterator
__stable_partition_impl(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred,
                   forward_iterator_tag)
{
    typedef typename iterator_traits<_ForwardIterator>::difference_type difference_type;
    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;

    const difference_type __alloc_limit = 3;

    while (true)
    {
        if (__first == __last)
            return __first;
        if (!__pred(*__first))
            break;
        ++__first;
    }


    difference_type __len = _IterOps<_AlgPolicy>::distance(__first, __last);
    pair<value_type*, ptrdiff_t> __p(0, 0);
    unique_ptr<value_type, __return_temporary_buffer> __h;
    if (__len >= __alloc_limit)
    {

#pragma GCC diagnostic push
# 146 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/stable_partition.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
# 146 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/stable_partition.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
        __p = std::get_temporary_buffer<value_type>(__len);
#pragma GCC diagnostic pop
        __h.reset(__p.first);
    }
    return std::__stable_partition_impl<_AlgPolicy, _Predicate&>(
        std::move(__first), std::move(__last), __pred, __len, __p, forward_iterator_tag());
}

template <class _AlgPolicy, class _Predicate, class _BidirectionalIterator, class _Distance, class _Pair>
_BidirectionalIterator
__stable_partition_impl(_BidirectionalIterator __first, _BidirectionalIterator __last, _Predicate __pred,
                   _Distance __len, _Pair __p, bidirectional_iterator_tag __bit)
{
    using _Ops = _IterOps<_AlgPolicy>;




    if (__len == 2)
    {
        _Ops::iter_swap(__first, __last);
        return __last;
    }
    if (__len == 3)
    {
        _BidirectionalIterator __m = __first;
        if (__pred(*++__m))
        {
            _Ops::iter_swap(__first, __m);
            _Ops::iter_swap(__m, __last);
            return __last;
        }
        _Ops::iter_swap(__m, __last);
        _Ops::iter_swap(__first, __m);
        return __m;
    }
    if (__len <= __p.second)
    {
        typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;
        __destruct_n __d(0);
        unique_ptr<value_type, __destruct_n&> __h(__p.first, __d);


        value_type* __t = __p.first;
        ::new ((void*)__t) value_type(_Ops::__iter_move(__first));
        __d.template __incr<value_type>();
        ++__t;
        _BidirectionalIterator __i = __first;
        while (++__i != __last)
        {
            if (__pred(*__i))
            {
                *__first = _Ops::__iter_move(__i);
                ++__first;
            }
            else
            {
                ::new ((void*)__t) value_type(_Ops::__iter_move(__i));
                __d.template __incr<value_type>();
                ++__t;
            }
        }

        *__first = _Ops::__iter_move(__i);
        __i = ++__first;


        for (value_type* __t2 = __p.first; __t2 < __t; ++__t2, (void) ++__i)
            *__i = _Ops::__iter_move(__t2);

        return __first;
    }


    _BidirectionalIterator __m = __first;
    _Distance __len2 = __len / 2;
    _Ops::advance(__m, __len2);



    _BidirectionalIterator __m1 = __m;
    _BidirectionalIterator __first_false = __first;
    _Distance __len_half = __len2;
    while (!__pred(*--__m1))
    {
        if (__m1 == __first)
            goto __first_half_done;
        --__len_half;
    }


    __first_false = std::__stable_partition_impl<_AlgPolicy, _Predicate&>(
        __first, __m1, __pred, __len_half, __p, __bit);
__first_half_done:



    __m1 = __m;
    _BidirectionalIterator __second_false = __last;
    ++__second_false;
    __len_half = __len - __len2;
    while (__pred(*__m1))
    {
        if (++__m1 == __last)
            goto __second_half_done;
        --__len_half;
    }


    __second_false = std::__stable_partition_impl<_AlgPolicy, _Predicate&>(
        __m1, __last, __pred, __len_half, __p, __bit);
__second_half_done:


    return std::__rotate<_AlgPolicy>(__first_false, __m, __second_false).first;


}

template <class _AlgPolicy, class _Predicate, class _BidirectionalIterator>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) _BidirectionalIterator
__stable_partition_impl(_BidirectionalIterator __first, _BidirectionalIterator __last, _Predicate __pred,
                   bidirectional_iterator_tag)
{
    typedef typename iterator_traits<_BidirectionalIterator>::difference_type difference_type;
    typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;
    const difference_type __alloc_limit = 4;

    while (true)
    {
        if (__first == __last)
            return __first;
        if (!__pred(*__first))
            break;
        ++__first;
    }


    do
    {
        if (__first == --__last)
            return __first;
    } while (!__pred(*__last));




    difference_type __len = _IterOps<_AlgPolicy>::distance(__first, __last) + 1;
    pair<value_type*, ptrdiff_t> __p(0, 0);
    unique_ptr<value_type, __return_temporary_buffer> __h;
    if (__len >= __alloc_limit)
    {

#pragma GCC diagnostic push
# 300 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/stable_partition.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
# 300 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/stable_partition.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
        __p = std::get_temporary_buffer<value_type>(__len);
#pragma GCC diagnostic pop
        __h.reset(__p.first);
    }
    return std::__stable_partition_impl<_AlgPolicy, _Predicate&>(
        std::move(__first), std::move(__last), __pred, __len, __p, bidirectional_iterator_tag());
}

template <class _AlgPolicy, class _Predicate, class _ForwardIterator, class _IterCategory>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
_ForwardIterator __stable_partition(
    _ForwardIterator __first, _ForwardIterator __last, _Predicate&& __pred, _IterCategory __iter_category) {
  return std::__stable_partition_impl<_AlgPolicy, __remove_cvref_t<_Predicate>&>(
      std::move(__first), std::move(__last), __pred, __iter_category);
}

template <class _ForwardIterator, class _Predicate>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
_ForwardIterator
stable_partition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred)
{
  using _IterCategory = typename iterator_traits<_ForwardIterator>::iterator_category;
  return std::__stable_partition<_ClassicAlgPolicy, _Predicate&>(
      std::move(__first), std::move(__last), __pred, _IterCategory());
}

}}
# 16 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_stable_partition.h" 2 3
# 35 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_stable_partition.h" 3




namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

namespace ranges {
namespace __stable_partition {

struct __fn {
  template <class _Iter, class _Sent, class _Proj, class _Pred>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) static subrange<__remove_cvref_t<_Iter>>
  __stable_partition_fn_impl(_Iter&& __first, _Sent&& __last, _Pred&& __pred, _Proj&& __proj) {
    auto __last_iter = ranges::next(__first, __last);

    auto&& __projected_pred = std::__make_projected(__pred, __proj);
    auto __result = std::__stable_partition<_RangeAlgPolicy>(
        std::move(__first), __last_iter, __projected_pred, __iterator_concept<_Iter>());

    return {std::move(__result), std::move(__last_iter)};
  }

  template <bidirectional_iterator _Iter,
            sentinel_for<_Iter> _Sent,
            class _Proj = identity,
            indirect_unary_predicate<projected<_Iter, _Proj>> _Pred>
    requires permutable<_Iter>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) subrange<_Iter> operator()(_Iter __first, _Sent __last, _Pred __pred, _Proj __proj = {}) const {
    return __stable_partition_fn_impl(__first, __last, __pred, __proj);
  }

  template <bidirectional_range _Range,
            class _Proj = identity,
            indirect_unary_predicate<projected<iterator_t<_Range>, _Proj>> _Pred>
    requires permutable<iterator_t<_Range>>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) borrowed_subrange_t<_Range>
  operator()(_Range&& __range, _Pred __pred, _Proj __proj = {}) const {
    return __stable_partition_fn_impl(ranges::begin(__range), ranges::end(__range), __pred, __proj);
  }
};

}

inline namespace __cpo {
inline constexpr auto stable_partition = __stable_partition::__fn{};
}
}

}}
# 1921 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/algorithm" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_stable_sort.h" 1 3
# 32 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_stable_sort.h" 3




namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

namespace ranges {
namespace __stable_sort {

struct __fn {
  template <class _Iter, class _Sent, class _Comp, class _Proj>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) static _Iter __stable_sort_fn_impl(_Iter __first, _Sent __last, _Comp& __comp, _Proj& __proj) {
    auto __last_iter = ranges::next(__first, __last);

    auto&& __projected_comp = std::__make_projected(__comp, __proj);
    std::__stable_sort_impl<_RangeAlgPolicy>(std::move(__first), __last_iter, __projected_comp);

    return __last_iter;
  }

  template <random_access_iterator _Iter, sentinel_for<_Iter> _Sent, class _Comp = ranges::less, class _Proj = identity>
    requires sortable<_Iter, _Comp, _Proj>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) _Iter operator()(_Iter __first, _Sent __last, _Comp __comp = {}, _Proj __proj = {}) const {
    return __stable_sort_fn_impl(std::move(__first), std::move(__last), __comp, __proj);
  }

  template <random_access_range _Range, class _Comp = ranges::less, class _Proj = identity>
    requires sortable<iterator_t<_Range>, _Comp, _Proj>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) borrowed_iterator_t<_Range>
  operator()(_Range&& __r, _Comp __comp = {}, _Proj __proj = {}) const {
    return __stable_sort_fn_impl(ranges::begin(__r), ranges::end(__r), __comp, __proj);
  }
};

}

inline namespace __cpo {
inline constexpr auto stable_sort = __stable_sort::__fn{};
}
}

}}
# 1922 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/algorithm" 2 3

# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_swap_ranges.h" 1 3
# 25 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_swap_ranges.h" 3




namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

namespace ranges {

template <class _I1, class _I2>
using swap_ranges_result = in_in_result<_I1, _I2>;

namespace __swap_ranges {
struct __fn {
  template <input_iterator _I1, sentinel_for<_I1> _S1, input_iterator _I2, sentinel_for<_I2> _S2>
    requires indirectly_swappable<_I1, _I2>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr swap_ranges_result<_I1, _I2>
  operator()(_I1 __first1, _S1 __last1, _I2 __first2, _S2 __last2) const {
    auto __ret = std::__swap_ranges<_RangeAlgPolicy>(
        std::move(__first1), std::move(__last1), std::move(__first2), std::move(__last2));
    return {std::move(__ret.first), std::move(__ret.second)};
  }

  template <input_range _R1, input_range _R2>
    requires indirectly_swappable<iterator_t<_R1>, iterator_t<_R2>>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr swap_ranges_result<borrowed_iterator_t<_R1>, borrowed_iterator_t<_R2>>
  operator()(_R1&& __r1, _R2&& __r2) const {
    return operator()(ranges::begin(__r1), ranges::end(__r1), ranges::begin(__r2), ranges::end(__r2));
  }
};
}

inline namespace __cpo {
inline constexpr auto swap_ranges = __swap_ranges::__fn{};
}
}

}}
# 1924 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/algorithm" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_transform.h" 1 3
# 27 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_transform.h" 3




namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

namespace ranges {

template <class _Ip, class _Op>
using unary_transform_result = in_out_result<_Ip, _Op>;

template <class _I1, class _I2, class _O1>
using binary_transform_result = in_in_out_result<_I1, _I2, _O1>;

namespace __transform {
struct __fn {
private:
  template <class _InIter, class _Sent, class _OutIter, class _Func, class _Proj>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) static constexpr unary_transform_result<_InIter, _OutIter>
  __unary(_InIter __first, _Sent __last, _OutIter __result, _Func& __operation, _Proj& __projection) {
    while (__first != __last) {
      *__result = std::invoke(__operation, std::invoke(__projection, *__first));
      ++__first;
      ++__result;
    }

    return {std::move(__first), std::move(__result)};
  }

  template <class _InIter1,
            class _Sent1,
            class _InIter2,
            class _Sent2,
            class _OutIter,
            class _Func,
            class _Proj1,
            class _Proj2>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) static constexpr binary_transform_result<_InIter1, _InIter2, _OutIter>
  __binary(_InIter1 __first1,
           _Sent1 __last1,
           _InIter2 __first2,
           _Sent2 __last2,
           _OutIter __result,
           _Func& __binary_operation,
           _Proj1& __projection1,
           _Proj2& __projection2) {
    while (__first1 != __last1 && __first2 != __last2) {
      *__result =
          std::invoke(__binary_operation, std::invoke(__projection1, *__first1), std::invoke(__projection2, *__first2));
      ++__first1;
      ++__first2;
      ++__result;
    }
    return {std::move(__first1), std::move(__first2), std::move(__result)};
  }

public:
  template <input_iterator _InIter,
            sentinel_for<_InIter> _Sent,
            weakly_incrementable _OutIter,
            copy_constructible _Func,
            class _Proj = identity>
    requires indirectly_writable<_OutIter, indirect_result_t<_Func&, projected<_InIter, _Proj>>>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr unary_transform_result<_InIter, _OutIter>
  operator()(_InIter __first, _Sent __last, _OutIter __result, _Func __operation, _Proj __proj = {}) const {
    return __unary(std::move(__first), std::move(__last), std::move(__result), __operation, __proj);
  }

  template <input_range _Range, weakly_incrementable _OutIter, copy_constructible _Func, class _Proj = identity>
    requires indirectly_writable<_OutIter, indirect_result_t<_Func, projected<iterator_t<_Range>, _Proj>>>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr unary_transform_result<borrowed_iterator_t<_Range>, _OutIter>
  operator()(_Range&& __range, _OutIter __result, _Func __operation, _Proj __projection = {}) const {
    return __unary(ranges::begin(__range), ranges::end(__range), std::move(__result), __operation, __projection);
  }

  template <input_iterator _InIter1,
            sentinel_for<_InIter1> _Sent1,
            input_iterator _InIter2,
            sentinel_for<_InIter2> _Sent2,
            weakly_incrementable _OutIter,
            copy_constructible _Func,
            class _Proj1 = identity,
            class _Proj2 = identity>
    requires indirectly_writable<_OutIter,
                                 indirect_result_t<_Func&, projected<_InIter1, _Proj1>, projected<_InIter2, _Proj2>>>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr binary_transform_result<_InIter1, _InIter2, _OutIter> operator()(
      _InIter1 __first1,
      _Sent1 __last1,
      _InIter2 __first2,
      _Sent2 __last2,
      _OutIter __result,
      _Func __binary_operation,
      _Proj1 __projection1 = {},
      _Proj2 __projection2 = {}) const {
    return __binary(
        std::move(__first1),
        std::move(__last1),
        std::move(__first2),
        std::move(__last2),
        std::move(__result),
        __binary_operation,
        __projection1,
        __projection2);
  }

  template <input_range _Range1,
            input_range _Range2,
            weakly_incrementable _OutIter,
            copy_constructible _Func,
            class _Proj1 = identity,
            class _Proj2 = identity>
    requires indirectly_writable<
        _OutIter,
        indirect_result_t<_Func&, projected<iterator_t<_Range1>, _Proj1>, projected<iterator_t<_Range2>, _Proj2>>>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr binary_transform_result<borrowed_iterator_t<_Range1>,
                                                          borrowed_iterator_t<_Range2>,
                                                          _OutIter>
  operator()(_Range1&& __range1,
             _Range2&& __range2,
             _OutIter __result,
             _Func __binary_operation,
             _Proj1 __projection1 = {},
             _Proj2 __projection2 = {}) const {
    return __binary(
        ranges::begin(__range1),
        ranges::end(__range1),
        ranges::begin(__range2),
        ranges::end(__range2),
        std::move(__result),
        __binary_operation,
        __projection1,
        __projection2);
  }
};
}

inline namespace __cpo {
inline constexpr auto transform = __transform::__fn{};
}
}

}}
# 1925 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/algorithm" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_unique.h" 1 3
# 14 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_unique.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/unique.h" 1 3
# 22 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/unique.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {



template <class _AlgPolicy, class _Iter, class _Sent, class _BinaryPredicate>
[[__nodiscard__]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr std::pair<_Iter, _Iter>
__unique(_Iter __first, _Sent __last, _BinaryPredicate&& __pred) {
  __first = std::__adjacent_find(__first, __last, __pred);
  if (__first != __last) {


    _Iter __i = __first;
    for (++__i; ++__i != __last;)
      if (!__pred(*__first, *__i))
        *++__first = _IterOps<_AlgPolicy>::__iter_move(__i);
    ++__first;
    return std::pair<_Iter, _Iter>(std::move(__first), std::move(__i));
  }
  return std::pair<_Iter, _Iter>(__first, __first);
}

template <class _ForwardIterator, class _BinaryPredicate>
[[__nodiscard__]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr _ForwardIterator
unique(_ForwardIterator __first, _ForwardIterator __last, _BinaryPredicate __pred) {
  return std::__unique<_ClassicAlgPolicy>(std::move(__first), std::move(__last), __pred).first;
}

template <class _ForwardIterator>
[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr _ForwardIterator
unique(_ForwardIterator __first, _ForwardIterator __last) {
  return std::unique(__first, __last, __equal_to());
}

}}
# 15 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_unique.h" 2 3
# 33 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_unique.h" 3




namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

namespace ranges {
namespace __unique {

struct __fn {
  template <permutable _Iter,
            sentinel_for<_Iter> _Sent,
            class _Proj = identity,
            indirect_equivalence_relation<projected<_Iter, _Proj>> _Comp = ranges::equal_to>
  [[__nodiscard__]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr subrange<_Iter>
  operator()(_Iter __first, _Sent __last, _Comp __comp = {}, _Proj __proj = {}) const {
    auto __ret =
        std::__unique<_RangeAlgPolicy>(std::move(__first), std::move(__last), std::__make_projected(__comp, __proj));
    return {std::move(__ret.first), std::move(__ret.second)};
  }

  template <forward_range _Range,
            class _Proj = identity,
            indirect_equivalence_relation<projected<iterator_t<_Range>, _Proj>> _Comp = ranges::equal_to>
    requires permutable<iterator_t<_Range>>
  [[__nodiscard__]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr borrowed_subrange_t<_Range>
  operator()(_Range&& __range, _Comp __comp = {}, _Proj __proj = {}) const {
    auto __ret = std::__unique<_RangeAlgPolicy>(
        ranges::begin(__range), ranges::end(__range), std::__make_projected(__comp, __proj));
    return {std::move(__ret.first), std::move(__ret.second)};
  }
};

}

inline namespace __cpo {
inline constexpr auto unique = __unique::__fn{};
}
}

}}
# 1926 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/algorithm" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_unique_copy.h" 1 3
# 15 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_unique_copy.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/unique_copy.h" 1 3
# 24 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/unique_copy.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

namespace __unique_copy_tags {

struct __reread_from_input_tag {};
struct __reread_from_output_tag {};
struct __read_from_tmp_value_tag {};

}

template <class _AlgPolicy, class _BinaryPredicate, class _InputIterator, class _Sent, class _OutputIterator>
constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) pair<_InputIterator, _OutputIterator>
__unique_copy(_InputIterator __first,
              _Sent __last,
              _OutputIterator __result,
              _BinaryPredicate&& __pred,
              __unique_copy_tags::__read_from_tmp_value_tag) {
  if (__first != __last) {
    typename _IterOps<_AlgPolicy>::template __value_type<_InputIterator> __t(*__first);
    *__result = __t;
    ++__result;
    while (++__first != __last) {
      if (!__pred(__t, *__first)) {
        __t = *__first;
        *__result = __t;
        ++__result;
      }
    }
  }
  return pair<_InputIterator, _OutputIterator>(std::move(__first), std::move(__result));
}

template <class _AlgPolicy, class _BinaryPredicate, class _ForwardIterator, class _Sent, class _OutputIterator>
constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) pair<_ForwardIterator, _OutputIterator>
__unique_copy(_ForwardIterator __first,
              _Sent __last,
              _OutputIterator __result,
              _BinaryPredicate&& __pred,
              __unique_copy_tags::__reread_from_input_tag) {
  if (__first != __last) {
    _ForwardIterator __i = __first;
    *__result = *__i;
    ++__result;
    while (++__first != __last) {
      if (!__pred(*__i, *__first)) {
        *__result = *__first;
        ++__result;
        __i = __first;
      }
    }
  }
  return pair<_ForwardIterator, _OutputIterator>(std::move(__first), std::move(__result));
}

template <class _AlgPolicy, class _BinaryPredicate, class _InputIterator, class _Sent, class _InputAndOutputIterator>
constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) pair<_InputIterator, _InputAndOutputIterator>
__unique_copy(_InputIterator __first,
              _Sent __last,
              _InputAndOutputIterator __result,
              _BinaryPredicate&& __pred,
              __unique_copy_tags::__reread_from_output_tag) {
  if (__first != __last) {
    *__result = *__first;
    while (++__first != __last)
      if (!__pred(*__result, *__first))
        *++__result = *__first;
    ++__result;
  }
  return pair<_InputIterator, _InputAndOutputIterator>(std::move(__first), std::move(__result));
}

template <class _InputIterator, class _OutputIterator, class _BinaryPredicate>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr _OutputIterator
unique_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _BinaryPredicate __pred) {
  using __algo_tag = __conditional_t<
      is_base_of<forward_iterator_tag, typename iterator_traits<_InputIterator>::iterator_category>::value,
      __unique_copy_tags::__reread_from_input_tag,
      __conditional_t<
          is_base_of<forward_iterator_tag, typename iterator_traits<_OutputIterator>::iterator_category>::value &&
              is_same< typename iterator_traits<_InputIterator>::value_type,
                       typename iterator_traits<_OutputIterator>::value_type>::value,
          __unique_copy_tags::__reread_from_output_tag,
          __unique_copy_tags::__read_from_tmp_value_tag> >;
  return std::__unique_copy<_ClassicAlgPolicy>(
             std::move(__first), std::move(__last), std::move(__result), __pred, __algo_tag())
      .second;
}

template <class _InputIterator, class _OutputIterator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr _OutputIterator
unique_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result) {
  return std::unique_copy(std::move(__first), std::move(__last), std::move(__result), __equal_to());
}

}}
# 16 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_unique_copy.h" 2 3
# 33 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_unique_copy.h" 3




namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

namespace ranges {

template <class _InIter, class _OutIter>
using unique_copy_result = in_out_result<_InIter, _OutIter>;

namespace __unique_copy {

template <class _InIter, class _OutIter>
concept __can_reread_from_output = (input_iterator<_OutIter> && same_as<iter_value_t<_InIter>, iter_value_t<_OutIter>>);

struct __fn {
  template <class _InIter, class _OutIter>
  static consteval auto __get_algo_tag() {
    if constexpr (forward_iterator<_InIter>) {
      return __unique_copy_tags::__reread_from_input_tag{};
    } else if constexpr (__can_reread_from_output<_InIter, _OutIter>) {
      return __unique_copy_tags::__reread_from_output_tag{};
    } else if constexpr (indirectly_copyable_storable<_InIter, _OutIter>) {
      return __unique_copy_tags::__read_from_tmp_value_tag{};
    }
  }

  template <class _InIter, class _OutIter>
  using __algo_tag_t = decltype(__get_algo_tag<_InIter, _OutIter>());

  template <input_iterator _InIter,
            sentinel_for<_InIter> _Sent,
            weakly_incrementable _OutIter,
            class _Proj = identity,
            indirect_equivalence_relation<projected<_InIter, _Proj>> _Comp = ranges::equal_to>
    requires indirectly_copyable<_InIter, _OutIter> &&
             (forward_iterator<_InIter> ||
              (input_iterator<_OutIter> && same_as<iter_value_t<_InIter>, iter_value_t<_OutIter>>) ||
              indirectly_copyable_storable<_InIter, _OutIter>)
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr unique_copy_result<_InIter, _OutIter>
  operator()(_InIter __first, _Sent __last, _OutIter __result, _Comp __comp = {}, _Proj __proj = {}) const {
    auto __ret = std::__unique_copy<_RangeAlgPolicy>(
        std::move(__first),
        std::move(__last),
        std::move(__result),
        std::__make_projected(__comp, __proj),
        __algo_tag_t<_InIter, _OutIter>());
    return {std::move(__ret.first), std::move(__ret.second)};
  }

  template <input_range _Range,
            weakly_incrementable _OutIter,
            class _Proj = identity,
            indirect_equivalence_relation<projected<iterator_t<_Range>, _Proj>> _Comp = ranges::equal_to>
    requires indirectly_copyable<iterator_t<_Range>, _OutIter> &&
             (forward_iterator<iterator_t<_Range>> ||
              (input_iterator<_OutIter> && same_as<range_value_t<_Range>, iter_value_t<_OutIter>>) ||
              indirectly_copyable_storable<iterator_t<_Range>, _OutIter>)
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr unique_copy_result<borrowed_iterator_t<_Range>, _OutIter>
  operator()(_Range&& __range, _OutIter __result, _Comp __comp = {}, _Proj __proj = {}) const {
    auto __ret = std::__unique_copy<_RangeAlgPolicy>(
        ranges::begin(__range),
        ranges::end(__range),
        std::move(__result),
        std::__make_projected(__comp, __proj),
        __algo_tag_t<iterator_t<_Range>, _OutIter>());
    return {std::move(__ret.first), std::move(__ret.second)};
  }
};

}

inline namespace __cpo {
inline constexpr auto unique_copy = __unique_copy::__fn{};
}
}

}}
# 1927 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/algorithm" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_upper_bound.h" 1 3
# 26 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/ranges_upper_bound.h" 3




namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

namespace ranges {
namespace __upper_bound {
struct __fn {
  template <forward_iterator _Iter,
            sentinel_for<_Iter> _Sent,
            class _Type,
            class _Proj = identity,
            indirect_strict_weak_order<const _Type*, projected<_Iter, _Proj>> _Comp = ranges::less>
  [[__nodiscard__]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr _Iter
  operator()(_Iter __first, _Sent __last, const _Type& __value, _Comp __comp = {}, _Proj __proj = {}) const {
    auto __comp_lhs_rhs_swapped = [&](const auto& __lhs, const auto& __rhs) {
      return !std::invoke(__comp, __rhs, __lhs);
    };

    return std::__lower_bound<_RangeAlgPolicy>(__first, __last, __value, __comp_lhs_rhs_swapped, __proj);
  }

  template <forward_range _Range,
            class _Type,
            class _Proj = identity,
            indirect_strict_weak_order<const _Type*, projected<iterator_t<_Range>, _Proj>> _Comp = ranges::less>
  [[__nodiscard__]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr borrowed_iterator_t<_Range>
  operator()(_Range&& __r, const _Type& __value, _Comp __comp = {}, _Proj __proj = {}) const {
    auto __comp_lhs_rhs_swapped = [&](const auto& __lhs, const auto& __rhs) {
      return !std::invoke(__comp, __rhs, __lhs);
    };

    return std::__lower_bound<_RangeAlgPolicy>(
        ranges::begin(__r), ranges::end(__r), __value, __comp_lhs_rhs_swapped, __proj);
  }
};
}

inline namespace __cpo {
inline constexpr auto upper_bound = __upper_bound::__fn{};
}
}

}}
# 1928 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/algorithm" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/remove.h" 1 3
# 19 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/remove.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _ForwardIterator, class _Tp>
[[__nodiscard__]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr _ForwardIterator
remove(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value)
{
    __first = std::find(__first, __last, __value);
    if (__first != __last)
    {
        _ForwardIterator __i = __first;
        while (++__i != __last)
        {
            if (!(*__i == __value))
            {
                *__first = std::move(*__i);
                ++__first;
            }
        }
    }
    return __first;
}

}}
# 1929 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/algorithm" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/remove_copy.h" 1 3
# 16 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/remove_copy.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _InputIterator, class _OutputIterator, class _Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
_OutputIterator
remove_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result, const _Tp& __value)
{
    for (; __first != __last; ++__first)
    {
        if (!(*__first == __value))
        {
            *__result = *__first;
            ++__result;
        }
    }
    return __result;
}

}}
# 1930 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/algorithm" 2 3

# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/remove_if.h" 1 3
# 18 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/remove_if.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _ForwardIterator, class _Predicate>
[[__nodiscard__]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr _ForwardIterator
remove_if(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred)
{
    __first = std::find_if<_ForwardIterator, _Predicate&>(__first, __last, __pred);
    if (__first != __last)
    {
        _ForwardIterator __i = __first;
        while (++__i != __last)
        {
            if (!__pred(*__i))
            {
                *__first = std::move(*__i);
                ++__first;
            }
        }
    }
    return __first;
}

}}
# 1932 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/algorithm" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/replace.h" 1 3
# 16 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/replace.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _ForwardIterator, class _Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
void
replace(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __old_value, const _Tp& __new_value)
{
    for (; __first != __last; ++__first)
        if (*__first == __old_value)
            *__first = __new_value;
}

}}
# 1933 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/algorithm" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/replace_copy.h" 1 3
# 16 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/replace_copy.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _InputIterator, class _OutputIterator, class _Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
_OutputIterator
replace_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result,
             const _Tp& __old_value, const _Tp& __new_value)
{
    for (; __first != __last; ++__first, (void) ++__result)
        if (*__first == __old_value)
            *__result = __new_value;
        else
            *__result = *__first;
    return __result;
}

}}
# 1934 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/algorithm" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/replace_copy_if.h" 1 3
# 16 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/replace_copy_if.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _InputIterator, class _OutputIterator, class _Predicate, class _Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
_OutputIterator
replace_copy_if(_InputIterator __first, _InputIterator __last, _OutputIterator __result,
                _Predicate __pred, const _Tp& __new_value)
{
    for (; __first != __last; ++__first, (void) ++__result)
        if (__pred(*__first))
            *__result = __new_value;
        else
            *__result = *__first;
    return __result;
}

}}
# 1935 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/algorithm" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/replace_if.h" 1 3
# 16 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/replace_if.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _ForwardIterator, class _Predicate, class _Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
void
replace_if(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred, const _Tp& __new_value)
{
    for (; __first != __last; ++__first)
        if (__pred(*__first))
            *__first = __new_value;
}

}}
# 1936 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/algorithm" 2 3

# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/reverse_copy.h" 1 3
# 16 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/reverse_copy.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _BidirectionalIterator, class _OutputIterator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
_OutputIterator
reverse_copy(_BidirectionalIterator __first, _BidirectionalIterator __last, _OutputIterator __result)
{
    for (; __first != __last; ++__result)
        *__result = *--__last;
    return __result;
}

}}
# 1938 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/algorithm" 2 3

# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/rotate_copy.h" 1 3
# 17 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/rotate_copy.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _ForwardIterator, class _OutputIterator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
_OutputIterator
rotate_copy(_ForwardIterator __first, _ForwardIterator __middle, _ForwardIterator __last, _OutputIterator __result)
{
    return std::copy(__first, __middle, std::copy(__middle, __last, __result));
}

}}
# 1940 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/algorithm" 2 3







# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/shift_left.h" 1 3
# 18 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/shift_left.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {



template <class _ForwardIterator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
_ForwardIterator
shift_left(_ForwardIterator __first, _ForwardIterator __last,
           typename iterator_traits<_ForwardIterator>::difference_type __n)
{
    if (__n == 0) {
        return __last;
    }

    _ForwardIterator __m = __first;
    if constexpr (__has_random_access_iterator_category<_ForwardIterator>::value) {
        if (__n >= __last - __first) {
            return __first;
        }
        __m += __n;
    } else {
        for (; __n > 0; --__n) {
            if (__m == __last) {
                return __first;
            }
            ++__m;
        }
    }
    return std::move(__m, __last, __first);
}



}}
# 1948 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/algorithm" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/shift_right.h" 1 3
# 21 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__algorithm/shift_right.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {



template <class _ForwardIterator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
_ForwardIterator
shift_right(_ForwardIterator __first, _ForwardIterator __last,
            typename iterator_traits<_ForwardIterator>::difference_type __n)
{
    if (__n == 0) {
        return __first;
    }

    if constexpr (__has_random_access_iterator_category<_ForwardIterator>::value) {
        decltype(__n) __d = __last - __first;
        if (__n >= __d) {
            return __last;
        }
        _ForwardIterator __m = __first + (__d - __n);
        return std::move_backward(__first, __m, __last);
    } else if constexpr (__has_bidirectional_iterator_category<_ForwardIterator>::value) {
        _ForwardIterator __m = __last;
        for (; __n > 0; --__n) {
            if (__m == __first) {
                return __last;
            }
            --__m;
        }
        return std::move_backward(__first, __m, __last);
    } else {
        _ForwardIterator __ret = __first;
        for (; __n > 0; --__n) {
            if (__ret == __last) {
                return __last;
            }
            ++__ret;
        }







        auto __trail = __first;
        auto __lead = __ret;
        while (__trail != __ret) {
            if (__lead == __last) {
                std::move(__first, __trail, __ret);
                return __ret;
            }
            ++__trail;
            ++__lead;
        }

        _ForwardIterator __mid = __first;
        while (true) {
            if (__lead == __last) {
                __trail = std::move(__mid, __ret, __trail);
                std::move(__first, __mid, __trail);
                return __ret;
            }
            swap(*__mid, *__trail);
            ++__mid;
            ++__trail;
            ++__lead;
            if (__mid == __ret) {
                __mid = __first;
            }
        }
    }
}



}}
# 1949 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/algorithm" 2 3
# 1969 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/algorithm" 3
# 2 "src/transform_reduce/std_vector.cpp" 2

# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/cassert" 1 3
# 24 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/cassert" 3
# 1 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/llvm_libc_wrappers/assert.h" 1 3
# 16 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/llvm_libc_wrappers/assert.h" 3
# 1 "/usr/include/assert.h" 1 3 4
# 64 "/usr/include/assert.h" 3 4
extern "C" {


extern void __assert_fail (const char *__assertion, const char *__file,
      unsigned int __line, const char *__function)
     throw () __attribute__ ((__noreturn__));


extern void __assert_perror_fail (int __errnum, const char *__file,
      unsigned int __line, const char *__function)
     throw () __attribute__ ((__noreturn__));




extern void __assert (const char *__assertion, const char *__file, int __line)
     throw () __attribute__ ((__noreturn__));


}
# 17 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/llvm_libc_wrappers/assert.h" 2 3
# 25 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/cassert" 2 3
# 32 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/cassert" 3
# 4 "src/transform_reduce/std_vector.cpp" 2
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/vector" 1 3
# 316 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/vector" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__bit_reference" 1 3
# 18 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__bit_reference" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__bit/popcount.h" 1 3
# 19 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__bit/popcount.h" 3



# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__undef_macros" 1 3
# 23 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__bit/popcount.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
int __libcpp_popcount(unsigned __x) noexcept { return __builtin_popcount(__x); }

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
int __libcpp_popcount(unsigned long __x) noexcept { return __builtin_popcountl(__x); }

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
int __libcpp_popcount(unsigned long long __x) noexcept { return __builtin_popcountll(__x); }



template <__libcpp_unsigned_integer _Tp>
[[__nodiscard__]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr int popcount(_Tp __t) noexcept {
  if (sizeof(_Tp) <= sizeof(unsigned int))
    return std::__libcpp_popcount(static_cast<unsigned int>(__t));
  else if (sizeof(_Tp) <= sizeof(unsigned long))
    return std::__libcpp_popcount(static_cast<unsigned long>(__t));
  else if (sizeof(_Tp) <= sizeof(unsigned long long))
    return std::__libcpp_popcount(static_cast<unsigned long long>(__t));
  else {
    int __ret = 0;
    while (__t != 0) {
      __ret += std::__libcpp_popcount(static_cast<unsigned long long>(__t));
      __t >>= numeric_limits<unsigned long long>::digits;
    }
    return __ret;
  }
}



}}
# 19 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__bit_reference" 2 3
# 30 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__bit_reference" 3



# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__undef_macros" 1 3
# 34 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__bit_reference" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Cp>
class __bit_const_reference;

template <class _Tp>
struct __has_storage_type {
  static const bool value = false;
};

template <class _Cp, bool = __has_storage_type<_Cp>::value>
class __bit_reference {
  using __storage_type = typename _Cp::__storage_type;
  using __storage_pointer = typename _Cp::__storage_pointer;

  __storage_pointer __seg_;
  __storage_type __mask_;

  friend typename _Cp::__self;

  friend class __bit_const_reference<_Cp>;
  friend class __bit_iterator<_Cp, false>;

public:
  using __container = typename _Cp::__self;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr __bit_reference(const __bit_reference&) = default;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr operator bool() const noexcept {
    return static_cast<bool>(*__seg_ & __mask_);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr bool operator~() const noexcept {
    return !static_cast<bool>(*this);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr __bit_reference& operator=(bool __x) noexcept {
    if (__x)
      *__seg_ |= __mask_;
    else
      *__seg_ &= ~__mask_;
    return *this;
  }


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr const __bit_reference& operator=(bool __x) const noexcept {
    if (__x)
      *__seg_ |= __mask_;
    else
      *__seg_ &= ~__mask_;
    return *this;
  }


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr __bit_reference& operator=(const __bit_reference& __x) noexcept {
    return operator=(static_cast<bool>(__x));
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr void flip() noexcept { *__seg_ ^= __mask_; }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr __bit_iterator<_Cp, false> operator&() const noexcept {
    return __bit_iterator<_Cp, false>(__seg_, static_cast<unsigned>(std::__libcpp_ctz(__mask_)));
  }

private:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr explicit __bit_reference(
      __storage_pointer __s, __storage_type __m) noexcept
      : __seg_(__s),
        __mask_(__m) {}
};

template <class _Cp>
class __bit_reference<_Cp, false> {};

template <class _Cp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr void
swap(__bit_reference<_Cp> __x, __bit_reference<_Cp> __y) noexcept {
  bool __t = __x;
  __x = __y;
  __y = __t;
}

template <class _Cp, class _Dp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr void
swap(__bit_reference<_Cp> __x, __bit_reference<_Dp> __y) noexcept {
  bool __t = __x;
  __x = __y;
  __y = __t;
}

template <class _Cp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr void swap(__bit_reference<_Cp> __x, bool& __y) noexcept {
  bool __t = __x;
  __x = __y;
  __y = __t;
}

template <class _Cp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr void swap(bool& __x, __bit_reference<_Cp> __y) noexcept {
  bool __t = __x;
  __x = __y;
  __y = __t;
}

template <class _Cp>
class __bit_const_reference {
  using __storage_type = typename _Cp::__storage_type;
  using __storage_pointer = typename _Cp::__const_storage_pointer;

  __storage_pointer __seg_;
  __storage_type __mask_;

  friend typename _Cp::__self;
  friend class __bit_iterator<_Cp, true>;

public:
  using __container = typename _Cp::__self;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) __bit_const_reference(const __bit_const_reference&) = default;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr __bit_const_reference(const __bit_reference<_Cp>& __x) noexcept
      : __seg_(__x.__seg_),
        __mask_(__x.__mask_) {}

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr operator bool() const noexcept {
    return static_cast<bool>(*__seg_ & __mask_);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr __bit_iterator<_Cp, true> operator&() const noexcept {
    return __bit_iterator<_Cp, true>(__seg_, static_cast<unsigned>(std::__libcpp_ctz(__mask_)));
  }

private:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr explicit __bit_const_reference(
      __storage_pointer __s, __storage_type __m) noexcept
      : __seg_(__s),
        __mask_(__m) {}

  __bit_const_reference& operator=(const __bit_const_reference&) = delete;
};



template <bool _ToCount, class _Cp, bool _IsConst>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr typename __bit_iterator<_Cp, _IsConst>::difference_type
__count_bool(__bit_iterator<_Cp, _IsConst> __first, typename _Cp::size_type __n) {
  using _It = __bit_iterator<_Cp, _IsConst>;
  using __storage_type = typename _It::__storage_type;
  using difference_type = typename _It::difference_type;

  const int __bits_per_word = _It::__bits_per_word;
  difference_type __r = 0;

  if (__first.__ctz_ != 0) {
    __storage_type __clz_f = static_cast<__storage_type>(__bits_per_word - __first.__ctz_);
    __storage_type __dn = std::min(__clz_f, __n);
    __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz_f - __dn));
    __r = std::__libcpp_popcount(std::__invert_if<!_ToCount>(*__first.__seg_) & __m);
    __n -= __dn;
    ++__first.__seg_;
  }

  for (; __n >= __bits_per_word; ++__first.__seg_, __n -= __bits_per_word)
    __r += std::__libcpp_popcount(std::__invert_if<!_ToCount>(*__first.__seg_));

  if (__n > 0) {
    __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
    __r += std::__libcpp_popcount(std::__invert_if<!_ToCount>(*__first.__seg_) & __m);
  }
  return __r;
}

template <class _Cp, bool _IsConst, class _Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) typename __bit_iterator<_Cp, _IsConst>::difference_type
count(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last, const _Tp& __value) {
  if (static_cast<bool>(__value))
    return std::__count_bool<true>(__first, static_cast<typename _Cp::size_type>(__last - __first));
  return std::__count_bool<false>(__first, static_cast<typename _Cp::size_type>(__last - __first));
}



template <bool _FillValue, class _Cp>
constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) void
__fill_n(__bit_iterator<_Cp, false> __first, typename _Cp::size_type __n) {
  using _It = __bit_iterator<_Cp, false>;
  using __storage_type = typename _It::__storage_type;

  const int __bits_per_word = _It::__bits_per_word;

  if (__first.__ctz_ != 0) {
    __storage_type __clz_f = static_cast<__storage_type>(__bits_per_word - __first.__ctz_);
    __storage_type __dn = std::min(__clz_f, __n);
    __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz_f - __dn));
    if (_FillValue)
      *__first.__seg_ |= __m;
    else
      *__first.__seg_ &= ~__m;
    __n -= __dn;
    ++__first.__seg_;
  }

  __storage_type __nw = __n / __bits_per_word;
  std::fill_n(std::__to_address(__first.__seg_), __nw, _FillValue ? static_cast<__storage_type>(-1) : 0);
  __n -= __nw * __bits_per_word;

  if (__n > 0) {
    __first.__seg_ += __nw;
    __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
    if (_FillValue)
      *__first.__seg_ |= __m;
    else
      *__first.__seg_ &= ~__m;
  }
}

template <class _Cp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr void
fill_n(__bit_iterator<_Cp, false> __first, typename _Cp::size_type __n, bool __value) {
  if (__n > 0) {
    if (__value)
      std::__fill_n<true>(__first, __n);
    else
      std::__fill_n<false>(__first, __n);
  }
}



template <class _Cp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr void
fill(__bit_iterator<_Cp, false> __first, __bit_iterator<_Cp, false> __last, bool __value) {
  std::fill_n(__first, static_cast<typename _Cp::size_type>(__last - __first), __value);
}



template <class _Cp, bool _IsConst>
constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) __bit_iterator<_Cp, false> __copy_aligned(
    __bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last, __bit_iterator<_Cp, false> __result) {
  using _In = __bit_iterator<_Cp, _IsConst>;
  using difference_type = typename _In::difference_type;
  using __storage_type = typename _In::__storage_type;

  const int __bits_per_word = _In::__bits_per_word;
  difference_type __n = __last - __first;
  if (__n > 0) {

    if (__first.__ctz_ != 0) {
      unsigned __clz = __bits_per_word - __first.__ctz_;
      difference_type __dn = std::min(static_cast<difference_type>(__clz), __n);
      __n -= __dn;
      __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz - __dn));
      __storage_type __b = *__first.__seg_ & __m;
      *__result.__seg_ &= ~__m;
      *__result.__seg_ |= __b;
      __result.__seg_ += (__dn + __result.__ctz_) / __bits_per_word;
      __result.__ctz_ = static_cast<unsigned>((__dn + __result.__ctz_) % __bits_per_word);
      ++__first.__seg_;

    }


    __storage_type __nw = __n / __bits_per_word;
    std::copy_n(std::__to_address(__first.__seg_), __nw, std::__to_address(__result.__seg_));
    __n -= __nw * __bits_per_word;
    __result.__seg_ += __nw;

    if (__n > 0) {
      __first.__seg_ += __nw;
      __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
      __storage_type __b = *__first.__seg_ & __m;
      *__result.__seg_ &= ~__m;
      *__result.__seg_ |= __b;
      __result.__ctz_ = static_cast<unsigned>(__n);
    }
  }
  return __result;
}

template <class _Cp, bool _IsConst>
constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) __bit_iterator<_Cp, false> __copy_unaligned(
    __bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last, __bit_iterator<_Cp, false> __result) {
  using _In = __bit_iterator<_Cp, _IsConst>;
  using difference_type = typename _In::difference_type;
  using __storage_type = typename _In::__storage_type;

  const int __bits_per_word = _In::__bits_per_word;
  difference_type __n = __last - __first;
  if (__n > 0) {

    if (__first.__ctz_ != 0) {
      unsigned __clz_f = __bits_per_word - __first.__ctz_;
      difference_type __dn = std::min(static_cast<difference_type>(__clz_f), __n);
      __n -= __dn;
      __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz_f - __dn));
      __storage_type __b = *__first.__seg_ & __m;
      unsigned __clz_r = __bits_per_word - __result.__ctz_;
      __storage_type __ddn = std::min<__storage_type>(__dn, __clz_r);
      __m = (~__storage_type(0) << __result.__ctz_) & (~__storage_type(0) >> (__clz_r - __ddn));
      *__result.__seg_ &= ~__m;
      if (__result.__ctz_ > __first.__ctz_)
        *__result.__seg_ |= __b << (__result.__ctz_ - __first.__ctz_);
      else
        *__result.__seg_ |= __b >> (__first.__ctz_ - __result.__ctz_);
      __result.__seg_ += (__ddn + __result.__ctz_) / __bits_per_word;
      __result.__ctz_ = static_cast<unsigned>((__ddn + __result.__ctz_) % __bits_per_word);
      __dn -= __ddn;
      if (__dn > 0) {
        __m = ~__storage_type(0) >> (__bits_per_word - __dn);
        *__result.__seg_ &= ~__m;
        *__result.__seg_ |= __b >> (__first.__ctz_ + __ddn);
        __result.__ctz_ = static_cast<unsigned>(__dn);
      }
      ++__first.__seg_;

    }


    unsigned __clz_r = __bits_per_word - __result.__ctz_;
    __storage_type __m = ~__storage_type(0) << __result.__ctz_;
    for (; __n >= __bits_per_word; __n -= __bits_per_word, ++__first.__seg_) {
      __storage_type __b = *__first.__seg_;
      *__result.__seg_ &= ~__m;
      *__result.__seg_ |= __b << __result.__ctz_;
      ++__result.__seg_;
      *__result.__seg_ &= __m;
      *__result.__seg_ |= __b >> __clz_r;
    }

    if (__n > 0) {
      __m = ~__storage_type(0) >> (__bits_per_word - __n);
      __storage_type __b = *__first.__seg_ & __m;
      __storage_type __dn = std::min(__n, static_cast<difference_type>(__clz_r));
      __m = (~__storage_type(0) << __result.__ctz_) & (~__storage_type(0) >> (__clz_r - __dn));
      *__result.__seg_ &= ~__m;
      *__result.__seg_ |= __b << __result.__ctz_;
      __result.__seg_ += (__dn + __result.__ctz_) / __bits_per_word;
      __result.__ctz_ = static_cast<unsigned>((__dn + __result.__ctz_) % __bits_per_word);
      __n -= __dn;
      if (__n > 0) {
        __m = ~__storage_type(0) >> (__bits_per_word - __n);
        *__result.__seg_ &= ~__m;
        *__result.__seg_ |= __b >> __dn;
        __result.__ctz_ = static_cast<unsigned>(__n);
      }
    }
  }
  return __result;
}

template <class _Cp, bool _IsConst>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr __bit_iterator<_Cp, false>
copy(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last, __bit_iterator<_Cp, false> __result) {
  if (__first.__ctz_ == __result.__ctz_)
    return std::__copy_aligned(__first, __last, __result);
  return std::__copy_unaligned(__first, __last, __result);
}



template <class _Cp, bool _IsConst>
constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) __bit_iterator<_Cp, false> __copy_backward_aligned(
    __bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last, __bit_iterator<_Cp, false> __result) {
  using _In = __bit_iterator<_Cp, _IsConst>;
  using difference_type = typename _In::difference_type;
  using __storage_type = typename _In::__storage_type;

  const int __bits_per_word = _In::__bits_per_word;
  difference_type __n = __last - __first;
  if (__n > 0) {

    if (__last.__ctz_ != 0) {
      difference_type __dn = std::min(static_cast<difference_type>(__last.__ctz_), __n);
      __n -= __dn;
      unsigned __clz = __bits_per_word - __last.__ctz_;
      __storage_type __m = (~__storage_type(0) << (__last.__ctz_ - __dn)) & (~__storage_type(0) >> __clz);
      __storage_type __b = *__last.__seg_ & __m;
      *__result.__seg_ &= ~__m;
      *__result.__seg_ |= __b;
      __result.__ctz_ = static_cast<unsigned>(((-__dn & (__bits_per_word - 1)) + __result.__ctz_) % __bits_per_word);

    }



    __storage_type __nw = __n / __bits_per_word;
    __result.__seg_ -= __nw;
    __last.__seg_ -= __nw;
    std::copy_n(std::__to_address(__last.__seg_), __nw, std::__to_address(__result.__seg_));
    __n -= __nw * __bits_per_word;

    if (__n > 0) {
      __storage_type __m = ~__storage_type(0) << (__bits_per_word - __n);
      __storage_type __b = *--__last.__seg_ & __m;
      *--__result.__seg_ &= ~__m;
      *__result.__seg_ |= __b;
      __result.__ctz_ = static_cast<unsigned>(-__n & (__bits_per_word - 1));
    }
  }
  return __result;
}

template <class _Cp, bool _IsConst>
constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) __bit_iterator<_Cp, false> __copy_backward_unaligned(
    __bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last, __bit_iterator<_Cp, false> __result) {
  using _In = __bit_iterator<_Cp, _IsConst>;
  using difference_type = typename _In::difference_type;
  using __storage_type = typename _In::__storage_type;

  const int __bits_per_word = _In::__bits_per_word;
  difference_type __n = __last - __first;
  if (__n > 0) {

    if (__last.__ctz_ != 0) {
      difference_type __dn = std::min(static_cast<difference_type>(__last.__ctz_), __n);
      __n -= __dn;
      unsigned __clz_l = __bits_per_word - __last.__ctz_;
      __storage_type __m = (~__storage_type(0) << (__last.__ctz_ - __dn)) & (~__storage_type(0) >> __clz_l);
      __storage_type __b = *__last.__seg_ & __m;
      unsigned __clz_r = __bits_per_word - __result.__ctz_;
      __storage_type __ddn = std::min(__dn, static_cast<difference_type>(__result.__ctz_));
      if (__ddn > 0) {
        __m = (~__storage_type(0) << (__result.__ctz_ - __ddn)) & (~__storage_type(0) >> __clz_r);
        *__result.__seg_ &= ~__m;
        if (__result.__ctz_ > __last.__ctz_)
          *__result.__seg_ |= __b << (__result.__ctz_ - __last.__ctz_);
        else
          *__result.__seg_ |= __b >> (__last.__ctz_ - __result.__ctz_);
        __result.__ctz_ = static_cast<unsigned>(((-__ddn & (__bits_per_word - 1)) + __result.__ctz_) % __bits_per_word);
        __dn -= __ddn;
      }
      if (__dn > 0) {

        --__result.__seg_;
        __result.__ctz_ = static_cast<unsigned>(-__dn & (__bits_per_word - 1));
        __m = ~__storage_type(0) << __result.__ctz_;
        *__result.__seg_ &= ~__m;
        __last.__ctz_ -= __dn + __ddn;
        *__result.__seg_ |= __b << (__result.__ctz_ - __last.__ctz_);
      }

    }



    unsigned __clz_r = __bits_per_word - __result.__ctz_;
    __storage_type __m = ~__storage_type(0) >> __clz_r;
    for (; __n >= __bits_per_word; __n -= __bits_per_word) {
      __storage_type __b = *--__last.__seg_;
      *__result.__seg_ &= ~__m;
      *__result.__seg_ |= __b >> __clz_r;
      *--__result.__seg_ &= __m;
      *__result.__seg_ |= __b << __result.__ctz_;
    }

    if (__n > 0) {
      __m = ~__storage_type(0) << (__bits_per_word - __n);
      __storage_type __b = *--__last.__seg_ & __m;
      __clz_r = __bits_per_word - __result.__ctz_;
      __storage_type __dn = std::min(__n, static_cast<difference_type>(__result.__ctz_));
      __m = (~__storage_type(0) << (__result.__ctz_ - __dn)) & (~__storage_type(0) >> __clz_r);
      *__result.__seg_ &= ~__m;
      *__result.__seg_ |= __b >> (__bits_per_word - __result.__ctz_);
      __result.__ctz_ = static_cast<unsigned>(((-__dn & (__bits_per_word - 1)) + __result.__ctz_) % __bits_per_word);
      __n -= __dn;
      if (__n > 0) {

        --__result.__seg_;
        __result.__ctz_ = static_cast<unsigned>(-__n & (__bits_per_word - 1));
        __m = ~__storage_type(0) << __result.__ctz_;
        *__result.__seg_ &= ~__m;
        *__result.__seg_ |= __b << (__result.__ctz_ - (__bits_per_word - __n - __dn));
      }
    }
  }
  return __result;
}

template <class _Cp, bool _IsConst>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr __bit_iterator<_Cp, false> copy_backward(
    __bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last, __bit_iterator<_Cp, false> __result) {
  if (__last.__ctz_ == __result.__ctz_)
    return std::__copy_backward_aligned(__first, __last, __result);
  return std::__copy_backward_unaligned(__first, __last, __result);
}



template <class _Cp, bool _IsConst>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) __bit_iterator<_Cp, false>
move(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last, __bit_iterator<_Cp, false> __result) {
  return std::copy(__first, __last, __result);
}



template <class _Cp, bool _IsConst>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) __bit_iterator<_Cp, false> move_backward(
    __bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last, __bit_iterator<_Cp, false> __result) {
  return std::copy_backward(__first, __last, __result);
}



template <class _Cl, class _Cr>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) __bit_iterator<_Cr, false> __swap_ranges_aligned(
    __bit_iterator<_Cl, false> __first, __bit_iterator<_Cl, false> __last, __bit_iterator<_Cr, false> __result) {
  using _I1 = __bit_iterator<_Cl, false>;
  using difference_type = typename _I1::difference_type;
  using __storage_type = typename _I1::__storage_type;

  const int __bits_per_word = _I1::__bits_per_word;
  difference_type __n = __last - __first;
  if (__n > 0) {

    if (__first.__ctz_ != 0) {
      unsigned __clz = __bits_per_word - __first.__ctz_;
      difference_type __dn = std::min(static_cast<difference_type>(__clz), __n);
      __n -= __dn;
      __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz - __dn));
      __storage_type __b1 = *__first.__seg_ & __m;
      *__first.__seg_ &= ~__m;
      __storage_type __b2 = *__result.__seg_ & __m;
      *__result.__seg_ &= ~__m;
      *__result.__seg_ |= __b1;
      *__first.__seg_ |= __b2;
      __result.__seg_ += (__dn + __result.__ctz_) / __bits_per_word;
      __result.__ctz_ = static_cast<unsigned>((__dn + __result.__ctz_) % __bits_per_word);
      ++__first.__seg_;

    }


    for (; __n >= __bits_per_word; __n -= __bits_per_word, ++__first.__seg_, ++__result.__seg_)
      swap(*__first.__seg_, *__result.__seg_);

    if (__n > 0) {
      __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
      __storage_type __b1 = *__first.__seg_ & __m;
      *__first.__seg_ &= ~__m;
      __storage_type __b2 = *__result.__seg_ & __m;
      *__result.__seg_ &= ~__m;
      *__result.__seg_ |= __b1;
      *__first.__seg_ |= __b2;
      __result.__ctz_ = static_cast<unsigned>(__n);
    }
  }
  return __result;
}

template <class _Cl, class _Cr>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) __bit_iterator<_Cr, false> __swap_ranges_unaligned(
    __bit_iterator<_Cl, false> __first, __bit_iterator<_Cl, false> __last, __bit_iterator<_Cr, false> __result) {
  using _I1 = __bit_iterator<_Cl, false>;
  using difference_type = typename _I1::difference_type;
  using __storage_type = typename _I1::__storage_type;

  const int __bits_per_word = _I1::__bits_per_word;
  difference_type __n = __last - __first;
  if (__n > 0) {

    if (__first.__ctz_ != 0) {
      unsigned __clz_f = __bits_per_word - __first.__ctz_;
      difference_type __dn = std::min(static_cast<difference_type>(__clz_f), __n);
      __n -= __dn;
      __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz_f - __dn));
      __storage_type __b1 = *__first.__seg_ & __m;
      *__first.__seg_ &= ~__m;
      unsigned __clz_r = __bits_per_word - __result.__ctz_;
      __storage_type __ddn = std::min<__storage_type>(__dn, __clz_r);
      __m = (~__storage_type(0) << __result.__ctz_) & (~__storage_type(0) >> (__clz_r - __ddn));
      __storage_type __b2 = *__result.__seg_ & __m;
      *__result.__seg_ &= ~__m;
      if (__result.__ctz_ > __first.__ctz_) {
        unsigned __s = __result.__ctz_ - __first.__ctz_;
        *__result.__seg_ |= __b1 << __s;
        *__first.__seg_ |= __b2 >> __s;
      } else {
        unsigned __s = __first.__ctz_ - __result.__ctz_;
        *__result.__seg_ |= __b1 >> __s;
        *__first.__seg_ |= __b2 << __s;
      }
      __result.__seg_ += (__ddn + __result.__ctz_) / __bits_per_word;
      __result.__ctz_ = static_cast<unsigned>((__ddn + __result.__ctz_) % __bits_per_word);
      __dn -= __ddn;
      if (__dn > 0) {
        __m = ~__storage_type(0) >> (__bits_per_word - __dn);
        __b2 = *__result.__seg_ & __m;
        *__result.__seg_ &= ~__m;
        unsigned __s = __first.__ctz_ + __ddn;
        *__result.__seg_ |= __b1 >> __s;
        *__first.__seg_ |= __b2 << __s;
        __result.__ctz_ = static_cast<unsigned>(__dn);
      }
      ++__first.__seg_;

    }


    __storage_type __m = ~__storage_type(0) << __result.__ctz_;
    unsigned __clz_r = __bits_per_word - __result.__ctz_;
    for (; __n >= __bits_per_word; __n -= __bits_per_word, ++__first.__seg_) {
      __storage_type __b1 = *__first.__seg_;
      __storage_type __b2 = *__result.__seg_ & __m;
      *__result.__seg_ &= ~__m;
      *__result.__seg_ |= __b1 << __result.__ctz_;
      *__first.__seg_ = __b2 >> __result.__ctz_;
      ++__result.__seg_;
      __b2 = *__result.__seg_ & ~__m;
      *__result.__seg_ &= __m;
      *__result.__seg_ |= __b1 >> __clz_r;
      *__first.__seg_ |= __b2 << __clz_r;
    }

    if (__n > 0) {
      __m = ~__storage_type(0) >> (__bits_per_word - __n);
      __storage_type __b1 = *__first.__seg_ & __m;
      *__first.__seg_ &= ~__m;
      __storage_type __dn = std::min<__storage_type>(__n, __clz_r);
      __m = (~__storage_type(0) << __result.__ctz_) & (~__storage_type(0) >> (__clz_r - __dn));
      __storage_type __b2 = *__result.__seg_ & __m;
      *__result.__seg_ &= ~__m;
      *__result.__seg_ |= __b1 << __result.__ctz_;
      *__first.__seg_ |= __b2 >> __result.__ctz_;
      __result.__seg_ += (__dn + __result.__ctz_) / __bits_per_word;
      __result.__ctz_ = static_cast<unsigned>((__dn + __result.__ctz_) % __bits_per_word);
      __n -= __dn;
      if (__n > 0) {
        __m = ~__storage_type(0) >> (__bits_per_word - __n);
        __b2 = *__result.__seg_ & __m;
        *__result.__seg_ &= ~__m;
        *__result.__seg_ |= __b1 >> __dn;
        *__first.__seg_ |= __b2 << __dn;
        __result.__ctz_ = static_cast<unsigned>(__n);
      }
    }
  }
  return __result;
}

template <class _Cl, class _Cr>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) __bit_iterator<_Cr, false> swap_ranges(
    __bit_iterator<_Cl, false> __first1, __bit_iterator<_Cl, false> __last1, __bit_iterator<_Cr, false> __first2) {
  if (__first1.__ctz_ == __first2.__ctz_)
    return std::__swap_ranges_aligned(__first1, __last1, __first2);
  return std::__swap_ranges_unaligned(__first1, __last1, __first2);
}



template <class _Cp>
struct __bit_array {
  using difference_type = typename _Cp::difference_type;
  using __storage_type = typename _Cp::__storage_type;
  using __storage_pointer = typename _Cp::__storage_pointer;
  using iterator = typename _Cp::iterator;

  static const unsigned __bits_per_word = _Cp::__bits_per_word;
  static const unsigned _Np = 4;

  difference_type __size_;
  __storage_type __word_[_Np];

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr static difference_type capacity() {
    return static_cast<difference_type>(_Np * __bits_per_word);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr explicit __bit_array(difference_type __s) : __size_(__s) {
    if (__libcpp_is_constant_evaluated()) {
      for (size_t __i = 0; __i != __bit_array<_Cp>::_Np; ++__i)
        std::__construct_at(__word_ + __i, 0);
    }
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr iterator begin() {
    return iterator(pointer_traits<__storage_pointer>::pointer_to(__word_[0]), 0);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr iterator end() {
    return iterator(pointer_traits<__storage_pointer>::pointer_to(__word_[0]) + __size_ / __bits_per_word,
                    static_cast<unsigned>(__size_ % __bits_per_word));
  }
};

template <class _Cp>
constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) __bit_iterator<_Cp, false>
rotate(__bit_iterator<_Cp, false> __first, __bit_iterator<_Cp, false> __middle, __bit_iterator<_Cp, false> __last) {
  using _I1 = __bit_iterator<_Cp, false>;
  using difference_type = typename _I1::difference_type;

  difference_type __d1 = __middle - __first;
  difference_type __d2 = __last - __middle;
  _I1 __r = __first + __d2;
  while (__d1 != 0 && __d2 != 0) {
    if (__d1 <= __d2) {
      if (__d1 <= __bit_array<_Cp>::capacity()) {
        __bit_array<_Cp> __b(__d1);
        std::copy(__first, __middle, __b.begin());
        std::copy(__b.begin(), __b.end(), std::copy(__middle, __last, __first));
        break;
      } else {
        __bit_iterator<_Cp, false> __mp = std::swap_ranges(__first, __middle, __middle);
        __first = __middle;
        __middle = __mp;
        __d2 -= __d1;
      }
    } else {
      if (__d2 <= __bit_array<_Cp>::capacity()) {
        __bit_array<_Cp> __b(__d2);
        std::copy(__middle, __last, __b.begin());
        std::copy_backward(__b.begin(), __b.end(), std::copy_backward(__first, __middle, __last));
        break;
      } else {
        __bit_iterator<_Cp, false> __mp = __first + __d2;
        std::swap_ranges(__first, __mp, __middle);
        __first = __mp;
        __d1 -= __d2;
      }
    }
  }
  return __r;
}



template <class _Cp, bool _IC1, bool _IC2>
constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) bool __equal_unaligned(
    __bit_iterator<_Cp, _IC1> __first1, __bit_iterator<_Cp, _IC1> __last1, __bit_iterator<_Cp, _IC2> __first2) {
  using _It = __bit_iterator<_Cp, _IC1>;
  using difference_type = typename _It::difference_type;
  using __storage_type = typename _It::__storage_type;

  const int __bits_per_word = _It::__bits_per_word;
  difference_type __n = __last1 - __first1;
  if (__n > 0) {

    if (__first1.__ctz_ != 0) {
      unsigned __clz_f = __bits_per_word - __first1.__ctz_;
      difference_type __dn = std::min(static_cast<difference_type>(__clz_f), __n);
      __n -= __dn;
      __storage_type __m = (~__storage_type(0) << __first1.__ctz_) & (~__storage_type(0) >> (__clz_f - __dn));
      __storage_type __b = *__first1.__seg_ & __m;
      unsigned __clz_r = __bits_per_word - __first2.__ctz_;
      __storage_type __ddn = std::min<__storage_type>(__dn, __clz_r);
      __m = (~__storage_type(0) << __first2.__ctz_) & (~__storage_type(0) >> (__clz_r - __ddn));
      if (__first2.__ctz_ > __first1.__ctz_) {
        if ((*__first2.__seg_ & __m) != (__b << (__first2.__ctz_ - __first1.__ctz_)))
          return false;
      } else {
        if ((*__first2.__seg_ & __m) != (__b >> (__first1.__ctz_ - __first2.__ctz_)))
          return false;
      }
      __first2.__seg_ += (__ddn + __first2.__ctz_) / __bits_per_word;
      __first2.__ctz_ = static_cast<unsigned>((__ddn + __first2.__ctz_) % __bits_per_word);
      __dn -= __ddn;
      if (__dn > 0) {
        __m = ~__storage_type(0) >> (__bits_per_word - __dn);
        if ((*__first2.__seg_ & __m) != (__b >> (__first1.__ctz_ + __ddn)))
          return false;
        __first2.__ctz_ = static_cast<unsigned>(__dn);
      }
      ++__first1.__seg_;

    }


    unsigned __clz_r = __bits_per_word - __first2.__ctz_;
    __storage_type __m = ~__storage_type(0) << __first2.__ctz_;
    for (; __n >= __bits_per_word; __n -= __bits_per_word, ++__first1.__seg_) {
      __storage_type __b = *__first1.__seg_;
      if ((*__first2.__seg_ & __m) != (__b << __first2.__ctz_))
        return false;
      ++__first2.__seg_;
      if ((*__first2.__seg_ & ~__m) != (__b >> __clz_r))
        return false;
    }

    if (__n > 0) {
      __m = ~__storage_type(0) >> (__bits_per_word - __n);
      __storage_type __b = *__first1.__seg_ & __m;
      __storage_type __dn = std::min(__n, static_cast<difference_type>(__clz_r));
      __m = (~__storage_type(0) << __first2.__ctz_) & (~__storage_type(0) >> (__clz_r - __dn));
      if ((*__first2.__seg_ & __m) != (__b << __first2.__ctz_))
        return false;
      __first2.__seg_ += (__dn + __first2.__ctz_) / __bits_per_word;
      __first2.__ctz_ = static_cast<unsigned>((__dn + __first2.__ctz_) % __bits_per_word);
      __n -= __dn;
      if (__n > 0) {
        __m = ~__storage_type(0) >> (__bits_per_word - __n);
        if ((*__first2.__seg_ & __m) != (__b >> __dn))
          return false;
      }
    }
  }
  return true;
}

template <class _Cp, bool _IC1, bool _IC2>
constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) bool __equal_aligned(
    __bit_iterator<_Cp, _IC1> __first1, __bit_iterator<_Cp, _IC1> __last1, __bit_iterator<_Cp, _IC2> __first2) {
  using _It = __bit_iterator<_Cp, _IC1>;
  using difference_type = typename _It::difference_type;
  using __storage_type = typename _It::__storage_type;

  const int __bits_per_word = _It::__bits_per_word;
  difference_type __n = __last1 - __first1;
  if (__n > 0) {

    if (__first1.__ctz_ != 0) {
      unsigned __clz = __bits_per_word - __first1.__ctz_;
      difference_type __dn = std::min(static_cast<difference_type>(__clz), __n);
      __n -= __dn;
      __storage_type __m = (~__storage_type(0) << __first1.__ctz_) & (~__storage_type(0) >> (__clz - __dn));
      if ((*__first2.__seg_ & __m) != (*__first1.__seg_ & __m))
        return false;
      ++__first2.__seg_;
      ++__first1.__seg_;


    }



    for (; __n >= __bits_per_word; __n -= __bits_per_word, ++__first1.__seg_, ++__first2.__seg_)
      if (*__first2.__seg_ != *__first1.__seg_)
        return false;

    if (__n > 0) {
      __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
      if ((*__first2.__seg_ & __m) != (*__first1.__seg_ & __m))
        return false;
    }
  }
  return true;
}

template <class _Cp, bool _IC1, bool _IC2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr bool
equal(__bit_iterator<_Cp, _IC1> __first1, __bit_iterator<_Cp, _IC1> __last1, __bit_iterator<_Cp, _IC2> __first2) {
  if (__first1.__ctz_ == __first2.__ctz_)
    return std::__equal_aligned(__first1, __last1, __first2);
  return std::__equal_unaligned(__first1, __last1, __first2);
}

template <class _Cp, bool _IsConst, typename _Cp::__storage_type>
class __bit_iterator {
public:
  using difference_type = typename _Cp::difference_type;
  using value_type = bool;
  using pointer = __bit_iterator;

  using reference = __conditional_t<_IsConst, __bit_const_reference<_Cp>, __bit_reference<_Cp> >;



  using iterator_category = random_access_iterator_tag;

private:
  using __storage_type = typename _Cp::__storage_type;
  using __storage_pointer =
      __conditional_t<_IsConst, typename _Cp::__const_storage_pointer, typename _Cp::__storage_pointer>;

  static const unsigned __bits_per_word = _Cp::__bits_per_word;

  __storage_pointer __seg_;
  unsigned __ctz_;

public:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr __bit_iterator() noexcept

      : __seg_(nullptr),
        __ctz_(0)

  {
  }






  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr __bit_iterator(const __bit_iterator<_Cp, false>& __it) noexcept
      : __seg_(__it.__seg_),
        __ctz_(__it.__ctz_) {}






  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr __bit_iterator&
  operator=(const _If<_IsConst, struct __private_nat, __bit_iterator>& __it) {
    __seg_ = __it.__seg_;
    __ctz_ = __it.__ctz_;
    return *this;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr reference operator*() const noexcept {
    return __conditional_t<_IsConst, __bit_const_reference<_Cp>, __bit_reference<_Cp> >(
        __seg_, __storage_type(1) << __ctz_);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr __bit_iterator& operator++() {
    if (__ctz_ != __bits_per_word - 1)
      ++__ctz_;
    else {
      __ctz_ = 0;
      ++__seg_;
    }
    return *this;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr __bit_iterator operator++(int) {
    __bit_iterator __tmp = *this;
    ++(*this);
    return __tmp;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr __bit_iterator& operator--() {
    if (__ctz_ != 0)
      --__ctz_;
    else {
      __ctz_ = __bits_per_word - 1;
      --__seg_;
    }
    return *this;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr __bit_iterator operator--(int) {
    __bit_iterator __tmp = *this;
    --(*this);
    return __tmp;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr __bit_iterator& operator+=(difference_type __n) {
    if (__n >= 0)
      __seg_ += (__n + __ctz_) / __bits_per_word;
    else
      __seg_ += static_cast<difference_type>(__n - __bits_per_word + __ctz_ + 1) /
                static_cast<difference_type>(__bits_per_word);
    __n &= (__bits_per_word - 1);
    __ctz_ = static_cast<unsigned>((__n + __ctz_) % __bits_per_word);
    return *this;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr __bit_iterator& operator-=(difference_type __n) {
    return *this += -__n;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr __bit_iterator operator+(difference_type __n) const {
    __bit_iterator __t(*this);
    __t += __n;
    return __t;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr __bit_iterator operator-(difference_type __n) const {
    __bit_iterator __t(*this);
    __t -= __n;
    return __t;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr friend __bit_iterator
  operator+(difference_type __n, const __bit_iterator& __it) {
    return __it + __n;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr friend difference_type
  operator-(const __bit_iterator& __x, const __bit_iterator& __y) {
    return (__x.__seg_ - __y.__seg_) * __bits_per_word + __x.__ctz_ - __y.__ctz_;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr reference operator[](difference_type __n) const {
    return *(*this + __n);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr friend bool
  operator==(const __bit_iterator& __x, const __bit_iterator& __y) {
    return __x.__seg_ == __y.__seg_ && __x.__ctz_ == __y.__ctz_;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr friend bool
  operator!=(const __bit_iterator& __x, const __bit_iterator& __y) {
    return !(__x == __y);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr friend bool
  operator<(const __bit_iterator& __x, const __bit_iterator& __y) {
    return __x.__seg_ < __y.__seg_ || (__x.__seg_ == __y.__seg_ && __x.__ctz_ < __y.__ctz_);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr friend bool
  operator>(const __bit_iterator& __x, const __bit_iterator& __y) {
    return __y < __x;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr friend bool
  operator<=(const __bit_iterator& __x, const __bit_iterator& __y) {
    return !(__y < __x);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr friend bool
  operator>=(const __bit_iterator& __x, const __bit_iterator& __y) {
    return !(__x < __y);
  }

private:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr explicit __bit_iterator(
      __storage_pointer __s, unsigned __ctz) noexcept
      : __seg_(__s),
        __ctz_(__ctz) {}

  friend typename _Cp::__self;

  friend class __bit_reference<_Cp>;
  friend class __bit_const_reference<_Cp>;
  friend class __bit_iterator<_Cp, true>;
  template <class _Dp>
  friend struct __bit_array;
  template <bool _FillValue, class _Dp>
  constexpr friend void __fill_n(__bit_iterator<_Dp, false> __first, typename _Dp::size_type __n);

  template <class _Dp, bool _IC>
  constexpr friend __bit_iterator<_Dp, false> __copy_aligned(
      __bit_iterator<_Dp, _IC> __first, __bit_iterator<_Dp, _IC> __last, __bit_iterator<_Dp, false> __result);
  template <class _Dp, bool _IC>
  constexpr friend __bit_iterator<_Dp, false> __copy_unaligned(
      __bit_iterator<_Dp, _IC> __first, __bit_iterator<_Dp, _IC> __last, __bit_iterator<_Dp, false> __result);
  template <class _Dp, bool _IC>
  constexpr friend __bit_iterator<_Dp, false>
  copy(__bit_iterator<_Dp, _IC> __first, __bit_iterator<_Dp, _IC> __last, __bit_iterator<_Dp, false> __result);
  template <class _Dp, bool _IC>
  constexpr friend __bit_iterator<_Dp, false> __copy_backward_aligned(
      __bit_iterator<_Dp, _IC> __first, __bit_iterator<_Dp, _IC> __last, __bit_iterator<_Dp, false> __result);
  template <class _Dp, bool _IC>
  constexpr friend __bit_iterator<_Dp, false> __copy_backward_unaligned(
      __bit_iterator<_Dp, _IC> __first, __bit_iterator<_Dp, _IC> __last, __bit_iterator<_Dp, false> __result);
  template <class _Dp, bool _IC>
  constexpr friend __bit_iterator<_Dp, false>
  copy_backward(__bit_iterator<_Dp, _IC> __first, __bit_iterator<_Dp, _IC> __last, __bit_iterator<_Dp, false> __result);
  template <class _Cl, class _Cr>
  friend __bit_iterator<_Cr, false>
      __swap_ranges_aligned(__bit_iterator<_Cl, false>, __bit_iterator<_Cl, false>, __bit_iterator<_Cr, false>);
  template <class _Cl, class _Cr>
  friend __bit_iterator<_Cr, false>
      __swap_ranges_unaligned(__bit_iterator<_Cl, false>, __bit_iterator<_Cl, false>, __bit_iterator<_Cr, false>);
  template <class _Cl, class _Cr>
  friend __bit_iterator<_Cr, false>
      swap_ranges(__bit_iterator<_Cl, false>, __bit_iterator<_Cl, false>, __bit_iterator<_Cr, false>);
  template <class _Dp>
  constexpr friend __bit_iterator<_Dp, false>
      rotate(__bit_iterator<_Dp, false>, __bit_iterator<_Dp, false>, __bit_iterator<_Dp, false>);
  template <class _Dp, bool _IC1, bool _IC2>
  constexpr friend bool
      __equal_aligned(__bit_iterator<_Dp, _IC1>, __bit_iterator<_Dp, _IC1>, __bit_iterator<_Dp, _IC2>);
  template <class _Dp, bool _IC1, bool _IC2>
  constexpr friend bool
      __equal_unaligned(__bit_iterator<_Dp, _IC1>, __bit_iterator<_Dp, _IC1>, __bit_iterator<_Dp, _IC2>);
  template <class _Dp, bool _IC1, bool _IC2>
  constexpr friend bool
      equal(__bit_iterator<_Dp, _IC1>, __bit_iterator<_Dp, _IC1>, __bit_iterator<_Dp, _IC2>);
  template <bool _ToFind, class _Dp, bool _IC>
  constexpr friend __bit_iterator<_Dp, _IC>
      __find_bool(__bit_iterator<_Dp, _IC>, typename _Dp::size_type);
  template <bool _ToCount, class _Dp, bool _IC>
  friend typename __bit_iterator<_Dp, _IC>::difference_type __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
      __count_bool(__bit_iterator<_Dp, _IC>, typename _Dp::size_type);
};

}}
# 317 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/vector" 2 3


# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__format/enable_insertable.h" 1 3
# 17 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__format/enable_insertable.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {



namespace __format {


template <class _Container>
inline constexpr bool __enable_insertable = false;

}



}}
# 320 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/vector" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__format/formatter.h" 1 3
# 15 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__format/formatter.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__format/format_fwd.h" 1 3
# 19 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__format/format_fwd.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {



template <class _Context>
class basic_format_arg;

template <class _OutIt, class _CharT>
  requires output_iterator<_OutIt, const _CharT&>
class basic_format_context;

template <class _Tp, class _CharT = char>
struct formatter;



}}
# 16 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__format/formatter.h" 2 3
# 19 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__format/formatter.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 34 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__format/formatter.h" 3
template <class _Tp, class _CharT>
struct formatter {
  formatter() = delete;
  formatter(const formatter&) = delete;
  formatter& operator=(const formatter&) = delete;
};



template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr void __set_debug_format(_Tp& __formatter) {
  if constexpr (requires { __formatter.set_debug_format(); })
    __formatter.set_debug_format();
}




}}
# 321 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/vector" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__format/formatter_bool.h" 1 3
# 17 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__format/formatter_bool.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__format/concepts.h" 1 3
# 17 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__format/concepts.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__format/format_parse_context.h" 1 3
# 14 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__format/format_parse_context.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__format/format_error.h" 1 3
# 15 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__format/format_error.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/stdexcept" 1 3
# 52 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/stdexcept" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {


class __attribute__((__visibility__("hidden"))) __libcpp_refstring
{
    const char* __imp_;

    bool __uses_refcount() const;
public:
    explicit __libcpp_refstring(const char* __msg);
    __libcpp_refstring(const __libcpp_refstring& __s) noexcept;
    __libcpp_refstring& operator=(const __libcpp_refstring& __s) noexcept;
    ~__libcpp_refstring();

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) const char* c_str() const noexcept {return __imp_;}
};


}}

namespace std
{

class __attribute__((__visibility__("default"))) logic_error
    : public exception
{

private:
    std::__libcpp_refstring __imp_;
public:
    explicit logic_error(const string&);
    explicit logic_error(const char*);

    logic_error(const logic_error&) noexcept;
    logic_error& operator=(const logic_error&) noexcept;

    ~logic_error() noexcept override;

    const char* what() const noexcept override;





};

class __attribute__((__visibility__("default"))) runtime_error
    : public exception
{

private:
    std::__libcpp_refstring __imp_;
public:
    explicit runtime_error(const string&);
    explicit runtime_error(const char*);

    runtime_error(const runtime_error&) noexcept;
    runtime_error& operator=(const runtime_error&) noexcept;

    ~runtime_error() noexcept override;

    const char* what() const noexcept override;





};

class __attribute__((__visibility__("default"))) domain_error
    : public logic_error
{
public:
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) explicit domain_error(const string& __s) : logic_error(__s) {}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) explicit domain_error(const char* __s) : logic_error(__s) {}


    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) domain_error(const domain_error&) noexcept = default;
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) domain_error& operator=(const domain_error&) noexcept = default;
    ~domain_error() noexcept override;

};

class __attribute__((__visibility__("default"))) invalid_argument
    : public logic_error
{
public:
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) explicit invalid_argument(const string& __s) : logic_error(__s) {}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) explicit invalid_argument(const char* __s) : logic_error(__s) {}


    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) invalid_argument(const invalid_argument&) noexcept = default;
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) invalid_argument& operator=(const invalid_argument&) noexcept = default;
    ~invalid_argument() noexcept override;

};

class __attribute__((__visibility__("default"))) length_error
    : public logic_error
{
public:
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) explicit length_error(const string& __s) : logic_error(__s) {}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) explicit length_error(const char* __s) : logic_error(__s) {}

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) length_error(const length_error&) noexcept = default;
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) length_error& operator=(const length_error&) noexcept = default;
    ~length_error() noexcept override;

};

class __attribute__((__visibility__("default"))) out_of_range
    : public logic_error
{
public:
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) explicit out_of_range(const string& __s) : logic_error(__s) {}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) explicit out_of_range(const char* __s) : logic_error(__s) {}


    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) out_of_range(const out_of_range&) noexcept = default;
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) out_of_range& operator=(const out_of_range&) noexcept = default;
    ~out_of_range() noexcept override;

};

class __attribute__((__visibility__("default"))) range_error
    : public runtime_error
{
public:
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) explicit range_error(const string& __s) : runtime_error(__s) {}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) explicit range_error(const char* __s) : runtime_error(__s) {}


    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) range_error(const range_error&) noexcept = default;
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) range_error& operator=(const range_error&) noexcept = default;
    ~range_error() noexcept override;

};

class __attribute__((__visibility__("default"))) overflow_error
    : public runtime_error
{
public:
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) explicit overflow_error(const string& __s) : runtime_error(__s) {}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) explicit overflow_error(const char* __s) : runtime_error(__s) {}


    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) overflow_error(const overflow_error&) noexcept = default;
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) overflow_error& operator=(const overflow_error&) noexcept = default;
    ~overflow_error() noexcept override;

};

class __attribute__((__visibility__("default"))) underflow_error
    : public runtime_error
{
public:
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) explicit underflow_error(const string& __s) : runtime_error(__s) {}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) explicit underflow_error(const char* __s) : runtime_error(__s) {}


    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) underflow_error(const underflow_error&) noexcept = default;
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) underflow_error& operator=(const underflow_error&) noexcept = default;
    ~underflow_error() noexcept override;

};

}

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {


[[noreturn]] __attribute__((__visibility__("default"))) void __throw_runtime_error(const char*);

[[noreturn]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
void __throw_logic_error(const char*__msg)
{



    ::std::__libcpp_verbose_abort("logic_error was thrown in -fno-exceptions mode with message \"%s\"", __msg);

}

[[noreturn]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
void __throw_domain_error(const char*__msg)
{



    ::std::__libcpp_verbose_abort("domain_error was thrown in -fno-exceptions mode with message \"%s\"", __msg);

}

[[noreturn]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
void __throw_invalid_argument(const char*__msg)
{



    ::std::__libcpp_verbose_abort("invalid_argument was thrown in -fno-exceptions mode with message \"%s\"", __msg);

}

[[noreturn]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
void __throw_length_error(const char*__msg)
{



    ::std::__libcpp_verbose_abort("length_error was thrown in -fno-exceptions mode with message \"%s\"", __msg);

}

[[noreturn]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
void __throw_out_of_range(const char*__msg)
{



    ::std::__libcpp_verbose_abort("out_of_range was thrown in -fno-exceptions mode with message \"%s\"", __msg);

}

[[noreturn]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
void __throw_range_error(const char*__msg)
{



    ::std::__libcpp_verbose_abort("range_error was thrown in -fno-exceptions mode with message \"%s\"", __msg);

}

[[noreturn]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
void __throw_overflow_error(const char*__msg)
{



    ::std::__libcpp_verbose_abort("overflow_error was thrown in -fno-exceptions mode with message \"%s\"", __msg);

}

[[noreturn]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
void __throw_underflow_error(const char*__msg)
{



    ::std::__libcpp_verbose_abort("underflow_error was thrown in -fno-exceptions mode with message \"%s\"", __msg);

}

}}
# 16 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__format/format_error.h" 2 3
# 19 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__format/format_error.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {



#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wweak-vtables"
class __attribute__((__visibility__("default"))) format_error : public runtime_error {
public:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) explicit format_error(const string& __s)
      : runtime_error(__s) {}
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) explicit format_error(const char* __s)
      : runtime_error(__s) {}
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) format_error(const format_error&) = default;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) format_error& operator=(const format_error&) = default;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__))
  ~format_error() noexcept override = default;
};
#pragma clang diagnostic pop

[[noreturn]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) void
__throw_format_error(const char* __s) {



  ::std::__libcpp_verbose_abort("format_error was thrown in -fno-exceptions mode with message \"%s\"", __s);

}



}}
# 15 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__format/format_parse_context.h" 2 3

# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/string_view" 1 3
# 210 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/string_view" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__fwd/string_view.h" 1 3
# 18 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__fwd/string_view.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template<class _CharT, class _Traits = char_traits<_CharT> >
class basic_string_view;

typedef basic_string_view<char> string_view;

typedef basic_string_view<char8_t> u8string_view;

typedef basic_string_view<char16_t> u16string_view;
typedef basic_string_view<char32_t> u32string_view;

typedef basic_string_view<wchar_t> wstring_view;



template <class _CharT, class _Traits>
class __attribute__((__preferred_name__(string_view)))

      __attribute__((__preferred_name__(wstring_view)))


      __attribute__((__preferred_name__(u8string_view)))

      __attribute__((__preferred_name__(u16string_view)))
      __attribute__((__preferred_name__(u32string_view)))
      basic_string_view;

}}
# 211 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/string_view" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__iterator/bounded_iter.h" 1 3
# 24 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__iterator/bounded_iter.h" 3



# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__undef_macros" 1 3
# 28 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__iterator/bounded_iter.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 41 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__iterator/bounded_iter.h" 3
template <class _Iterator, class = __enable_if_t< __libcpp_is_contiguous_iterator<_Iterator>::value > >
struct __bounded_iter {
  using value_type = typename iterator_traits<_Iterator>::value_type;
  using difference_type = typename iterator_traits<_Iterator>::difference_type;
  using pointer = typename iterator_traits<_Iterator>::pointer;
  using reference = typename iterator_traits<_Iterator>::reference;
  using iterator_category = typename iterator_traits<_Iterator>::iterator_category;

  using iterator_concept = contiguous_iterator_tag;






  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) __bounded_iter() = default;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) __bounded_iter(__bounded_iter const&) = default;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) __bounded_iter(__bounded_iter&&) = default;

  template <class _OtherIterator, class = __enable_if_t< is_convertible<_OtherIterator, _Iterator>::value > >
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr __bounded_iter(__bounded_iter<_OtherIterator> const& __other) noexcept
      : __current_(__other.__current_),
        __begin_(__other.__begin_),
        __end_(__other.__end_) {}


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) __bounded_iter& operator=(__bounded_iter const&) = default;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) __bounded_iter& operator=(__bounded_iter&&) = default;

private:
# 81 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__iterator/bounded_iter.h" 3
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr explicit __bounded_iter(
      _Iterator __current, _Iterator __begin, _Iterator __end)
      : __current_(__current), __begin_(__begin), __end_(__end) {
    ((void)0);
  }

  template <class _It>
  friend constexpr __bounded_iter<_It> __make_bounded_iter(_It, _It, _It);

public:



  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr reference operator*() const noexcept {
    ((void)0);

    return *__current_;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr pointer operator->() const noexcept {
    ((void)0);

    return std::__to_address(__current_);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr reference operator[](difference_type __n) const noexcept {
    ((void)0);

    return __current_[__n];
  }





  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr __bounded_iter& operator++() noexcept {
    ++__current_;
    return *this;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr __bounded_iter operator++(int) noexcept {
    __bounded_iter __tmp(*this);
    ++*this;
    return __tmp;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr __bounded_iter& operator--() noexcept {
    --__current_;
    return *this;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr __bounded_iter operator--(int) noexcept {
    __bounded_iter __tmp(*this);
    --*this;
    return __tmp;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr __bounded_iter& operator+=(difference_type __n) noexcept {
    __current_ += __n;
    return *this;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr friend __bounded_iter
  operator+(__bounded_iter const& __self, difference_type __n) noexcept {
    __bounded_iter __tmp(__self);
    __tmp += __n;
    return __tmp;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr friend __bounded_iter
  operator+(difference_type __n, __bounded_iter const& __self) noexcept {
    __bounded_iter __tmp(__self);
    __tmp += __n;
    return __tmp;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr __bounded_iter& operator-=(difference_type __n) noexcept {
    __current_ -= __n;
    return *this;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr friend __bounded_iter
  operator-(__bounded_iter const& __self, difference_type __n) noexcept {
    __bounded_iter __tmp(__self);
    __tmp -= __n;
    return __tmp;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr friend difference_type
  operator-(__bounded_iter const& __x, __bounded_iter const& __y) noexcept {
    return __x.__current_ - __y.__current_;
  }







  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr friend bool
  operator==(__bounded_iter const& __x, __bounded_iter const& __y) noexcept {
    return __x.__current_ == __y.__current_;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr friend bool
  operator!=(__bounded_iter const& __x, __bounded_iter const& __y) noexcept {
    return __x.__current_ != __y.__current_;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr friend bool
  operator<(__bounded_iter const& __x, __bounded_iter const& __y) noexcept {
    return __x.__current_ < __y.__current_;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr friend bool
  operator>(__bounded_iter const& __x, __bounded_iter const& __y) noexcept {
    return __x.__current_ > __y.__current_;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr friend bool
  operator<=(__bounded_iter const& __x, __bounded_iter const& __y) noexcept {
    return __x.__current_ <= __y.__current_;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr friend bool
  operator>=(__bounded_iter const& __x, __bounded_iter const& __y) noexcept {
    return __x.__current_ >= __y.__current_;
  }

private:

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr bool __in_bounds(_Iterator const& __iter) const {
    return __iter >= __begin_ && __iter < __end_;
  }

  template <class>
  friend struct pointer_traits;
  _Iterator __current_;
  _Iterator __begin_, __end_;
};

template <class _It>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr __bounded_iter<_It> __make_bounded_iter(_It __it, _It __begin, _It __end) {
  return __bounded_iter<_It>(std::move(__it), std::move(__begin), std::move(__end));
}






template <class _Iterator>
struct pointer_traits<__bounded_iter<_Iterator> > {
  using pointer = __bounded_iter<_Iterator>;
  using element_type = typename pointer_traits<_Iterator>::element_type;
  using difference_type = typename pointer_traits<_Iterator>::difference_type;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr static element_type* to_address(pointer __it) noexcept {
    return std::__to_address(__it.__current_);
  }
};

}}
# 212 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/string_view" 2 3
# 221 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/string_view" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__string/char_traits.h" 1 3
# 25 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__string/char_traits.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/cstdio" 1 3
# 113 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/cstdio" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

using ::FILE __attribute__((__using_if_exists__));
using ::fpos_t __attribute__((__using_if_exists__));
using ::size_t __attribute__((__using_if_exists__));

using ::fclose __attribute__((__using_if_exists__));
using ::fflush __attribute__((__using_if_exists__));
using ::setbuf __attribute__((__using_if_exists__));
using ::setvbuf __attribute__((__using_if_exists__));
using ::fprintf __attribute__((__using_if_exists__));
using ::fscanf __attribute__((__using_if_exists__));
using ::snprintf __attribute__((__using_if_exists__));
using ::sprintf __attribute__((__using_if_exists__));
using ::sscanf __attribute__((__using_if_exists__));
using ::vfprintf __attribute__((__using_if_exists__));
using ::vfscanf __attribute__((__using_if_exists__));
using ::vsscanf __attribute__((__using_if_exists__));
using ::vsnprintf __attribute__((__using_if_exists__));
using ::vsprintf __attribute__((__using_if_exists__));
using ::fgetc __attribute__((__using_if_exists__));
using ::fgets __attribute__((__using_if_exists__));
using ::fputc __attribute__((__using_if_exists__));
using ::fputs __attribute__((__using_if_exists__));
using ::getc __attribute__((__using_if_exists__));
using ::putc __attribute__((__using_if_exists__));
using ::ungetc __attribute__((__using_if_exists__));
using ::fread __attribute__((__using_if_exists__));
using ::fwrite __attribute__((__using_if_exists__));

using ::fgetpos __attribute__((__using_if_exists__));

using ::fseek __attribute__((__using_if_exists__));

using ::fsetpos __attribute__((__using_if_exists__));

using ::ftell __attribute__((__using_if_exists__));
using ::rewind __attribute__((__using_if_exists__));
using ::clearerr __attribute__((__using_if_exists__));
using ::feof __attribute__((__using_if_exists__));
using ::ferror __attribute__((__using_if_exists__));
using ::perror __attribute__((__using_if_exists__));

using ::fopen __attribute__((__using_if_exists__));
using ::freopen __attribute__((__using_if_exists__));
using ::remove __attribute__((__using_if_exists__));
using ::rename __attribute__((__using_if_exists__));
using ::tmpfile __attribute__((__using_if_exists__));
using ::tmpnam __attribute__((__using_if_exists__));

using ::getchar __attribute__((__using_if_exists__));



using ::scanf __attribute__((__using_if_exists__));
using ::vscanf __attribute__((__using_if_exists__));

using ::printf __attribute__((__using_if_exists__));
using ::putchar __attribute__((__using_if_exists__));
using ::puts __attribute__((__using_if_exists__));
using ::vprintf __attribute__((__using_if_exists__));

}}
# 26 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__string/char_traits.h" 2 3
# 34 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__string/char_traits.h" 3



# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__undef_macros" 1 3
# 38 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__string/char_traits.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _CharT>
struct char_traits;
# 79 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__string/char_traits.h" 3
template <class _CharT>
struct __attribute__((__deprecated__("char_traits<T> for T not equal to char, wchar_t, char8_t, char16_t or char32_t is non-standard and is provided for a temporary period. It will be removed in LLVM 18, so please migrate off of it.")))
    char_traits
{
    using char_type = _CharT;
    using int_type = int;
    using off_type = streamoff;
    using pos_type = streampos;
    using state_type = mbstate_t;

    static inline void constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
        assign(char_type& __c1, const char_type& __c2) noexcept {__c1 = __c2;}
    static inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr bool eq(char_type __c1, char_type __c2) noexcept
        {return __c1 == __c2;}
    static inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr bool lt(char_type __c1, char_type __c2) noexcept
        {return __c1 < __c2;}

    static __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    int compare(const char_type* __s1, const char_type* __s2, size_t __n) {
        for (; __n; --__n, ++__s1, ++__s2)
        {
            if (lt(*__s1, *__s2))
                return -1;
            if (lt(*__s2, *__s1))
                return 1;
        }
        return 0;
    }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) static constexpr
    size_t length(const char_type* __s) {
        size_t __len = 0;
        for (; !eq(*__s, char_type(0)); ++__s)
            ++__len;
        return __len;
    }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) static constexpr
    const char_type* find(const char_type* __s, size_t __n, const char_type& __a) {
        for (; __n; --__n)
        {
            if (eq(*__s, __a))
                return __s;
            ++__s;
        }
        return nullptr;
    }
    static __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    char_type* move(char_type* __s1, const char_type* __s2, size_t __n) {
        if (__n == 0) return __s1;
        char_type* __r = __s1;
        if (__s1 < __s2)
        {
            for (; __n; --__n, ++__s1, ++__s2)
                assign(*__s1, *__s2);
        }
        else if (__s2 < __s1)
        {
            __s1 += __n;
            __s2 += __n;
            for (; __n; --__n)
                assign(*--__s1, *--__s2);
        }
        return __r;
    }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    static constexpr
    char_type* copy(char_type* __s1, const char_type* __s2, size_t __n) {
        if (!__libcpp_is_constant_evaluated()) {
            ((void)0);

        }
        char_type* __r = __s1;
        for (; __n; --__n, ++__s1, ++__s2)
            assign(*__s1, *__s2);
        return __r;
    }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    static constexpr
    char_type* assign(char_type* __s, size_t __n, char_type __a) {
        char_type* __r = __s;
        for (; __n; --__n, ++__s)
            assign(*__s, __a);
        return __r;
    }

    static inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr int_type not_eof(int_type __c) noexcept
        {return eq_int_type(__c, eof()) ? ~eof() : __c;}
    static inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr char_type to_char_type(int_type __c) noexcept
        {return char_type(__c);}
    static inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr int_type to_int_type(char_type __c) noexcept
        {return int_type(__c);}
    static inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr bool eq_int_type(int_type __c1, int_type __c2) noexcept
        {return __c1 == __c2;}
    static inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr int_type eof() noexcept
        {return int_type((-1));}
};




template <>
struct char_traits<char>
{
    using char_type = char;
    using int_type = int;
    using off_type = streamoff;
    using pos_type = streampos;
    using state_type = mbstate_t;

    using comparison_category = strong_ordering;


    static inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    void assign(char_type& __c1, const char_type& __c2) noexcept {__c1 = __c2;}


    static inline __attribute__((__visibility__("hidden"))) constexpr bool eq(char_type __c1, char_type __c2) noexcept
            {return __c1 == __c2;}
    static inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr bool lt(char_type __c1, char_type __c2) noexcept
        {return (unsigned char)__c1 < (unsigned char)__c2;}


    static __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr int
    compare(const char_type* __lhs, const char_type* __rhs, size_t __count) noexcept {
      if (__libcpp_is_constant_evaluated()) {

        return __builtin_memcmp(__lhs, __rhs, __count);
# 218 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__string/char_traits.h" 3
      } else {
        return __builtin_memcmp(__lhs, __rhs, __count);
      }
    }

    static inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) size_t constexpr length(const char_type* __s) noexcept {
      return std::__constexpr_strlen(__s);
    }

    static __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    const char_type* find(const char_type* __s, size_t __n, const char_type& __a) noexcept {
      if (__n == 0)
          return nullptr;
      return std::__constexpr_memchr(__s, __a, __n);
    }

    static inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    char_type* move(char_type* __s1, const char_type* __s2, size_t __n) noexcept {
        return std::__constexpr_memmove(__s1, __s2, __element_count(__n));
    }

    static inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    char_type* copy(char_type* __s1, const char_type* __s2, size_t __n) noexcept {
        if (!__libcpp_is_constant_evaluated())
            ((void)0);

        std::copy_n(__s2, __n, __s1);
        return __s1;
    }

    static inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    char_type* assign(char_type* __s, size_t __n, char_type __a) noexcept {
        std::fill_n(__s, __n, __a);
        return __s;
    }

    static inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr int_type not_eof(int_type __c) noexcept
        {return eq_int_type(__c, eof()) ? ~eof() : __c;}
    static inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr char_type to_char_type(int_type __c) noexcept
        {return char_type(__c);}
    static inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr int_type to_int_type(char_type __c) noexcept
        {return int_type((unsigned char)__c);}
    static inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr bool eq_int_type(int_type __c1, int_type __c2) noexcept
        {return __c1 == __c2;}
    static inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr int_type eof() noexcept
        {return int_type((-1));}
};




template <>
struct char_traits<wchar_t>
{
    using char_type = wchar_t;
    using int_type = wint_t;
    using off_type = streamoff;
    using pos_type = streampos;
    using state_type = mbstate_t;

    using comparison_category = strong_ordering;


    static inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    void assign(char_type& __c1, const char_type& __c2) noexcept {__c1 = __c2;}
    static inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr bool eq(char_type __c1, char_type __c2) noexcept
        {return __c1 == __c2;}
    static inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr bool lt(char_type __c1, char_type __c2) noexcept
        {return __c1 < __c2;}

  static __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr int
  compare(const char_type* __s1, const char_type* __s2, size_t __n) noexcept {
    if (__n == 0)
      return 0;
    return std::__constexpr_wmemcmp(__s1, __s2, __n);
  }

  static __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr size_t length(const char_type* __s) noexcept {
    return std::__constexpr_wcslen(__s);
  }

  static __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
  const char_type* find(const char_type* __s, size_t __n, const char_type& __a) noexcept {
    if (__n == 0)
        return nullptr;
    return std::__constexpr_wmemchr(__s, __a, __n);
  }

    static inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    char_type* move(char_type* __s1, const char_type* __s2, size_t __n) noexcept {
        return std::__constexpr_memmove(__s1, __s2, __element_count(__n));
    }

    static inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    char_type* copy(char_type* __s1, const char_type* __s2, size_t __n) noexcept {
        if (!__libcpp_is_constant_evaluated())
            ((void)0);

        std::copy_n(__s2, __n, __s1);
        return __s1;
    }

    static inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    char_type* assign(char_type* __s, size_t __n, char_type __a) noexcept {
        std::fill_n(__s, __n, __a);
        return __s;
    }

    static inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr int_type not_eof(int_type __c) noexcept
        {return eq_int_type(__c, eof()) ? ~eof() : __c;}
    static inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr char_type to_char_type(int_type __c) noexcept
        {return char_type(__c);}
    static inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr int_type to_int_type(char_type __c) noexcept
        {return int_type(__c);}
    static inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr bool eq_int_type(int_type __c1, int_type __c2) noexcept
        {return __c1 == __c2;}
    static inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr int_type eof() noexcept
        {return int_type((0xffffffffu));}
};




template <>
struct char_traits<char8_t>
{
    using char_type = char8_t;
    using int_type = unsigned int;
    using off_type = streamoff;
    using pos_type = u8streampos;
    using state_type = mbstate_t;

    using comparison_category = strong_ordering;


    static inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr void assign(char_type& __c1, const char_type& __c2) noexcept
        {__c1 = __c2;}
    static inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr bool eq(char_type __c1, char_type __c2) noexcept
        {return __c1 == __c2;}
    static inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr bool lt(char_type __c1, char_type __c2) noexcept
        {return __c1 < __c2;}

  static __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr int
  compare(const char_type* __s1, const char_type* __s2, size_t __n) noexcept {
      return std::__constexpr_memcmp(__s1, __s2, __element_count(__n));
  }

    static __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    size_t length(const char_type* __s) noexcept;

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) static constexpr
    const char_type* find(const char_type* __s, size_t __n, const char_type& __a) noexcept;

    static __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    char_type* move(char_type* __s1, const char_type* __s2, size_t __n) noexcept {
        return std::__constexpr_memmove(__s1, __s2, __element_count(__n));
    }

    static __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    char_type* copy(char_type* __s1, const char_type* __s2, size_t __n) noexcept {
        if (!__libcpp_is_constant_evaluated())
            ((void)0);

        std::copy_n(__s2, __n, __s1);
        return __s1;
    }

    static __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    char_type* assign(char_type* __s, size_t __n, char_type __a) noexcept {
        std::fill_n(__s, __n, __a);
        return __s;
    }

    static inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr int_type not_eof(int_type __c) noexcept
        {return eq_int_type(__c, eof()) ? ~eof() : __c;}
    static inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr char_type to_char_type(int_type __c) noexcept
        {return char_type(__c);}
    static inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr int_type to_int_type(char_type __c) noexcept
        {return int_type(__c);}
    static inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr bool eq_int_type(int_type __c1, int_type __c2) noexcept
        {return __c1 == __c2;}
    static inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr int_type eof() noexcept
        {return int_type((-1));}
};


inline constexpr
size_t
char_traits<char8_t>::length(const char_type* __s) noexcept
{
    size_t __len = 0;
    for (; !eq(*__s, char_type(0)); ++__s)
        ++__len;
    return __len;
}


inline constexpr
const char8_t*
char_traits<char8_t>::find(const char_type* __s, size_t __n, const char_type& __a) noexcept
{
    for (; __n; --__n)
    {
        if (eq(*__s, __a))
            return __s;
        ++__s;
    }
    return nullptr;
}



template <>
struct char_traits<char16_t>
{
    using char_type = char16_t;
    using int_type = uint_least16_t;
    using off_type = streamoff;
    using pos_type = u16streampos;
    using state_type = mbstate_t;

    using comparison_category = strong_ordering;


    static inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    void assign(char_type& __c1, const char_type& __c2) noexcept {__c1 = __c2;}
    static inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr bool eq(char_type __c1, char_type __c2) noexcept
        {return __c1 == __c2;}
    static inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr bool lt(char_type __c1, char_type __c2) noexcept
        {return __c1 < __c2;}

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) static constexpr
    int compare(const char_type* __s1, const char_type* __s2, size_t __n) noexcept;
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) static constexpr
    size_t length(const char_type* __s) noexcept;
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) static constexpr
    const char_type* find(const char_type* __s, size_t __n, const char_type& __a) noexcept;

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    static char_type* move(char_type* __s1, const char_type* __s2, size_t __n) noexcept {
        return std::__constexpr_memmove(__s1, __s2, __element_count(__n));
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    static char_type* copy(char_type* __s1, const char_type* __s2, size_t __n) noexcept {
        if (!__libcpp_is_constant_evaluated())
            ((void)0);

        std::copy_n(__s2, __n, __s1);
        return __s1;
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    static char_type* assign(char_type* __s, size_t __n, char_type __a) noexcept {
        std::fill_n(__s, __n, __a);
        return __s;
    }

    static inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr int_type not_eof(int_type __c) noexcept
        {return eq_int_type(__c, eof()) ? ~eof() : __c;}
    static inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr char_type to_char_type(int_type __c) noexcept
        {return char_type(__c);}
    static inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr int_type to_int_type(char_type __c) noexcept
        {return int_type(__c);}
    static inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr bool eq_int_type(int_type __c1, int_type __c2) noexcept
        {return __c1 == __c2;}
    static inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr int_type eof() noexcept
        {return int_type(0xFFFF);}
};

inline constexpr
int
char_traits<char16_t>::compare(const char_type* __s1, const char_type* __s2, size_t __n) noexcept
{
    for (; __n; --__n, ++__s1, ++__s2)
    {
        if (lt(*__s1, *__s2))
            return -1;
        if (lt(*__s2, *__s1))
            return 1;
    }
    return 0;
}

inline constexpr
size_t
char_traits<char16_t>::length(const char_type* __s) noexcept
{
    size_t __len = 0;
    for (; !eq(*__s, char_type(0)); ++__s)
        ++__len;
    return __len;
}

inline constexpr
const char16_t*
char_traits<char16_t>::find(const char_type* __s, size_t __n, const char_type& __a) noexcept
{
    for (; __n; --__n)
    {
        if (eq(*__s, __a))
            return __s;
        ++__s;
    }
    return nullptr;
}

template <>
struct char_traits<char32_t>
{
    using char_type = char32_t;
    using int_type = uint_least32_t;
    using off_type = streamoff;
    using pos_type = u32streampos;
    using state_type = mbstate_t;

    using comparison_category = strong_ordering;


    static inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    void assign(char_type& __c1, const char_type& __c2) noexcept {__c1 = __c2;}
    static inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr bool eq(char_type __c1, char_type __c2) noexcept
        {return __c1 == __c2;}
    static inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr bool lt(char_type __c1, char_type __c2) noexcept
        {return __c1 < __c2;}

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) static constexpr
    int compare(const char_type* __s1, const char_type* __s2, size_t __n) noexcept;
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) static constexpr
    size_t length(const char_type* __s) noexcept;
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) static constexpr
    const char_type* find(const char_type* __s, size_t __n, const char_type& __a) noexcept;

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    static char_type* move(char_type* __s1, const char_type* __s2, size_t __n) noexcept {
        return std::__constexpr_memmove(__s1, __s2, __element_count(__n));
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    static char_type* copy(char_type* __s1, const char_type* __s2, size_t __n) noexcept {
        std::copy_n(__s2, __n, __s1);
        return __s1;
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    static char_type* assign(char_type* __s, size_t __n, char_type __a) noexcept {
        std::fill_n(__s, __n, __a);
        return __s;
    }

    static inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr int_type not_eof(int_type __c) noexcept
        {return eq_int_type(__c, eof()) ? ~eof() : __c;}
    static inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr char_type to_char_type(int_type __c) noexcept
        {return char_type(__c);}
    static inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr int_type to_int_type(char_type __c) noexcept
        {return int_type(__c);}
    static inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr bool eq_int_type(int_type __c1, int_type __c2) noexcept
        {return __c1 == __c2;}
    static inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr int_type eof() noexcept
        {return int_type(0xFFFFFFFF);}
};

inline constexpr
int
char_traits<char32_t>::compare(const char_type* __s1, const char_type* __s2, size_t __n) noexcept
{
    for (; __n; --__n, ++__s1, ++__s2)
    {
        if (lt(*__s1, *__s2))
            return -1;
        if (lt(*__s2, *__s1))
            return 1;
    }
    return 0;
}

inline constexpr
size_t
char_traits<char32_t>::length(const char_type* __s) noexcept
{
    size_t __len = 0;
    for (; !eq(*__s, char_type(0)); ++__s)
        ++__len;
    return __len;
}

inline constexpr
const char32_t*
char_traits<char32_t>::find(const char_type* __s, size_t __n, const char_type& __a) noexcept
{
    for (; __n; --__n)
    {
        if (eq(*__s, __a))
            return __s;
        ++__s;
    }
    return nullptr;
}




template<class _CharT, class _SizeT, class _Traits, _SizeT __npos>
inline _SizeT constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
__str_find(const _CharT *__p, _SizeT __sz,
             _CharT __c, _SizeT __pos) noexcept
{
    if (__pos >= __sz)
        return __npos;
    const _CharT* __r = _Traits::find(__p + __pos, __sz - __pos, __c);
    if (__r == nullptr)
        return __npos;
    return static_cast<_SizeT>(__r - __p);
}

template <class _CharT, class _Traits>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) inline constexpr const _CharT *
__search_substring(const _CharT *__first1, const _CharT *__last1,
                   const _CharT *__first2, const _CharT *__last2) noexcept {


  const ptrdiff_t __len2 = __last2 - __first2;
  if (__len2 == 0)
    return __first1;

  ptrdiff_t __len1 = __last1 - __first1;
  if (__len1 < __len2)
    return __last1;


  _CharT __f2 = *__first2;
  while (true) {
    __len1 = __last1 - __first1;

    if (__len1 < __len2)
      return __last1;


    __first1 = _Traits::find(__first1, __len1 - __len2 + 1, __f2);
    if (__first1 == nullptr)
      return __last1;






    if (_Traits::compare(__first1, __first2, __len2) == 0)
      return __first1;

    ++__first1;
  }
}

template<class _CharT, class _SizeT, class _Traits, _SizeT __npos>
inline _SizeT constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
__str_find(const _CharT *__p, _SizeT __sz,
       const _CharT* __s, _SizeT __pos, _SizeT __n) noexcept
{
    if (__pos > __sz)
        return __npos;

    if (__n == 0)
        return __pos;

    const _CharT *__r = std::__search_substring<_CharT, _Traits>(
        __p + __pos, __p + __sz, __s, __s + __n);

    if (__r == __p + __sz)
        return __npos;
    return static_cast<_SizeT>(__r - __p);
}




template<class _CharT, class _SizeT, class _Traits, _SizeT __npos>
inline _SizeT constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
__str_rfind(const _CharT *__p, _SizeT __sz,
              _CharT __c, _SizeT __pos) noexcept
{
    if (__sz < 1)
        return __npos;
    if (__pos < __sz)
        ++__pos;
    else
        __pos = __sz;
    for (const _CharT* __ps = __p + __pos; __ps != __p;)
    {
        if (_Traits::eq(*--__ps, __c))
            return static_cast<_SizeT>(__ps - __p);
    }
    return __npos;
}

template<class _CharT, class _SizeT, class _Traits, _SizeT __npos>
inline _SizeT constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
__str_rfind(const _CharT *__p, _SizeT __sz,
        const _CharT* __s, _SizeT __pos, _SizeT __n) noexcept
{
    __pos = std::min(__pos, __sz);
    if (__n < __sz - __pos)
        __pos += __n;
    else
        __pos = __sz;
    const _CharT* __r = std::__find_end_classic(__p, __p + __pos, __s, __s + __n, _Traits::eq);
    if (__n > 0 && __r == __p + __pos)
        return __npos;
    return static_cast<_SizeT>(__r - __p);
}


template<class _CharT, class _SizeT, class _Traits, _SizeT __npos>
inline _SizeT constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
__str_find_first_of(const _CharT *__p, _SizeT __sz,
                const _CharT* __s, _SizeT __pos, _SizeT __n) noexcept
{
    if (__pos >= __sz || __n == 0)
        return __npos;
    const _CharT* __r = std::__find_first_of_ce
        (__p + __pos, __p + __sz, __s, __s + __n, _Traits::eq );
    if (__r == __p + __sz)
        return __npos;
    return static_cast<_SizeT>(__r - __p);
}



template<class _CharT, class _SizeT, class _Traits, _SizeT __npos>
inline _SizeT constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
__str_find_last_of(const _CharT *__p, _SizeT __sz,
               const _CharT* __s, _SizeT __pos, _SizeT __n) noexcept
    {
    if (__n != 0)
    {
        if (__pos < __sz)
            ++__pos;
        else
            __pos = __sz;
        for (const _CharT* __ps = __p + __pos; __ps != __p;)
        {
            const _CharT* __r = _Traits::find(__s, __n, *--__ps);
            if (__r)
                return static_cast<_SizeT>(__ps - __p);
        }
    }
    return __npos;
}



template<class _CharT, class _SizeT, class _Traits, _SizeT __npos>
inline _SizeT constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
__str_find_first_not_of(const _CharT *__p, _SizeT __sz,
                    const _CharT* __s, _SizeT __pos, _SizeT __n) noexcept
{
    if (__pos < __sz)
    {
        const _CharT* __pe = __p + __sz;
        for (const _CharT* __ps = __p + __pos; __ps != __pe; ++__ps)
            if (_Traits::find(__s, __n, *__ps) == nullptr)
                return static_cast<_SizeT>(__ps - __p);
    }
    return __npos;
}


template<class _CharT, class _SizeT, class _Traits, _SizeT __npos>
inline _SizeT constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
__str_find_first_not_of(const _CharT *__p, _SizeT __sz,
                          _CharT __c, _SizeT __pos) noexcept
{
    if (__pos < __sz)
    {
        const _CharT* __pe = __p + __sz;
        for (const _CharT* __ps = __p + __pos; __ps != __pe; ++__ps)
            if (!_Traits::eq(*__ps, __c))
                return static_cast<_SizeT>(__ps - __p);
    }
    return __npos;
}



template<class _CharT, class _SizeT, class _Traits, _SizeT __npos>
inline _SizeT constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
__str_find_last_not_of(const _CharT *__p, _SizeT __sz,
                   const _CharT* __s, _SizeT __pos, _SizeT __n) noexcept
{
    if (__pos < __sz)
        ++__pos;
    else
        __pos = __sz;
    for (const _CharT* __ps = __p + __pos; __ps != __p;)
        if (_Traits::find(__s, __n, *--__ps) == nullptr)
            return static_cast<_SizeT>(__ps - __p);
    return __npos;
}


template<class _CharT, class _SizeT, class _Traits, _SizeT __npos>
inline _SizeT constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
__str_find_last_not_of(const _CharT *__p, _SizeT __sz,
                         _CharT __c, _SizeT __pos) noexcept
{
    if (__pos < __sz)
        ++__pos;
    else
        __pos = __sz;
    for (const _CharT* __ps = __p + __pos; __ps != __p;)
        if (!_Traits::eq(*--__ps, __c))
            return static_cast<_SizeT>(__ps - __p);
    return __npos;
}

template<class _Ptr>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
size_t __do_string_hash(_Ptr __p, _Ptr __e)
{
    typedef typename iterator_traits<_Ptr>::value_type value_type;
    return __murmur2_or_cityhash<size_t>()(__p, (__e-__p)*sizeof(value_type));
}

}}
# 222 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/string_view" 2 3
# 240 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/string_view" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__iterator/data.h" 1 3
# 19 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__iterator/data.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {



template <class _Cont> constexpr
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
auto data(_Cont& __c)
noexcept(noexcept(__c.data()))
-> decltype (__c.data())
{ return __c.data(); }

template <class _Cont> constexpr
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
auto data(const _Cont& __c)
noexcept(noexcept(__c.data()))
-> decltype (__c.data())
{ return __c.data(); }

template <class _Tp, size_t _Sz>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
constexpr _Tp* data(_Tp (&__array)[_Sz]) noexcept { return __array; }

template <class _Ep>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
constexpr const _Ep* data(initializer_list<_Ep> __il) noexcept { return __il.begin(); }



}}
# 241 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/string_view" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__iterator/empty.h" 1 3
# 19 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__iterator/empty.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {



template <class _Cont>
[[__nodiscard__]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
constexpr auto empty(const _Cont& __c)
noexcept(noexcept(__c.empty()))
-> decltype (__c.empty())
{ return __c.empty(); }

template <class _Tp, size_t _Sz>
[[__nodiscard__]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
constexpr bool empty(const _Tp (&)[_Sz]) noexcept { return false; }

template <class _Ep>
[[__nodiscard__]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
constexpr bool empty(initializer_list<_Ep> __il) noexcept { return __il.size() == 0; }



}}
# 242 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/string_view" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__iterator/reverse_access.h" 1 3
# 20 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__iterator/reverse_access.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {



template <class _Tp, size_t _Np>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
reverse_iterator<_Tp*> rbegin(_Tp (&__array)[_Np])
{
    return reverse_iterator<_Tp*>(__array + _Np);
}

template <class _Tp, size_t _Np>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
reverse_iterator<_Tp*> rend(_Tp (&__array)[_Np])
{
    return reverse_iterator<_Tp*>(__array);
}

template <class _Ep>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
reverse_iterator<const _Ep*> rbegin(initializer_list<_Ep> __il)
{
    return reverse_iterator<const _Ep*>(__il.end());
}

template <class _Ep>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
reverse_iterator<const _Ep*> rend(initializer_list<_Ep> __il)
{
    return reverse_iterator<const _Ep*>(__il.begin());
}

template <class _Cp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
auto rbegin(_Cp& __c) -> decltype(__c.rbegin())
{
    return __c.rbegin();
}

template <class _Cp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
auto rbegin(const _Cp& __c) -> decltype(__c.rbegin())
{
    return __c.rbegin();
}

template <class _Cp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
auto rend(_Cp& __c) -> decltype(__c.rend())
{
    return __c.rend();
}

template <class _Cp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
auto rend(const _Cp& __c) -> decltype(__c.rend())
{
    return __c.rend();
}

template <class _Cp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
auto crbegin(const _Cp& __c) -> decltype(std::rbegin(__c))
{
    return std::rbegin(__c);
}

template <class _Cp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
auto crend(const _Cp& __c) -> decltype(std::rend(__c))
{
    return std::rend(__c);
}



}}
# 243 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/string_view" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__iterator/size.h" 1 3
# 20 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__iterator/size.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {



template <class _Cont>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
constexpr auto size(const _Cont& __c)
noexcept(noexcept(__c.size()))
-> decltype (__c.size())
{ return __c.size(); }

template <class _Tp, size_t _Sz>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
constexpr size_t size(const _Tp (&)[_Sz]) noexcept { return _Sz; }


template <class _Cont>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
constexpr auto ssize(const _Cont& __c)
noexcept(noexcept(static_cast<common_type_t<ptrdiff_t, make_signed_t<decltype(__c.size())>>>(__c.size())))
-> common_type_t<ptrdiff_t, make_signed_t<decltype(__c.size())>>
{ return static_cast<common_type_t<ptrdiff_t, make_signed_t<decltype(__c.size())>>>(__c.size()); }



#pragma clang diagnostic push

template <class _Tp, ptrdiff_t _Sz>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
constexpr ptrdiff_t ssize(const _Tp (&)[_Sz]) noexcept { return _Sz; }
#pragma clang diagnostic pop




}}
# 244 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/string_view" 2 3
# 250 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/string_view" 3



# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__undef_macros" 1 3
# 254 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/string_view" 2 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {



template <class _Traits>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
inline size_t __char_traits_length_checked(const typename _Traits::char_type* __s) noexcept {

  return ((void)0),

      _Traits::length(__s);
}

template<class _CharT, class _Traits>
class basic_string_view {
public:

    using traits_type = _Traits;
    using value_type = _CharT;
    using pointer = _CharT*;
    using const_pointer = const _CharT*;
    using reference = _CharT&;
    using const_reference = const _CharT&;



    using const_iterator = const_pointer;

    using iterator = const_iterator;
    using const_reverse_iterator = std::reverse_iterator<const_iterator>;
    using reverse_iterator = const_reverse_iterator;
    using size_type = size_t;
    using difference_type = ptrdiff_t;
    static constexpr const size_type npos = -1;

    static_assert((!is_array<value_type>::value), "Character type of basic_string_view must not be an array");
    static_assert(( is_standard_layout<value_type>::value), "Character type of basic_string_view must be standard-layout");
    static_assert(( is_trivial<value_type>::value), "Character type of basic_string_view must be trivial");
    static_assert((is_same<_CharT, typename traits_type::char_type>::value),
                  "traits_type::char_type must be the same type as CharT");


    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    basic_string_view() noexcept : __data_(nullptr), __size_(0) {}

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    basic_string_view(const basic_string_view&) noexcept = default;

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    basic_string_view& operator=(const basic_string_view&) noexcept = default;

    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    basic_string_view(const _CharT* __s, size_type __len) noexcept
        : __data_(__s), __size_(__len)
    {

    ((void)0);


    ((void)0);


    }


    template <contiguous_iterator _It, sized_sentinel_for<_It> _End>
      requires (is_same_v<iter_value_t<_It>, _CharT> && !is_convertible_v<_End, size_type>)
    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) basic_string_view(_It __begin, _End __end)
       : __data_(std::to_address(__begin)), __size_(__end - __begin)
    {
      ((void)0);

    }



    template <class _Range>
      requires (
        !is_same_v<remove_cvref_t<_Range>, basic_string_view> &&
        ranges::contiguous_range<_Range> &&
        ranges::sized_range<_Range> &&
        is_same_v<ranges::range_value_t<_Range>, _CharT> &&
        !is_convertible_v<_Range, const _CharT*> &&
        (!requires(remove_cvref_t<_Range>& __d) {
          __d.operator std::basic_string_view<_CharT, _Traits>();
        })
      )
    constexpr explicit __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    basic_string_view(_Range&& __r) : __data_(ranges::data(__r)), __size_(ranges::size(__r)) {}


    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    basic_string_view(const _CharT* __s)
        : __data_(__s), __size_(std::__char_traits_length_checked<_Traits>(__s)) {}


    basic_string_view(nullptr_t) = delete;



    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    const_iterator begin() const noexcept { return cbegin(); }

    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    const_iterator end() const noexcept { return cend(); }

    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    const_iterator cbegin() const noexcept {



        return __data_;

    }

    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    const_iterator cend() const noexcept {



        return __data_ + __size_;

    }

    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    const_reverse_iterator rbegin() const noexcept { return const_reverse_iterator(cend()); }

    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    const_reverse_iterator rend() const noexcept { return const_reverse_iterator(cbegin()); }

    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    const_reverse_iterator crbegin() const noexcept { return const_reverse_iterator(cend()); }

    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    const_reverse_iterator crend() const noexcept { return const_reverse_iterator(cbegin()); }


    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    size_type size() const noexcept { return __size_; }

    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    size_type length() const noexcept { return __size_; }

    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    size_type max_size() const noexcept { return numeric_limits<size_type>::max() / sizeof(value_type); }

    [[__nodiscard__]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    bool empty() const noexcept { return __size_ == 0; }


    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    const_reference operator[](size_type __pos) const noexcept {
      return ((void)0), __data_[__pos];
    }

    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    const_reference at(size_type __pos) const
    {
        return __pos >= size()
            ? (__throw_out_of_range("string_view::at"), __data_[0])
            : __data_[__pos];
    }

    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    const_reference front() const noexcept
    {
        return ((void)0), __data_[0];
    }

    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    const_reference back() const noexcept
    {
        return ((void)0),
               __data_[__size_ - 1];
    }

    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    const_pointer data() const noexcept { return __data_; }


    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    void remove_prefix(size_type __n) noexcept
    {
        ((void)0);
        __data_ += __n;
        __size_ -= __n;
    }

    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    void remove_suffix(size_type __n) noexcept
    {
        ((void)0);
        __size_ -= __n;
    }

    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    void swap(basic_string_view& __other) noexcept
    {
        const value_type *__p = __data_;
        __data_ = __other.__data_;
        __other.__data_ = __p;

        size_type __sz = __size_;
        __size_ = __other.__size_;
        __other.__size_ = __sz;
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    size_type copy(_CharT* __s, size_type __n, size_type __pos = 0) const
    {
        if (__pos > size())
            __throw_out_of_range("string_view::copy");
        size_type __rlen = std::min(__n, size() - __pos);
        _Traits::copy(__s, data() + __pos, __rlen);
        return __rlen;
    }

    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    basic_string_view substr(size_type __pos = 0, size_type __n = npos) const
    {
        return __pos > size()
            ? (__throw_out_of_range("string_view::substr"), basic_string_view())
            : basic_string_view(data() + __pos, std::min(__n, size() - __pos));
    }

    constexpr int compare(basic_string_view __sv) const noexcept
    {
        size_type __rlen = std::min(size(), __sv.size());
        int __retval = _Traits::compare(data(), __sv.data(), __rlen);
        if (__retval == 0)
            __retval = size() == __sv.size() ? 0 : (size() < __sv.size() ? -1 : 1);
        return __retval;
    }

    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    int compare(size_type __pos1, size_type __n1, basic_string_view __sv) const
    {
        return substr(__pos1, __n1).compare(__sv);
    }

    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    int compare( size_type __pos1, size_type __n1,
                basic_string_view __sv, size_type __pos2, size_type __n2) const
    {
        return substr(__pos1, __n1).compare(__sv.substr(__pos2, __n2));
    }

    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    int compare(const _CharT* __s) const noexcept
    {
        return compare(basic_string_view(__s));
    }

    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    int compare(size_type __pos1, size_type __n1, const _CharT* __s) const
    {
        return substr(__pos1, __n1).compare(basic_string_view(__s));
    }

    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    int compare(size_type __pos1, size_type __n1, const _CharT* __s, size_type __n2) const
    {
        return substr(__pos1, __n1).compare(basic_string_view(__s, __n2));
    }


    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    size_type find(basic_string_view __s, size_type __pos = 0) const noexcept
    {
        ((void)0);
        return std::__str_find<value_type, size_type, traits_type, npos>
            (data(), size(), __s.data(), __pos, __s.size());
    }

    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    size_type find(_CharT __c, size_type __pos = 0) const noexcept
    {
        return std::__str_find<value_type, size_type, traits_type, npos>
            (data(), size(), __c, __pos);
    }

    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    size_type find(const _CharT* __s, size_type __pos, size_type __n) const noexcept
    {
        ((void)0);
        return std::__str_find<value_type, size_type, traits_type, npos>
            (data(), size(), __s, __pos, __n);
    }

    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    size_type find(const _CharT* __s, size_type __pos = 0) const noexcept
    {
        ((void)0);
        return std::__str_find<value_type, size_type, traits_type, npos>
            (data(), size(), __s, __pos, traits_type::length(__s));
    }


    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    size_type rfind(basic_string_view __s, size_type __pos = npos) const noexcept
    {
        ((void)0);
        return std::__str_rfind<value_type, size_type, traits_type, npos>
            (data(), size(), __s.data(), __pos, __s.size());
    }

    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    size_type rfind(_CharT __c, size_type __pos = npos) const noexcept
    {
        return std::__str_rfind<value_type, size_type, traits_type, npos>
            (data(), size(), __c, __pos);
    }

    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    size_type rfind(const _CharT* __s, size_type __pos, size_type __n) const noexcept
    {
        ((void)0);
        return std::__str_rfind<value_type, size_type, traits_type, npos>
            (data(), size(), __s, __pos, __n);
    }

    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    size_type rfind(const _CharT* __s, size_type __pos=npos) const noexcept
    {
        ((void)0);
        return std::__str_rfind<value_type, size_type, traits_type, npos>
            (data(), size(), __s, __pos, traits_type::length(__s));
    }


    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    size_type find_first_of(basic_string_view __s, size_type __pos = 0) const noexcept
    {
        ((void)0);

        return std::__str_find_first_of<value_type, size_type, traits_type, npos>
            (data(), size(), __s.data(), __pos, __s.size());
    }

    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    size_type find_first_of(_CharT __c, size_type __pos = 0) const noexcept
    { return find(__c, __pos); }

    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    size_type find_first_of(const _CharT* __s, size_type __pos, size_type __n) const noexcept
    {
        ((void)0);
        return std::__str_find_first_of<value_type, size_type, traits_type, npos>
            (data(), size(), __s, __pos, __n);
    }

    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    size_type find_first_of(const _CharT* __s, size_type __pos=0) const noexcept
    {
        ((void)0);
        return std::__str_find_first_of<value_type, size_type, traits_type, npos>
            (data(), size(), __s, __pos, traits_type::length(__s));
    }


    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    size_type find_last_of(basic_string_view __s, size_type __pos=npos) const noexcept
    {
        ((void)0);

        return std::__str_find_last_of<value_type, size_type, traits_type, npos>
            (data(), size(), __s.data(), __pos, __s.size());
    }

    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    size_type find_last_of(_CharT __c, size_type __pos = npos) const noexcept
    { return rfind(__c, __pos); }

    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    size_type find_last_of(const _CharT* __s, size_type __pos, size_type __n) const noexcept
    {
        ((void)0);
        return std::__str_find_last_of<value_type, size_type, traits_type, npos>
            (data(), size(), __s, __pos, __n);
    }

    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    size_type find_last_of(const _CharT* __s, size_type __pos=npos) const noexcept
    {
        ((void)0);
        return std::__str_find_last_of<value_type, size_type, traits_type, npos>
            (data(), size(), __s, __pos, traits_type::length(__s));
    }


    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    size_type find_first_not_of(basic_string_view __s, size_type __pos=0) const noexcept
    {
        ((void)0);

        return std::__str_find_first_not_of<value_type, size_type, traits_type, npos>
            (data(), size(), __s.data(), __pos, __s.size());
    }

    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    size_type find_first_not_of(_CharT __c, size_type __pos=0) const noexcept
    {
        return std::__str_find_first_not_of<value_type, size_type, traits_type, npos>
            (data(), size(), __c, __pos);
    }

    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    size_type find_first_not_of(const _CharT* __s, size_type __pos, size_type __n) const noexcept
    {
        ((void)0);
        return std::__str_find_first_not_of<value_type, size_type, traits_type, npos>
            (data(), size(), __s, __pos, __n);
    }

    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    size_type find_first_not_of(const _CharT* __s, size_type __pos=0) const noexcept
    {
        ((void)0);
        return std::__str_find_first_not_of<value_type, size_type, traits_type, npos>
            (data(), size(), __s, __pos, traits_type::length(__s));
    }


    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    size_type find_last_not_of(basic_string_view __s, size_type __pos=npos) const noexcept
    {
        ((void)0);

        return std::__str_find_last_not_of<value_type, size_type, traits_type, npos>
            (data(), size(), __s.data(), __pos, __s.size());
    }

    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    size_type find_last_not_of(_CharT __c, size_type __pos=npos) const noexcept
    {
        return std::__str_find_last_not_of<value_type, size_type, traits_type, npos>
            (data(), size(), __c, __pos);
    }

    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    size_type find_last_not_of(const _CharT* __s, size_type __pos, size_type __n) const noexcept
    {
        ((void)0);
        return std::__str_find_last_not_of<value_type, size_type, traits_type, npos>
            (data(), size(), __s, __pos, __n);
    }

    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    size_type find_last_not_of(const _CharT* __s, size_type __pos=npos) const noexcept
    {
        ((void)0);
        return std::__str_find_last_not_of<value_type, size_type, traits_type, npos>
            (data(), size(), __s, __pos, traits_type::length(__s));
    }


    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    bool starts_with(basic_string_view __s) const noexcept
    { return size() >= __s.size() && compare(0, __s.size(), __s) == 0; }

    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    bool starts_with(value_type __c) const noexcept
    { return !empty() && _Traits::eq(front(), __c); }

    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    bool starts_with(const value_type* __s) const noexcept
    { return starts_with(basic_string_view(__s)); }

    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    bool ends_with(basic_string_view __s) const noexcept
    { return size() >= __s.size() && compare(size() - __s.size(), npos, __s) == 0; }

    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    bool ends_with(value_type __c) const noexcept
    { return !empty() && _Traits::eq(back(), __c); }

    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    bool ends_with(const value_type* __s) const noexcept
    { return ends_with(basic_string_view(__s)); }



    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    bool contains(basic_string_view __sv) const noexcept
    { return find(__sv) != npos; }

    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    bool contains(value_type __c) const noexcept
    { return find(__c) != npos; }

    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    bool contains(const value_type* __s) const
    { return find(__s) != npos; }


private:
    const value_type* __data_;
    size_type __size_;
};
template <class... _Tag> [[maybe_unused]] basic_string_view(typename _Tag::__allow_ctad...)->basic_string_view<_Tag...>;


template <class _CharT, class _Traits>
inline constexpr bool ranges::enable_view<basic_string_view<_CharT, _Traits>> = true;

template <class _CharT, class _Traits>
inline constexpr bool ranges::enable_borrowed_range<basic_string_view<_CharT, _Traits> > = true;





template <contiguous_iterator _It, sized_sentinel_for<_It> _End>
  basic_string_view(_It, _End) -> basic_string_view<iter_value_t<_It>>;




template <ranges::contiguous_range _Range>
  basic_string_view(_Range) -> basic_string_view<ranges::range_value_t<_Range>>;






template<class _CharT, class _Traits>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
bool operator==(basic_string_view<_CharT, _Traits> __lhs,
                type_identity_t<basic_string_view<_CharT, _Traits>> __rhs) noexcept {
    if (__lhs.size() != __rhs.size()) return false;
    return __lhs.compare(__rhs) == 0;
}

template <class _CharT, class _Traits>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr auto operator<=>(
    basic_string_view<_CharT, _Traits> __lhs, type_identity_t<basic_string_view<_CharT, _Traits>> __rhs) noexcept {
    if constexpr (requires { typename _Traits::comparison_category; }) {

        static_assert(
            __comparison_category<typename _Traits::comparison_category>,
            "return type is not a comparison category type");
        return static_cast<typename _Traits::comparison_category>(__lhs.compare(__rhs) <=> 0);
    } else {
        return static_cast<weak_ordering>(__lhs.compare(__rhs) <=> 0);
    }
}
# 970 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/string_view" 3
template<class _CharT, class _Traits>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os,
           basic_string_view<_CharT, _Traits> __str);


template<class _CharT>
struct __string_view_hash : public __unary_function<basic_string_view<_CharT, char_traits<_CharT> >, size_t>
{
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    size_t operator()(const basic_string_view<_CharT, char_traits<_CharT> > __val) const noexcept {
        return std::__do_string_hash(__val.data(), __val.data() + __val.size());
    }
};

template <>
struct hash<basic_string_view<char, char_traits<char> > > : __string_view_hash<char> {};


template <>
struct hash<basic_string_view<char8_t, char_traits<char8_t> > > : __string_view_hash<char8_t> {};


template <>
struct hash<basic_string_view<char16_t, char_traits<char16_t> > > : __string_view_hash<char16_t> {};

template <>
struct hash<basic_string_view<char32_t, char_traits<char32_t> > > : __string_view_hash<char32_t> {};


template <>
struct hash<basic_string_view<wchar_t, char_traits<wchar_t> > > : __string_view_hash<wchar_t> {};



inline namespace literals
{
  inline namespace string_view_literals
  {
    inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    basic_string_view<char> operator""sv(const char *__str, size_t __len) noexcept
    {
        return basic_string_view<char> (__str, __len);
    }


    inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    basic_string_view<wchar_t> operator""sv(const wchar_t *__str, size_t __len) noexcept
    {
        return basic_string_view<wchar_t> (__str, __len);
    }



    inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    basic_string_view<char8_t> operator""sv(const char8_t *__str, size_t __len) noexcept
    {
        return basic_string_view<char8_t> (__str, __len);
    }


    inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    basic_string_view<char16_t> operator""sv(const char16_t *__str, size_t __len) noexcept
    {
        return basic_string_view<char16_t> (__str, __len);
    }

    inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    basic_string_view<char32_t> operator""sv(const char32_t *__str, size_t __len) noexcept
    {
        return basic_string_view<char32_t> (__str, __len);
    }
  }
}

}}
# 17 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__format/format_parse_context.h" 2 3
# 20 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__format/format_parse_context.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {



template <class _CharT>
class basic_format_parse_context {
public:
  using char_type = _CharT;
  using const_iterator = typename basic_string_view<_CharT>::const_iterator;
  using iterator = const_iterator;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
  constexpr explicit basic_format_parse_context(basic_string_view<_CharT> __fmt,
                                                size_t __num_args = 0) noexcept
      : __begin_(__fmt.begin()),
        __end_(__fmt.end()),
        __indexing_(__unknown),
        __next_arg_id_(0),
        __num_args_(__num_args) {}

  basic_format_parse_context(const basic_format_parse_context&) = delete;
  basic_format_parse_context&
  operator=(const basic_format_parse_context&) = delete;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr const_iterator begin() const noexcept {
    return __begin_;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr const_iterator end() const noexcept {
    return __end_;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr void advance_to(const_iterator __it) {
    __begin_ = __it;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr size_t next_arg_id() {
    if (__indexing_ == __manual)
      std::__throw_format_error("Using automatic argument numbering in manual argument numbering mode");

    if (__indexing_ == __unknown)
      __indexing_ = __automatic;
# 71 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__format/format_parse_context.h" 3
    if (is_constant_evaluated() && __next_arg_id_ >= __num_args_)
      std::__throw_format_error("Argument index outside the valid range");

    return __next_arg_id_++;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr void check_arg_id(size_t __id) {
    if (__indexing_ == __automatic)
      std::__throw_format_error("Using manual argument numbering in automatic argument numbering mode");

    if (__indexing_ == __unknown)
      __indexing_ = __manual;
# 90 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__format/format_parse_context.h" 3
    if (is_constant_evaluated() && __id >= __num_args_)
      std::__throw_format_error("Argument index outside the valid range");
  }

private:
  iterator __begin_;
  iterator __end_;
  enum _Indexing { __unknown, __manual, __automatic };
  _Indexing __indexing_;
  size_t __next_arg_id_;
  size_t __num_args_;
};
template <class... _Tag> [[maybe_unused]] basic_format_parse_context(typename _Tag::__allow_ctad...)->basic_format_parse_context<_Tag...>;

using format_parse_context = basic_format_parse_context<char>;

using wformat_parse_context = basic_format_parse_context<wchar_t>;




}}
# 18 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__format/concepts.h" 2 3



# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/tuple" 1 3
# 212 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/tuple" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__memory/allocator_arg_t.h" 1 3
# 14 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__memory/allocator_arg_t.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__memory/uses_allocator.h" 1 3
# 19 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__memory/uses_allocator.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Tp>
struct __has_allocator_type
{
private:
    template <class _Up> static false_type __test(...);
    template <class _Up> static true_type __test(typename _Up::allocator_type* = 0);
public:
    static const bool value = decltype(__test<_Tp>(0))::value;
};

template <class _Tp, class _Alloc, bool = __has_allocator_type<_Tp>::value>
struct __uses_allocator
    : public integral_constant<bool,
        is_convertible<_Alloc, typename _Tp::allocator_type>::value>
{
};

template <class _Tp, class _Alloc>
struct __uses_allocator<_Tp, _Alloc, false>
    : public false_type
{
};

template <class _Tp, class _Alloc>
struct uses_allocator
    : public __uses_allocator<_Tp, _Alloc>
{
};


template <class _Tp, class _Alloc>
inline constexpr bool uses_allocator_v = uses_allocator<_Tp, _Alloc>::value;


}}
# 15 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__memory/allocator_arg_t.h" 2 3
# 22 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__memory/allocator_arg_t.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

struct allocator_arg_t { explicit allocator_arg_t() = default; };


inline constexpr allocator_arg_t allocator_arg = allocator_arg_t();
# 38 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__memory/allocator_arg_t.h" 3
template <class _Tp, class _Alloc, class ..._Args>
struct __uses_alloc_ctor_imp
{
    typedef __attribute__((__nodebug__)) __remove_cvref_t<_Alloc> _RawAlloc;
    static const bool __ua = uses_allocator<_Tp, _RawAlloc>::value;
    static const bool __ic =
        is_constructible<_Tp, allocator_arg_t, _Alloc, _Args...>::value;
    static const int value = __ua ? 2 - __ic : 0;
};

template <class _Tp, class _Alloc, class ..._Args>
struct __uses_alloc_ctor
    : integral_constant<int, __uses_alloc_ctor_imp<_Tp, _Alloc, _Args...>::value>
    {};

template <class _Tp, class _Allocator, class... _Args>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
void __user_alloc_construct_impl (integral_constant<int, 0>, _Tp *__storage, const _Allocator &, _Args &&... __args )
{
    new (__storage) _Tp (std::forward<_Args>(__args)...);
}


template <class _Tp, class _Allocator, class... _Args>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
void __user_alloc_construct_impl (integral_constant<int, 1>, _Tp *__storage, const _Allocator &__a, _Args &&... __args )
{
    new (__storage) _Tp (allocator_arg, __a, std::forward<_Args>(__args)...);
}


template <class _Tp, class _Allocator, class... _Args>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
void __user_alloc_construct_impl (integral_constant<int, 2>, _Tp *__storage, const _Allocator &__a, _Args &&... __args )
{
    new (__storage) _Tp (std::forward<_Args>(__args)..., __a);
}



}}
# 213 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/tuple" 2 3
# 272 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/tuple" 3



# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__undef_macros" 1 3
# 276 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/tuple" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {






template <size_t _Ip, class _Hp,
          bool=is_empty<_Hp>::value && !__libcpp_is_final<_Hp>::value
         >
class __tuple_leaf;

template <size_t _Ip, class _Hp, bool _Ep>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
void swap(__tuple_leaf<_Ip, _Hp, _Ep>& __x, __tuple_leaf<_Ip, _Hp, _Ep>& __y)
    noexcept(__is_nothrow_swappable<_Hp>::value)
{
    swap(__x.get(), __y.get());
}

template <size_t _Ip, class _Hp, bool _Ep>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
void swap(const __tuple_leaf<_Ip, _Hp, _Ep>& __x, const __tuple_leaf<_Ip, _Hp, _Ep>& __y)
     noexcept(__is_nothrow_swappable<const _Hp>::value) {
  swap(__x.get(), __y.get());
}

template <size_t _Ip, class _Hp, bool>
class __tuple_leaf
{
    _Hp __value_;

    template <class _Tp>
    static __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr bool __can_bind_reference() {

      return !__reference_binds_to_temporary(_Hp, _Tp);



    }

    constexpr
    __tuple_leaf& operator=(const __tuple_leaf&);
public:
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr __tuple_leaf()
             noexcept(is_nothrow_default_constructible<_Hp>::value) : __value_()
       {static_assert(!is_reference<_Hp>::value,
              "Attempted to default construct a reference element in a tuple");}

    template <class _Alloc>
        __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
        __tuple_leaf(integral_constant<int, 0>, const _Alloc&)
            : __value_()
        {static_assert(!is_reference<_Hp>::value,
              "Attempted to default construct a reference element in a tuple");}

    template <class _Alloc>
        __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
        __tuple_leaf(integral_constant<int, 1>, const _Alloc& __a)
            : __value_(allocator_arg_t(), __a)
        {static_assert(!is_reference<_Hp>::value,
              "Attempted to default construct a reference element in a tuple");}

    template <class _Alloc>
        __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
        __tuple_leaf(integral_constant<int, 2>, const _Alloc& __a)
            : __value_(__a)
        {static_assert(!is_reference<_Hp>::value,
              "Attempted to default construct a reference element in a tuple");}

    template <class _Tp,
              class = __enable_if_t<
                  _And<
                      _IsNotSame<__remove_cvref_t<_Tp>, __tuple_leaf>,
                      is_constructible<_Hp, _Tp>
                    >::value
                >
            >
        __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
        explicit __tuple_leaf(_Tp&& __t) noexcept((is_nothrow_constructible<_Hp, _Tp>::value))
            : __value_(std::forward<_Tp>(__t))
        {static_assert(__can_bind_reference<_Tp&&>(),
       "Attempted construction of reference element binds to a temporary whose lifetime has ended");}

    template <class _Tp, class _Alloc>
        __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
        explicit __tuple_leaf(integral_constant<int, 0>, const _Alloc&, _Tp&& __t)
            : __value_(std::forward<_Tp>(__t))
        {static_assert(__can_bind_reference<_Tp&&>(),
       "Attempted construction of reference element binds to a temporary whose lifetime has ended");}

    template <class _Tp, class _Alloc>
        __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
        explicit __tuple_leaf(integral_constant<int, 1>, const _Alloc& __a, _Tp&& __t)
            : __value_(allocator_arg_t(), __a, std::forward<_Tp>(__t))
        {static_assert(!is_reference<_Hp>::value,
            "Attempted to uses-allocator construct a reference element in a tuple");}

    template <class _Tp, class _Alloc>
        __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
        explicit __tuple_leaf(integral_constant<int, 2>, const _Alloc& __a, _Tp&& __t)
            : __value_(std::forward<_Tp>(__t), __a)
        {static_assert(!is_reference<_Hp>::value,
           "Attempted to uses-allocator construct a reference element in a tuple");}

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) __tuple_leaf(const __tuple_leaf& __t) = default;
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) __tuple_leaf(__tuple_leaf&& __t) = default;

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    int swap(__tuple_leaf& __t) noexcept(__is_nothrow_swappable<__tuple_leaf>::value)
    {
        std::swap(*this, __t);
        return 0;
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    int swap(const __tuple_leaf& __t) const noexcept(__is_nothrow_swappable<const __tuple_leaf>::value) {
        std::swap(*this, __t);
        return 0;
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr _Hp& get() noexcept {return __value_;}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr const _Hp& get() const noexcept {return __value_;}
};

template <size_t _Ip, class _Hp>
class __tuple_leaf<_Ip, _Hp, true>
    : private _Hp
{
    constexpr
    __tuple_leaf& operator=(const __tuple_leaf&);
public:
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr __tuple_leaf()
             noexcept(is_nothrow_default_constructible<_Hp>::value) {}

    template <class _Alloc>
        __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
        __tuple_leaf(integral_constant<int, 0>, const _Alloc&) {}

    template <class _Alloc>
        __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
        __tuple_leaf(integral_constant<int, 1>, const _Alloc& __a)
            : _Hp(allocator_arg_t(), __a) {}

    template <class _Alloc>
        __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
        __tuple_leaf(integral_constant<int, 2>, const _Alloc& __a)
            : _Hp(__a) {}

    template <class _Tp,
              class = __enable_if_t<
                  _And<
                    _IsNotSame<__remove_cvref_t<_Tp>, __tuple_leaf>,
                    is_constructible<_Hp, _Tp>
                  >::value
                >
            >
        __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
        explicit __tuple_leaf(_Tp&& __t) noexcept((is_nothrow_constructible<_Hp, _Tp>::value))
            : _Hp(std::forward<_Tp>(__t)) {}

    template <class _Tp, class _Alloc>
        __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
        explicit __tuple_leaf(integral_constant<int, 0>, const _Alloc&, _Tp&& __t)
            : _Hp(std::forward<_Tp>(__t)) {}

    template <class _Tp, class _Alloc>
        __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
        explicit __tuple_leaf(integral_constant<int, 1>, const _Alloc& __a, _Tp&& __t)
            : _Hp(allocator_arg_t(), __a, std::forward<_Tp>(__t)) {}

    template <class _Tp, class _Alloc>
        __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
        explicit __tuple_leaf(integral_constant<int, 2>, const _Alloc& __a, _Tp&& __t)
            : _Hp(std::forward<_Tp>(__t), __a) {}

    __tuple_leaf(__tuple_leaf const &) = default;
    __tuple_leaf(__tuple_leaf &&) = default;

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    int
    swap(__tuple_leaf& __t) noexcept(__is_nothrow_swappable<__tuple_leaf>::value)
    {
        std::swap(*this, __t);
        return 0;
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    int swap(const __tuple_leaf& __rhs) const noexcept(__is_nothrow_swappable<const __tuple_leaf>::value) {
        std::swap(*this, __rhs);
        return 0;
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr _Hp& get() noexcept {return static_cast<_Hp&>(*this);}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr const _Hp& get() const noexcept {return static_cast<const _Hp&>(*this);}
};

template <class ..._Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
void __swallow(_Tp&&...) noexcept {}

template <class _Tp>
struct __all_default_constructible;

template <class ..._Tp>
struct __all_default_constructible<__tuple_types<_Tp...>>
    : __all<is_default_constructible<_Tp>::value...>
{ };



template<class _Indx, class ..._Tp> struct __tuple_impl;

template<size_t ..._Indx, class ..._Tp>
struct __tuple_impl<__tuple_indices<_Indx...>, _Tp...>
    : public __tuple_leaf<_Indx, _Tp>...
{
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    constexpr __tuple_impl()
        noexcept(__all<is_nothrow_default_constructible<_Tp>::value...>::value) {}

    template <size_t ..._Uf, class ..._Tf,
              size_t ..._Ul, class ..._Tl, class ..._Up>
        __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
        explicit
        __tuple_impl(__tuple_indices<_Uf...>, __tuple_types<_Tf...>,
                     __tuple_indices<_Ul...>, __tuple_types<_Tl...>,
                     _Up&&... __u)
                     noexcept((__all<is_nothrow_constructible<_Tf, _Up>::value...>::value && __all<is_nothrow_default_constructible<_Tl>::value...>::value)) :

            __tuple_leaf<_Uf, _Tf>(std::forward<_Up>(__u))...,
            __tuple_leaf<_Ul, _Tl>()...
            {}

    template <class _Alloc, size_t ..._Uf, class ..._Tf,
              size_t ..._Ul, class ..._Tl, class ..._Up>
        __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
        explicit
        __tuple_impl(allocator_arg_t, const _Alloc& __a,
                     __tuple_indices<_Uf...>, __tuple_types<_Tf...>,
                     __tuple_indices<_Ul...>, __tuple_types<_Tl...>,
                     _Up&&... __u) :
            __tuple_leaf<_Uf, _Tf>(__uses_alloc_ctor<_Tf, _Alloc, _Up>(), __a,
            std::forward<_Up>(__u))...,
            __tuple_leaf<_Ul, _Tl>(__uses_alloc_ctor<_Tl, _Alloc>(), __a)...
            {}

    template <class _Tuple,
              class = __enable_if_t<__tuple_constructible<_Tuple, tuple<_Tp...> >::value>
             >
        __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
        __tuple_impl(_Tuple&& __t) noexcept((__all<is_nothrow_constructible<_Tp, typename tuple_element<_Indx, typename __make_tuple_types<_Tuple>::type>::type>::value...>::value))

            : __tuple_leaf<_Indx, _Tp>(std::forward<typename tuple_element<_Indx,
                                       typename __make_tuple_types<_Tuple>::type>::type>(std::get<_Indx>(__t)))...
            {}

    template <class _Alloc, class _Tuple,
              class = __enable_if_t<__tuple_constructible<_Tuple, tuple<_Tp...> >::value>
             >
        __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
        __tuple_impl(allocator_arg_t, const _Alloc& __a, _Tuple&& __t)
            : __tuple_leaf<_Indx, _Tp>(__uses_alloc_ctor<_Tp, _Alloc, typename tuple_element<_Indx,
                                       typename __make_tuple_types<_Tuple>::type>::type>(), __a,
                                       std::forward<typename tuple_element<_Indx,
                                       typename __make_tuple_types<_Tuple>::type>::type>(std::get<_Indx>(__t)))...
            {}

    __tuple_impl(const __tuple_impl&) = default;
    __tuple_impl(__tuple_impl&&) = default;

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    void swap(__tuple_impl& __t)
        noexcept(__all<__is_nothrow_swappable<_Tp>::value...>::value)
    {
        std::__swallow(__tuple_leaf<_Indx, _Tp>::swap(static_cast<__tuple_leaf<_Indx, _Tp>&>(__t))...);
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    void swap(const __tuple_impl& __t) const
        noexcept(__all<__is_nothrow_swappable<const _Tp>::value...>::value)
    {
        std::__swallow(__tuple_leaf<_Indx, _Tp>::swap(static_cast<const __tuple_leaf<_Indx, _Tp>&>(__t))...);
    }
};

template<class _Dest, class _Source, size_t ..._Np>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
void __memberwise_copy_assign(_Dest& __dest, _Source const& __source, __tuple_indices<_Np...>) {
    std::__swallow(((std::get<_Np>(__dest) = std::get<_Np>(__source)), void(), 0)...);
}

template<class _Dest, class _Source, class ..._Up, size_t ..._Np>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
void __memberwise_forward_assign(_Dest& __dest, _Source&& __source, __tuple_types<_Up...>, __tuple_indices<_Np...>) {
    std::__swallow(((
        std::get<_Np>(__dest) = std::forward<_Up>(std::get<_Np>(__source))
    ), void(), 0)...);
}

template <class ..._Tp>
class tuple
{
    typedef __tuple_impl<typename __make_tuple_indices<sizeof...(_Tp)>::type, _Tp...> _BaseT;

    _BaseT __base_;

    template <size_t _Jp, class ..._Up> friend constexpr
        typename tuple_element<_Jp, tuple<_Up...> >::type& get(tuple<_Up...>&) noexcept;
    template <size_t _Jp, class ..._Up> friend constexpr
        const typename tuple_element<_Jp, tuple<_Up...> >::type& get(const tuple<_Up...>&) noexcept;
    template <size_t _Jp, class ..._Up> friend constexpr
        typename tuple_element<_Jp, tuple<_Up...> >::type&& get(tuple<_Up...>&&) noexcept;
    template <size_t _Jp, class ..._Up> friend constexpr
        const typename tuple_element<_Jp, tuple<_Up...> >::type&& get(const tuple<_Up...>&&) noexcept;
public:



    template <template<class...> class _IsImpDefault = __is_implicitly_default_constructible, __enable_if_t<
        _And<
            _IsImpDefault<_Tp>...
        >::value
    , int> = 0>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    tuple()
        noexcept(_And<is_nothrow_default_constructible<_Tp>...>::value)
    { }

    template <template<class...> class _IsImpDefault = __is_implicitly_default_constructible,
              template<class...> class _IsDefault = is_default_constructible, __enable_if_t<
        _And<
            _IsDefault<_Tp>...,
            _Not<_Lazy<_And, _IsImpDefault<_Tp>...> >
        >::value
    , int> = 0>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    explicit tuple()
        noexcept(_And<is_nothrow_default_constructible<_Tp>...>::value)
    { }

    template <class _Alloc, template<class...> class _IsImpDefault = __is_implicitly_default_constructible, __enable_if_t<
        _And<
            _IsImpDefault<_Tp>...
        >::value
    , int> = 0>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    tuple(allocator_arg_t, _Alloc const& __a)
      : __base_(allocator_arg_t(), __a,
                    __tuple_indices<>(), __tuple_types<>(),
                    typename __make_tuple_indices<sizeof...(_Tp), 0>::type(),
                    __tuple_types<_Tp...>()) {}

    template <class _Alloc,
              template<class...> class _IsImpDefault = __is_implicitly_default_constructible,
              template<class...> class _IsDefault = is_default_constructible, __enable_if_t<
        _And<
            _IsDefault<_Tp>...,
            _Not<_Lazy<_And, _IsImpDefault<_Tp>...> >
        >::value
    , int> = 0>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    explicit tuple(allocator_arg_t, _Alloc const& __a)
      : __base_(allocator_arg_t(), __a,
                    __tuple_indices<>(), __tuple_types<>(),
                    typename __make_tuple_indices<sizeof...(_Tp), 0>::type(),
                    __tuple_types<_Tp...>()) {}


    template <template<class...> class _And = _And, __enable_if_t<
        _And<
            _BoolConstant<sizeof...(_Tp) >= 1>,
            is_copy_constructible<_Tp>...,
            is_convertible<const _Tp&, _Tp>...
        >::value
    , int> = 0>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    tuple(const _Tp& ... __t)
        noexcept(_And<is_nothrow_copy_constructible<_Tp>...>::value)
        : __base_(typename __make_tuple_indices<sizeof...(_Tp)>::type(),
                typename __make_tuple_types<tuple, sizeof...(_Tp)>::type(),
                typename __make_tuple_indices<0>::type(),
                typename __make_tuple_types<tuple, 0>::type(),
                __t...
               ) {}

    template <template<class...> class _And = _And, __enable_if_t<
        _And<
            _BoolConstant<sizeof...(_Tp) >= 1>,
            is_copy_constructible<_Tp>...,
            _Not<_Lazy<_And, is_convertible<const _Tp&, _Tp>...> >
        >::value
    , int> = 0>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    explicit tuple(const _Tp& ... __t)
        noexcept(_And<is_nothrow_copy_constructible<_Tp>...>::value)
        : __base_(typename __make_tuple_indices<sizeof...(_Tp)>::type(),
                typename __make_tuple_types<tuple, sizeof...(_Tp)>::type(),
                typename __make_tuple_indices<0>::type(),
                typename __make_tuple_types<tuple, 0>::type(),
                __t...
               ) {}

    template <class _Alloc, template<class...> class _And = _And, __enable_if_t<
        _And<
            _BoolConstant<sizeof...(_Tp) >= 1>,
            is_copy_constructible<_Tp>...,
            is_convertible<const _Tp&, _Tp>...
        >::value
    , int> = 0>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    tuple(allocator_arg_t, const _Alloc& __a, const _Tp& ... __t)
        : __base_(allocator_arg_t(), __a,
                typename __make_tuple_indices<sizeof...(_Tp)>::type(),
                typename __make_tuple_types<tuple, sizeof...(_Tp)>::type(),
                typename __make_tuple_indices<0>::type(),
                typename __make_tuple_types<tuple, 0>::type(),
                __t...
               ) {}

    template <class _Alloc, template<class...> class _And = _And, __enable_if_t<
        _And<
            _BoolConstant<sizeof...(_Tp) >= 1>,
            is_copy_constructible<_Tp>...,
            _Not<_Lazy<_And, is_convertible<const _Tp&, _Tp>...> >
        >::value
    , int> = 0>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    explicit tuple(allocator_arg_t, const _Alloc& __a, const _Tp& ... __t)
        : __base_(allocator_arg_t(), __a,
                typename __make_tuple_indices<sizeof...(_Tp)>::type(),
                typename __make_tuple_types<tuple, sizeof...(_Tp)>::type(),
                typename __make_tuple_indices<0>::type(),
                typename __make_tuple_types<tuple, 0>::type(),
                __t...
               ) {}


    template <class ..._Up> struct _IsThisTuple : false_type { };
    template <class _Up> struct _IsThisTuple<_Up> : is_same<__remove_cvref_t<_Up>, tuple> { };

    template <class ..._Up>
    struct _EnableUTypesCtor : _And<
        _BoolConstant<sizeof...(_Tp) >= 1>,
        _Not<_IsThisTuple<_Up...> >,
        is_constructible<_Tp, _Up>...
    > { };

    template <class ..._Up, __enable_if_t<
        _And<
            _BoolConstant<sizeof...(_Up) == sizeof...(_Tp)>,
            _EnableUTypesCtor<_Up...>,
            is_convertible<_Up, _Tp>...
        >::value
    , int> = 0>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    tuple(_Up&&... __u)
        noexcept((_And<is_nothrow_constructible<_Tp, _Up>...>::value))
        : __base_(typename __make_tuple_indices<sizeof...(_Up)>::type(),
                    typename __make_tuple_types<tuple, sizeof...(_Up)>::type(),
                    typename __make_tuple_indices<sizeof...(_Tp), sizeof...(_Up)>::type(),
                    typename __make_tuple_types<tuple, sizeof...(_Tp), sizeof...(_Up)>::type(),
                    std::forward<_Up>(__u)...) {}

    template <class ..._Up, __enable_if_t<
        _And<
            _BoolConstant<sizeof...(_Up) == sizeof...(_Tp)>,
            _EnableUTypesCtor<_Up...>,
            _Not<_Lazy<_And, is_convertible<_Up, _Tp>...> >
        >::value
    , int> = 0>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    explicit tuple(_Up&&... __u)
        noexcept((_And<is_nothrow_constructible<_Tp, _Up>...>::value))
        : __base_(typename __make_tuple_indices<sizeof...(_Up)>::type(),
                    typename __make_tuple_types<tuple, sizeof...(_Up)>::type(),
                    typename __make_tuple_indices<sizeof...(_Tp), sizeof...(_Up)>::type(),
                    typename __make_tuple_types<tuple, sizeof...(_Tp), sizeof...(_Up)>::type(),
                    std::forward<_Up>(__u)...) {}

    template <class _Alloc, class ..._Up, __enable_if_t<
        _And<
            _BoolConstant<sizeof...(_Up) == sizeof...(_Tp)>,
            _EnableUTypesCtor<_Up...>,
            is_convertible<_Up, _Tp>...
        >::value
    , int> = 0>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    tuple(allocator_arg_t, const _Alloc& __a, _Up&&... __u)
        : __base_(allocator_arg_t(), __a,
                    typename __make_tuple_indices<sizeof...(_Up)>::type(),
                    typename __make_tuple_types<tuple, sizeof...(_Up)>::type(),
                    typename __make_tuple_indices<sizeof...(_Tp), sizeof...(_Up)>::type(),
                    typename __make_tuple_types<tuple, sizeof...(_Tp), sizeof...(_Up)>::type(),
                    std::forward<_Up>(__u)...) {}

    template <class _Alloc, class ..._Up, __enable_if_t<
        _And<
            _BoolConstant<sizeof...(_Up) == sizeof...(_Tp)>,
            _EnableUTypesCtor<_Up...>,
            _Not<_Lazy<_And, is_convertible<_Up, _Tp>...> >
        >::value
    , int> = 0>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    explicit tuple(allocator_arg_t, const _Alloc& __a, _Up&&... __u)
        : __base_(allocator_arg_t(), __a,
                    typename __make_tuple_indices<sizeof...(_Up)>::type(),
                    typename __make_tuple_types<tuple, sizeof...(_Up)>::type(),
                    typename __make_tuple_indices<sizeof...(_Tp), sizeof...(_Up)>::type(),
                    typename __make_tuple_types<tuple, sizeof...(_Tp), sizeof...(_Up)>::type(),
                    std::forward<_Up>(__u)...) {}


    tuple(const tuple&) = default;
    tuple(tuple&&) = default;

    template <class _Alloc, template<class...> class _And = _And, __enable_if_t<
        _And<is_copy_constructible<_Tp>...>::value
    , int> = 0>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    tuple(allocator_arg_t, const _Alloc& __alloc, const tuple& __t)
        : __base_(allocator_arg_t(), __alloc, __t)
    { }

    template <class _Alloc, template<class...> class _And = _And, __enable_if_t<
        _And<is_move_constructible<_Tp>...>::value
    , int> = 0>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    tuple(allocator_arg_t, const _Alloc& __alloc, tuple&& __t)
        : __base_(allocator_arg_t(), __alloc, std::move(__t))
    { }



    template <class _OtherTuple, class _DecayedOtherTuple = __remove_cvref_t<_OtherTuple>, class = void>
    struct _EnableCtorFromUTypesTuple : false_type {};

    template <class _OtherTuple, class... _Up>
    struct _EnableCtorFromUTypesTuple<_OtherTuple, tuple<_Up...>,

               __enable_if_t<sizeof...(_Up) == sizeof...(_Tp)>> : _And<


        _Not<is_same<_OtherTuple, const tuple&> >,
        _Not<is_same<_OtherTuple, tuple&&> >,
        is_constructible<_Tp, __copy_cvref_t<_OtherTuple, _Up> >...,
        _Lazy<_Or, _BoolConstant<sizeof...(_Tp) != 1>,


            _Lazy<_And,
                _Not<is_same<_Tp, _Up> >...,
                _Not<is_convertible<_OtherTuple, _Tp> >...,
                _Not<is_constructible<_Tp, _OtherTuple> >...
            >
        >
    > {};

    template <class ..._Up, __enable_if_t<
        _And<
            _EnableCtorFromUTypesTuple<const tuple<_Up...>&>,
            is_convertible<const _Up&, _Tp>...
        >::value
    , int> = 0>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    tuple(const tuple<_Up...>& __t)
        noexcept((_And<is_nothrow_constructible<_Tp, const _Up&>...>::value))
        : __base_(__t)
    { }

    template <class ..._Up, __enable_if_t<
        _And<
            _EnableCtorFromUTypesTuple<const tuple<_Up...>&>,
            _Not<_Lazy<_And, is_convertible<const _Up&, _Tp>...> >
        >::value
    , int> = 0>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    explicit tuple(const tuple<_Up...>& __t)
        noexcept((_And<is_nothrow_constructible<_Tp, const _Up&>...>::value))
        : __base_(__t)
    { }

    template <class ..._Up, class _Alloc, __enable_if_t<
        _And<
            _EnableCtorFromUTypesTuple<const tuple<_Up...>&>,
            is_convertible<const _Up&, _Tp>...
        >::value
    , int> = 0>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    tuple(allocator_arg_t, const _Alloc& __a, const tuple<_Up...>& __t)
        : __base_(allocator_arg_t(), __a, __t)
    { }

    template <class ..._Up, class _Alloc, __enable_if_t<
        _And<
            _EnableCtorFromUTypesTuple<const tuple<_Up...>&>,
            _Not<_Lazy<_And, is_convertible<const _Up&, _Tp>...> >
        >::value
    , int> = 0>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    explicit tuple(allocator_arg_t, const _Alloc& __a, const tuple<_Up...>& __t)
        : __base_(allocator_arg_t(), __a, __t)
    { }




    template <class... _Up, enable_if_t<
        _EnableCtorFromUTypesTuple<tuple<_Up...>&>::value>* = nullptr>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
        explicit(!(is_convertible_v<_Up&, _Tp> && ...))
    tuple(tuple<_Up...>& __t) : __base_(__t) {}

    template <class _Alloc, class... _Up, enable_if_t<
        _EnableCtorFromUTypesTuple<tuple<_Up...>&>::value>* = nullptr>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
        explicit(!(is_convertible_v<_Up&, _Tp> && ...))
    tuple(allocator_arg_t, const _Alloc& __alloc, tuple<_Up...>& __t) : __base_(allocator_arg_t(), __alloc, __t) {}




    template <class ..._Up, __enable_if_t<
        _And<
            _EnableCtorFromUTypesTuple<tuple<_Up...>&&>,
            is_convertible<_Up, _Tp>...
        >::value
    , int> = 0>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    tuple(tuple<_Up...>&& __t)
        noexcept((_And<is_nothrow_constructible<_Tp, _Up>...>::value))
        : __base_(std::move(__t))
    { }

    template <class ..._Up, __enable_if_t<
        _And<
            _EnableCtorFromUTypesTuple<tuple<_Up...>&&>,
            _Not<_Lazy<_And, is_convertible<_Up, _Tp>...> >
        >::value
    , int> = 0>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    explicit tuple(tuple<_Up...>&& __t)
        noexcept((_And<is_nothrow_constructible<_Tp, _Up>...>::value))
        : __base_(std::move(__t))
    { }

    template <class _Alloc, class ..._Up, __enable_if_t<
        _And<
            _EnableCtorFromUTypesTuple<tuple<_Up...>&&>,
            is_convertible<_Up, _Tp>...
        >::value
    , int> = 0>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    tuple(allocator_arg_t, const _Alloc& __a, tuple<_Up...>&& __t)
        : __base_(allocator_arg_t(), __a, std::move(__t))
    { }

    template <class _Alloc, class ..._Up, __enable_if_t<
        _And<
            _EnableCtorFromUTypesTuple<tuple<_Up...>&&>,
            _Not<_Lazy<_And, is_convertible<_Up, _Tp>...> >
        >::value
    , int> = 0>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    explicit tuple(allocator_arg_t, const _Alloc& __a, tuple<_Up...>&& __t)
        : __base_(allocator_arg_t(), __a, std::move(__t))
    { }




    template <class... _Up, enable_if_t<
        _EnableCtorFromUTypesTuple<const tuple<_Up...>&&>::value>* = nullptr>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
        explicit(!(is_convertible_v<const _Up&&, _Tp> && ...))
    tuple(const tuple<_Up...>&& __t) : __base_(std::move(__t)) {}

    template <class _Alloc, class... _Up, enable_if_t<
        _EnableCtorFromUTypesTuple<const tuple<_Up...>&&>::value>* = nullptr>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
        explicit(!(is_convertible_v<const _Up&&, _Tp> && ...))
    tuple(allocator_arg_t, const _Alloc& __alloc, const tuple<_Up...>&& __t)
        : __base_(allocator_arg_t(), __alloc, std::move(__t)) {}




    template <template <class...> class _Pred, class _Pair, class _DecayedPair = __remove_cvref_t<_Pair>, class _Tuple = tuple>
    struct _CtorPredicateFromPair : false_type{};

    template <template <class...> class _Pred, class _Pair, class _Up1, class _Up2, class _Tp1, class _Tp2>
    struct _CtorPredicateFromPair<_Pred, _Pair, pair<_Up1, _Up2>, tuple<_Tp1, _Tp2> > : _And<
        _Pred<_Tp1, __copy_cvref_t<_Pair, _Up1> >,
        _Pred<_Tp2, __copy_cvref_t<_Pair, _Up2> >
    > {};

    template <class _Pair>
    struct _EnableCtorFromPair : _CtorPredicateFromPair<is_constructible, _Pair>{};

    template <class _Pair>
    struct _NothrowConstructibleFromPair : _CtorPredicateFromPair<is_nothrow_constructible, _Pair>{};

    template <class _Pair, class _DecayedPair = __remove_cvref_t<_Pair>, class _Tuple = tuple>
    struct _BothImplicitlyConvertible : false_type{};

    template <class _Pair, class _Up1, class _Up2, class _Tp1, class _Tp2>
    struct _BothImplicitlyConvertible<_Pair, pair<_Up1, _Up2>, tuple<_Tp1, _Tp2> > : _And<
        is_convertible<__copy_cvref_t<_Pair, _Up1>, _Tp1>,
        is_convertible<__copy_cvref_t<_Pair, _Up2>, _Tp2>
    > {};

    template <class _Up1, class _Up2, template<class...> class _And = _And, __enable_if_t<
        _And<
            _EnableCtorFromPair<const pair<_Up1, _Up2>&>,
            _BothImplicitlyConvertible<const pair<_Up1, _Up2>&>
        >::value
    , int> = 0>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    tuple(const pair<_Up1, _Up2>& __p)
        noexcept((_NothrowConstructibleFromPair<const pair<_Up1, _Up2>&>::value))
        : __base_(__p)
    { }

    template <class _Up1, class _Up2, template<class...> class _And = _And, __enable_if_t<
        _And<
            _EnableCtorFromPair<const pair<_Up1, _Up2>&>,
            _Not<_BothImplicitlyConvertible<const pair<_Up1, _Up2>&> >
        >::value
    , int> = 0>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    explicit tuple(const pair<_Up1, _Up2>& __p)
        noexcept((_NothrowConstructibleFromPair<const pair<_Up1, _Up2>&>::value))
        : __base_(__p)
    { }

    template <class _Alloc, class _Up1, class _Up2, template<class...> class _And = _And, __enable_if_t<
        _And<
            _EnableCtorFromPair<const pair<_Up1, _Up2>&>,
            _BothImplicitlyConvertible<const pair<_Up1, _Up2>&>
        >::value
    , int> = 0>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    tuple(allocator_arg_t, const _Alloc& __a, const pair<_Up1, _Up2>& __p)
        : __base_(allocator_arg_t(), __a, __p)
    { }

    template <class _Alloc, class _Up1, class _Up2, template<class...> class _And = _And, __enable_if_t<
        _And<
            _EnableCtorFromPair<const pair<_Up1, _Up2>&>,
            _Not<_BothImplicitlyConvertible<const pair<_Up1, _Up2>&> >
        >::value
    , int> = 0>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    explicit tuple(allocator_arg_t, const _Alloc& __a, const pair<_Up1, _Up2>& __p)
        : __base_(allocator_arg_t(), __a, __p)
    { }




    template <class _U1, class _U2, enable_if_t<
        _EnableCtorFromPair<pair<_U1, _U2>&>::value>* = nullptr>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
        explicit(!_BothImplicitlyConvertible<pair<_U1, _U2>&>::value)
    tuple(pair<_U1, _U2>& __p) : __base_(__p) {}

    template <class _Alloc, class _U1, class _U2, enable_if_t<
        _EnableCtorFromPair<std::pair<_U1, _U2>&>::value>* = nullptr>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
        explicit(!_BothImplicitlyConvertible<pair<_U1, _U2>&>::value)
    tuple(allocator_arg_t, const _Alloc& __alloc, pair<_U1, _U2>& __p) : __base_(allocator_arg_t(), __alloc, __p) {}




    template <class _Up1, class _Up2, template<class...> class _And = _And, __enable_if_t<
        _And<
            _EnableCtorFromPair<pair<_Up1, _Up2>&&>,
            _BothImplicitlyConvertible<pair<_Up1, _Up2>&&>
        >::value
    , int> = 0>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    tuple(pair<_Up1, _Up2>&& __p)
        noexcept((_NothrowConstructibleFromPair<pair<_Up1, _Up2>&&>::value))
        : __base_(std::move(__p))
    { }

    template <class _Up1, class _Up2, template<class...> class _And = _And, __enable_if_t<
        _And<
            _EnableCtorFromPair<pair<_Up1, _Up2>&&>,
            _Not<_BothImplicitlyConvertible<pair<_Up1, _Up2>&&> >
        >::value
    , int> = 0>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    explicit tuple(pair<_Up1, _Up2>&& __p)
        noexcept((_NothrowConstructibleFromPair<pair<_Up1, _Up2>&&>::value))
        : __base_(std::move(__p))
    { }

    template <class _Alloc, class _Up1, class _Up2, template<class...> class _And = _And, __enable_if_t<
        _And<
            _EnableCtorFromPair<pair<_Up1, _Up2>&&>,
            _BothImplicitlyConvertible<pair<_Up1, _Up2>&&>
        >::value
    , int> = 0>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    tuple(allocator_arg_t, const _Alloc& __a, pair<_Up1, _Up2>&& __p)
        : __base_(allocator_arg_t(), __a, std::move(__p))
    { }

    template <class _Alloc, class _Up1, class _Up2, template<class...> class _And = _And, __enable_if_t<
        _And<
            _EnableCtorFromPair<pair<_Up1, _Up2>&&>,
            _Not<_BothImplicitlyConvertible<pair<_Up1, _Up2>&&> >
        >::value
    , int> = 0>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    explicit tuple(allocator_arg_t, const _Alloc& __a, pair<_Up1, _Up2>&& __p)
        : __base_(allocator_arg_t(), __a, std::move(__p))
    { }




    template <class _U1, class _U2, enable_if_t<
        _EnableCtorFromPair<const pair<_U1, _U2>&&>::value>* = nullptr>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
        explicit(!_BothImplicitlyConvertible<const pair<_U1, _U2>&&>::value)
    tuple(const pair<_U1, _U2>&& __p) : __base_(std::move(__p)) {}

    template <class _Alloc, class _U1, class _U2, enable_if_t<
        _EnableCtorFromPair<const pair<_U1, _U2>&&>::value>* = nullptr>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
        explicit(!_BothImplicitlyConvertible<const pair<_U1, _U2>&&>::value)
    tuple(allocator_arg_t, const _Alloc& __alloc, const pair<_U1, _U2>&& __p)
        : __base_(allocator_arg_t(), __alloc, std::move(__p)) {}



    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    tuple& operator=(_If<_And<is_copy_assignable<_Tp>...>::value, tuple, __nat> const& __tuple)
        noexcept((_And<is_nothrow_copy_assignable<_Tp>...>::value))
    {
        std::__memberwise_copy_assign(*this, __tuple,
            typename __make_tuple_indices<sizeof...(_Tp)>::type());
        return *this;
    }


    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    const tuple& operator=(tuple const& __tuple) const
      requires (_And<is_copy_assignable<const _Tp>...>::value) {
        std::__memberwise_copy_assign(*this, __tuple, typename __make_tuple_indices<sizeof...(_Tp)>::type());
        return *this;
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    const tuple& operator=(tuple&& __tuple) const
      requires (_And<is_assignable<const _Tp&, _Tp>...>::value) {
        std::__memberwise_forward_assign(*this,
                                         std::move(__tuple),
                                         __tuple_types<_Tp...>(),
                                         typename __make_tuple_indices<sizeof...(_Tp)>::type());
        return *this;
    }


    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    tuple& operator=(_If<_And<is_move_assignable<_Tp>...>::value, tuple, __nat>&& __tuple)
        noexcept((_And<is_nothrow_move_assignable<_Tp>...>::value))
    {
        std::__memberwise_forward_assign(*this, std::move(__tuple),
            __tuple_types<_Tp...>(),
            typename __make_tuple_indices<sizeof...(_Tp)>::type());
        return *this;
    }

    template<class... _Up, __enable_if_t<
        _And<
            _BoolConstant<sizeof...(_Tp) == sizeof...(_Up)>,
            is_assignable<_Tp&, _Up const&>...
        >::value
    ,int> = 0>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    tuple& operator=(tuple<_Up...> const& __tuple)
        noexcept((_And<is_nothrow_assignable<_Tp&, _Up const&>...>::value))
    {
        std::__memberwise_copy_assign(*this, __tuple,
            typename __make_tuple_indices<sizeof...(_Tp)>::type());
        return *this;
    }

    template<class... _Up, __enable_if_t<
        _And<
            _BoolConstant<sizeof...(_Tp) == sizeof...(_Up)>,
            is_assignable<_Tp&, _Up>...
        >::value
    ,int> = 0>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    tuple& operator=(tuple<_Up...>&& __tuple)
        noexcept((_And<is_nothrow_assignable<_Tp&, _Up>...>::value))
    {
        std::__memberwise_forward_assign(*this, std::move(__tuple),
            __tuple_types<_Up...>(),
            typename __make_tuple_indices<sizeof...(_Tp)>::type());
        return *this;
    }



    template <class... _UTypes, enable_if_t<
        _And<_BoolConstant<sizeof...(_Tp) == sizeof...(_UTypes)>,
             is_assignable<const _Tp&, const _UTypes&>...>::value>* = nullptr>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    const tuple& operator=(const tuple<_UTypes...>& __u) const {
        std::__memberwise_copy_assign(*this,
                                      __u,
                                      typename __make_tuple_indices<sizeof...(_Tp)>::type());
        return *this;
    }

    template <class... _UTypes, enable_if_t<
        _And<_BoolConstant<sizeof...(_Tp) == sizeof...(_UTypes)>,
             is_assignable<const _Tp&, _UTypes>...>::value>* = nullptr>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    const tuple& operator=(tuple<_UTypes...>&& __u) const {
        std::__memberwise_forward_assign(*this,
                                         __u,
                                         __tuple_types<_UTypes...>(),
                                         typename __make_tuple_indices<sizeof...(_Tp)>::type());
        return *this;
    }


    template <template<class...> class _Pred, bool _Const,
              class _Pair, class _DecayedPair = __remove_cvref_t<_Pair>, class _Tuple = tuple>
    struct _AssignPredicateFromPair : false_type {};

    template <template<class...> class _Pred, bool _Const,
              class _Pair, class _Up1, class _Up2, class _Tp1, class _Tp2>
    struct _AssignPredicateFromPair<_Pred, _Const, _Pair, pair<_Up1, _Up2>, tuple<_Tp1, _Tp2> > :
        _And<_Pred<__maybe_const<_Const, _Tp1>&, __copy_cvref_t<_Pair, _Up1> >,
             _Pred<__maybe_const<_Const, _Tp2>&, __copy_cvref_t<_Pair, _Up2> >
            > {};

    template <bool _Const, class _Pair>
    struct _EnableAssignFromPair : _AssignPredicateFromPair<is_assignable, _Const, _Pair> {};

    template <bool _Const, class _Pair>
    struct _NothrowAssignFromPair : _AssignPredicateFromPair<is_nothrow_assignable, _Const, _Pair> {};


    template <class _U1, class _U2, enable_if_t<
        _EnableAssignFromPair<true, const pair<_U1, _U2>&>::value>* = nullptr>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    const tuple& operator=(const pair<_U1, _U2>& __pair) const
      noexcept(_NothrowAssignFromPair<true, const pair<_U1, _U2>&>::value) {
        std::get<0>(*this) = __pair.first;
        std::get<1>(*this) = __pair.second;
        return *this;
    }

    template <class _U1, class _U2, enable_if_t<
        _EnableAssignFromPair<true, pair<_U1, _U2>&&>::value>* = nullptr>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    const tuple& operator=(pair<_U1, _U2>&& __pair) const
      noexcept(_NothrowAssignFromPair<true, pair<_U1, _U2>&&>::value) {
        std::get<0>(*this) = std::move(__pair.first);
        std::get<1>(*this) = std::move(__pair.second);
        return *this;
    }


    template<class _Up1, class _Up2, __enable_if_t<
        _EnableAssignFromPair<false, pair<_Up1, _Up2> const&>::value
    ,int> = 0>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    tuple& operator=(pair<_Up1, _Up2> const& __pair)
        noexcept((_NothrowAssignFromPair<false, pair<_Up1, _Up2> const&>::value))
    {
        std::get<0>(*this) = __pair.first;
        std::get<1>(*this) = __pair.second;
        return *this;
    }

    template<class _Up1, class _Up2, __enable_if_t<
        _EnableAssignFromPair<false, pair<_Up1, _Up2>&&>::value
    ,int> = 0>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    tuple& operator=(pair<_Up1, _Up2>&& __pair)
        noexcept((_NothrowAssignFromPair<false, pair<_Up1, _Up2>&&>::value))
    {
        std::get<0>(*this) = std::forward<_Up1>(__pair.first);
        std::get<1>(*this) = std::forward<_Up2>(__pair.second);
        return *this;
    }


    template<class _Up, size_t _Np, class = __enable_if_t<
        _And<
            _BoolConstant<_Np == sizeof...(_Tp)>,
            is_assignable<_Tp&, _Up const&>...
        >::value
    > >
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    tuple& operator=(array<_Up, _Np> const& __array)
        noexcept((_And<is_nothrow_assignable<_Tp&, _Up const&>...>::value))
    {
        std::__memberwise_copy_assign(*this, __array,
            typename __make_tuple_indices<sizeof...(_Tp)>::type());
        return *this;
    }


    template<class _Up, size_t _Np, class = void, class = __enable_if_t<
        _And<
            _BoolConstant<_Np == sizeof...(_Tp)>,
            is_assignable<_Tp&, _Up>...
        >::value
    > >
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    tuple& operator=(array<_Up, _Np>&& __array)
        noexcept((_And<is_nothrow_assignable<_Tp&, _Up>...>::value))
    {
        std::__memberwise_forward_assign(*this, std::move(__array),
            __tuple_types<_If<true, _Up, _Tp>...>(),
            typename __make_tuple_indices<sizeof...(_Tp)>::type());
        return *this;
    }


    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    void swap(tuple& __t) noexcept(__all<__is_nothrow_swappable<_Tp>::value...>::value)
        {__base_.swap(__t.__base_);}


    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    void swap(const tuple& __t) const noexcept(__all<is_nothrow_swappable_v<const _Tp&>...>::value) {
        __base_.swap(__t.__base_);
    }

};

template <>
class tuple<>
{
public:
    constexpr tuple() noexcept = default;
    template <class _Alloc>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
        tuple(allocator_arg_t, const _Alloc&) noexcept {}
    template <class _Alloc>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
        tuple(allocator_arg_t, const _Alloc&, const tuple&) noexcept {}
    template <class _Up>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
        tuple(array<_Up, 0>) noexcept {}
    template <class _Alloc, class _Up>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
        tuple(allocator_arg_t, const _Alloc&, array<_Up, 0>) noexcept {}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    void swap(tuple&) noexcept {}

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr void swap(const tuple&) const noexcept {}

};


template <class... _TTypes, class... _UTypes, template<class> class _TQual, template<class> class _UQual>
    requires requires { typename tuple<common_reference_t<_TQual<_TTypes>, _UQual<_UTypes>>...>; }
struct basic_common_reference<tuple<_TTypes...>, tuple<_UTypes...>, _TQual, _UQual> {
    using type = tuple<common_reference_t<_TQual<_TTypes>, _UQual<_UTypes>>...>;
};

template <class... _TTypes, class... _UTypes>
    requires requires { typename tuple<common_type_t<_TTypes, _UTypes>...>; }
struct common_type<tuple<_TTypes...>, tuple<_UTypes...>> {
    using type = tuple<common_type_t<_TTypes, _UTypes>...>;
};



template <class ..._Tp>
tuple(_Tp...) -> tuple<_Tp...>;
template <class _Tp1, class _Tp2>
tuple(pair<_Tp1, _Tp2>) -> tuple<_Tp1, _Tp2>;
template <class _Alloc, class ..._Tp>
tuple(allocator_arg_t, _Alloc, _Tp...) -> tuple<_Tp...>;
template <class _Alloc, class _Tp1, class _Tp2>
tuple(allocator_arg_t, _Alloc, pair<_Tp1, _Tp2>) -> tuple<_Tp1, _Tp2>;
template <class _Alloc, class ..._Tp>
tuple(allocator_arg_t, _Alloc, tuple<_Tp...>) -> tuple<_Tp...>;


template <class ..._Tp, __enable_if_t<__all<__is_swappable<_Tp>::value...>::value, int> = 0>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
void
swap(tuple<_Tp...>& __t, tuple<_Tp...>& __u)
                 noexcept(__all<__is_nothrow_swappable<_Tp>::value...>::value)
    {__t.swap(__u);}


template <class... _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
enable_if_t<__all<is_swappable_v<const _Tp>...>::value, void>
swap(const tuple<_Tp...>& __lhs, const tuple<_Tp...>& __rhs)
        noexcept(__all<is_nothrow_swappable_v<const _Tp>...>::value) {
    __lhs.swap(__rhs);
}




template <size_t _Ip, class ..._Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
typename tuple_element<_Ip, tuple<_Tp...> >::type&
get(tuple<_Tp...>& __t) noexcept
{
    typedef __attribute__((__nodebug__)) typename tuple_element<_Ip, tuple<_Tp...> >::type type;
    return static_cast<__tuple_leaf<_Ip, type>&>(__t.__base_).get();
}

template <size_t _Ip, class ..._Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
const typename tuple_element<_Ip, tuple<_Tp...> >::type&
get(const tuple<_Tp...>& __t) noexcept
{
    typedef __attribute__((__nodebug__)) typename tuple_element<_Ip, tuple<_Tp...> >::type type;
    return static_cast<const __tuple_leaf<_Ip, type>&>(__t.__base_).get();
}

template <size_t _Ip, class ..._Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
typename tuple_element<_Ip, tuple<_Tp...> >::type&&
get(tuple<_Tp...>&& __t) noexcept
{
    typedef __attribute__((__nodebug__)) typename tuple_element<_Ip, tuple<_Tp...> >::type type;
    return static_cast<type&&>(
             static_cast<__tuple_leaf<_Ip, type>&&>(__t.__base_).get());
}

template <size_t _Ip, class ..._Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
const typename tuple_element<_Ip, tuple<_Tp...> >::type&&
get(const tuple<_Tp...>&& __t) noexcept
{
    typedef __attribute__((__nodebug__)) typename tuple_element<_Ip, tuple<_Tp...> >::type type;
    return static_cast<const type&&>(
             static_cast<const __tuple_leaf<_Ip, type>&&>(__t.__base_).get());
}



namespace __find_detail {

static constexpr size_t __not_found = static_cast<size_t>(-1);
static constexpr size_t __ambiguous = __not_found - 1;

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
constexpr size_t __find_idx_return(size_t __curr_i, size_t __res, bool __matches) {
    return !__matches ? __res :
        (__res == __not_found ? __curr_i : __ambiguous);
}

template <size_t _Nx>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
constexpr size_t __find_idx(size_t __i, const bool (&__matches)[_Nx]) {
  return __i == _Nx ? __not_found :
      __find_detail::__find_idx_return(__i, __find_detail::__find_idx(__i + 1, __matches), __matches[__i]);
}

template <class _T1, class ..._Args>
struct __find_exactly_one_checked {
    static constexpr bool __matches[sizeof...(_Args)] = {is_same<_T1, _Args>::value...};
    static constexpr size_t value = __find_detail::__find_idx(0, __matches);
    static_assert(value != __not_found, "type not found in type list" );
    static_assert(value != __ambiguous, "type occurs more than once in type list");
};

template <class _T1>
struct __find_exactly_one_checked<_T1> {
    static_assert(!is_same<_T1, _T1>::value, "type not in empty type list");
};

}

template <typename _T1, typename... _Args>
struct __find_exactly_one_t
    : public __find_detail::__find_exactly_one_checked<_T1, _Args...> {
};

template <class _T1, class... _Args>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
constexpr _T1& get(tuple<_Args...>& __tup) noexcept
{
    return std::get<__find_exactly_one_t<_T1, _Args...>::value>(__tup);
}

template <class _T1, class... _Args>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
constexpr _T1 const& get(tuple<_Args...> const& __tup) noexcept
{
    return std::get<__find_exactly_one_t<_T1, _Args...>::value>(__tup);
}

template <class _T1, class... _Args>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
constexpr _T1&& get(tuple<_Args...>&& __tup) noexcept
{
    return std::get<__find_exactly_one_t<_T1, _Args...>::value>(std::move(__tup));
}

template <class _T1, class... _Args>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
constexpr _T1 const&& get(tuple<_Args...> const&& __tup) noexcept
{
    return std::get<__find_exactly_one_t<_T1, _Args...>::value>(std::move(__tup));
}





template <class ..._Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
tuple<_Tp&...>
tie(_Tp&... __t) noexcept
{
    return tuple<_Tp&...>(__t...);
}

template <class _Up>
struct __ignore_t
{
    template <class _Tp>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    const __ignore_t& operator=(_Tp&&) const {return *this;}
};


inline constexpr __ignore_t<unsigned char> ignore = __ignore_t<unsigned char>();






template <class... _Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
tuple<typename __unwrap_ref_decay<_Tp>::type...>
make_tuple(_Tp&&... __t)
{
    return tuple<typename __unwrap_ref_decay<_Tp>::type...>(std::forward<_Tp>(__t)...);
}

template <class... _Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
tuple<_Tp&&...>
forward_as_tuple(_Tp&&... __t) noexcept
{
    return tuple<_Tp&&...>(std::forward<_Tp>(__t)...);
}

template <size_t _Ip>
struct __tuple_equal
{
    template <class _Tp, class _Up>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    bool operator()(const _Tp& __x, const _Up& __y)
    {
        return __tuple_equal<_Ip - 1>()(__x, __y) && std::get<_Ip-1>(__x) == std::get<_Ip-1>(__y);
    }
};

template <>
struct __tuple_equal<0>
{
    template <class _Tp, class _Up>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    bool operator()(const _Tp&, const _Up&)
    {
        return true;
    }
};

template <class ..._Tp, class ..._Up>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
bool
operator==(const tuple<_Tp...>& __x, const tuple<_Up...>& __y)
{
    static_assert (sizeof...(_Tp) == sizeof...(_Up), "Can't compare tuples of different sizes");
    return __tuple_equal<sizeof...(_Tp)>()(__x, __y);
}





template <class ..._Tp, class ..._Up, size_t ..._Is>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
auto
__tuple_compare_three_way(const tuple<_Tp...>& __x, const tuple<_Up...>& __y, index_sequence<_Is...>) {
    common_comparison_category_t<__synth_three_way_result<_Tp, _Up>...> __result = strong_ordering::equal;
    static_cast<void>(((__result = std::__synth_three_way(std::get<_Is>(__x), std::get<_Is>(__y)), __result != 0) || ...));
    return __result;
}

template <class ..._Tp, class ..._Up>
requires (sizeof...(_Tp) == sizeof...(_Up))
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
common_comparison_category_t<__synth_three_way_result<_Tp, _Up>...>
operator<=>(const tuple<_Tp...>& __x, const tuple<_Up...>& __y)
{
    return std::__tuple_compare_three_way(__x, __y, index_sequence_for<_Tp...>{});
}
# 1666 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/tuple" 3
template <class _Tp, class _Up> struct __tuple_cat_type;

template <class ..._Ttypes, class ..._Utypes>
struct __tuple_cat_type<tuple<_Ttypes...>, __tuple_types<_Utypes...> >
{
    typedef __attribute__((__nodebug__)) tuple<_Ttypes..., _Utypes...> type;
};

template <class _ResultTuple, bool _Is_Tuple0TupleLike, class ..._Tuples>
struct __tuple_cat_return_1
{
};

template <class ..._Types, class _Tuple0>
struct __tuple_cat_return_1<tuple<_Types...>, true, _Tuple0>
{
  using type __attribute__((__nodebug__)) = typename __tuple_cat_type<
      tuple<_Types...>,
      typename __make_tuple_types<__remove_cvref_t<_Tuple0> >::type
    >::type;
};

template <class ..._Types, class _Tuple0, class _Tuple1, class ..._Tuples>
struct __tuple_cat_return_1<tuple<_Types...>, true, _Tuple0, _Tuple1, _Tuples...>
    : public __tuple_cat_return_1<
                 typename __tuple_cat_type<
                     tuple<_Types...>,
                     typename __make_tuple_types<__remove_cvref_t<_Tuple0> >::type
                 >::type,
                 __tuple_like_ext<__libcpp_remove_reference_t<_Tuple1> >::value,
                 _Tuple1, _Tuples...>
{
};

template <class ..._Tuples> struct __tuple_cat_return;

template <class _Tuple0, class ..._Tuples>
struct __tuple_cat_return<_Tuple0, _Tuples...>
    : public __tuple_cat_return_1<tuple<>,
         __tuple_like_ext<__libcpp_remove_reference_t<_Tuple0> >::value, _Tuple0,
                                                                     _Tuples...>
{
};

template <>
struct __tuple_cat_return<>
{
    typedef __attribute__((__nodebug__)) tuple<> type;
};

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
tuple<>
tuple_cat()
{
    return tuple<>();
}

template <class _Rp, class _Indices, class _Tuple0, class ..._Tuples>
struct __tuple_cat_return_ref_imp;

template <class ..._Types, size_t ..._I0, class _Tuple0>
struct __tuple_cat_return_ref_imp<tuple<_Types...>, __tuple_indices<_I0...>, _Tuple0>
{
    typedef __attribute__((__nodebug__)) __libcpp_remove_reference_t<_Tuple0> _T0;
    typedef tuple<_Types..., __apply_cv_t<_Tuple0, typename tuple_element<_I0, _T0>::type>&&...> type;
};

template <class ..._Types, size_t ..._I0, class _Tuple0, class _Tuple1, class ..._Tuples>
struct __tuple_cat_return_ref_imp<tuple<_Types...>, __tuple_indices<_I0...>,
                                  _Tuple0, _Tuple1, _Tuples...>
    : public __tuple_cat_return_ref_imp<
         tuple<_Types..., __apply_cv_t<_Tuple0,
                                       typename tuple_element<_I0, __libcpp_remove_reference_t<_Tuple0>>::type>&&...>,
         typename __make_tuple_indices<tuple_size<__libcpp_remove_reference_t<_Tuple1> >::value>::type,
         _Tuple1, _Tuples...>
{
};

template <class _Tuple0, class ..._Tuples>
struct __tuple_cat_return_ref
    : public __tuple_cat_return_ref_imp<tuple<>,
               typename __make_tuple_indices<
                        tuple_size<__libcpp_remove_reference_t<_Tuple0> >::value
               >::type, _Tuple0, _Tuples...>
{
};

template <class _Types, class _I0, class _J0>
struct __tuple_cat;

template <class ..._Types, size_t ..._I0, size_t ..._J0>
struct __tuple_cat<tuple<_Types...>, __tuple_indices<_I0...>, __tuple_indices<_J0...> >
{
    template <class _Tuple0>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    typename __tuple_cat_return_ref<tuple<_Types...>&&, _Tuple0&&>::type
    operator()(tuple<_Types...> __t, _Tuple0&& __t0)
    {
        (void)__t;
        return std::forward_as_tuple(
            std::forward<_Types>(std::get<_I0>(__t))...,
            std::get<_J0>(std::forward<_Tuple0>(__t0))...);
    }

    template <class _Tuple0, class _Tuple1, class ..._Tuples>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    typename __tuple_cat_return_ref<tuple<_Types...>&&, _Tuple0&&, _Tuple1&&, _Tuples&&...>::type
    operator()(tuple<_Types...> __t, _Tuple0&& __t0, _Tuple1&& __t1, _Tuples&& ...__tpls)
    {
        (void)__t;
        typedef __attribute__((__nodebug__)) __libcpp_remove_reference_t<_Tuple0> _T0;
        typedef __attribute__((__nodebug__)) __libcpp_remove_reference_t<_Tuple1> _T1;
        return __tuple_cat<tuple<_Types..., __apply_cv_t<_Tuple0, typename tuple_element<_J0, _T0>::type>&&...>,
                           typename __make_tuple_indices<sizeof...(_Types) + tuple_size<_T0>::value>::type,
                           typename __make_tuple_indices<tuple_size<_T1>::value>::type>()(
            std::forward_as_tuple(
                std::forward<_Types>(std::get<_I0>(__t))...,
                std::get<_J0>(std::forward<_Tuple0>(__t0))...),
            std::forward<_Tuple1>(__t1), std::forward<_Tuples>(__tpls)...);
    }
};

template <class _Tuple0, class... _Tuples>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
typename __tuple_cat_return<_Tuple0, _Tuples...>::type
tuple_cat(_Tuple0&& __t0, _Tuples&&... __tpls)
{
    typedef __attribute__((__nodebug__)) __libcpp_remove_reference_t<_Tuple0> _T0;
    return __tuple_cat<tuple<>, __tuple_indices<>,
                  typename __make_tuple_indices<tuple_size<_T0>::value>::type>()
                  (tuple<>(), std::forward<_Tuple0>(__t0),
                                            std::forward<_Tuples>(__tpls)...);
}

template <class ..._Tp, class _Alloc>
struct uses_allocator<tuple<_Tp...>, _Alloc>
    : true_type {};

template <class _T1, class _T2>
template <class... _Args1, class... _Args2, size_t ..._I1, size_t ..._I2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
pair<_T1, _T2>::pair(piecewise_construct_t,
                     tuple<_Args1...>& __first_args, tuple<_Args2...>& __second_args,
                     __tuple_indices<_I1...>, __tuple_indices<_I2...>)
    : first(std::forward<_Args1>(std::get<_I1>( __first_args))...),
      second(std::forward<_Args2>(std::get<_I2>(__second_args))...)
{
}


template <class _Tp>
inline constexpr size_t tuple_size_v = tuple_size<_Tp>::value;



template <class _Fn, class _Tuple, size_t ..._Id>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
constexpr decltype(auto) __apply_tuple_impl(_Fn && __f, _Tuple && __t,
                                            __tuple_indices<_Id...>)
noexcept(noexcept(std::__invoke( std::forward<_Fn>(__f), std::get<_Id>(std::forward<_Tuple>(__t))...))) { return std::__invoke( std::forward<_Fn>(__f), std::get<_Id>(std::forward<_Tuple>(__t))...); }





template <class _Fn, class _Tuple>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
constexpr decltype(auto) apply(_Fn && __f, _Tuple && __t)
noexcept(noexcept(std::__apply_tuple_impl( std::forward<_Fn>(__f), std::forward<_Tuple>(__t), typename __make_tuple_indices<tuple_size_v<remove_reference_t<_Tuple>>>::type{}))) { return std::__apply_tuple_impl( std::forward<_Fn>(__f), std::forward<_Tuple>(__t), typename __make_tuple_indices<tuple_size_v<remove_reference_t<_Tuple>>>::type{}); }





template <class _Tp, class _Tuple, size_t... _Idx>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
constexpr _Tp __make_from_tuple_impl(_Tuple&& __t, __tuple_indices<_Idx...>)
noexcept(noexcept(_Tp(std::get<_Idx>(std::forward<_Tuple>(__t))...))) { return _Tp(std::get<_Idx>(std::forward<_Tuple>(__t))...); }



template <class _Tp, class _Tuple>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
constexpr _Tp make_from_tuple(_Tuple&& __t)
noexcept(noexcept(std::__make_from_tuple_impl<_Tp>(std::forward<_Tuple>(__t), typename __make_tuple_indices<tuple_size_v<remove_reference_t<_Tuple>>>::type{}))) { return std::__make_from_tuple_impl<_Tp>(std::forward<_Tuple>(__t), typename __make_tuple_indices<tuple_size_v<remove_reference_t<_Tuple>>>::type{}); }
# 1861 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/tuple" 3
}}
# 22 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__format/concepts.h" 2 3
# 25 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__format/concepts.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {




template <class _CharT>
concept __fmt_char_type =
    same_as<_CharT, char>

    || same_as<_CharT, wchar_t>

    ;





template <class _CharT>
using __fmt_iter_for = _CharT*;

template <class _Tp, class _Context, class _Formatter = typename _Context::template formatter_type<remove_const_t<_Tp>>>
concept __formattable_with =
    semiregular<_Formatter> &&
    requires(_Formatter& __f,
             const _Formatter& __cf,
             _Tp&& __t,
             _Context __fc,
             basic_format_parse_context<typename _Context::char_type> __pc) {
      { __f.parse(__pc) } -> same_as<typename decltype(__pc)::iterator>;
      { __cf.format(__t, __fc) } -> same_as<typename _Context::iterator>;
    };

template <class _Tp, class _CharT>
concept __formattable =
    __formattable_with<remove_reference_t<_Tp>, basic_format_context<__fmt_iter_for<_CharT>, _CharT>>;


template <class _Tp, class _CharT>
concept formattable = __formattable<_Tp, _CharT>;






template <class _Tp>
concept __fmt_pair_like =
    __is_specialization_v<_Tp, pair> || (__is_specialization_v<_Tp, tuple> && tuple_size_v<_Tp> == 2);




}}
# 18 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__format/formatter_bool.h" 2 3


# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__format/formatter_integral.h" 1 3
# 13 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__format/formatter_integral.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__charconv/to_chars_integral.h" 1 3
# 15 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__charconv/to_chars_integral.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__charconv/tables.h" 1 3
# 18 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__charconv/tables.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {



namespace __itoa {

inline constexpr char __base_2_lut[64] = {
    '0', '0', '0', '0', '0', '0', '0', '1', '0', '0', '1', '0', '0', '0', '1', '1', '0', '1', '0', '0', '0', '1',
    '0', '1', '0', '1', '1', '0', '0', '1', '1', '1', '1', '0', '0', '0', '1', '0', '0', '1', '1', '0', '1', '0',
    '1', '0', '1', '1', '1', '1', '0', '0', '1', '1', '0', '1', '1', '1', '1', '0', '1', '1', '1', '1'};

inline constexpr char __base_8_lut[128] = {
    '0', '0', '0', '1', '0', '2', '0', '3', '0', '4', '0', '5', '0', '6', '0', '7', '1', '0', '1', '1', '1', '2',
    '1', '3', '1', '4', '1', '5', '1', '6', '1', '7', '2', '0', '2', '1', '2', '2', '2', '3', '2', '4', '2', '5',
    '2', '6', '2', '7', '3', '0', '3', '1', '3', '2', '3', '3', '3', '4', '3', '5', '3', '6', '3', '7', '4', '0',
    '4', '1', '4', '2', '4', '3', '4', '4', '4', '5', '4', '6', '4', '7', '5', '0', '5', '1', '5', '2', '5', '3',
    '5', '4', '5', '5', '5', '6', '5', '7', '6', '0', '6', '1', '6', '2', '6', '3', '6', '4', '6', '5', '6', '6',
    '6', '7', '7', '0', '7', '1', '7', '2', '7', '3', '7', '4', '7', '5', '7', '6', '7', '7'};

inline constexpr char __base_16_lut[512] = {
    '0', '0', '0', '1', '0', '2', '0', '3', '0', '4', '0', '5', '0', '6', '0', '7', '0', '8', '0', '9', '0', 'a', '0',
    'b', '0', 'c', '0', 'd', '0', 'e', '0', 'f', '1', '0', '1', '1', '1', '2', '1', '3', '1', '4', '1', '5', '1', '6',
    '1', '7', '1', '8', '1', '9', '1', 'a', '1', 'b', '1', 'c', '1', 'd', '1', 'e', '1', 'f', '2', '0', '2', '1', '2',
    '2', '2', '3', '2', '4', '2', '5', '2', '6', '2', '7', '2', '8', '2', '9', '2', 'a', '2', 'b', '2', 'c', '2', 'd',
    '2', 'e', '2', 'f', '3', '0', '3', '1', '3', '2', '3', '3', '3', '4', '3', '5', '3', '6', '3', '7', '3', '8', '3',
    '9', '3', 'a', '3', 'b', '3', 'c', '3', 'd', '3', 'e', '3', 'f', '4', '0', '4', '1', '4', '2', '4', '3', '4', '4',
    '4', '5', '4', '6', '4', '7', '4', '8', '4', '9', '4', 'a', '4', 'b', '4', 'c', '4', 'd', '4', 'e', '4', 'f', '5',
    '0', '5', '1', '5', '2', '5', '3', '5', '4', '5', '5', '5', '6', '5', '7', '5', '8', '5', '9', '5', 'a', '5', 'b',
    '5', 'c', '5', 'd', '5', 'e', '5', 'f', '6', '0', '6', '1', '6', '2', '6', '3', '6', '4', '6', '5', '6', '6', '6',
    '7', '6', '8', '6', '9', '6', 'a', '6', 'b', '6', 'c', '6', 'd', '6', 'e', '6', 'f', '7', '0', '7', '1', '7', '2',
    '7', '3', '7', '4', '7', '5', '7', '6', '7', '7', '7', '8', '7', '9', '7', 'a', '7', 'b', '7', 'c', '7', 'd', '7',
    'e', '7', 'f', '8', '0', '8', '1', '8', '2', '8', '3', '8', '4', '8', '5', '8', '6', '8', '7', '8', '8', '8', '9',
    '8', 'a', '8', 'b', '8', 'c', '8', 'd', '8', 'e', '8', 'f', '9', '0', '9', '1', '9', '2', '9', '3', '9', '4', '9',
    '5', '9', '6', '9', '7', '9', '8', '9', '9', '9', 'a', '9', 'b', '9', 'c', '9', 'd', '9', 'e', '9', 'f', 'a', '0',
    'a', '1', 'a', '2', 'a', '3', 'a', '4', 'a', '5', 'a', '6', 'a', '7', 'a', '8', 'a', '9', 'a', 'a', 'a', 'b', 'a',
    'c', 'a', 'd', 'a', 'e', 'a', 'f', 'b', '0', 'b', '1', 'b', '2', 'b', '3', 'b', '4', 'b', '5', 'b', '6', 'b', '7',
    'b', '8', 'b', '9', 'b', 'a', 'b', 'b', 'b', 'c', 'b', 'd', 'b', 'e', 'b', 'f', 'c', '0', 'c', '1', 'c', '2', 'c',
    '3', 'c', '4', 'c', '5', 'c', '6', 'c', '7', 'c', '8', 'c', '9', 'c', 'a', 'c', 'b', 'c', 'c', 'c', 'd', 'c', 'e',
    'c', 'f', 'd', '0', 'd', '1', 'd', '2', 'd', '3', 'd', '4', 'd', '5', 'd', '6', 'd', '7', 'd', '8', 'd', '9', 'd',
    'a', 'd', 'b', 'd', 'c', 'd', 'd', 'd', 'e', 'd', 'f', 'e', '0', 'e', '1', 'e', '2', 'e', '3', 'e', '4', 'e', '5',
    'e', '6', 'e', '7', 'e', '8', 'e', '9', 'e', 'a', 'e', 'b', 'e', 'c', 'e', 'd', 'e', 'e', 'e', 'f', 'f', '0', 'f',
    '1', 'f', '2', 'f', '3', 'f', '4', 'f', '5', 'f', '6', 'f', '7', 'f', '8', 'f', '9', 'f', 'a', 'f', 'b', 'f', 'c',
    'f', 'd', 'f', 'e', 'f', 'f'};

inline constexpr uint32_t __pow10_32[10] = {
    0U,
    10U,
    100U,
    1000U,
    10000U,
    100000U,
    1000000U,
    10000000U,
    100000000U,
    1000000000U};

inline constexpr uint64_t __pow10_64[20] = {
    0UL,
    10UL,
    100UL,
    1000UL,
    10000UL,
    100000UL,
    1000000UL,
    10000000UL,
    100000000UL,
    1000000000UL,
    10000000000UL,
    100000000000UL,
    1000000000000UL,
    10000000000000UL,
    100000000000000UL,
    1000000000000000UL,
    10000000000000000UL,
    100000000000000000UL,
    1000000000000000000UL,
    10000000000000000000UL};


inline constexpr int __pow10_128_offset = 0;
inline constexpr __uint128_t __pow10_128[40] = {
    0UL,
    10UL,
    100UL,
    1000UL,
    10000UL,
    100000UL,
    1000000UL,
    10000000UL,
    100000000UL,
    1000000000UL,
    10000000000UL,
    100000000000UL,
    1000000000000UL,
    10000000000000UL,
    100000000000000UL,
    1000000000000000UL,
    10000000000000000UL,
    100000000000000000UL,
    1000000000000000000UL,
    10000000000000000000UL,
    __uint128_t(10000000000000000000UL) * 10UL,
    __uint128_t(10000000000000000000UL) * 100UL,
    __uint128_t(10000000000000000000UL) * 1000UL,
    __uint128_t(10000000000000000000UL) * 10000UL,
    __uint128_t(10000000000000000000UL) * 100000UL,
    __uint128_t(10000000000000000000UL) * 1000000UL,
    __uint128_t(10000000000000000000UL) * 10000000UL,
    __uint128_t(10000000000000000000UL) * 100000000UL,
    __uint128_t(10000000000000000000UL) * 1000000000UL,
    __uint128_t(10000000000000000000UL) * 10000000000UL,
    __uint128_t(10000000000000000000UL) * 100000000000UL,
    __uint128_t(10000000000000000000UL) * 1000000000000UL,
    __uint128_t(10000000000000000000UL) * 10000000000000UL,
    __uint128_t(10000000000000000000UL) * 100000000000000UL,
    __uint128_t(10000000000000000000UL) * 1000000000000000UL,
    __uint128_t(10000000000000000000UL) * 10000000000000000UL,
    __uint128_t(10000000000000000000UL) * 100000000000000000UL,
    __uint128_t(10000000000000000000UL) * 1000000000000000000UL,
    __uint128_t(10000000000000000000UL) * 10000000000000000000UL,
    (__uint128_t(10000000000000000000UL) * 10000000000000000000UL) * 10};


inline constexpr char __digits_base_10[200] = {

    '0', '0', '0', '1', '0', '2', '0', '3', '0', '4', '0', '5', '0', '6', '0', '7', '0', '8', '0', '9',
    '1', '0', '1', '1', '1', '2', '1', '3', '1', '4', '1', '5', '1', '6', '1', '7', '1', '8', '1', '9',
    '2', '0', '2', '1', '2', '2', '2', '3', '2', '4', '2', '5', '2', '6', '2', '7', '2', '8', '2', '9',
    '3', '0', '3', '1', '3', '2', '3', '3', '3', '4', '3', '5', '3', '6', '3', '7', '3', '8', '3', '9',
    '4', '0', '4', '1', '4', '2', '4', '3', '4', '4', '4', '5', '4', '6', '4', '7', '4', '8', '4', '9',
    '5', '0', '5', '1', '5', '2', '5', '3', '5', '4', '5', '5', '5', '6', '5', '7', '5', '8', '5', '9',
    '6', '0', '6', '1', '6', '2', '6', '3', '6', '4', '6', '5', '6', '6', '6', '7', '6', '8', '6', '9',
    '7', '0', '7', '1', '7', '2', '7', '3', '7', '4', '7', '5', '7', '6', '7', '7', '7', '8', '7', '9',
    '8', '0', '8', '1', '8', '2', '8', '3', '8', '4', '8', '5', '8', '6', '8', '7', '8', '8', '8', '9',
    '9', '0', '9', '1', '9', '2', '9', '3', '9', '4', '9', '5', '9', '6', '9', '7', '9', '8', '9', '9'};


}



}}
# 16 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__charconv/to_chars_integral.h" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__charconv/to_chars_base_10.h" 1 3
# 21 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__charconv/to_chars_base_10.h" 3



# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__undef_macros" 1 3
# 25 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__charconv/to_chars_base_10.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {



namespace __itoa {

constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) inline char* __append1(char* __first, uint32_t __value) noexcept {
  *__first = '0' + static_cast<char>(__value);
  return __first + 1;
}

constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) inline char* __append2(char* __first, uint32_t __value) noexcept {
  return std::copy_n(&__digits_base_10[__value * 2], 2, __first);
}

constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) inline char* __append3(char* __first, uint32_t __value) noexcept {
  return __itoa::__append2(__itoa::__append1(__first, __value / 100), __value % 100);
}

constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) inline char* __append4(char* __first, uint32_t __value) noexcept {
  return __itoa::__append2(__itoa::__append2(__first, __value / 100), __value % 100);
}

constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) inline char* __append5(char* __first, uint32_t __value) noexcept {
  return __itoa::__append4(__itoa::__append1(__first, __value / 10000), __value % 10000);
}

constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) inline char* __append6(char* __first, uint32_t __value) noexcept {
  return __itoa::__append4(__itoa::__append2(__first, __value / 10000), __value % 10000);
}

constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) inline char* __append7(char* __first, uint32_t __value) noexcept {
  return __itoa::__append6(__itoa::__append1(__first, __value / 1000000), __value % 1000000);
}

constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) inline char* __append8(char* __first, uint32_t __value) noexcept {
  return __itoa::__append6(__itoa::__append2(__first, __value / 1000000), __value % 1000000);
}

constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) inline char* __append9(char* __first, uint32_t __value) noexcept {
  return __itoa::__append8(__itoa::__append1(__first, __value / 100000000), __value % 100000000);
}

template <class _Tp>
constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) char* __append10(char* __first, _Tp __value) noexcept {
  return __itoa::__append8(__itoa::__append2(__first, static_cast<uint32_t>(__value / 100000000)),
                           static_cast<uint32_t>(__value % 100000000));
}

constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) inline char*
__base_10_u32(char* __first, uint32_t __value) noexcept {
  if (__value < 1000000) {
    if (__value < 10000) {
      if (__value < 100) {

        if (__value < 10)
          return __itoa::__append1(__first, __value);
        return __itoa::__append2(__first, __value);
      }

      if (__value < 1000)
        return __itoa::__append3(__first, __value);
      return __itoa::__append4(__first, __value);
    }


    if (__value < 100000)
      return __itoa::__append5(__first, __value);
    return __itoa::__append6(__first, __value);
  }


  if (__value < 100000000) {

    if (__value < 10000000)
      return __itoa::__append7(__first, __value);
    return __itoa::__append8(__first, __value);
  }


  if (__value < 1000000000)
    return __itoa::__append9(__first, __value);
  return __itoa::__append10(__first, __value);
}

constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) inline char*
__base_10_u64(char* __buffer, uint64_t __value) noexcept {
  if (__value <= (4294967295U))
    return __itoa::__base_10_u32(__buffer, static_cast<uint32_t>(__value));



  if (__value >= 10000000000) {

    __buffer = __itoa::__base_10_u32(__buffer, static_cast<uint32_t>(__value / 10000000000));
    __value %= 10000000000;
  }
  return __itoa::__append10(__buffer, __value);
}
# 134 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__charconv/to_chars_base_10.h" 3
constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) inline __uint128_t __pow_10(int __exp) noexcept {
  ((void)0);
  return __pow10_128[__exp - __pow10_128_offset];
}

constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) inline char*
__base_10_u128(char* __buffer, __uint128_t __value) noexcept {
  ((void)0);
# 154 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__charconv/to_chars_base_10.h" 3
  if (__value >= __itoa::__pow_10(38)) {

    __buffer = __itoa::__append1(__buffer, static_cast<uint32_t>(__value / __itoa::__pow_10(38)));
    __value %= __itoa::__pow_10(38);



    __buffer = __itoa::__append9(__buffer, static_cast<uint32_t>(__value / __itoa::__pow_10(29)));
    __value %= __itoa::__pow_10(29);
    __buffer = __itoa::__append10(__buffer, static_cast<uint64_t>(__value / __itoa::__pow_10(19)));
    __value %= __itoa::__pow_10(19);
  } else {


    __buffer = __base_10_u64(__buffer, static_cast<uint64_t>(__value / __itoa::__pow_10(19)));
    __value %= __itoa::__pow_10(19);
  }


  __buffer = __itoa::__append9(__buffer, static_cast<uint32_t>(__value / 10000000000));
  __buffer = __itoa::__append10(__buffer, static_cast<uint64_t>(__value % 10000000000));

  return __buffer;
}

}



}}
# 17 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__charconv/to_chars_integral.h" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__charconv/to_chars_result.h" 1 3
# 14 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__charconv/to_chars_result.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__system_error/errc.h" 1 3
# 104 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__system_error/errc.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/cerrno" 1 3
# 40 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/cerrno" 3
# 105 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__system_error/errc.h" 2 3
# 108 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__system_error/errc.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {





enum class errc
{
    address_family_not_supported = 97,
    address_in_use = 98,
    address_not_available = 99,
    already_connected = 106,
    argument_list_too_long = 7,
    argument_out_of_domain = 33,
    bad_address = 14,
    bad_file_descriptor = 9,
    bad_message = 74,
    broken_pipe = 32,
    connection_aborted = 103,
    connection_already_in_progress = 114,
    connection_refused = 111,
    connection_reset = 104,
    cross_device_link = 18,
    destination_address_required = 89,
    device_or_resource_busy = 16,
    directory_not_empty = 39,
    executable_format_error = 8,
    file_exists = 17,
    file_too_large = 27,
    filename_too_long = 36,
    function_not_supported = 38,
    host_unreachable = 113,
    identifier_removed = 43,
    illegal_byte_sequence = 84,
    inappropriate_io_control_operation = 25,
    interrupted = 4,
    invalid_argument = 22,
    invalid_seek = 29,
    io_error = 5,
    is_a_directory = 21,
    message_size = 90,
    network_down = 100,
    network_reset = 102,
    network_unreachable = 101,
    no_buffer_space = 105,
    no_child_process = 10,
    no_link = 67,
    no_lock_available = 37,

    no_message_available = 61,



    no_message = 42,
    no_protocol_option = 92,
    no_space_on_device = 28,

    no_stream_resources = 63,



    no_such_device_or_address = 6,
    no_such_device = 19,
    no_such_file_or_directory = 2,
    no_such_process = 3,
    not_a_directory = 20,
    not_a_socket = 88,

    not_a_stream = 60,



    not_connected = 107,
    not_enough_memory = 12,
    not_supported = 95,
    operation_canceled = 125,
    operation_in_progress = 115,
    operation_not_permitted = 1,
    operation_not_supported = 95,
    operation_would_block = 11,
    owner_dead = 130,
    permission_denied = 13,
    protocol_error = 71,
    protocol_not_supported = 93,
    read_only_file_system = 30,
    resource_deadlock_would_occur = 35,
    resource_unavailable_try_again = 11,
    result_out_of_range = 34,
    state_not_recoverable = 131,

    stream_timeout = 62,



    text_file_busy = 26,
    timed_out = 110,
    too_many_files_open_in_system = 23,
    too_many_files_open = 24,
    too_many_links = 31,
    too_many_symbolic_link_levels = 40,
    value_too_large = 75,
    wrong_protocol_type = 91
};


}}
# 15 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__charconv/to_chars_result.h" 2 3
# 18 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__charconv/to_chars_result.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {



struct __attribute__((__visibility__("default"))) to_chars_result {
  char* ptr;
  errc ec;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) friend bool operator==(const to_chars_result&, const to_chars_result&) = default;




};



}}
# 18 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__charconv/to_chars_integral.h" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__charconv/traits.h" 1 3
# 24 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__charconv/traits.h" 3



# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__undef_macros" 1 3
# 28 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__charconv/traits.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {



namespace __itoa {

template <typename _Tp, typename = void>
struct __attribute__((__visibility__("hidden"))) __traits_base;

template <typename _Tp>
struct __attribute__((__visibility__("hidden"))) __traits_base<_Tp, __enable_if_t<sizeof(_Tp) <= sizeof(uint32_t)>> {
  using type = uint32_t;
# 50 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__charconv/traits.h" 3
  static constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) int __width(_Tp __v) {
    auto __t = (32 - std::__libcpp_clz(static_cast<type>(__v | 1))) * 1233 >> 12;
    return __t - (__v < __itoa::__pow10_32[__t]) + 1;
  }

  static constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) char* __convert(char* __p, _Tp __v) {
    return __itoa::__base_10_u32(__p, __v);
  }

  static constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) decltype(__pow10_32)& __pow() {
    return __itoa::__pow10_32;
  }
};

template <typename _Tp>
struct __attribute__((__visibility__("hidden"))) __traits_base<_Tp, __enable_if_t<sizeof(_Tp) == sizeof(uint64_t)>> {
  using type = uint64_t;
# 76 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__charconv/traits.h" 3
  static constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) int __width(_Tp __v) {
    auto __t = (64 - std::__libcpp_clz(static_cast<type>(__v | 1))) * 1233 >> 12;
    return __t - (__v < __itoa::__pow10_64[__t]) + 1;
  }

  static constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) char* __convert(char* __p, _Tp __v) {
    return __itoa::__base_10_u64(__p, __v);
  }

  static constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) decltype(__pow10_64)& __pow() {
    return __itoa::__pow10_64;
  }
};


template <typename _Tp>
struct __attribute__((__visibility__("hidden"))) __traits_base<_Tp, __enable_if_t<sizeof(_Tp) == sizeof(__uint128_t)> > {
  using type = __uint128_t;
# 103 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__charconv/traits.h" 3
  static constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) int __width(_Tp __v) {
    ((void)0);


    auto __t = (128 - std::__libcpp_clz(static_cast<uint64_t>(__v >> 64))) * 1233 >> 12;
    ((void)0);

    return __t - (__v < __itoa::__pow10_128[__t - __itoa::__pow10_128_offset]) + 1;
  }

  static constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) char* __convert(char* __p, _Tp __v) {
    return __itoa::__base_10_u128(__p, __v);
  }



  static constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) decltype(__pow10_128)& __pow() {
    return __itoa::__pow10_128;
  }
};


template <typename _Tp>
inline constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) bool
__mul_overflowed(unsigned char __a, _Tp __b, unsigned char& __r) {
  auto __c = __a * __b;
  __r = __c;
  return __c > numeric_limits<unsigned char>::max();
}

template <typename _Tp>
inline constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) bool
__mul_overflowed(unsigned short __a, _Tp __b, unsigned short& __r) {
  auto __c = __a * __b;
  __r = __c;
  return __c > numeric_limits<unsigned short>::max();
}

template <typename _Tp>
inline constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) bool __mul_overflowed(_Tp __a, _Tp __b, _Tp& __r) {
  static_assert(is_unsigned<_Tp>::value, "");
  return __builtin_mul_overflow(__a, __b, &__r);
}

template <typename _Tp, typename _Up>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) bool constexpr __mul_overflowed(_Tp __a, _Up __b, _Tp& __r) {
  return __itoa::__mul_overflowed(__a, static_cast<_Tp>(__b), __r);
}

template <typename _Tp>
struct __attribute__((__visibility__("hidden"))) __traits : __traits_base<_Tp> {
  static constexpr int digits = numeric_limits<_Tp>::digits10 + 1;
  using __traits_base<_Tp>::__pow;
  using typename __traits_base<_Tp>::type;


  static constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) char const*
  __read(char const* __p, char const* __ep, type& __a, type& __b) {
    type __cprod[digits];
    int __j = digits - 1;
    int __i = digits;
    do {
      if (*__p < '0' || *__p > '9')
        break;
      __cprod[--__i] = *__p++ - '0';
    } while (__p != __ep && __i != 0);

    __a = __inner_product(__cprod + __i + 1, __cprod + __j, __pow() + 1, __cprod[__i]);
    if (__itoa::__mul_overflowed(__cprod[__j], __pow()[__j - __i], __b))
      --__p;
    return __p;
  }

  template <typename _It1, typename _It2, class _Up>
  static constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) _Up
  __inner_product(_It1 __first1, _It1 __last1, _It2 __first2, _Up __init) {
    for (; __first1 < __last1; ++__first1, ++__first2)
      __init = __init + *__first1 * *__first2;
    return __init;
  }
};

}

template <typename _Tp>
inline constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) _Tp __complement(_Tp __x) {
  static_assert(is_unsigned<_Tp>::value, "cast to unsigned first");
  return _Tp(~__x + 1);
}



}}
# 19 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__charconv/to_chars_integral.h" 2 3





# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/make_32_64_or_128_bit.h" 1 3
# 22 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/make_32_64_or_128_bit.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {




template <class _Tp>

  requires(is_signed_v<_Tp> || is_unsigned_v<_Tp> || is_same_v<_Tp, char>)


using __make_32_64_or_128_bit_t =
    __copy_unsigned_t<_Tp,
        __conditional_t<sizeof(_Tp) <= sizeof(int32_t), int32_t,
        __conditional_t<sizeof(_Tp) <= sizeof(int64_t), int64_t,

        __conditional_t<sizeof(_Tp) <= sizeof(__int128_t), __int128_t,
                                                           void>



    > > >;


}}
# 25 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__charconv/to_chars_integral.h" 2 3
# 33 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__charconv/to_chars_integral.h" 3



# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__undef_macros" 1 3
# 37 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__charconv/to_chars_integral.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {



to_chars_result to_chars(char*, char*, bool, int = 10) = delete;

template <typename _Tp>
inline constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) to_chars_result
__to_chars_itoa(char* __first, char* __last, _Tp __value, false_type);

template <typename _Tp>
inline constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) to_chars_result
__to_chars_itoa(char* __first, char* __last, _Tp __value, true_type) {
  auto __x = std::__to_unsigned_like(__value);
  if (__value < 0 && __first != __last) {
    *__first++ = '-';
    __x = std::__complement(__x);
  }

  return std::__to_chars_itoa(__first, __last, __x, false_type());
}

template <typename _Tp>
inline constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) to_chars_result
__to_chars_itoa(char* __first, char* __last, _Tp __value, false_type) {
  using __tx = __itoa::__traits<_Tp>;
  auto __diff = __last - __first;

  if (__tx::digits <= __diff || __tx::__width(__value) <= __diff)
    return {__tx::__convert(__first, __value), errc(0)};
  else
    return {__last, errc::value_too_large};
}


template <>
inline constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) to_chars_result
__to_chars_itoa(char* __first, char* __last, __uint128_t __value, false_type) {




  if (__value <= numeric_limits<uint64_t>::max())
    return __to_chars_itoa(__first, __last, static_cast<uint64_t>(__value), false_type());

  using __tx = __itoa::__traits<__uint128_t>;
  auto __diff = __last - __first;

  if (__tx::digits <= __diff || __tx::__width(__value) <= __diff)
    return {__tx::__convert(__first, __value), errc(0)};
  else
    return {__last, errc::value_too_large};
}


template <class _Tp>
inline constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) to_chars_result
__to_chars_integral(char* __first, char* __last, _Tp __value, int __base, false_type);

template <typename _Tp>
inline constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) to_chars_result
__to_chars_integral(char* __first, char* __last, _Tp __value, int __base, true_type) {
  auto __x = std::__to_unsigned_like(__value);
  if (__value < 0 && __first != __last) {
    *__first++ = '-';
    __x = std::__complement(__x);
  }

  return std::__to_chars_integral(__first, __last, __x, __base, false_type());
}

namespace __itoa {

template <unsigned _Base>
struct __attribute__((__visibility__("hidden"))) __integral;

template <>
struct __attribute__((__visibility__("hidden"))) __integral<2> {
  template <typename _Tp>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) static constexpr int __width(_Tp __value) noexcept {



    return numeric_limits<_Tp>::digits - std::__libcpp_clz(__value | 1);
  }

  template <typename _Tp>
  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) static to_chars_result
  __to_chars(char* __first, char* __last, _Tp __value) {
    ptrdiff_t __cap = __last - __first;
    int __n = __width(__value);
    if (__n > __cap)
      return {__last, errc::value_too_large};

    __last = __first + __n;
    char* __p = __last;
    const unsigned __divisor = 16;
    while (__value > __divisor) {
      unsigned __c = __value % __divisor;
      __value /= __divisor;
      __p -= 4;
      std::copy_n(&__base_2_lut[4 * __c], 4, __p);
    }
    do {
      unsigned __c = __value % 2;
      __value /= 2;
      *--__p = "01"[__c];
    } while (__value != 0);
    return {__last, errc(0)};
  }
};

template <>
struct __attribute__((__visibility__("hidden"))) __integral<8> {
  template <typename _Tp>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) static constexpr int __width(_Tp __value) noexcept {



    return ((numeric_limits<_Tp>::digits - std::__libcpp_clz(__value | 1)) + 2) / 3;
  }

  template <typename _Tp>
  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) static to_chars_result
  __to_chars(char* __first, char* __last, _Tp __value) {
    ptrdiff_t __cap = __last - __first;
    int __n = __width(__value);
    if (__n > __cap)
      return {__last, errc::value_too_large};

    __last = __first + __n;
    char* __p = __last;
    unsigned __divisor = 64;
    while (__value > __divisor) {
      unsigned __c = __value % __divisor;
      __value /= __divisor;
      __p -= 2;
      std::copy_n(&__base_8_lut[2 * __c], 2, __p);
    }
    do {
      unsigned __c = __value % 8;
      __value /= 8;
      *--__p = "01234567"[__c];
    } while (__value != 0);
    return {__last, errc(0)};
  }
};

template <>
struct __attribute__((__visibility__("hidden"))) __integral<16> {
  template <typename _Tp>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) static constexpr int __width(_Tp __value) noexcept {



    return (numeric_limits<_Tp>::digits - std::__libcpp_clz(__value | 1) + 3) / 4;
  }

  template <typename _Tp>
  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) static to_chars_result
  __to_chars(char* __first, char* __last, _Tp __value) {
    ptrdiff_t __cap = __last - __first;
    int __n = __width(__value);
    if (__n > __cap)
      return {__last, errc::value_too_large};

    __last = __first + __n;
    char* __p = __last;
    unsigned __divisor = 256;
    while (__value > __divisor) {
      unsigned __c = __value % __divisor;
      __value /= __divisor;
      __p -= 2;
      std::copy_n(&__base_16_lut[2 * __c], 2, __p);
    }
    if (__first != __last)
      do {
        unsigned __c = __value % 16;
        __value /= 16;
        *--__p = "0123456789abcdef"[__c];
      } while (__value != 0);
    return {__last, errc(0)};
  }
};

}

template <unsigned _Base, typename _Tp, __enable_if_t<(sizeof(_Tp) >= sizeof(unsigned)), int> = 0>
constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) int __to_chars_integral_width(_Tp __value) {
  return __itoa::__integral<_Base>::__width(__value);
}

template <unsigned _Base, typename _Tp, __enable_if_t<(sizeof(_Tp) < sizeof(unsigned)), int> = 0>
constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) int __to_chars_integral_width(_Tp __value) {
  return std::__to_chars_integral_width<_Base>(static_cast<unsigned>(__value));
}

template <unsigned _Base, typename _Tp, __enable_if_t<(sizeof(_Tp) >= sizeof(unsigned)), int> = 0>
constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) to_chars_result
__to_chars_integral(char* __first, char* __last, _Tp __value) {
  return __itoa::__integral<_Base>::__to_chars(__first, __last, __value);
}

template <unsigned _Base, typename _Tp, __enable_if_t<(sizeof(_Tp) < sizeof(unsigned)), int> = 0>
constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) to_chars_result
__to_chars_integral(char* __first, char* __last, _Tp __value) {
  return std::__to_chars_integral<_Base>(__first, __last, static_cast<unsigned>(__value));
}

template <typename _Tp>
constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) int __to_chars_integral_width(_Tp __value, unsigned __base) {
  ((void)0);

  unsigned __base_2 = __base * __base;
  unsigned __base_3 = __base_2 * __base;
  unsigned __base_4 = __base_2 * __base_2;

  int __r = 0;
  while (true) {
    if (__value < __base)
      return __r + 1;
    if (__value < __base_2)
      return __r + 2;
    if (__value < __base_3)
      return __r + 3;
    if (__value < __base_4)
      return __r + 4;

    __value /= __base_4;
    __r += 4;
  }

  __libcpp_unreachable();
}

template <typename _Tp>
inline constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) to_chars_result
__to_chars_integral(char* __first, char* __last, _Tp __value, int __base, false_type) {
  if (__base == 10) [[likely]]
    return std::__to_chars_itoa(__first, __last, __value, false_type());

  switch (__base) {
  case 2:
    return std::__to_chars_integral<2>(__first, __last, __value);
  case 8:
    return std::__to_chars_integral<8>(__first, __last, __value);
  case 16:
    return std::__to_chars_integral<16>(__first, __last, __value);
  }

  ptrdiff_t __cap = __last - __first;
  int __n = std::__to_chars_integral_width(__value, __base);
  if (__n > __cap)
    return {__last, errc::value_too_large};

  __last = __first + __n;
  char* __p = __last;
  do {
    unsigned __c = __value % __base;
    __value /= __base;
    *--__p = "0123456789abcdefghijklmnopqrstuvwxyz"[__c];
  } while (__value != 0);
  return {__last, errc(0)};
}

template <typename _Tp, __enable_if_t<is_integral<_Tp>::value, int> = 0>
inline constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) to_chars_result
to_chars(char* __first, char* __last, _Tp __value) {
  using _Type = __make_32_64_or_128_bit_t<_Tp>;
  static_assert(!is_same<_Type, void>::value, "unsupported integral type used in to_chars");
  return std::__to_chars_itoa(__first, __last, static_cast<_Type>(__value), is_signed<_Tp>());
}

template <typename _Tp, __enable_if_t<is_integral<_Tp>::value, int> = 0>
inline constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) to_chars_result
to_chars(char* __first, char* __last, _Tp __value, int __base) {
  ((void)0);

  using _Type = __make_32_64_or_128_bit_t<_Tp>;
  return std::__to_chars_integral(__first, __last, static_cast<_Type>(__value), __base, is_signed<_Tp>());
}



}}
# 14 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__format/formatter_integral.h" 2 3







# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__format/formatter_output.h" 1 3
# 19 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__format/formatter_output.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__format/buffer.h" 1 3
# 24 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__format/buffer.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__format/format_to_n_result.h" 1 3
# 18 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__format/format_to_n_result.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {



template <class _OutIt>
struct format_to_n_result {
  _OutIt out;
  iter_difference_t<_OutIt> size;
};
template <class... _Tag> [[maybe_unused]] format_to_n_result(typename _Tag::__allow_ctad...)->format_to_n_result<_Tag...>;



}}
# 25 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__format/buffer.h" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__iterator/back_insert_iterator.h" 1 3
# 22 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__iterator/back_insert_iterator.h" 3



# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__undef_macros" 1 3
# 26 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__iterator/back_insert_iterator.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

#pragma GCC diagnostic push
# 29 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__iterator/back_insert_iterator.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
# 29 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__iterator/back_insert_iterator.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
template <class _Container>
class back_insert_iterator

    : public iterator<output_iterator_tag, void, void, void, void>

{
#pragma GCC diagnostic pop
protected:
    _Container* container;
public:
    typedef output_iterator_tag iterator_category;
    typedef void value_type;

    typedef ptrdiff_t difference_type;



    typedef void pointer;
    typedef void reference;
    typedef _Container container_type;

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr explicit back_insert_iterator(_Container& __x) : container(std::addressof(__x)) {}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr back_insert_iterator& operator=(const typename _Container::value_type& __value)
        {container->push_back(__value); return *this;}

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr back_insert_iterator& operator=(typename _Container::value_type&& __value)
        {container->push_back(std::move(__value)); return *this;}

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr back_insert_iterator& operator*() {return *this;}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr back_insert_iterator& operator++() {return *this;}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr back_insert_iterator operator++(int) {return *this;}

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr _Container* __get_container() const { return container; }
};
template <class... _Tag> [[maybe_unused]] back_insert_iterator(typename _Tag::__allow_ctad...)->back_insert_iterator<_Tag...>;

template <class _Container>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
back_insert_iterator<_Container>
back_inserter(_Container& __x)
{
    return back_insert_iterator<_Container>(__x);
}

}}
# 26 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__format/buffer.h" 2 3





# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__memory/allocate_at_least.h" 1 3
# 18 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__memory/allocate_at_least.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {


template <class _Pointer>
struct allocation_result {
  _Pointer ptr;
  size_t count;
};
template <class... _Tag> [[maybe_unused]] allocation_result(typename _Tag::__allow_ctad...)->allocation_result<_Tag...>;

template <class _Alloc>
[[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
allocation_result<typename allocator_traits<_Alloc>::pointer> allocate_at_least(_Alloc& __alloc, size_t __n) {
  if constexpr (requires { __alloc.allocate_at_least(__n); }) {
    return __alloc.allocate_at_least(__n);
  } else {
    return {__alloc.allocate(__n), __n};
  }
}

template <class _Alloc>
[[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
auto __allocate_at_least(_Alloc& __alloc, size_t __n) {
  return std::allocate_at_least(__alloc, __n);
}
# 60 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__memory/allocate_at_least.h" 3
}}
# 32 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__format/buffer.h" 2 3


# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__memory/ranges_construct_at.h" 1 3
# 17 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__memory/ranges_construct_at.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__memory/concepts.h" 1 3
# 26 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__memory/concepts.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {



namespace ranges {





template <class _Ip>
concept __nothrow_input_iterator =
    input_iterator<_Ip> &&
    is_lvalue_reference_v<iter_reference_t<_Ip>> &&
    same_as<remove_cvref_t<iter_reference_t<_Ip>>, iter_value_t<_Ip>>;

template <class _Sp, class _Ip>
concept __nothrow_sentinel_for = sentinel_for<_Sp, _Ip>;

template <class _Rp>
concept __nothrow_input_range =
    range<_Rp> &&
    __nothrow_input_iterator<iterator_t<_Rp>> &&
    __nothrow_sentinel_for<sentinel_t<_Rp>, iterator_t<_Rp>>;

template <class _Ip>
concept __nothrow_forward_iterator =
    __nothrow_input_iterator<_Ip> &&
    forward_iterator<_Ip> &&
    __nothrow_sentinel_for<_Ip, _Ip>;

template <class _Rp>
concept __nothrow_forward_range =
    __nothrow_input_range<_Rp> &&
    __nothrow_forward_iterator<iterator_t<_Rp>>;

}



}}
# 18 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__memory/ranges_construct_at.h" 2 3
# 29 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__memory/ranges_construct_at.h" 3



# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__undef_macros" 1 3
# 33 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__memory/ranges_construct_at.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {


namespace ranges {



namespace __construct_at {

struct __fn {
  template<class _Tp, class... _Args, class = decltype(
    ::new (std::declval<void*>()) _Tp(std::declval<_Args>()...)
  )>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
  constexpr _Tp* operator()(_Tp* __location, _Args&& ...__args) const {
    return std::construct_at(__location, std::forward<_Args>(__args)...);
  }
};

}

inline namespace __cpo {
  inline constexpr auto construct_at = __construct_at::__fn{};
}



namespace __destroy_at {

struct __fn {
  template <destructible _Tp>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
  constexpr void operator()(_Tp* __location) const noexcept {
    std::destroy_at(__location);
  }
};

}

inline namespace __cpo {
  inline constexpr auto destroy_at = __destroy_at::__fn{};
}



namespace __destroy {

struct __fn {
  template <__nothrow_input_iterator _InputIterator, __nothrow_sentinel_for<_InputIterator> _Sentinel>
    requires destructible<iter_value_t<_InputIterator>>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
  constexpr _InputIterator operator()(_InputIterator __first, _Sentinel __last) const noexcept {
    return std::__destroy(std::move(__first), std::move(__last));
  }

  template <__nothrow_input_range _InputRange>
    requires destructible<range_value_t<_InputRange>>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
  constexpr borrowed_iterator_t<_InputRange> operator()(_InputRange&& __range) const noexcept {
    return (*this)(ranges::begin(__range), ranges::end(__range));
  }
};

}

inline namespace __cpo {
  inline constexpr auto destroy = __destroy::__fn{};
}



namespace __destroy_n {

struct __fn {
  template <__nothrow_input_iterator _InputIterator>
    requires destructible<iter_value_t<_InputIterator>>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
  constexpr _InputIterator operator()(_InputIterator __first, iter_difference_t<_InputIterator> __n) const noexcept {
    return std::destroy_n(std::move(__first), __n);
  }
};

}

inline namespace __cpo {
  inline constexpr auto destroy_n = __destroy_n::__fn{};
}

}



}}
# 35 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__format/buffer.h" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__memory/uninitialized_algorithms.h" 1 3
# 43 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__memory/uninitialized_algorithms.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {



struct __unreachable_sentinel {
  template <class _Iter>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) friend constexpr bool operator!=(const _Iter&, __unreachable_sentinel) noexcept {
    return true;
  }
};



template <class _ValueType, class _InputIterator, class _Sentinel1, class _ForwardIterator, class _Sentinel2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) pair<_InputIterator, _ForwardIterator>
__uninitialized_copy(_InputIterator __ifirst, _Sentinel1 __ilast,
                     _ForwardIterator __ofirst, _Sentinel2 __olast) {
  _ForwardIterator __idx = __ofirst;



    for (; __ifirst != __ilast && __idx != __olast; ++__ifirst, (void)++__idx)
      ::new (std::__voidify(*__idx)) _ValueType(*__ifirst);







  return pair<_InputIterator, _ForwardIterator>(std::move(__ifirst), std::move(__idx));
}

template <class _InputIterator, class _ForwardIterator>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
_ForwardIterator uninitialized_copy(_InputIterator __ifirst, _InputIterator __ilast,
                                    _ForwardIterator __ofirst) {
  typedef typename iterator_traits<_ForwardIterator>::value_type _ValueType;
  auto __result = std::__uninitialized_copy<_ValueType>(std::move(__ifirst), std::move(__ilast),
                                                          std::move(__ofirst), __unreachable_sentinel());
  return std::move(__result.second);
}



template <class _ValueType, class _InputIterator, class _Size, class _ForwardIterator, class _Sentinel>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) pair<_InputIterator, _ForwardIterator>
__uninitialized_copy_n(_InputIterator __ifirst, _Size __n,
                       _ForwardIterator __ofirst, _Sentinel __olast) {
  _ForwardIterator __idx = __ofirst;



    for (; __n > 0 && __idx != __olast; ++__ifirst, (void)++__idx, (void)--__n)
      ::new (std::__voidify(*__idx)) _ValueType(*__ifirst);







  return pair<_InputIterator, _ForwardIterator>(std::move(__ifirst), std::move(__idx));
}

template <class _InputIterator, class _Size, class _ForwardIterator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) _ForwardIterator uninitialized_copy_n(_InputIterator __ifirst, _Size __n,
                                                                   _ForwardIterator __ofirst) {
  typedef typename iterator_traits<_ForwardIterator>::value_type _ValueType;
  auto __result = std::__uninitialized_copy_n<_ValueType>(std::move(__ifirst), __n, std::move(__ofirst),
                                                            __unreachable_sentinel());
  return std::move(__result.second);
}



template <class _ValueType, class _ForwardIterator, class _Sentinel, class _Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
_ForwardIterator __uninitialized_fill(_ForwardIterator __first, _Sentinel __last, const _Tp& __x)
{
    _ForwardIterator __idx = __first;




        for (; __idx != __last; ++__idx)
            ::new (std::__voidify(*__idx)) _ValueType(__x);
# 141 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__memory/uninitialized_algorithms.h" 3
    return __idx;
}

template <class _ForwardIterator, class _Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
void uninitialized_fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __x)
{
    typedef typename iterator_traits<_ForwardIterator>::value_type _ValueType;
    (void)std::__uninitialized_fill<_ValueType>(__first, __last, __x);
}



template <class _ValueType, class _ForwardIterator, class _Size, class _Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
_ForwardIterator __uninitialized_fill_n(_ForwardIterator __first, _Size __n, const _Tp& __x)
{
    _ForwardIterator __idx = __first;




        for (; __n > 0; ++__idx, (void) --__n)
            ::new (std::__voidify(*__idx)) _ValueType(__x);
# 174 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__memory/uninitialized_algorithms.h" 3
    return __idx;
}

template <class _ForwardIterator, class _Size, class _Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
_ForwardIterator uninitialized_fill_n(_ForwardIterator __first, _Size __n, const _Tp& __x)
{
    typedef typename iterator_traits<_ForwardIterator>::value_type _ValueType;
    return std::__uninitialized_fill_n<_ValueType>(__first, __n, __x);
}





template <class _ValueType, class _ForwardIterator, class _Sentinel>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
_ForwardIterator __uninitialized_default_construct(_ForwardIterator __first, _Sentinel __last) {
    auto __idx = __first;



    for (; __idx != __last; ++__idx)
        ::new (std::__voidify(*__idx)) _ValueType;







    return __idx;
}

template <class _ForwardIterator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
void uninitialized_default_construct(_ForwardIterator __first, _ForwardIterator __last) {
    using _ValueType = typename iterator_traits<_ForwardIterator>::value_type;
    (void)std::__uninitialized_default_construct<_ValueType>(
        std::move(__first), std::move(__last));
}



template <class _ValueType, class _ForwardIterator, class _Size>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
_ForwardIterator __uninitialized_default_construct_n(_ForwardIterator __first, _Size __n) {
    auto __idx = __first;



    for (; __n > 0; ++__idx, (void) --__n)
        ::new (std::__voidify(*__idx)) _ValueType;







    return __idx;
}

template <class _ForwardIterator, class _Size>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
_ForwardIterator uninitialized_default_construct_n(_ForwardIterator __first, _Size __n) {
    using _ValueType = typename iterator_traits<_ForwardIterator>::value_type;
    return std::__uninitialized_default_construct_n<_ValueType>(std::move(__first), __n);
}



template <class _ValueType, class _ForwardIterator, class _Sentinel>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
_ForwardIterator __uninitialized_value_construct(_ForwardIterator __first, _Sentinel __last) {
    auto __idx = __first;



    for (; __idx != __last; ++__idx)
        ::new (std::__voidify(*__idx)) _ValueType();







    return __idx;
}

template <class _ForwardIterator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
void uninitialized_value_construct(_ForwardIterator __first, _ForwardIterator __last) {
    using _ValueType = typename iterator_traits<_ForwardIterator>::value_type;
    (void)std::__uninitialized_value_construct<_ValueType>(
        std::move(__first), std::move(__last));
}



template <class _ValueType, class _ForwardIterator, class _Size>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
_ForwardIterator __uninitialized_value_construct_n(_ForwardIterator __first, _Size __n) {
    auto __idx = __first;



    for (; __n > 0; ++__idx, (void) --__n)
        ::new (std::__voidify(*__idx)) _ValueType();







    return __idx;
}

template <class _ForwardIterator, class _Size>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
_ForwardIterator uninitialized_value_construct_n(_ForwardIterator __first, _Size __n) {
    using _ValueType = typename iterator_traits<_ForwardIterator>::value_type;
    return std::__uninitialized_value_construct_n<_ValueType>(std::move(__first), __n);
}



template <class _ValueType, class _InputIterator, class _Sentinel1, class _ForwardIterator, class _Sentinel2,
          class _IterMove>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) pair<_InputIterator, _ForwardIterator>
__uninitialized_move(_InputIterator __ifirst, _Sentinel1 __ilast,
                     _ForwardIterator __ofirst, _Sentinel2 __olast, _IterMove __iter_move) {
  auto __idx = __ofirst;



    for (; __ifirst != __ilast && __idx != __olast; ++__idx, (void)++__ifirst) {
      ::new (std::__voidify(*__idx)) _ValueType(__iter_move(__ifirst));
    }







  return {std::move(__ifirst), std::move(__idx)};
}

template <class _InputIterator, class _ForwardIterator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) _ForwardIterator uninitialized_move(_InputIterator __ifirst, _InputIterator __ilast,
                                                                 _ForwardIterator __ofirst) {
  using _ValueType = typename iterator_traits<_ForwardIterator>::value_type;
  auto __iter_move = [](auto&& __iter) -> decltype(auto) { return std::move(*__iter); };

  auto __result = std::__uninitialized_move<_ValueType>(std::move(__ifirst), std::move(__ilast),
                                                          std::move(__ofirst), __unreachable_sentinel(), __iter_move);
  return std::move(__result.second);
}



template <class _ValueType, class _InputIterator, class _Size, class _ForwardIterator, class _Sentinel, class _IterMove>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) pair<_InputIterator, _ForwardIterator>
__uninitialized_move_n(_InputIterator __ifirst, _Size __n,
                       _ForwardIterator __ofirst, _Sentinel __olast, _IterMove __iter_move) {
  auto __idx = __ofirst;



    for (; __n > 0 && __idx != __olast; ++__idx, (void)++__ifirst, --__n)
      ::new (std::__voidify(*__idx)) _ValueType(__iter_move(__ifirst));







  return {std::move(__ifirst), std::move(__idx)};
}

template <class _InputIterator, class _Size, class _ForwardIterator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) pair<_InputIterator, _ForwardIterator>
uninitialized_move_n(_InputIterator __ifirst, _Size __n, _ForwardIterator __ofirst) {
  using _ValueType = typename iterator_traits<_ForwardIterator>::value_type;
  auto __iter_move = [](auto&& __iter) -> decltype(auto) { return std::move(*__iter); };

  return std::__uninitialized_move_n<_ValueType>(std::move(__ifirst), __n, std::move(__ofirst),
                                                   __unreachable_sentinel(), __iter_move);
}
# 375 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__memory/uninitialized_algorithms.h" 3
template<class _Alloc, class _BidirIter, class = __enable_if_t<
    __has_bidirectional_iterator_category<_BidirIter>::value
>>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
constexpr void __allocator_destroy_multidimensional(_Alloc& __alloc, _BidirIter __first, _BidirIter __last) noexcept {
    using _ValueType = typename iterator_traits<_BidirIter>::value_type;
    static_assert(is_same_v<typename allocator_traits<_Alloc>::value_type, _ValueType>,
        "The allocator should already be rebound to the correct type");

    if (__first == __last)
        return;

    if constexpr (is_array_v<_ValueType>) {
        static_assert(!__libcpp_is_unbounded_array<_ValueType>::value,
            "arrays of unbounded arrays don't exist, but if they did we would mess up here");

        using _Element = remove_extent_t<_ValueType>;
        __allocator_traits_rebind_t<_Alloc, _Element> __elem_alloc(__alloc);
        do {
            --__last;
            decltype(auto) __array = *__last;
            std::__allocator_destroy_multidimensional(__elem_alloc, __array, __array + extent_v<_ValueType>);
        } while (__last != __first);
    } else {
        do {
            --__last;
            allocator_traits<_Alloc>::destroy(__alloc, std::addressof(*__last));
        } while (__last != __first);
    }
}
# 413 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__memory/uninitialized_algorithms.h" 3
template<class _Alloc, class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
constexpr void __allocator_construct_at_multidimensional(_Alloc& __alloc, _Tp* __loc) {
    static_assert(is_same_v<typename allocator_traits<_Alloc>::value_type, _Tp>,
        "The allocator should already be rebound to the correct type");

    if constexpr (is_array_v<_Tp>) {
        using _Element = remove_extent_t<_Tp>;
        __allocator_traits_rebind_t<_Alloc, _Element> __elem_alloc(__alloc);
        size_t __i = 0;
        _Tp& __array = *__loc;


        auto __guard = std::__make_exception_guard([&]() {
          std::__allocator_destroy_multidimensional(__elem_alloc, __array, __array + __i);
        });

        for (; __i != extent_v<_Tp>; ++__i) {
            std::__allocator_construct_at_multidimensional(__elem_alloc, std::addressof(__array[__i]));
        }
        __guard.__complete();
    } else {
        allocator_traits<_Alloc>::construct(__alloc, __loc);
    }
}
# 449 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__memory/uninitialized_algorithms.h" 3
template<class _Alloc, class _Tp, class _Arg>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
constexpr void __allocator_construct_at_multidimensional(_Alloc& __alloc, _Tp* __loc, _Arg const& __arg) {
    static_assert(is_same_v<typename allocator_traits<_Alloc>::value_type, _Tp>,
        "The allocator should already be rebound to the correct type");

    if constexpr (is_array_v<_Tp>) {
        static_assert(is_array_v<_Arg>,
            "Provided non-array initialization argument to __allocator_construct_at_multidimensional when "
            "trying to construct an array.");

        using _Element = remove_extent_t<_Tp>;
        __allocator_traits_rebind_t<_Alloc, _Element> __elem_alloc(__alloc);
        size_t __i = 0;
        _Tp& __array = *__loc;


        auto __guard = std::__make_exception_guard([&]() {
          std::__allocator_destroy_multidimensional(__elem_alloc, __array, __array + __i);
        });
        for (; __i != extent_v<_Tp>; ++__i) {
            std::__allocator_construct_at_multidimensional(__elem_alloc, std::addressof(__array[__i]), __arg[__i]);
        }
        __guard.__complete();
    } else {
        allocator_traits<_Alloc>::construct(__alloc, __loc, __arg);
    }
}
# 485 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__memory/uninitialized_algorithms.h" 3
template<class _Alloc, class _BidirIter, class _Tp, class _Size = typename iterator_traits<_BidirIter>::difference_type>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr void
__uninitialized_allocator_fill_n_multidimensional(_Alloc& __alloc, _BidirIter __it, _Size __n, _Tp const& __value) {
    using _ValueType = typename iterator_traits<_BidirIter>::value_type;
    __allocator_traits_rebind_t<_Alloc, _ValueType> __value_alloc(__alloc);
    _BidirIter __begin = __it;


    auto __guard = std::__make_exception_guard([&]() { std::__allocator_destroy_multidimensional(__value_alloc, __begin, __it); });
    for (; __n != 0; --__n, ++__it) {
        std::__allocator_construct_at_multidimensional(__value_alloc, std::addressof(*__it), __value);
    }
    __guard.__complete();
}



template <class _Alloc, class _BidirIter, class _Size = typename iterator_traits<_BidirIter>::difference_type>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr void
__uninitialized_allocator_value_construct_n_multidimensional(_Alloc& __alloc, _BidirIter __it, _Size __n) {
    using _ValueType = typename iterator_traits<_BidirIter>::value_type;
    __allocator_traits_rebind_t<_Alloc, _ValueType> __value_alloc(__alloc);
    _BidirIter __begin = __it;


    auto __guard = std::__make_exception_guard([&]() { std::__allocator_destroy_multidimensional(__value_alloc, __begin, __it); });
    for (; __n != 0; --__n, ++__it) {
        std::__allocator_construct_at_multidimensional(__value_alloc, std::addressof(*__it));
    }
    __guard.__complete();
}




template <class _Alloc, class _Iter, class _Sent>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr void
__allocator_destroy(_Alloc& __alloc, _Iter __first, _Sent __last) {
  for (; __first != __last; ++__first)
     allocator_traits<_Alloc>::destroy(__alloc, std::__to_address(__first));
}

template <class _Alloc, class _Iter>
class _AllocatorDestroyRangeReverse {
public:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
  _AllocatorDestroyRangeReverse(_Alloc& __alloc, _Iter& __first, _Iter& __last)
      : __alloc_(__alloc), __first_(__first), __last_(__last) {}

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr void operator()() const {
    std::__allocator_destroy(__alloc_, std::reverse_iterator<_Iter>(__last_), std::reverse_iterator<_Iter>(__first_));
  }

private:
  _Alloc& __alloc_;
  _Iter& __first_;
  _Iter& __last_;
};





template <class _Alloc, class _Iter1, class _Sent1, class _Iter2>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr _Iter2
__uninitialized_allocator_copy_impl(_Alloc& __alloc, _Iter1 __first1, _Sent1 __last1, _Iter2 __first2) {
  auto __destruct_first = __first2;
  auto __guard =
      std::__make_exception_guard(_AllocatorDestroyRangeReverse<_Alloc, _Iter2>(__alloc, __destruct_first, __first2));
  while (__first1 != __last1) {
    allocator_traits<_Alloc>::construct(__alloc, std::__to_address(__first2), *__first1);
    ++__first1;
    ++__first2;
  }
  __guard.__complete();
  return __first2;
}

template <class _Alloc, class _Type>
struct __allocator_has_trivial_copy_construct : _Not<__has_construct<_Alloc, _Type*, const _Type&> > {};

template <class _Type>
struct __allocator_has_trivial_copy_construct<allocator<_Type>, _Type> : true_type {};

template <class _Alloc,
          class _In,
          class _RawTypeIn = __remove_const_t<_In>,
          class _Out,
          __enable_if_t<

              is_trivially_copy_constructible<_RawTypeIn>::value && is_trivially_copy_assignable<_RawTypeIn>::value &&
              is_same<__remove_const_t<_In>, __remove_const_t<_Out> >::value &&
              __allocator_has_trivial_copy_construct<_Alloc, _RawTypeIn>::value>* = nullptr>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr _Out*
__uninitialized_allocator_copy_impl(_Alloc&, _In* __first1, _In* __last1, _Out* __first2) {

  if (__libcpp_is_constant_evaluated()) {
    while (__first1 != __last1) {
      std::__construct_at(std::__to_address(__first2), *__first1);
      ++__first1;
      ++__first2;
    }
    return __first2;
  } else {
    return std::copy(__first1, __last1, const_cast<_RawTypeIn*>(__first2));
  }
}

template <class _Alloc, class _Iter1, class _Sent1, class _Iter2>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr _Iter2 __uninitialized_allocator_copy(_Alloc& __alloc, _Iter1 __first1, _Sent1 __last1, _Iter2 __first2) {
    auto __unwrapped_range = std::__unwrap_range(__first1, __last1);
    auto __result = std::__uninitialized_allocator_copy_impl(__alloc, __unwrapped_range.first, __unwrapped_range.second, std::__unwrap_iter(__first2));
    return std::__rewrap_iter(__first2, __result);
}






template <class _Alloc, class _Iter1, class _Sent1, class _Iter2>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr _Iter2 __uninitialized_allocator_move_if_noexcept(
    _Alloc& __alloc, _Iter1 __first1, _Sent1 __last1, _Iter2 __first2) {
  static_assert(__is_cpp17_move_insertable<_Alloc>::value,
                "The specified type does not meet the requirements of Cpp17MoveInsertable");
  auto __destruct_first = __first2;
  auto __guard =
      std::__make_exception_guard(_AllocatorDestroyRangeReverse<_Alloc, _Iter2>(__alloc, __destruct_first, __first2));
  while (__first1 != __last1) {



    allocator_traits<_Alloc>::construct(__alloc, std::__to_address(__first2), std::move(*__first1));

    ++__first1;
    ++__first2;
  }
  __guard.__complete();
  return __first2;
}

template <class _Alloc, class _Type>
struct __allocator_has_trivial_move_construct : _Not<__has_construct<_Alloc, _Type*, _Type&&> > {};

template <class _Type>
struct __allocator_has_trivial_move_construct<allocator<_Type>, _Type> : true_type {};


template <
    class _Alloc,
    class _Iter1,
    class _Iter2,
    class _Type = typename iterator_traits<_Iter1>::value_type,
    class = __enable_if_t<is_trivially_move_constructible<_Type>::value && is_trivially_move_assignable<_Type>::value &&
                          __allocator_has_trivial_move_construct<_Alloc, _Type>::value> >
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr _Iter2
__uninitialized_allocator_move_if_noexcept(_Alloc&, _Iter1 __first1, _Iter1 __last1, _Iter2 __first2) {
  if (__libcpp_is_constant_evaluated()) {
    while (__first1 != __last1) {
      std::__construct_at(std::__to_address(__first2), std::move(*__first1));
      ++__first1;
      ++__first2;
    }
    return __first2;
  } else {
    return std::move(__first1, __last1, __first2);
  }
}


}}
# 36 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__format/buffer.h" 2 3
# 45 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__format/buffer.h" 3



# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__undef_macros" 1 3
# 49 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__format/buffer.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {



namespace __format {






template <__fmt_char_type _CharT>
class __output_buffer {
public:
  using value_type = _CharT;

  template <class _Tp>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) explicit __output_buffer(_CharT* __ptr, size_t __capacity, _Tp* __obj)
      : __ptr_(__ptr),
        __capacity_(__capacity),
        __flush_([](_CharT* __p, size_t __n, void* __o) { static_cast<_Tp*>(__o)->__flush(__p, __n); }),
        __obj_(__obj) {}

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) void __reset(_CharT* __ptr, size_t __capacity) {
    __ptr_ = __ptr;
    __capacity_ = __capacity;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) auto __make_output_iterator() { return std::back_insert_iterator{*this}; }


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) void push_back(_CharT __c) {
    __ptr_[__size_++] = __c;



    if (__size_ == __capacity_)
      __flush();
  }





  template <__fmt_char_type _InCharT>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) void __copy(basic_string_view<_InCharT> __str) {
# 107 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__format/buffer.h" 3
    size_t __n = __str.size();

    __flush_on_overflow(__n);
    if (__n < __capacity_) {
      std::copy_n(__str.data(), __n, std::addressof(__ptr_[__size_]));
      __size_ += __n;
      return;
    }



    ((void)0);
    const _InCharT* __first = __str.data();
    do {
      size_t __chunk = std::min(__n, __capacity_);
      std::copy_n(__first, __chunk, std::addressof(__ptr_[__size_]));
      __size_ = __chunk;
      __first += __chunk;
      __n -= __chunk;
      __flush();
    } while (__n);
  }




  template <__fmt_char_type _InCharT, class _UnaryOperation>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) void __transform(const _InCharT* __first, const _InCharT* __last, _UnaryOperation __operation) {
    ((void)0);

    size_t __n = static_cast<size_t>(__last - __first);
    __flush_on_overflow(__n);
    if (__n < __capacity_) {
      std::transform(__first, __last, std::addressof(__ptr_[__size_]), std::move(__operation));
      __size_ += __n;
      return;
    }



    ((void)0);
    do {
      size_t __chunk = std::min(__n, __capacity_);
      std::transform(__first, __first + __chunk, std::addressof(__ptr_[__size_]), __operation);
      __size_ = __chunk;
      __first += __chunk;
      __n -= __chunk;
      __flush();
    } while (__n);
  }


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) void __fill(size_t __n, _CharT __value) {
    __flush_on_overflow(__n);
    if (__n < __capacity_) {
      std::fill_n(std::addressof(__ptr_[__size_]), __n, __value);
      __size_ += __n;
      return;
    }



    ((void)0);
    do {
      size_t __chunk = std::min(__n, __capacity_);
      std::fill_n(std::addressof(__ptr_[__size_]), __chunk, __value);
      __size_ = __chunk;
      __n -= __chunk;
      __flush();
    } while (__n);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) void __flush() {
    __flush_(__ptr_, __size_, __obj_);
    __size_ = 0;
  }

private:
  _CharT* __ptr_;
  size_t __capacity_;
  size_t __size_{0};
  void (*__flush_)(_CharT*, size_t, void*);
  void* __obj_;
# 224 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__format/buffer.h" 3
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) void __flush_on_overflow(size_t __n) {
    if (__size_ + __n >= __capacity_)
      __flush();
  }
};





template <__fmt_char_type _CharT>
class __internal_storage {
public:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) _CharT* __begin() { return __buffer_; }

  static constexpr size_t __buffer_size = 256 / sizeof(_CharT);

private:
  _CharT __buffer_[__buffer_size];
};






template <__fmt_char_type _CharT>
class __direct_storage {};

template <class _OutIt, class _CharT>
concept __enable_direct_output = __fmt_char_type<_CharT> &&
    (same_as<_OutIt, _CharT*>


     || same_as<_OutIt, __wrap_iter<_CharT*>>
    );


template <class _OutIt, __fmt_char_type _CharT>
class __writer_direct {
public:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) explicit __writer_direct(_OutIt __out_it)
      : __out_it_(__out_it) {}

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) _OutIt __out_it() { return __out_it_; }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) void __flush(_CharT*, size_t __n) {


    __out_it_ += __n;
  }

private:
  _OutIt __out_it_;
};


template <class _OutIt, __fmt_char_type _CharT>
class __writer_iterator {
public:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) explicit __writer_iterator(_OutIt __out_it)
      : __out_it_{std::move(__out_it)} {}

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) _OutIt __out_it() && { return std::move(__out_it_); }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) void __flush(_CharT* __ptr, size_t __n) {
    __out_it_ = std::ranges::copy_n(__ptr, __n, std::move(__out_it_)).out;
  }

private:
  _OutIt __out_it_;
};
# 304 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__format/buffer.h" 3
template <class _Container>
concept __insertable =
    __enable_insertable<_Container> && __fmt_char_type<typename _Container::value_type> &&
    requires(_Container& __t, add_pointer_t<typename _Container::value_type> __first,
             add_pointer_t<typename _Container::value_type> __last) { __t.insert(__t.end(), __first, __last); };


template <class _It>
struct __back_insert_iterator_container {
  using type = void;
};

template <__insertable _Container>
struct __back_insert_iterator_container<back_insert_iterator<_Container>> {
  using type = _Container;
};


template <class _Container>
class __writer_container {
public:
  using _CharT = typename _Container::value_type;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) explicit __writer_container(back_insert_iterator<_Container> __out_it)
      : __container_{__out_it.__get_container()} {}

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) auto __out_it() { return std::back_inserter(*__container_); }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) void __flush(_CharT* __ptr, size_t __n) {
    __container_->insert(__container_->end(), __ptr, __ptr + __n);
  }

private:
  _Container* __container_;
};


template <class _OutIt, class _CharT>
class __writer_selector {
  using _Container = typename __back_insert_iterator_container<_OutIt>::type;

public:
  using type = conditional_t<!same_as<_Container, void>, __writer_container<_Container>,
                             conditional_t<__enable_direct_output<_OutIt, _CharT>, __writer_direct<_OutIt, _CharT>,
                                           __writer_iterator<_OutIt, _CharT>>>;
};


template <class _OutIt, __fmt_char_type _CharT>
requires(output_iterator<_OutIt, const _CharT&>) class
    __format_buffer {
  using _Storage =
      conditional_t<__enable_direct_output<_OutIt, _CharT>,
                    __direct_storage<_CharT>, __internal_storage<_CharT>>;

public:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) explicit __format_buffer(_OutIt __out_it)
    requires(same_as<_Storage, __internal_storage<_CharT>>)
      : __output_(__storage_.__begin(), __storage_.__buffer_size, this), __writer_(std::move(__out_it)) {}

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) explicit __format_buffer(_OutIt __out_it) requires(
      same_as<_Storage, __direct_storage<_CharT>>)
      : __output_(std::__unwrap_iter(__out_it), size_t(-1), this),
        __writer_(std::move(__out_it)) {}

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) auto __make_output_iterator() { return __output_.__make_output_iterator(); }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) void __flush(_CharT* __ptr, size_t __n) { __writer_.__flush(__ptr, __n); }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) _OutIt __out_it() && {
    __output_.__flush();
    return std::move(__writer_).__out_it();
  }

private:
  [[__no_unique_address__]] _Storage __storage_;
  __output_buffer<_CharT> __output_;
  typename __writer_selector<_OutIt, _CharT>::type __writer_;
};





template <__fmt_char_type _CharT>
class __formatted_size_buffer {
public:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) auto __make_output_iterator() { return __output_.__make_output_iterator(); }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) void __flush(const _CharT*, size_t __n) { __size_ += __n; }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) size_t __result() && {
    __output_.__flush();
    return __size_;
  }

private:
  __internal_storage<_CharT> __storage_;
  __output_buffer<_CharT> __output_{__storage_.__begin(), __storage_.__buffer_size, this};
  size_t __size_{0};
};


template <class _OutIt, __fmt_char_type _CharT, bool>
  requires(output_iterator<_OutIt, const _CharT&>)
struct __format_to_n_buffer_base {
  using _Size = iter_difference_t<_OutIt>;

public:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) explicit __format_to_n_buffer_base(_OutIt __out_it, _Size __max_size)
      : __writer_(std::move(__out_it)), __max_size_(std::max(_Size(0), __max_size)) {}

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) void __flush(_CharT* __ptr, size_t __n) {
    if (_Size(__size_) <= __max_size_)
      __writer_.__flush(__ptr, std::min(_Size(__n), __max_size_ - __size_));
    __size_ += __n;
  }

protected:
  __internal_storage<_CharT> __storage_;
  __output_buffer<_CharT> __output_{__storage_.__begin(), __storage_.__buffer_size, this};
  typename __writer_selector<_OutIt, _CharT>::type __writer_;

  _Size __max_size_;
  _Size __size_{0};
};







template <class _OutIt, __fmt_char_type _CharT>
  requires(output_iterator<_OutIt, const _CharT&>)
class __format_to_n_buffer_base<_OutIt, _CharT, true> {
  using _Size = iter_difference_t<_OutIt>;

public:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) explicit __format_to_n_buffer_base(_OutIt __out_it, _Size __max_size)
      : __output_(std::__unwrap_iter(__out_it), __max_size, this),
        __writer_(std::move(__out_it)),
        __max_size_(__max_size) {
    if (__max_size <= 0) [[unlikely]]
      __output_.__reset(__storage_.__begin(), __storage_.__buffer_size);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) void __flush(_CharT* __ptr, size_t __n) {
# 463 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__format/buffer.h" 3
    if (__size_ == 0 && __ptr != __storage_.__begin()) {
      __writer_.__flush(__ptr, __n);
      __output_.__reset(__storage_.__begin(), __storage_.__buffer_size);
    } else if (__size_ < __max_size_) {


      _Size __s = std::min(_Size(__n), __max_size_ - __size_);
      std::copy_n(__ptr, __s, __writer_.__out_it());
      __writer_.__flush(__ptr, __s);
    }

    __size_ += __n;
  }

protected:
  __internal_storage<_CharT> __storage_;
  __output_buffer<_CharT> __output_;
  __writer_direct<_OutIt, _CharT> __writer_;

  _Size __max_size_;
  _Size __size_{0};
};


template <class _OutIt, __fmt_char_type _CharT>
  requires(output_iterator<_OutIt, const _CharT&>)
struct __format_to_n_buffer final
    : public __format_to_n_buffer_base< _OutIt, _CharT, __enable_direct_output<_OutIt, _CharT>> {
  using _Base = __format_to_n_buffer_base<_OutIt, _CharT, __enable_direct_output<_OutIt, _CharT>>;
  using _Size = iter_difference_t<_OutIt>;

public:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) explicit __format_to_n_buffer(_OutIt __out_it, _Size __max_size)
      : _Base(std::move(__out_it), __max_size) {}
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) auto __make_output_iterator() { return this->__output_.__make_output_iterator(); }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) format_to_n_result<_OutIt> __result() && {
    this->__output_.__flush();
    return {std::move(this->__writer_).__out_it(), this->__size_};
  }
};
# 523 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__format/buffer.h" 3
template <__fmt_char_type _CharT>
class __retarget_buffer {
  using _Alloc = allocator<_CharT>;

public:
  using value_type = _CharT;

  struct __iterator {
    using difference_type = ptrdiff_t;
    using value_type = _CharT;

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr explicit __iterator(__retarget_buffer& __buffer)
        : __buffer_(std::addressof(__buffer)) {}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr __iterator& operator=(const _CharT& __c) {
      __buffer_->push_back(__c);
      return *this;
    }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr __iterator& operator=(_CharT&& __c) {
      __buffer_->push_back(__c);
      return *this;
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr __iterator& operator*() { return *this; }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr __iterator& operator++() { return *this; }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr __iterator operator++(int) { return *this; }
    __retarget_buffer* __buffer_;
  };

  __retarget_buffer(const __retarget_buffer&) = delete;
  __retarget_buffer& operator=(const __retarget_buffer&) = delete;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) explicit __retarget_buffer(size_t __size_hint) {







    auto __result = std::__allocate_at_least(__alloc_, std::max(__size_hint, 256 / sizeof(_CharT)));
    __ptr_ = __result.ptr;
    __capacity_ = __result.count;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) ~__retarget_buffer() {
    ranges::destroy_n(__ptr_, __size_);
    allocator_traits<_Alloc>::deallocate(__alloc_, __ptr_, __capacity_);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) __iterator __make_output_iterator() { return __iterator{*this}; }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) void push_back(_CharT __c) {
    std::construct_at(__ptr_ + __size_, __c);
    ++__size_;

    if (__size_ == __capacity_)
      __grow_buffer();
  }

  template <__fmt_char_type _InCharT>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) void __copy(basic_string_view<_InCharT> __str) {
    size_t __n = __str.size();
    if (__size_ + __n >= __capacity_)

      __grow_buffer(__size_ + __n + 1);

    std::uninitialized_copy_n(__str.data(), __n, __ptr_ + __size_);
    __size_ += __n;
  }

  template <__fmt_char_type _InCharT, class _UnaryOperation>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) void __transform(const _InCharT* __first, const _InCharT* __last, _UnaryOperation __operation) {
    ((void)0);

    size_t __n = static_cast<size_t>(__last - __first);
    if (__size_ + __n >= __capacity_)

      __grow_buffer(__size_ + __n + 1);

    std::uninitialized_default_construct_n(__ptr_ + __size_, __n);
    std::transform(__first, __last, __ptr_ + __size_, std::move(__operation));
    __size_ += __n;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) void __fill(size_t __n, _CharT __value) {
    if (__size_ + __n >= __capacity_)

      __grow_buffer(__size_ + __n + 1);

    std::uninitialized_fill_n(__ptr_ + __size_, __n, __value);
    __size_ += __n;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) basic_string_view<_CharT> __view() { return {__ptr_, __size_}; }

private:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) void __grow_buffer() { __grow_buffer(__capacity_ * 1.6); }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) void __grow_buffer(size_t __capacity) {
    ((void)0);
    auto __result = std::__allocate_at_least(__alloc_, __capacity);
    auto __guard = std::__make_exception_guard([&] {
      allocator_traits<_Alloc>::deallocate(__alloc_, __result.ptr, __result.count);
    });


    std::uninitialized_move_n(__ptr_, __size_, __result.ptr);
    __guard.__complete();
    ranges::destroy_n(__ptr_, __size_);
    allocator_traits<_Alloc>::deallocate(__alloc_, __ptr_, __capacity_);

    __ptr_ = __result.ptr;
    __capacity_ = __result.count;
  }
  [[__no_unique_address__]] _Alloc __alloc_;
  _CharT* __ptr_;
  size_t __capacity_;
  size_t __size_{0};
};

}



}}
# 20 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__format/formatter_output.h" 2 3


# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__format/parser_std_format_spec.h" 1 3
# 25 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__format/parser_std_format_spec.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__format/format_arg.h" 1 3
# 25 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__format/format_arg.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__variant/monostate.h" 1 3
# 20 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__variant/monostate.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {



struct monostate {};

__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr bool operator==(monostate, monostate) noexcept { return true; }



__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr strong_ordering operator<=>(monostate, monostate) noexcept {
  return strong_ordering::equal;
}
# 50 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__variant/monostate.h" 3
template <>
struct hash<monostate> {
  using argument_type = monostate;
  using result_type = size_t;

  inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) result_type operator()(const argument_type&) const noexcept {
    return 66740831;
  }
};



}}
# 26 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__format/format_arg.h" 2 3
# 31 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__format/format_arg.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {



namespace __format {
# 56 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__format/format_arg.h" 3
enum class __arg_t : uint8_t {
  __none,
  __boolean,
  __char_type,
  __int,
  __long_long,
  __i128,
  __unsigned,
  __unsigned_long_long,
  __u128,
  __float,
  __double,
  __long_double,
  __const_char_type_ptr,
  __string_view,
  __ptr,
  __handle
};

inline constexpr unsigned __packed_arg_t_bits = 5;
inline constexpr uint8_t __packed_arg_t_mask = 0x1f;

inline constexpr unsigned __packed_types_storage_bits = 64;
inline constexpr unsigned __packed_types_max = __packed_types_storage_bits / __packed_arg_t_bits;

__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
constexpr bool __use_packed_format_arg_store(size_t __size) { return __size <= __packed_types_max; }

__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
constexpr __arg_t __get_packed_type(uint64_t __types, size_t __id) {
  ((void)0);

  if (__id > 0)
    __types >>= __id * __packed_arg_t_bits;

  return static_cast<__format::__arg_t>(__types & __packed_arg_t_mask);
}

}



template <class _Visitor, class _Context>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) decltype(auto)
__visit_format_arg(_Visitor&& __vis, basic_format_arg<_Context> __arg) {
  switch (__arg.__type_) {
  case __format::__arg_t::__none:
    return std::invoke(std::forward<_Visitor>(__vis), __arg.__value_.__monostate_);
  case __format::__arg_t::__boolean:
    return std::invoke(std::forward<_Visitor>(__vis), __arg.__value_.__boolean_);
  case __format::__arg_t::__char_type:
    return std::invoke(std::forward<_Visitor>(__vis), __arg.__value_.__char_type_);
  case __format::__arg_t::__int:
    return std::invoke(std::forward<_Visitor>(__vis), __arg.__value_.__int_);
  case __format::__arg_t::__long_long:
    return std::invoke(std::forward<_Visitor>(__vis), __arg.__value_.__long_long_);
  case __format::__arg_t::__i128:

    return std::invoke(std::forward<_Visitor>(__vis), __arg.__value_.__i128_);



  case __format::__arg_t::__unsigned:
    return std::invoke(std::forward<_Visitor>(__vis), __arg.__value_.__unsigned_);
  case __format::__arg_t::__unsigned_long_long:
    return std::invoke(std::forward<_Visitor>(__vis), __arg.__value_.__unsigned_long_long_);
  case __format::__arg_t::__u128:

    return std::invoke(std::forward<_Visitor>(__vis), __arg.__value_.__u128_);



  case __format::__arg_t::__float:
    return std::invoke(std::forward<_Visitor>(__vis), __arg.__value_.__float_);
  case __format::__arg_t::__double:
    return std::invoke(std::forward<_Visitor>(__vis), __arg.__value_.__double_);
  case __format::__arg_t::__long_double:
    return std::invoke(std::forward<_Visitor>(__vis), __arg.__value_.__long_double_);
  case __format::__arg_t::__const_char_type_ptr:
    return std::invoke(std::forward<_Visitor>(__vis), __arg.__value_.__const_char_type_ptr_);
  case __format::__arg_t::__string_view:
    return std::invoke(std::forward<_Visitor>(__vis), __arg.__value_.__string_view_);
  case __format::__arg_t::__ptr:
    return std::invoke(std::forward<_Visitor>(__vis), __arg.__value_.__ptr_);
  case __format::__arg_t::__handle:
    return std::invoke(std::forward<_Visitor>(__vis),
                         typename basic_format_arg<_Context>::handle{__arg.__value_.__handle_});
  }

  __libcpp_unreachable();
}





template <class _Context>
class __basic_format_arg_value {
  using _CharT = typename _Context::char_type;

public:

  struct __handle {
    template <class _Tp>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) explicit __handle(_Tp& __v) noexcept
        : __ptr_(std::addressof(__v)),
          __format_([](basic_format_parse_context<_CharT>& __parse_ctx, _Context& __ctx, const void* __ptr) {
            using _Dp = remove_const_t<_Tp>;
            using _Qp = conditional_t<__formattable_with<const _Dp, _Context>, const _Dp, _Dp>;
            static_assert(__formattable_with<_Qp, _Context>, "Mandated by [format.arg]/10");

            typename _Context::template formatter_type<_Dp> __f;
            __parse_ctx.advance_to(__f.parse(__parse_ctx));
            __ctx.advance_to(__f.format(*const_cast<_Qp*>(static_cast<const _Dp*>(__ptr)), __ctx));
          }) {}

    const void* __ptr_;
    void (*__format_)(basic_format_parse_context<_CharT>&, _Context&, const void*);
  };

  union {
    monostate __monostate_;
    bool __boolean_;
    _CharT __char_type_;
    int __int_;
    unsigned __unsigned_;
    long long __long_long_;
    unsigned long long __unsigned_long_long_;

    __int128_t __i128_;
    __uint128_t __u128_;

    float __float_;
    double __double_;
    long double __long_double_;
    const _CharT* __const_char_type_ptr_;
    basic_string_view<_CharT> __string_view_;
    const void* __ptr_;
    __handle __handle_;
  };




  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) __basic_format_arg_value() noexcept : __monostate_() {}
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) __basic_format_arg_value(bool __value) noexcept : __boolean_(__value) {}
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) __basic_format_arg_value(_CharT __value) noexcept : __char_type_(__value) {}
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) __basic_format_arg_value(int __value) noexcept : __int_(__value) {}
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) __basic_format_arg_value(unsigned __value) noexcept : __unsigned_(__value) {}
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) __basic_format_arg_value(long long __value) noexcept : __long_long_(__value) {}
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) __basic_format_arg_value(unsigned long long __value) noexcept
      : __unsigned_long_long_(__value) {}

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) __basic_format_arg_value(__int128_t __value) noexcept : __i128_(__value) {}
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) __basic_format_arg_value(__uint128_t __value) noexcept : __u128_(__value) {}

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) __basic_format_arg_value(float __value) noexcept : __float_(__value) {}
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) __basic_format_arg_value(double __value) noexcept : __double_(__value) {}
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) __basic_format_arg_value(long double __value) noexcept : __long_double_(__value) {}
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) __basic_format_arg_value(const _CharT* __value) noexcept : __const_char_type_ptr_(__value) {}
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) __basic_format_arg_value(basic_string_view<_CharT> __value) noexcept
      : __string_view_(__value) {}
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) __basic_format_arg_value(const void* __value) noexcept : __ptr_(__value) {}
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) __basic_format_arg_value(__handle&& __value) noexcept : __handle_(std::move(__value)) {}
};

template <class _Context>
class basic_format_arg {
public:
  class handle;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) basic_format_arg() noexcept
      : __type_{__format::__arg_t::__none} {}

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) explicit operator bool() const noexcept {
    return __type_ != __format::__arg_t::__none;
  }

private:
  using char_type = typename _Context::char_type;
# 248 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__format/format_arg.h" 3
public:
  __basic_format_arg_value<_Context> __value_;
  __format::__arg_t __type_;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) explicit basic_format_arg(__format::__arg_t __type,
                                                  __basic_format_arg_value<_Context> __value) noexcept
      : __value_(__value), __type_(__type) {}
};

template <class _Context>
class basic_format_arg<_Context>::handle {
public:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
  void format(basic_format_parse_context<char_type>& __parse_ctx, _Context& __ctx) const {
    __handle_.__format_(__parse_ctx, __ctx, __handle_.__ptr_);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) explicit handle(typename __basic_format_arg_value<_Context>::__handle& __handle) noexcept
      : __handle_(__handle) {}

private:
  typename __basic_format_arg_value<_Context>::__handle& __handle_;
};



template <class _Visitor, class _Context>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) decltype(auto)
visit_format_arg(_Visitor&& __vis, basic_format_arg<_Context> __arg) {
  switch (__arg.__type_) {

  case __format::__arg_t::__i128: {
    typename __basic_format_arg_value<_Context>::__handle __h{__arg.__value_.__i128_};
    return std::invoke(std::forward<_Visitor>(__vis), typename basic_format_arg<_Context>::handle{__h});
  }

  case __format::__arg_t::__u128: {
    typename __basic_format_arg_value<_Context>::__handle __h{__arg.__value_.__u128_};
    return std::invoke(std::forward<_Visitor>(__vis), typename basic_format_arg<_Context>::handle{__h});
  }

  default:
    return std::__visit_format_arg(std::forward<_Visitor>(__vis), __arg);
  }
}



}}
# 26 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__format/parser_std_format_spec.h" 2 3


# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__format/format_string.h" 1 3
# 23 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__format/format_string.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {



namespace __format {

template <contiguous_iterator _Iterator>
struct __parse_number_result {
  _Iterator __last;
  uint32_t __value;
};

template <contiguous_iterator _Iterator>
__parse_number_result(_Iterator, uint32_t) -> __parse_number_result<_Iterator>;

template <contiguous_iterator _Iterator>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr __parse_number_result<_Iterator>
__parse_number(_Iterator __begin, _Iterator __end);
# 55 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__format/format_string.h" 3
inline constexpr uint32_t __number_max = (2147483647);

namespace __detail {
template <contiguous_iterator _Iterator>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr __parse_number_result<_Iterator>
__parse_zero(_Iterator __begin, _Iterator, auto& __parse_ctx) {
  __parse_ctx.check_arg_id(0);
  return {++__begin, 0};
}

template <contiguous_iterator _Iterator>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr __parse_number_result<_Iterator>
__parse_automatic(_Iterator __begin, _Iterator, auto& __parse_ctx) {
  size_t __value = __parse_ctx.next_arg_id();
  ((void)0);



  return {__begin, uint32_t(__value)};
}

template <contiguous_iterator _Iterator>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr __parse_number_result<_Iterator>
__parse_manual(_Iterator __begin, _Iterator __end, auto& __parse_ctx) {
  __parse_number_result<_Iterator> __r = __format::__parse_number(__begin, __end);
  __parse_ctx.check_arg_id(__r.__value);
  return __r;
}

}







template <contiguous_iterator _Iterator>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr __parse_number_result<_Iterator>
__parse_number(_Iterator __begin, _Iterator __end_input) {
  using _CharT = iter_value_t<_Iterator>;
  static_assert(__format::__number_max == (2147483647),
                "The algorithm is implemented based on this value.");







  _Iterator __end = __end_input - __begin > 9 ? __begin + 9 : __end_input;
  uint32_t __value = *__begin - _CharT('0');
  while (++__begin != __end) {
    if (*__begin < _CharT('0') || *__begin > _CharT('9'))
      return {__begin, __value};

    __value = __value * 10 + *__begin - _CharT('0');
  }

  if (__begin != __end_input && *__begin >= _CharT('0') &&
      *__begin <= _CharT('9')) {







    uint64_t __v = uint64_t(__value) * 10 + *__begin++ - _CharT('0');
    if (__v > __number_max ||
        (__begin != __end_input && *__begin >= _CharT('0') &&
         *__begin <= _CharT('9')))
      std::__throw_format_error("The numeric value of the format specifier is too large");

    __value = __v;
  }

  return {__begin, __value};
}







template <contiguous_iterator _Iterator>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr __parse_number_result<_Iterator>
__parse_arg_id(_Iterator __begin, _Iterator __end, auto& __parse_ctx) {
  using _CharT = iter_value_t<_Iterator>;
  switch (*__begin) {
  case _CharT('0'):
    return __detail::__parse_zero(__begin, __end, __parse_ctx);

  case _CharT(':'):



  case _CharT('}'):
    return __detail::__parse_automatic(__begin, __end, __parse_ctx);
  }
  if (*__begin < _CharT('0') || *__begin > _CharT('9'))
    std::__throw_format_error("The argument index starts with an invalid character");

  return __detail::__parse_manual(__begin, __end, __parse_ctx);
}

}



}}
# 29 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__format/parser_std_format_spec.h" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__format/unicode.h" 1 3
# 17 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__format/unicode.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__format/extended_grapheme_cluster_table.h" 1 3
# 72 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__format/extended_grapheme_cluster_table.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {



namespace __extended_grapheme_custer_property_boundary {

enum class __property : uint8_t {

  __CR,
  __Control,
  __Extend,
  __Extended_Pictographic,
  __L,
  __LF,
  __LV,
  __LVT,
  __Prepend,
  __Regional_Indicator,
  __SpacingMark,
  __T,
  __V,
  __ZWJ,




  __sot,
  __eot,


  __none
};
# 127 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__format/extended_grapheme_cluster_table.h" 3
inline constexpr uint32_t __entries[1496] = {
    0x00000091,
    0x00005005,
    0x00005811,
    0x00006800,
    0x00007111,
    0x0003fa01,
    0x00054803,
    0x00056801,
    0x00057003,
    0x001806f2,
    0x00241862,
    0x002c8ac2,
    0x002df802,
    0x002e0812,
    0x002e2012,
    0x002e3802,
    0x00300058,
    0x003080a2,
    0x0030e001,
    0x00325942,
    0x00338002,
    0x0036b062,
    0x0036e808,
    0x0036f852,
    0x00373812,
    0x00375032,
    0x00387808,
    0x00388802,
    0x003981a2,
    0x003d30a2,
    0x003f5882,
    0x003fe802,
    0x0040b032,
    0x0040d882,
    0x00412822,
    0x00414842,
    0x0042c822,
    0x00448018,
    0x0044c072,
    0x00465172,
    0x00471008,
    0x004719f2,
    0x0048180a,
    0x0049d002,
    0x0049d80a,
    0x0049e002,
    0x0049f02a,
    0x004a0872,
    0x004a483a,
    0x004a6802,
    0x004a701a,
    0x004a8862,
    0x004b1012,
    0x004c0802,
    0x004c101a,
    0x004de002,
    0x004df002,
    0x004df81a,
    0x004e0832,
    0x004e381a,
    0x004e581a,
    0x004e6802,
    0x004eb802,
    0x004f1012,
    0x004ff002,
    0x00500812,
    0x0050180a,
    0x0051e002,
    0x0051f02a,
    0x00520812,
    0x00523812,
    0x00525822,
    0x00528802,
    0x00538012,
    0x0053a802,
    0x00540812,
    0x0054180a,
    0x0055e002,
    0x0055f02a,
    0x00560842,
    0x00563812,
    0x0056480a,
    0x0056581a,
    0x00566802,
    0x00571012,
    0x0057d052,
    0x00580802,
    0x0058101a,
    0x0059e002,
    0x0059f012,
    0x005a000a,
    0x005a0832,
    0x005a381a,
    0x005a581a,
    0x005a6802,
    0x005aa822,
    0x005b1012,
    0x005c1002,
    0x005df002,
    0x005df80a,
    0x005e0002,
    0x005e081a,
    0x005e302a,
    0x005e502a,
    0x005e6802,
    0x005eb802,
    0x00600002,
    0x0060082a,
    0x00602002,
    0x0061e002,
    0x0061f022,
    0x0062083a,
    0x00623022,
    0x00625032,
    0x0062a812,
    0x00631012,
    0x00640802,
    0x0064101a,
    0x0065e002,
    0x0065f00a,
    0x0065f802,
    0x0066001a,
    0x00661002,
    0x0066181a,
    0x00663002,
    0x0066381a,
    0x0066501a,
    0x00666012,
    0x0066a812,
    0x00671012,
    0x0067980a,
    0x00680012,
    0x0068101a,
    0x0069d812,
    0x0069f002,
    0x0069f81a,
    0x006a0832,
    0x006a302a,
    0x006a502a,
    0x006a6802,
    0x006a7008,
    0x006ab802,
    0x006b1012,
    0x006c0802,
    0x006c101a,
    0x006e5002,
    0x006e7802,
    0x006e801a,
    0x006e9022,
    0x006eb002,
    0x006ec06a,
    0x006ef802,
    0x006f901a,
    0x00718802,
    0x0071980a,
    0x0071a062,
    0x00723872,
    0x00758802,
    0x0075980a,
    0x0075a082,
    0x00764062,
    0x0078c012,
    0x0079a802,
    0x0079b802,
    0x0079c802,
    0x0079f01a,
    0x007b88d2,
    0x007bf80a,
    0x007c0042,
    0x007c3012,
    0x007c68a2,
    0x007cca32,
    0x007e3002,
    0x00816832,
    0x0081880a,
    0x00819052,
    0x0081c812,
    0x0081d81a,
    0x0081e812,
    0x0082b01a,
    0x0082c012,
    0x0082f022,
    0x00838832,
    0x00841002,
    0x0084200a,
    0x00842812,
    0x00846802,
    0x0084e802,
    0x008805f4,
    0x008b047c,
    0x008d457b,
    0x009ae822,
    0x00b89022,
    0x00b8a80a,
    0x00b99012,
    0x00b9a00a,
    0x00ba9012,
    0x00bb9012,
    0x00bda012,
    0x00bdb00a,
    0x00bdb862,
    0x00bdf07a,
    0x00be3002,
    0x00be381a,
    0x00be48a2,
    0x00bee802,
    0x00c05822,
    0x00c07001,
    0x00c07802,
    0x00c42812,
    0x00c54802,
    0x00c90022,
    0x00c9183a,
    0x00c93812,
    0x00c9482a,
    0x00c9801a,
    0x00c99002,
    0x00c9985a,
    0x00c9c822,
    0x00d0b812,
    0x00d0c81a,
    0x00d0d802,
    0x00d2a80a,
    0x00d2b002,
    0x00d2b80a,
    0x00d2c062,
    0x00d30002,
    0x00d31002,
    0x00d32872,
    0x00d3685a,
    0x00d39892,
    0x00d3f802,
    0x00d581e2,
    0x00d80032,
    0x00d8200a,
    0x00d9a062,
    0x00d9d80a,
    0x00d9e002,
    0x00d9e84a,
    0x00da1002,
    0x00da181a,
    0x00db5882,
    0x00dc0012,
    0x00dc100a,
    0x00dd080a,
    0x00dd1032,
    0x00dd301a,
    0x00dd4012,
    0x00dd500a,
    0x00dd5822,
    0x00df3002,
    0x00df380a,
    0x00df4012,
    0x00df502a,
    0x00df6802,
    0x00df700a,
    0x00df7822,
    0x00df901a,
    0x00e1207a,
    0x00e16072,
    0x00e1a01a,
    0x00e1b012,
    0x00e68022,
    0x00e6a0c2,
    0x00e7080a,
    0x00e71062,
    0x00e76802,
    0x00e7a002,
    0x00e7b80a,
    0x00e7c012,
    0x00ee03f2,
    0x01005801,
    0x01006002,
    0x0100680d,
    0x01007011,
    0x01014061,
    0x0101e003,
    0x01024803,
    0x010300f1,
    0x01068202,
    0x01091003,
    0x0109c803,
    0x010ca053,
    0x010d4813,
    0x0118d013,
    0x01194003,
    0x011c4003,
    0x011e7803,
    0x011f48a3,
    0x011fc023,
    0x01261003,
    0x012d5013,
    0x012db003,
    0x012e0003,
    0x012fd833,
    0x01300053,
    0x013038b3,
    0x0130a713,
    0x01348753,
    0x013840a3,
    0x0138a003,
    0x0138b003,
    0x0138e803,
    0x01390803,
    0x01394003,
    0x01399813,
    0x013a2003,
    0x013a3803,
    0x013a6003,
    0x013a7003,
    0x013a9823,
    0x013ab803,
    0x013b1843,
    0x013ca823,
    0x013d0803,
    0x013d8003,
    0x013df803,
    0x0149a013,
    0x01582823,
    0x0158d813,
    0x015a8003,
    0x015aa803,
    0x01677822,
    0x016bf802,
    0x016f01f2,
    0x01815052,
    0x01818003,
    0x0181e803,
    0x0184c812,
    0x0194b803,
    0x0194c803,
    0x05337832,
    0x0533a092,
    0x0534f012,
    0x05378012,
    0x05401002,
    0x05403002,
    0x05405802,
    0x0541181a,
    0x05412812,
    0x0541380a,
    0x05416002,
    0x0544001a,
    0x0545a0fa,
    0x05462012,
    0x05470112,
    0x0547f802,
    0x05493072,
    0x054a38a2,
    0x054a901a,
    0x054b01c4,
    0x054c0022,
    0x054c180a,
    0x054d9802,
    0x054da01a,
    0x054db032,
    0x054dd01a,
    0x054de012,
    0x054df02a,
    0x054f2802,
    0x05514852,
    0x0551781a,
    0x05518812,
    0x0551981a,
    0x0551a812,
    0x05521802,
    0x05526002,
    0x0552680a,
    0x0553e002,
    0x05558002,
    0x05559022,
    0x0555b812,
    0x0555f012,
    0x05560802,
    0x0557580a,
    0x05576012,
    0x0557701a,
    0x0557a80a,
    0x0557b002,
    0x055f181a,
    0x055f2802,
    0x055f301a,
    0x055f4002,
    0x055f481a,
    0x055f600a,
    0x055f6802,
    0x05600006,
    0x056009a7,
    0x0560e006,
    0x0560e9a7,
    0x0561c006,
    0x0561c9a7,
    0x0562a006,
    0x0562a9a7,
    0x05638006,
    0x056389a7,
    0x05646006,
    0x056469a7,
    0x05654006,
    0x056549a7,
    0x05662006,
    0x056629a7,
    0x05670006,
    0x056709a7,
    0x0567e006,
    0x0567e9a7,
    0x0568c006,
    0x0568c9a7,
    0x0569a006,
    0x0569a9a7,
    0x056a8006,
    0x056a89a7,
    0x056b6006,
    0x056b69a7,
    0x056c4006,
    0x056c49a7,
    0x056d2006,
    0x056d29a7,
    0x056e0006,
    0x056e09a7,
    0x056ee006,
    0x056ee9a7,
    0x056fc006,
    0x056fc9a7,
    0x0570a006,
    0x0570a9a7,
    0x05718006,
    0x057189a7,
    0x05726006,
    0x057269a7,
    0x05734006,
    0x057349a7,
    0x05742006,
    0x057429a7,
    0x05750006,
    0x057509a7,
    0x0575e006,
    0x0575e9a7,
    0x0576c006,
    0x0576c9a7,
    0x0577a006,
    0x0577a9a7,
    0x05788006,
    0x057889a7,
    0x05796006,
    0x057969a7,
    0x057a4006,
    0x057a49a7,
    0x057b2006,
    0x057b29a7,
    0x057c0006,
    0x057c09a7,
    0x057ce006,
    0x057ce9a7,
    0x057dc006,
    0x057dc9a7,
    0x057ea006,
    0x057ea9a7,
    0x057f8006,
    0x057f89a7,
    0x05806006,
    0x058069a7,
    0x05814006,
    0x058149a7,
    0x05822006,
    0x058229a7,
    0x05830006,
    0x058309a7,
    0x0583e006,
    0x0583e9a7,
    0x0584c006,
    0x0584c9a7,
    0x0585a006,
    0x0585a9a7,
    0x05868006,
    0x058689a7,
    0x05876006,
    0x058769a7,
    0x05884006,
    0x058849a7,
    0x05892006,
    0x058929a7,
    0x058a0006,
    0x058a09a7,
    0x058ae006,
    0x058ae9a7,
    0x058bc006,
    0x058bc9a7,
    0x058ca006,
    0x058ca9a7,
    0x058d8006,
    0x058d89a7,
    0x058e6006,
    0x058e69a7,
    0x058f4006,
    0x058f49a7,
    0x05902006,
    0x059029a7,
    0x05910006,
    0x059109a7,
    0x0591e006,
    0x0591e9a7,
    0x0592c006,
    0x0592c9a7,
    0x0593a006,
    0x0593a9a7,
    0x05948006,
    0x059489a7,
    0x05956006,
    0x059569a7,
    0x05964006,
    0x059649a7,
    0x05972006,
    0x059729a7,
    0x05980006,
    0x059809a7,
    0x0598e006,
    0x0598e9a7,
    0x0599c006,
    0x0599c9a7,
    0x059aa006,
    0x059aa9a7,
    0x059b8006,
    0x059b89a7,
    0x059c6006,
    0x059c69a7,
    0x059d4006,
    0x059d49a7,
    0x059e2006,
    0x059e29a7,
    0x059f0006,
    0x059f09a7,
    0x059fe006,
    0x059fe9a7,
    0x05a0c006,
    0x05a0c9a7,
    0x05a1a006,
    0x05a1a9a7,
    0x05a28006,
    0x05a289a7,
    0x05a36006,
    0x05a369a7,
    0x05a44006,
    0x05a449a7,
    0x05a52006,
    0x05a529a7,
    0x05a60006,
    0x05a609a7,
    0x05a6e006,
    0x05a6e9a7,
    0x05a7c006,
    0x05a7c9a7,
    0x05a8a006,
    0x05a8a9a7,
    0x05a98006,
    0x05a989a7,
    0x05aa6006,
    0x05aa69a7,
    0x05ab4006,
    0x05ab49a7,
    0x05ac2006,
    0x05ac29a7,
    0x05ad0006,
    0x05ad09a7,
    0x05ade006,
    0x05ade9a7,
    0x05aec006,
    0x05aec9a7,
    0x05afa006,
    0x05afa9a7,
    0x05b08006,
    0x05b089a7,
    0x05b16006,
    0x05b169a7,
    0x05b24006,
    0x05b249a7,
    0x05b32006,
    0x05b329a7,
    0x05b40006,
    0x05b409a7,
    0x05b4e006,
    0x05b4e9a7,
    0x05b5c006,
    0x05b5c9a7,
    0x05b6a006,
    0x05b6a9a7,
    0x05b78006,
    0x05b789a7,
    0x05b86006,
    0x05b869a7,
    0x05b94006,
    0x05b949a7,
    0x05ba2006,
    0x05ba29a7,
    0x05bb0006,
    0x05bb09a7,
    0x05bbe006,
    0x05bbe9a7,
    0x05bcc006,
    0x05bcc9a7,
    0x05bda006,
    0x05bda9a7,
    0x05be8006,
    0x05be89a7,
    0x05bf6006,
    0x05bf69a7,
    0x05c04006,
    0x05c049a7,
    0x05c12006,
    0x05c129a7,
    0x05c20006,
    0x05c209a7,
    0x05c2e006,
    0x05c2e9a7,
    0x05c3c006,
    0x05c3c9a7,
    0x05c4a006,
    0x05c4a9a7,
    0x05c58006,
    0x05c589a7,
    0x05c66006,
    0x05c669a7,
    0x05c74006,
    0x05c749a7,
    0x05c82006,
    0x05c829a7,
    0x05c90006,
    0x05c909a7,
    0x05c9e006,
    0x05c9e9a7,
    0x05cac006,
    0x05cac9a7,
    0x05cba006,
    0x05cba9a7,
    0x05cc8006,
    0x05cc89a7,
    0x05cd6006,
    0x05cd69a7,
    0x05ce4006,
    0x05ce49a7,
    0x05cf2006,
    0x05cf29a7,
    0x05d00006,
    0x05d009a7,
    0x05d0e006,
    0x05d0e9a7,
    0x05d1c006,
    0x05d1c9a7,
    0x05d2a006,
    0x05d2a9a7,
    0x05d38006,
    0x05d389a7,
    0x05d46006,
    0x05d469a7,
    0x05d54006,
    0x05d549a7,
    0x05d62006,
    0x05d629a7,
    0x05d70006,
    0x05d709a7,
    0x05d7e006,
    0x05d7e9a7,
    0x05d8c006,
    0x05d8c9a7,
    0x05d9a006,
    0x05d9a9a7,
    0x05da8006,
    0x05da89a7,
    0x05db6006,
    0x05db69a7,
    0x05dc4006,
    0x05dc49a7,
    0x05dd2006,
    0x05dd29a7,
    0x05de0006,
    0x05de09a7,
    0x05dee006,
    0x05dee9a7,
    0x05dfc006,
    0x05dfc9a7,
    0x05e0a006,
    0x05e0a9a7,
    0x05e18006,
    0x05e189a7,
    0x05e26006,
    0x05e269a7,
    0x05e34006,
    0x05e349a7,
    0x05e42006,
    0x05e429a7,
    0x05e50006,
    0x05e509a7,
    0x05e5e006,
    0x05e5e9a7,
    0x05e6c006,
    0x05e6c9a7,
    0x05e7a006,
    0x05e7a9a7,
    0x05e88006,
    0x05e889a7,
    0x05e96006,
    0x05e969a7,
    0x05ea4006,
    0x05ea49a7,
    0x05eb2006,
    0x05eb29a7,
    0x05ec0006,
    0x05ec09a7,
    0x05ece006,
    0x05ece9a7,
    0x05edc006,
    0x05edc9a7,
    0x05eea006,
    0x05eea9a7,
    0x05ef8006,
    0x05ef89a7,
    0x05f06006,
    0x05f069a7,
    0x05f14006,
    0x05f149a7,
    0x05f22006,
    0x05f229a7,
    0x05f30006,
    0x05f309a7,
    0x05f3e006,
    0x05f3e9a7,
    0x05f4c006,
    0x05f4c9a7,
    0x05f5a006,
    0x05f5a9a7,
    0x05f68006,
    0x05f689a7,
    0x05f76006,
    0x05f769a7,
    0x05f84006,
    0x05f849a7,
    0x05f92006,
    0x05f929a7,
    0x05fa0006,
    0x05fa09a7,
    0x05fae006,
    0x05fae9a7,
    0x05fbc006,
    0x05fbc9a7,
    0x05fca006,
    0x05fca9a7,
    0x05fd8006,
    0x05fd89a7,
    0x05fe6006,
    0x05fe69a7,
    0x05ff4006,
    0x05ff49a7,
    0x06002006,
    0x060029a7,
    0x06010006,
    0x060109a7,
    0x0601e006,
    0x0601e9a7,
    0x0602c006,
    0x0602c9a7,
    0x0603a006,
    0x0603a9a7,
    0x06048006,
    0x060489a7,
    0x06056006,
    0x060569a7,
    0x06064006,
    0x060649a7,
    0x06072006,
    0x060729a7,
    0x06080006,
    0x060809a7,
    0x0608e006,
    0x0608e9a7,
    0x0609c006,
    0x0609c9a7,
    0x060aa006,
    0x060aa9a7,
    0x060b8006,
    0x060b89a7,
    0x060c6006,
    0x060c69a7,
    0x060d4006,
    0x060d49a7,
    0x060e2006,
    0x060e29a7,
    0x060f0006,
    0x060f09a7,
    0x060fe006,
    0x060fe9a7,
    0x0610c006,
    0x0610c9a7,
    0x0611a006,
    0x0611a9a7,
    0x06128006,
    0x061289a7,
    0x06136006,
    0x061369a7,
    0x06144006,
    0x061449a7,
    0x06152006,
    0x061529a7,
    0x06160006,
    0x061609a7,
    0x0616e006,
    0x0616e9a7,
    0x0617c006,
    0x0617c9a7,
    0x0618a006,
    0x0618a9a7,
    0x06198006,
    0x061989a7,
    0x061a6006,
    0x061a69a7,
    0x061b4006,
    0x061b49a7,
    0x061c2006,
    0x061c29a7,
    0x061d0006,
    0x061d09a7,
    0x061de006,
    0x061de9a7,
    0x061ec006,
    0x061ec9a7,
    0x061fa006,
    0x061fa9a7,
    0x06208006,
    0x062089a7,
    0x06216006,
    0x062169a7,
    0x06224006,
    0x062249a7,
    0x06232006,
    0x062329a7,
    0x06240006,
    0x062409a7,
    0x0624e006,
    0x0624e9a7,
    0x0625c006,
    0x0625c9a7,
    0x0626a006,
    0x0626a9a7,
    0x06278006,
    0x062789a7,
    0x06286006,
    0x062869a7,
    0x06294006,
    0x062949a7,
    0x062a2006,
    0x062a29a7,
    0x062b0006,
    0x062b09a7,
    0x062be006,
    0x062be9a7,
    0x062cc006,
    0x062cc9a7,
    0x062da006,
    0x062da9a7,
    0x062e8006,
    0x062e89a7,
    0x062f6006,
    0x062f69a7,
    0x06304006,
    0x063049a7,
    0x06312006,
    0x063129a7,
    0x06320006,
    0x063209a7,
    0x0632e006,
    0x0632e9a7,
    0x0633c006,
    0x0633c9a7,
    0x0634a006,
    0x0634a9a7,
    0x06358006,
    0x063589a7,
    0x06366006,
    0x063669a7,
    0x06374006,
    0x063749a7,
    0x06382006,
    0x063829a7,
    0x06390006,
    0x063909a7,
    0x0639e006,
    0x0639e9a7,
    0x063ac006,
    0x063ac9a7,
    0x063ba006,
    0x063ba9a7,
    0x063c8006,
    0x063c89a7,
    0x063d6006,
    0x063d69a7,
    0x063e4006,
    0x063e49a7,
    0x063f2006,
    0x063f29a7,
    0x06400006,
    0x064009a7,
    0x0640e006,
    0x0640e9a7,
    0x0641c006,
    0x0641c9a7,
    0x0642a006,
    0x0642a9a7,
    0x06438006,
    0x064389a7,
    0x06446006,
    0x064469a7,
    0x06454006,
    0x064549a7,
    0x06462006,
    0x064629a7,
    0x06470006,
    0x064709a7,
    0x0647e006,
    0x0647e9a7,
    0x0648c006,
    0x0648c9a7,
    0x0649a006,
    0x0649a9a7,
    0x064a8006,
    0x064a89a7,
    0x064b6006,
    0x064b69a7,
    0x064c4006,
    0x064c49a7,
    0x064d2006,
    0x064d29a7,
    0x064e0006,
    0x064e09a7,
    0x064ee006,
    0x064ee9a7,
    0x064fc006,
    0x064fc9a7,
    0x0650a006,
    0x0650a9a7,
    0x06518006,
    0x065189a7,
    0x06526006,
    0x065269a7,
    0x06534006,
    0x065349a7,
    0x06542006,
    0x065429a7,
    0x06550006,
    0x065509a7,
    0x0655e006,
    0x0655e9a7,
    0x0656c006,
    0x0656c9a7,
    0x0657a006,
    0x0657a9a7,
    0x06588006,
    0x065889a7,
    0x06596006,
    0x065969a7,
    0x065a4006,
    0x065a49a7,
    0x065b2006,
    0x065b29a7,
    0x065c0006,
    0x065c09a7,
    0x065ce006,
    0x065ce9a7,
    0x065dc006,
    0x065dc9a7,
    0x065ea006,
    0x065ea9a7,
    0x065f8006,
    0x065f89a7,
    0x06606006,
    0x066069a7,
    0x06614006,
    0x066149a7,
    0x06622006,
    0x066229a7,
    0x06630006,
    0x066309a7,
    0x0663e006,
    0x0663e9a7,
    0x0664c006,
    0x0664c9a7,
    0x0665a006,
    0x0665a9a7,
    0x06668006,
    0x066689a7,
    0x06676006,
    0x066769a7,
    0x06684006,
    0x066849a7,
    0x06692006,
    0x066929a7,
    0x066a0006,
    0x066a09a7,
    0x066ae006,
    0x066ae9a7,
    0x066bc006,
    0x066bc9a7,
    0x066ca006,
    0x066ca9a7,
    0x066d8006,
    0x066d89a7,
    0x066e6006,
    0x066e69a7,
    0x066f4006,
    0x066f49a7,
    0x06702006,
    0x067029a7,
    0x06710006,
    0x067109a7,
    0x0671e006,
    0x0671e9a7,
    0x0672c006,
    0x0672c9a7,
    0x0673a006,
    0x0673a9a7,
    0x06748006,
    0x067489a7,
    0x06756006,
    0x067569a7,
    0x06764006,
    0x067649a7,
    0x06772006,
    0x067729a7,
    0x06780006,
    0x067809a7,
    0x0678e006,
    0x0678e9a7,
    0x0679c006,
    0x0679c9a7,
    0x067aa006,
    0x067aa9a7,
    0x067b8006,
    0x067b89a7,
    0x067c6006,
    0x067c69a7,
    0x067d4006,
    0x067d49a7,
    0x067e2006,
    0x067e29a7,
    0x067f0006,
    0x067f09a7,
    0x067fe006,
    0x067fe9a7,
    0x0680c006,
    0x0680c9a7,
    0x0681a006,
    0x0681a9a7,
    0x06828006,
    0x068289a7,
    0x06836006,
    0x068369a7,
    0x06844006,
    0x068449a7,
    0x06852006,
    0x068529a7,
    0x06860006,
    0x068609a7,
    0x0686e006,
    0x0686e9a7,
    0x0687c006,
    0x0687c9a7,
    0x0688a006,
    0x0688a9a7,
    0x06898006,
    0x068989a7,
    0x068a6006,
    0x068a69a7,
    0x068b4006,
    0x068b49a7,
    0x068c2006,
    0x068c29a7,
    0x068d0006,
    0x068d09a7,
    0x068de006,
    0x068de9a7,
    0x068ec006,
    0x068ec9a7,
    0x068fa006,
    0x068fa9a7,
    0x06908006,
    0x069089a7,
    0x06916006,
    0x069169a7,
    0x06924006,
    0x069249a7,
    0x06932006,
    0x069329a7,
    0x06940006,
    0x069409a7,
    0x0694e006,
    0x0694e9a7,
    0x0695c006,
    0x0695c9a7,
    0x0696a006,
    0x0696a9a7,
    0x06978006,
    0x069789a7,
    0x06986006,
    0x069869a7,
    0x06994006,
    0x069949a7,
    0x069a2006,
    0x069a29a7,
    0x069b0006,
    0x069b09a7,
    0x069be006,
    0x069be9a7,
    0x069cc006,
    0x069cc9a7,
    0x069da006,
    0x069da9a7,
    0x069e8006,
    0x069e89a7,
    0x069f6006,
    0x069f69a7,
    0x06a04006,
    0x06a049a7,
    0x06a12006,
    0x06a129a7,
    0x06a20006,
    0x06a209a7,
    0x06a2e006,
    0x06a2e9a7,
    0x06a3c006,
    0x06a3c9a7,
    0x06a4a006,
    0x06a4a9a7,
    0x06a58006,
    0x06a589a7,
    0x06a66006,
    0x06a669a7,
    0x06a74006,
    0x06a749a7,
    0x06a82006,
    0x06a829a7,
    0x06a90006,
    0x06a909a7,
    0x06a9e006,
    0x06a9e9a7,
    0x06aac006,
    0x06aac9a7,
    0x06aba006,
    0x06aba9a7,
    0x06ac8006,
    0x06ac89a7,
    0x06ad6006,
    0x06ad69a7,
    0x06ae4006,
    0x06ae49a7,
    0x06af2006,
    0x06af29a7,
    0x06b00006,
    0x06b009a7,
    0x06b0e006,
    0x06b0e9a7,
    0x06b1c006,
    0x06b1c9a7,
    0x06b2a006,
    0x06b2a9a7,
    0x06b38006,
    0x06b389a7,
    0x06b46006,
    0x06b469a7,
    0x06b54006,
    0x06b549a7,
    0x06b62006,
    0x06b629a7,
    0x06b70006,
    0x06b709a7,
    0x06b7e006,
    0x06b7e9a7,
    0x06b8c006,
    0x06b8c9a7,
    0x06b9a006,
    0x06b9a9a7,
    0x06ba8006,
    0x06ba89a7,
    0x06bb6006,
    0x06bb69a7,
    0x06bc4006,
    0x06bc49a7,
    0x06bd816c,
    0x06be5b0b,
    0x07d8f002,
    0x07f000f2,
    0x07f100f2,
    0x07f7f801,
    0x07fcf012,
    0x07ff80b1,
    0x080fe802,
    0x08170002,
    0x081bb042,
    0x08500822,
    0x08502812,
    0x08506032,
    0x0851c022,
    0x0851f802,
    0x08572812,
    0x08692032,
    0x08755812,
    0x0877e822,
    0x087a30a2,
    0x087c1032,
    0x0880000a,
    0x08800802,
    0x0880100a,
    0x0881c0e2,
    0x08838002,
    0x08839812,
    0x0883f822,
    0x0884100a,
    0x0885802a,
    0x08859832,
    0x0885b81a,
    0x0885c812,
    0x0885e808,
    0x08861002,
    0x08866808,
    0x08880022,
    0x08893842,
    0x0889600a,
    0x08896872,
    0x088a281a,
    0x088b9802,
    0x088c0012,
    0x088c100a,
    0x088d982a,
    0x088db082,
    0x088df81a,
    0x088e1018,
    0x088e4832,
    0x088e700a,
    0x088e7802,
    0x0891602a,
    0x08917822,
    0x0891901a,
    0x0891a002,
    0x0891a80a,
    0x0891b012,
    0x0891f002,
    0x08920802,
    0x0896f802,
    0x0897002a,
    0x08971872,
    0x08980012,
    0x0898101a,
    0x0899d812,
    0x0899f002,
    0x0899f80a,
    0x089a0002,
    0x089a083a,
    0x089a381a,
    0x089a582a,
    0x089ab802,
    0x089b101a,
    0x089b3062,
    0x089b8042,
    0x08a1a82a,
    0x08a1c072,
    0x08a2001a,
    0x08a21022,
    0x08a2280a,
    0x08a23002,
    0x08a2f002,
    0x08a58002,
    0x08a5881a,
    0x08a59852,
    0x08a5c80a,
    0x08a5d002,
    0x08a5d81a,
    0x08a5e802,
    0x08a5f00a,
    0x08a5f812,
    0x08a6080a,
    0x08a61012,
    0x08ad7802,
    0x08ad801a,
    0x08ad9032,
    0x08adc03a,
    0x08ade012,
    0x08adf00a,
    0x08adf812,
    0x08aee012,
    0x08b1802a,
    0x08b19872,
    0x08b1d81a,
    0x08b1e802,
    0x08b1f00a,
    0x08b1f812,
    0x08b55802,
    0x08b5600a,
    0x08b56802,
    0x08b5701a,
    0x08b58052,
    0x08b5b00a,
    0x08b5b802,
    0x08b8e822,
    0x08b91032,
    0x08b9300a,
    0x08b93842,
    0x08c1602a,
    0x08c17882,
    0x08c1c00a,
    0x08c1c812,
    0x08c98002,
    0x08c9884a,
    0x08c9b81a,
    0x08c9d812,
    0x08c9e80a,
    0x08c9f002,
    0x08c9f808,
    0x08ca000a,
    0x08ca0808,
    0x08ca100a,
    0x08ca1802,
    0x08ce882a,
    0x08cea032,
    0x08ced012,
    0x08cee03a,
    0x08cf0002,
    0x08cf200a,
    0x08d00892,
    0x08d19852,
    0x08d1c80a,
    0x08d1d008,
    0x08d1d832,
    0x08d23802,
    0x08d28852,
    0x08d2b81a,
    0x08d2c822,
    0x08d42058,
    0x08d450c2,
    0x08d4b80a,
    0x08d4c012,
    0x08e1780a,
    0x08e18062,
    0x08e1c052,
    0x08e1f00a,
    0x08e1f802,
    0x08e49152,
    0x08e5480a,
    0x08e55062,
    0x08e5880a,
    0x08e59012,
    0x08e5a00a,
    0x08e5a812,
    0x08e98852,
    0x08e9d002,
    0x08e9e012,
    0x08e9f862,
    0x08ea3008,
    0x08ea3802,
    0x08ec504a,
    0x08ec8012,
    0x08ec981a,
    0x08eca802,
    0x08ecb00a,
    0x08ecb802,
    0x08f79812,
    0x08f7a81a,
    0x08f80012,
    0x08f81008,
    0x08f8180a,
    0x08f9a01a,
    0x08f9b042,
    0x08f9f01a,
    0x08fa0002,
    0x08fa080a,
    0x08fa1002,
    0x09a180f1,
    0x09a20002,
    0x09a238e2,
    0x0b578042,
    0x0b598062,
    0x0b7a7802,
    0x0b7a8b6a,
    0x0b7c7832,
    0x0b7f2002,
    0x0b7f801a,
    0x0de4e812,
    0x0de50031,
    0x0e7802d2,
    0x0e798162,
    0x0e8b2802,
    0x0e8b300a,
    0x0e8b3822,
    0x0e8b680a,
    0x0e8b7042,
    0x0e8b9871,
    0x0e8bd872,
    0x0e8c2862,
    0x0e8d5032,
    0x0e921022,
    0x0ed00362,
    0x0ed1db12,
    0x0ed3a802,
    0x0ed42002,
    0x0ed4d842,
    0x0ed508e2,
    0x0f000062,
    0x0f004102,
    0x0f00d862,
    0x0f011812,
    0x0f013042,
    0x0f047802,
    0x0f098062,
    0x0f157002,
    0x0f176032,
    0x0f276032,
    0x0f468062,
    0x0f4a2062,
    0x0f8007f3,
    0x0f8407f3,
    0x0f886823,
    0x0f897803,
    0x0f8b6053,
    0x0f8bf013,
    0x0f8c7003,
    0x0f8c8893,
    0x0f8d6b83,
    0x0f8f3199,
    0x0f9008e3,
    0x0f90d003,
    0x0f917803,
    0x0f919083,
    0x0f91e033,
    0x0f924ff3,
    0x0f964ff3,
    0x0f9a4ff3,
    0x0f9e4b13,
    0x0f9fd842,
    0x0fa007f3,
    0x0fa407f3,
    0x0fa803d3,
    0x0faa37f3,
    0x0fae37f3,
    0x0fb23093,
    0x0fb407f3,
    0x0fbba0b3,
    0x0fbeaaa3,
    0x0fc06033,
    0x0fc24073,
    0x0fc2d053,
    0x0fc44073,
    0x0fc57513,
    0x0fc862e3,
    0x0fc9e093,
    0x0fca3ff3,
    0x0fce3ff3,
    0x0fd23ff3,
    0x0fd63b83,
    0x0fe007f3,
    0x0fe407f3,
    0x0fe807f3,
    0x0fec07f3,
    0x0ff007f3,
    0x0ff407f3,
    0x0ff807f3,
    0x0ffc07d3,
    0x700001f1,
    0x700105f2,
    0x700407f1,
    0x700807f2,
    0x700c06f2,
    0x700f87f1,
    0x701387f1,
    0x701787f1,
    0x701b87f1,
    0x701f87f1,
    0x702387f1,
    0x702787f1,
    0x702b87f1,
    0x702f87f1,
    0x703387f1,
    0x703787f1,
    0x703b87f1,
    0x703f87f1,
    0x704387f1,
    0x704787f1,
    0x704b87f1,
    0x704f87f1,
    0x705387f1,
    0x705787f1,
    0x705b87f1,
    0x705f87f1,
    0x706387f1,
    0x706787f1,
    0x706b87f1,
    0x706f87f1,
    0x707387f1,
    0x707787f1,
    0x707b87f1,
    0x707f80f1};


[[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr __property __get_property(const char32_t __code_point) noexcept {
# 1643 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__format/extended_grapheme_cluster_table.h" 3
  ptrdiff_t __i = std::ranges::upper_bound(__entries, (__code_point << 11) | 0x7ffu) - __entries;
  if (__i == 0)
    return __property::__none;

  --__i;
  uint32_t __upper_bound = (__entries[__i] >> 11) + ((__entries[__i] >> 4) & 0x7f);
  if (__code_point <= __upper_bound)
    return static_cast<__property>(__entries[__i] & 0xf);

  return __property::__none;
}

}



}}
# 18 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__format/unicode.h" 2 3
# 24 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__format/unicode.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {



namespace __unicode {
# 41 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__format/unicode.h" 3
struct __consume_result {


  char32_t __code_point : 31;

  enum : char32_t {

    __ok = 0,

    __error = 1
  } __status : 1 {__ok};
};
static_assert(sizeof(__consume_result) == sizeof(char32_t));
# 70 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__format/unicode.h" 3
inline constexpr char32_t __replacement_character = U'\ufffd';






inline constexpr __consume_result __consume_result_error{__replacement_character, __consume_result::__error};

[[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr bool __is_high_surrogate(char32_t __value) {
  return __value >= 0xd800 && __value <= 0xdbff;
}

[[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr bool __is_low_surrogate(char32_t __value) {
  return __value >= 0xdc00 && __value <= 0xdfff;
}


[[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) inline constexpr bool __is_surrogate(char32_t __value) {
  return __value >= 0xd800 && __value <= 0xdfff;
}


[[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) inline constexpr bool __is_code_point(char32_t __value) {
  return __value <= 0x10ffff;
}


[[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) inline constexpr bool __is_scalar_value(char32_t __value) {
  return __unicode::__is_code_point(__value) && !__unicode::__is_surrogate(__value);
}

template <contiguous_iterator _Iterator>
  requires same_as<iter_value_t<_Iterator>, char>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr bool __is_continuation(_Iterator __char, int __count) {
  do {
    if ((*__char & 0b1100'0000) != 0b1000'0000)
      return false;
    --__count;
    ++__char;
  } while (__count);
  return true;
}





template <class _CharT>
class __code_point_view;


template <>
class __code_point_view<char> {
  using _Iterator = basic_string_view<char>::const_iterator;

public:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr explicit __code_point_view(_Iterator __first, _Iterator __last)
      : __first_(__first), __last_(__last) {}

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr bool __at_end() const noexcept { return __first_ == __last_; }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr _Iterator __position() const noexcept { return __first_; }
# 155 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__format/unicode.h" 3
  [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr __consume_result __consume() noexcept {
    ((void)0);




    switch (std::countl_one(static_cast<unsigned char>(*__first_))) {
    case 0:
      return {static_cast<unsigned char>(*__first_++)};

    case 2: {
      if (__last_ - __first_ < 2 || !__unicode::__is_continuation(__first_ + 1, 1)) [[unlikely]]
        break;

      char32_t __value = static_cast<unsigned char>(*__first_++) & 0x1f;
      __value <<= 6;
      __value |= static_cast<unsigned char>(*__first_++) & 0x3f;


      if (__value < 0x0080) [[unlikely]]
        return __consume_result_error;

      return {__value};
    }

    case 3: {
      if (__last_ - __first_ < 3 || !__unicode::__is_continuation(__first_ + 1, 2)) [[unlikely]]
        break;

      char32_t __value = static_cast<unsigned char>(*__first_++) & 0x0f;
      __value <<= 6;
      __value |= static_cast<unsigned char>(*__first_++) & 0x3f;
      __value <<= 6;
      __value |= static_cast<unsigned char>(*__first_++) & 0x3f;


      if (__value < 0x0800) [[unlikely]]
        return __consume_result_error;


      if (__unicode::__is_surrogate(__value)) [[unlikely]]
        return __consume_result_error;

      return {__value};
    }

    case 4: {
      if (__last_ - __first_ < 4 || !__unicode::__is_continuation(__first_ + 1, 3)) [[unlikely]]
        break;

      char32_t __value = static_cast<unsigned char>(*__first_++) & 0x07;
      __value <<= 6;
      __value |= static_cast<unsigned char>(*__first_++) & 0x3f;
      __value <<= 6;
      __value |= static_cast<unsigned char>(*__first_++) & 0x3f;
      __value <<= 6;
      __value |= static_cast<unsigned char>(*__first_++) & 0x3f;


      if (__value < 0x10000) [[unlikely]]
        return __consume_result_error;


      if (!__unicode::__is_code_point(__value)) [[unlikely]]
        return __consume_result_error;

      return {__value};
    }
    }



    ++__first_;
    return __consume_result_error;
  }

private:
  _Iterator __first_;
  _Iterator __last_;
};


__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr bool __is_surrogate_pair_high(wchar_t __value) {
  return __value >= 0xd800 && __value <= 0xdbff;
}

__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr bool __is_surrogate_pair_low(wchar_t __value) {
  return __value >= 0xdc00 && __value <= 0xdfff;
}




template <>
class __code_point_view<wchar_t> {
  using _Iterator = typename basic_string_view<wchar_t>::const_iterator;

public:
  static_assert(sizeof(wchar_t) == 2 || sizeof(wchar_t) == 4, "sizeof(wchar_t) has a not implemented value");

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr explicit __code_point_view(_Iterator __first, _Iterator __last)
      : __first_(__first), __last_(__last) {}

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr _Iterator __position() const noexcept { return __first_; }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr bool __at_end() const noexcept { return __first_ == __last_; }

  [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr __consume_result __consume() noexcept {
    ((void)0);

    char32_t __value = static_cast<char32_t>(*__first_++);
    if constexpr (sizeof(wchar_t) == 2) {
      if (__unicode::__is_low_surrogate(__value)) [[unlikely]]
        return __consume_result_error;

      if (__unicode::__is_high_surrogate(__value)) {
        if (__first_ == __last_ || !__unicode::__is_low_surrogate(static_cast<char32_t>(*__first_))) [[unlikely]]
          return __consume_result_error;

        __value -= 0xd800;
        __value <<= 10;
        __value += static_cast<char32_t>(*__first_++) - 0xdc00;
        __value += 0x10000;

        if (!__unicode::__is_code_point(__value)) [[unlikely]]
          return __consume_result_error;
      }
    } else {
      if (!__unicode::__is_scalar_value(__value)) [[unlikely]]
        return __consume_result_error;
    }

    return {__value};
  }

private:
  _Iterator __first_;
  _Iterator __last_;
};


__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr bool __at_extended_grapheme_cluster_break(
    bool& __ri_break_allowed,
    bool __has_extened_pictographic,
    __extended_grapheme_custer_property_boundary::__property __prev,
    __extended_grapheme_custer_property_boundary::__property __next) {
  using __extended_grapheme_custer_property_boundary::__property;

  __has_extened_pictographic |= __prev == __property::__Extended_Pictographic;





  ((void)0);
  ((void)0);


  if (__prev == __property::__CR && __next == __property::__LF)
    return false;

  if (__prev == __property::__Control || __prev == __property::__CR || __prev == __property::__LF)
    return true;

  if (__next == __property::__Control || __next == __property::__CR || __next == __property::__LF)
    return true;


  if (__prev == __property::__L &&
      (__next == __property::__L || __next == __property::__V || __next == __property::__LV ||
       __next == __property::__LVT))
    return false;

  if ((__prev == __property::__LV || __prev == __property::__V) &&
      (__next == __property::__V || __next == __property::__T))
    return false;

  if ((__prev == __property::__LVT || __prev == __property::__T) && __next == __property::__T)
    return false;


  if (__next == __property::__Extend || __next == __property::__ZWJ)
    return false;


  if (__next == __property::__SpacingMark)
    return false;

  if (__prev == __property::__Prepend)
    return false;
# 358 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__format/unicode.h" 3
  if (__has_extened_pictographic && __prev == __property::__ZWJ && __next == __property::__Extended_Pictographic)
    return false;






  if (__prev == __property::__Regional_Indicator && __next == __property::__Regional_Indicator) {
    __ri_break_allowed = !__ri_break_allowed;
    return __ri_break_allowed;
  }


  return true;
}






template <class _CharT>
class __extended_grapheme_cluster_view {
  using _Iterator = typename basic_string_view<_CharT>::const_iterator;

public:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr explicit __extended_grapheme_cluster_view(_Iterator __first, _Iterator __last)
      : __code_point_view_(__first, __last),
        __next_code_point_(__code_point_view_.__consume().__code_point),
        __next_prop_(__extended_grapheme_custer_property_boundary::__get_property(__next_code_point_)) {}

  struct __cluster {




    char32_t __code_point_;





    _Iterator __last_;
  };

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr __cluster __consume() {
    ((void)0);



    char32_t __code_point = __next_code_point_;
    if (!__code_point_view_.__at_end())
      return {__code_point, __get_break()};

    __next_prop_ = __extended_grapheme_custer_property_boundary::__property::__eot;
    return {__code_point, __code_point_view_.__position()};
  }

private:
  __code_point_view<_CharT> __code_point_view_;

  char32_t __next_code_point_;
  __extended_grapheme_custer_property_boundary::__property __next_prop_;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr _Iterator __get_break() {
    bool __ri_break_allowed = true;
    bool __has_extened_pictographic = false;
    while (true) {
      _Iterator __result = __code_point_view_.__position();
      __extended_grapheme_custer_property_boundary::__property __prev = __next_prop_;
      if (__code_point_view_.__at_end()) {
        __next_prop_ = __extended_grapheme_custer_property_boundary::__property::__eot;
        return __result;
      }
      __next_code_point_ = __code_point_view_.__consume().__code_point;
      __next_prop_ = __extended_grapheme_custer_property_boundary::__get_property(__next_code_point_);

      __has_extened_pictographic |=
          __prev == __extended_grapheme_custer_property_boundary::__property::__Extended_Pictographic;

      if (__at_extended_grapheme_cluster_break(__ri_break_allowed, __has_extened_pictographic, __prev, __next_prop_))
        return __result;
    }
  }
};

template <contiguous_iterator _Iterator>
__extended_grapheme_cluster_view(_Iterator, _Iterator) -> __extended_grapheme_cluster_view<iter_value_t<_Iterator>>;
# 475 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__format/unicode.h" 3
}



}}
# 30 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__format/parser_std_format_spec.h" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__format/width_estimation_table.h" 1 3
# 71 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__format/width_estimation_table.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {



namespace __width_estimation_table {
# 122 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__format/width_estimation_table.h" 3
inline constexpr uint32_t __entries[108] = {
    0x0440005f ,
    0x08c68001 ,
    0x08ca4001 ,
    0x08fa4003 ,
    0x08fc0000 ,
    0x08fcc000 ,
    0x097f4001 ,
    0x09850001 ,
    0x0992000b ,
    0x099fc000 ,
    0x09a4c000 ,
    0x09a84000 ,
    0x09aa8001 ,
    0x09af4001 ,
    0x09b10001 ,
    0x09b38000 ,
    0x09b50000 ,
    0x09ba8000 ,
    0x09bc8001 ,
    0x09bd4000 ,
    0x09be8000 ,
    0x09bf4000 ,
    0x09c14000 ,
    0x09c28001 ,
    0x09ca0000 ,
    0x09d30000 ,
    0x09d38000 ,
    0x09d4c002 ,
    0x09d5c000 ,
    0x09e54002 ,
    0x09ec0000 ,
    0x09efc000 ,
    0x0ac6c001 ,
    0x0ad40000 ,
    0x0ad54000 ,
    0x0ba00019 ,
    0x0ba6c058 ,
    0x0bc000d5 ,
    0x0bfc000b ,
    0x0c00003e ,
    0x0c104055 ,
    0x0c264066 ,
    0x0c41402a ,
    0x0c4c405d ,
    0x0c640053 ,
    0x0c7c002e ,
    0x0c880027 ,
    0x0c943fff ,
    0x1c94323c ,
    0x29240036 ,
    0x2a58001c ,
    0x2b002ba3 ,
    0x3e4001ff ,
    0x3f840009 ,
    0x3f8c0022 ,
    0x3f950012 ,
    0x3f9a0003 ,
    0x3fc0405f ,
    0x3ff80006 ,
    0x5bf80004 ,
    0x5bfc0001 ,
    0x5c0017f7 ,
    0x620004d5 ,
    0x63400008 ,
    0x6bfc0003 ,
    0x6bfd4006 ,
    0x6bff4001 ,
    0x6c000122 ,
    0x6c4c8000 ,
    0x6c540002 ,
    0x6c554000 ,
    0x6c590003 ,
    0x6c5c018b ,
    0x7c010000 ,
    0x7c33c000 ,
    0x7c638000 ,
    0x7c644009 ,
    0x7c800002 ,
    0x7c84002b ,
    0x7c900008 ,
    0x7c940001 ,
    0x7c980005 ,
    0x7cc0034f ,
    0x7da00045 ,
    0x7db30000 ,
    0x7db40002 ,
    0x7db54002 ,
    0x7db70003 ,
    0x7dbac001 ,
    0x7dbd0008 ,
    0x7df8000b ,
    0x7dfc0000 ,
    0x7e4000ff ,
    0x7e9c000c ,
    0x7ea00008 ,
    0x7ea4002d ,
    0x7eafc006 ,
    0x7eb3800d ,
    0x7eb80008 ,
    0x7ebc0008 ,
    0x80003fff ,
    0x90003fff ,
    0xa0003fff ,
    0xb0003ffd ,
    0xc0003fff ,
    0xd0003fff ,
    0xe0003fff ,
    0xf0003ffd };






inline constexpr uint32_t __table_upper_bound = 0x0003fffd;




[[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr int __estimated_width(const char32_t __code_point) noexcept {


  if (__code_point > __table_upper_bound) [[unlikely]]
    return 1;






  if (__code_point < (__entries[0] >> 14))
    return 1;

  ptrdiff_t __i = std::ranges::upper_bound(__entries, (__code_point << 14) | 0x3fffu) - __entries;
  if (__i == 0)
    return 1;

  --__i;
  uint32_t __upper_bound = (__entries[__i] >> 14) + (__entries[__i] & 0x3fffu);
  return 1 + (__code_point <= __upper_bound);
}

}



}}
# 31 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__format/parser_std_format_spec.h" 2 3








# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/string" 1 3
# 577 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/string" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__ios/fpos.h" 1 3
# 18 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__ios/fpos.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _StateT>
class fpos {
private:
  _StateT __st_;
  streamoff __off_;

public:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) fpos(streamoff __off = streamoff()) : __st_(), __off_(__off) {}

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) operator streamoff() const { return __off_; }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) _StateT state() const { return __st_; }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) void state(_StateT __st) { __st_ = __st; }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) fpos& operator+=(streamoff __off) {
    __off_ += __off;
    return *this;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) fpos operator+(streamoff __off) const {
    fpos __t(*this);
    __t += __off;
    return __t;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) fpos& operator-=(streamoff __off) {
    __off_ -= __off;
    return *this;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) fpos operator-(streamoff __off) const {
    fpos __t(*this);
    __t -= __off;
    return __t;
  }
};

template <class _StateT>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
streamoff operator-(const fpos<_StateT>& __x, const fpos<_StateT>& __y) {
  return streamoff(__x) - streamoff(__y);
}

template <class _StateT>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
bool operator==(const fpos<_StateT>& __x, const fpos<_StateT>& __y) {
  return streamoff(__x) == streamoff(__y);
}

template <class _StateT>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
bool operator!=(const fpos<_StateT>& __x, const fpos<_StateT>& __y) {
  return streamoff(__x) != streamoff(__y);
}

}}
# 578 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/string" 2 3






# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__memory/allocator.h" 1 3
# 27 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__memory/allocator.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Tp> class allocator;
# 75 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__memory/allocator.h" 3
template <bool _Cond, class _Unique>
struct __non_trivial_if { };

template <class _Unique>
struct __non_trivial_if<true, _Unique> {
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    constexpr __non_trivial_if() noexcept { }
};






template <class _Tp>
class allocator
    : private __non_trivial_if<!is_void<_Tp>::value, allocator<_Tp> >
{
    static_assert(!is_volatile<_Tp>::value, "std::allocator does not support volatile types");
public:
    typedef size_t size_type;
    typedef ptrdiff_t difference_type;
    typedef _Tp value_type;
    typedef true_type propagate_on_container_move_assignment;
    typedef true_type is_always_equal;

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr allocator() noexcept = default;

    template <class _Up>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    allocator(const allocator<_Up>&) noexcept { }

    [[__nodiscard__]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    _Tp* allocate(size_t __n) {
        if (__n > allocator_traits<allocator>::max_size(*this))
            __throw_bad_array_new_length();
        if (__libcpp_is_constant_evaluated()) {
            return static_cast<_Tp*>(::operator new(__n * sizeof(_Tp)));
        } else {
            return static_cast<_Tp*>(std::__libcpp_allocate(__n * sizeof(_Tp), alignof(_Tp)));
        }
    }


    [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    allocation_result<_Tp*> allocate_at_least(size_t __n) {
        return {allocate(__n), __n};
    }


    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    void deallocate(_Tp* __p, size_t __n) noexcept {
        if (__libcpp_is_constant_evaluated()) {
            ::operator delete(__p);
        } else {
            std::__libcpp_deallocate((void*)__p, __n * sizeof(_Tp), alignof(_Tp));
        }
    }
# 175 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__memory/allocator.h" 3
};

template <class _Tp>
class allocator<const _Tp>
    : private __non_trivial_if<!is_void<_Tp>::value, allocator<const _Tp> >
{
    static_assert(!is_volatile<_Tp>::value, "std::allocator does not support volatile types");
public:
    typedef size_t size_type;
    typedef ptrdiff_t difference_type;
    typedef const _Tp value_type;
    typedef true_type propagate_on_container_move_assignment;
    typedef true_type is_always_equal;

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr allocator() noexcept = default;

    template <class _Up>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    allocator(const allocator<_Up>&) noexcept { }

    [[__nodiscard__]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    const _Tp* allocate(size_t __n) {
        if (__n > allocator_traits<allocator>::max_size(*this))
            __throw_bad_array_new_length();
        if (__libcpp_is_constant_evaluated()) {
            return static_cast<const _Tp*>(::operator new(__n * sizeof(_Tp)));
        } else {
            return static_cast<const _Tp*>(std::__libcpp_allocate(__n * sizeof(_Tp), alignof(_Tp)));
        }
    }


    [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    allocation_result<const _Tp*> allocate_at_least(size_t __n) {
        return {allocate(__n), __n};
    }


    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    void deallocate(const _Tp* __p, size_t __n) {
        if (__libcpp_is_constant_evaluated()) {
            ::operator delete(const_cast<_Tp*>(__p));
        } else {
            std::__libcpp_deallocate((void*) const_cast<_Tp *>(__p), __n * sizeof(_Tp), alignof(_Tp));
        }
    }
# 259 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__memory/allocator.h" 3
};

template <class _Tp, class _Up>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
bool operator==(const allocator<_Tp>&, const allocator<_Up>&) noexcept {return true;}
# 273 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__memory/allocator.h" 3
}}
# 585 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/string" 2 3




# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__memory/swap_allocator.h" 1 3
# 20 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__memory/swap_allocator.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <typename _Alloc>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr void __swap_allocator(_Alloc& __a1, _Alloc& __a2, true_type)

    noexcept



{
  using std::swap;
  swap(__a1, __a2);
}

template <typename _Alloc>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr void
__swap_allocator(_Alloc&, _Alloc&, false_type) noexcept {}

template <typename _Alloc>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr void __swap_allocator(_Alloc& __a1, _Alloc& __a2)

    noexcept



{
  std::__swap_allocator(
      __a1, __a2, integral_constant<bool, allocator_traits<_Alloc>::propagate_on_container_swap::value>());
}

}}
# 590 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/string" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__memory_resource/polymorphic_allocator.h" 1 3
# 15 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__memory_resource/polymorphic_allocator.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__memory_resource/memory_resource.h" 1 3
# 19 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__memory_resource/memory_resource.h" 3




namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

namespace pmr {



class __attribute__((__visibility__("default"))) memory_resource {
  static const size_t __max_align = alignof(max_align_t);

public:
  virtual ~memory_resource();

  [[__nodiscard__]]
  [[using __gnu__: __returns_nonnull__, __alloc_size__(2), __alloc_align__(3)]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) void*
  allocate(size_t __bytes, size_t __align = __max_align) {
    return do_allocate(__bytes, __align);
  }

  [[__gnu__::__nonnull__]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) void
  deallocate(void* __p, size_t __bytes, size_t __align = __max_align) {
    do_deallocate(__p, __bytes, __align);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) bool is_equal(const memory_resource& __other) const noexcept { return do_is_equal(__other); }

private:
  virtual void* do_allocate(size_t, size_t) = 0;
  virtual void do_deallocate(void*, size_t, size_t) = 0;
  virtual bool do_is_equal(memory_resource const&) const noexcept = 0;
};



inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) bool
operator==(const memory_resource& __lhs, const memory_resource& __rhs) noexcept {
  return &__lhs == &__rhs || __lhs.is_equal(__rhs);
}
# 72 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__memory_resource/memory_resource.h" 3
[[__gnu__::__returns_nonnull__]] __attribute__((__visibility__("default"))) memory_resource*
get_default_resource() noexcept;

[[__gnu__::__returns_nonnull__]] __attribute__((__visibility__("default"))) memory_resource*
set_default_resource(memory_resource*) noexcept;

[[using __gnu__: __returns_nonnull__, __const__]] __attribute__((__visibility__("default"))) memory_resource*
new_delete_resource() noexcept;

[[using __gnu__: __returns_nonnull__, __const__]] __attribute__((__visibility__("default"))) memory_resource*
null_memory_resource() noexcept;

}

}}
# 16 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__memory_resource/polymorphic_allocator.h" 2 3
# 25 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__memory_resource/polymorphic_allocator.h" 3



# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__undef_macros" 1 3
# 29 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__memory_resource/polymorphic_allocator.h" 2 3



namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

namespace pmr {



template <class _ValueType

          = byte

          >
class polymorphic_allocator {

public:
  using value_type = _ValueType;



  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) polymorphic_allocator() noexcept : __res_(std::pmr::get_default_resource()) {}

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) polymorphic_allocator(memory_resource* __r) noexcept : __res_(__r) {}

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) polymorphic_allocator(const polymorphic_allocator&) = default;

  template <class _Tp>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) polymorphic_allocator(const polymorphic_allocator<_Tp>& __other) noexcept
      : __res_(__other.resource()) {}

  polymorphic_allocator& operator=(const polymorphic_allocator&) = delete;



  [[__nodiscard__]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) _ValueType* allocate(size_t __n) {
    if (__n > __max_size()) {
      __throw_bad_array_new_length();
    }
    return static_cast<_ValueType*>(__res_->allocate(__n * sizeof(_ValueType), alignof(_ValueType)));
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) void deallocate(_ValueType* __p, size_t __n) {
    ((void)0);
    __res_->deallocate(__p, __n * sizeof(_ValueType), alignof(_ValueType));
  }



  [[nodiscard]] [[using __gnu__: __alloc_size__(2), __alloc_align__(3)]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) void*
  allocate_bytes(size_t __nbytes, size_t __alignment = alignof(max_align_t)) {
    return __res_->allocate(__nbytes, __alignment);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) void deallocate_bytes(void* __ptr, size_t __nbytes, size_t __alignment = alignof(max_align_t)) {
    __res_->deallocate(__ptr, __nbytes, __alignment);
  }

  template <class _Type>
  [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) _Type* allocate_object(size_t __n = 1) {
    if (numeric_limits<size_t>::max() / sizeof(_Type) < __n)
      std::__throw_bad_array_new_length();
    return static_cast<_Type*>(allocate_bytes(__n * sizeof(_Type), alignof(_Type)));
  }

  template <class _Type>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) void deallocate_object(_Type* __ptr, size_t __n = 1) {
    deallocate_bytes(__ptr, __n * sizeof(_Type), alignof(_Type));
  }

  template <class _Type, class... _CtorArgs>
  [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) _Type* new_object(_CtorArgs&&... __ctor_args) {
    _Type* __ptr = allocate_object<_Type>();
    auto __guard = std::__make_exception_guard([&] { deallocate_object(__ptr); });
    construct(__ptr, std::forward<_CtorArgs>(__ctor_args)...);
    __guard.__complete();
    return __ptr;
  }

  template <class _Type>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) void delete_object(_Type* __ptr) {
    destroy(__ptr);
    deallocate_object(__ptr);
  }



  template <class _Tp, class... _Ts>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) void construct(_Tp* __p, _Ts&&... __args) {
    std::__user_alloc_construct_impl(
        typename __uses_alloc_ctor<_Tp, polymorphic_allocator&, _Ts...>::type(),
        __p,
        *this,
        std::forward<_Ts>(__args)...);
  }

  template <class _T1, class _T2, class... _Args1, class... _Args2>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) void
  construct(pair<_T1, _T2>* __p, piecewise_construct_t, tuple<_Args1...> __x, tuple<_Args2...> __y) {
    ::new ((void*)__p) pair<_T1, _T2>(
        piecewise_construct,
        __transform_tuple(typename __uses_alloc_ctor< _T1, polymorphic_allocator&, _Args1... >::type(),
                          std::move(__x),
                          typename __make_tuple_indices<sizeof...(_Args1)>::type{}),
        __transform_tuple(typename __uses_alloc_ctor< _T2, polymorphic_allocator&, _Args2... >::type(),
                          std::move(__y),
                          typename __make_tuple_indices<sizeof...(_Args2)>::type{}));
  }

  template <class _T1, class _T2>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) void construct(pair<_T1, _T2>* __p) {
    construct(__p, piecewise_construct, tuple<>(), tuple<>());
  }

  template <class _T1, class _T2, class _Up, class _Vp>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) void construct(pair<_T1, _T2>* __p, _Up&& __u, _Vp&& __v) {
    construct(__p,
              piecewise_construct,
              std::forward_as_tuple(std::forward<_Up>(__u)),
              std::forward_as_tuple(std::forward<_Vp>(__v)));
  }

  template <class _T1, class _T2, class _U1, class _U2>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) void construct(pair<_T1, _T2>* __p, const pair<_U1, _U2>& __pr) {
    construct(__p, piecewise_construct, std::forward_as_tuple(__pr.first), std::forward_as_tuple(__pr.second));
  }

  template <class _T1, class _T2, class _U1, class _U2>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) void construct(pair<_T1, _T2>* __p, pair<_U1, _U2>&& __pr) {
    construct(__p,
              piecewise_construct,
              std::forward_as_tuple(std::forward<_U1>(__pr.first)),
              std::forward_as_tuple(std::forward<_U2>(__pr.second)));
  }

  template <class _Tp>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) void destroy(_Tp* __p) {
    __p->~_Tp();
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) polymorphic_allocator select_on_container_copy_construction() const noexcept {
    return polymorphic_allocator();
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) memory_resource* resource() const noexcept { return __res_; }

private:
  template <class... _Args, size_t... _Is>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) tuple<_Args&&...>
  __transform_tuple(integral_constant<int, 0>, tuple<_Args...>&& __t, __tuple_indices<_Is...>) {
    return std::forward_as_tuple(std::get<_Is>(std::move(__t))...);
  }

  template <class... _Args, size_t... _Is>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) tuple<allocator_arg_t const&, polymorphic_allocator&, _Args&&...>
  __transform_tuple(integral_constant<int, 1>, tuple<_Args...>&& __t, __tuple_indices<_Is...>) {
    using _Tup = tuple<allocator_arg_t const&, polymorphic_allocator&, _Args&&...>;
    return _Tup(allocator_arg, *this, std::get<_Is>(std::move(__t))...);
  }

  template <class... _Args, size_t... _Is>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) tuple<_Args&&..., polymorphic_allocator&>
  __transform_tuple(integral_constant<int, 2>, tuple<_Args...>&& __t, __tuple_indices<_Is...>) {
    using _Tup = tuple<_Args&&..., polymorphic_allocator&>;
    return _Tup(std::get<_Is>(std::move(__t))..., *this);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) size_t __max_size() const noexcept {
    return numeric_limits<size_t>::max() / sizeof(value_type);
  }

  memory_resource* __res_;
};



template <class _Tp, class _Up>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) bool
operator==(const polymorphic_allocator<_Tp>& __lhs, const polymorphic_allocator<_Up>& __rhs) noexcept {
  return *__lhs.resource() == *__rhs.resource();
}
# 221 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__memory_resource/polymorphic_allocator.h" 3
}

}}
# 591 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/string" 2 3


# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__ranges/container_compatible_range.h" 1 3
# 19 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__ranges/container_compatible_range.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {



template <class _Range, class _Tp>
concept _ContainerCompatibleRange =
    ranges::input_range<_Range> && convertible_to<ranges::range_reference_t<_Range>, _Tp>;



}}
# 594 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/string" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__ranges/from_range.h" 1 3
# 17 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__ranges/from_range.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {



struct from_range_t {
  explicit from_range_t() = default;
};

inline constexpr from_range_t from_range{};



}}
# 595 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/string" 2 3


# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__string/extern_template_lists.h" 1 3
# 16 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__string/extern_template_lists.h" 3
# 598 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/string" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_allocator.h" 1 3
# 20 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/is_allocator.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <typename _Alloc, typename = void, typename = void>
struct __is_allocator : false_type {};

template <typename _Alloc>
struct __is_allocator<_Alloc,
                      __void_t<typename _Alloc::value_type>,
                      __void_t<decltype(std::declval<_Alloc&>().allocate(size_t(0)))> > : true_type {};

}}
# 599 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/string" 2 3







# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/noexcept_move_assign_container.h" 1 3
# 19 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__type_traits/noexcept_move_assign_container.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <typename _Alloc, typename _Traits = allocator_traits<_Alloc> >
struct __noexcept_move_assign_container
    : public integral_constant<bool,
                               _Traits::propagate_on_container_move_assignment::value

                                   || _Traits::is_always_equal::value



                               > {
};

}}
# 607 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/string" 2 3
# 644 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/string" 3



# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__undef_macros" 1 3
# 648 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/string" 2 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {



template<class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
operator+(const basic_string<_CharT, _Traits, _Allocator>& __x,
          const basic_string<_CharT, _Traits, _Allocator>& __y);

template<class _CharT, class _Traits, class _Allocator>
__attribute__((__visibility__("hidden"))) constexpr
basic_string<_CharT, _Traits, _Allocator>
operator+(const _CharT* __x, const basic_string<_CharT,_Traits,_Allocator>& __y);

template<class _CharT, class _Traits, class _Allocator>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
basic_string<_CharT, _Traits, _Allocator>
operator+(_CharT __x, const basic_string<_CharT,_Traits,_Allocator>& __y);

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
basic_string<_CharT, _Traits, _Allocator>
operator+(const basic_string<_CharT, _Traits, _Allocator>& __x, const _CharT* __y);

template<class _CharT, class _Traits, class _Allocator>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
basic_string<_CharT, _Traits, _Allocator>
operator+(const basic_string<_CharT, _Traits, _Allocator>& __x, _CharT __y);

extern template __attribute__((__visibility__("default"))) string operator+
    <char, char_traits<char>, allocator<char> >(char const*, string const&);

template <class _Iter>
struct __string_is_trivial_iterator : public false_type {};

template <class _Tp>
struct __string_is_trivial_iterator<_Tp*>
    : public is_arithmetic<_Tp> {};

template <class _Iter>
struct __string_is_trivial_iterator<__wrap_iter<_Iter> >
    : public __string_is_trivial_iterator<_Iter> {};

template <class _CharT, class _Traits, class _Tp>
struct __can_be_converted_to_string_view : public _BoolConstant<
      is_convertible<const _Tp&, basic_string_view<_CharT, _Traits> >::value &&
     !is_convertible<const _Tp&, const _CharT*>::value
    > {};

struct __uninitialized_size_tag {};
struct __init_with_sentinel_tag {};

template<class _CharT, class _Traits, class _Allocator>
class basic_string
{
public:
    typedef basic_string __self;
    typedef basic_string_view<_CharT, _Traits> __self_view;
    typedef _Traits traits_type;
    typedef _CharT value_type;
    typedef _Allocator allocator_type;
    typedef allocator_traits<allocator_type> __alloc_traits;
    typedef typename __alloc_traits::size_type size_type;
    typedef typename __alloc_traits::difference_type difference_type;
    typedef value_type& reference;
    typedef const value_type& const_reference;
    typedef typename __alloc_traits::pointer pointer;
    typedef typename __alloc_traits::const_pointer const_pointer;

    static_assert((!is_array<value_type>::value), "Character type of basic_string must not be an array");
    static_assert(( is_standard_layout<value_type>::value), "Character type of basic_string must be standard-layout");
    static_assert(( is_trivial<value_type>::value), "Character type of basic_string must be trivial");
    static_assert(( is_same<_CharT, typename traits_type::char_type>::value),
                  "traits_type::char_type must be the same type as CharT");
    static_assert(( is_same<typename allocator_type::value_type, value_type>::value),
                  "Allocator::value_type must be same type as value_type");

    static_assert(is_same<allocator_type, __rebind_alloc<__alloc_traits, value_type> >::value,
                  "[allocator.requirements] states that rebinding an allocator to the same type should result in the "
                  "original allocator");


    typedef __wrap_iter<pointer> iterator;
    typedef __wrap_iter<const_pointer> const_iterator;
    typedef std::reverse_iterator<iterator> reverse_iterator;
    typedef std::reverse_iterator<const_iterator> const_reverse_iterator;

private:
    static_assert(8 == 8, "This implementation assumes that one byte contains 8 bits");
# 786 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/string" 3
    static const size_type __endian_factor = 2;






    struct __long
    {
        struct __attribute__((__packed__)) {
            size_type __is_long_ : 1;
            size_type __cap_ : sizeof(size_type) * 8 - 1;
        };
        size_type __size_;
        pointer __data_;
    };

    enum {__min_cap = (sizeof(__long) - 1)/sizeof(value_type) > 2 ?
                      (sizeof(__long) - 1)/sizeof(value_type) : 2};

    struct __short
    {
        struct __attribute__((__packed__)) {
            unsigned char __is_long_ : 1;
            unsigned char __size_ : 7;
        };
        char __padding_[sizeof(value_type) - 1];
        value_type __data_[__min_cap];
    };



    static_assert(sizeof(__short) == (sizeof(value_type) * (__min_cap + 1)), "__short has an unexpected size.");

    union __ulx{__long __lx; __short __lxx;};

    enum {__n_words = sizeof(__ulx) / sizeof(size_type)};

    struct __raw
    {
        size_type __words[__n_words];
    };

    struct __rep
    {
        union
        {
            __long __l;
            __short __s;
            __raw __r;
        };
    };

    __compressed_pair<__rep, allocator_type> __r_;




    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    explicit basic_string(__uninitialized_size_tag, size_type __size, const allocator_type& __a)
            : __r_(__default_init_tag(), __a) {
        if (__size > max_size())
            __throw_length_error();
        if (__fits_in_sso(__size)) {
            __r_.first() = __rep();
            __set_short_size(__size);
        } else {
            auto __capacity = __recommend(__size) + 1;
            auto __allocation = __alloc_traits::allocate(__alloc(), __capacity);
            __begin_lifetime(__allocation, __capacity);
            __set_long_cap(__capacity);
            __set_long_pointer(__allocation);
            __set_long_size(__size);
        }
    }

    template <class _Iter, class _Sent>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    basic_string(__init_with_sentinel_tag, _Iter __first, _Sent __last, const allocator_type& __a)
        : __r_(__default_init_tag(), __a) {
      __init_with_sentinel(std::move(__first), std::move(__last));
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr iterator __make_iterator(pointer __p) {
        return iterator(__p);
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr const_iterator __make_const_iterator(const_pointer __p) const {
        return const_iterator(__p);
    }

public:
  __attribute__((__visibility__("default"))) static const size_type npos = -1;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr basic_string()
      noexcept(is_nothrow_default_constructible<allocator_type>::value)
      : __r_(__default_init_tag(), __default_init_tag()) {
    __default_init();
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr explicit basic_string(const allocator_type& __a)



      noexcept

      : __r_(__default_init_tag(), __a) {
    __default_init();
  }

  constexpr basic_string(const basic_string& __str)
      : __r_(__default_init_tag(), __alloc_traits::select_on_container_copy_construction(__str.__alloc())) {
    if (!__str.__is_long())
      __r_.first() = __str.__r_.first();
    else
      __init_copy_ctor_external(std::__to_address(__str.__get_long_pointer()), __str.__get_long_size());
  }

  constexpr basic_string(const basic_string& __str, const allocator_type& __a)
      : __r_(__default_init_tag(), __a) {
    if (!__str.__is_long())
      __r_.first() = __str.__r_.first();
    else
      __init_copy_ctor_external(std::__to_address(__str.__get_long_pointer()), __str.__get_long_size());
  }


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr basic_string(basic_string&& __str)



      noexcept

      : __r_(std::move(__str.__r_)) {
    __str.__default_init();
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr basic_string(basic_string&& __str, const allocator_type& __a)
      : __r_(__default_init_tag(), __a) {
    if (__str.__is_long() && __a != __str.__alloc())
      __init(std::__to_address(__str.__get_long_pointer()), __str.__get_long_size());
    else {
      if (__libcpp_is_constant_evaluated())
        __r_.first() = __rep();
      __r_.first() = __str.__r_.first();
      __str.__default_init();
    }
  }


  template <__enable_if_t<__is_allocator<_Allocator>::value, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr basic_string(const _CharT* __s)
      : __r_(__default_init_tag(), __default_init_tag()) {
    ((void)0);
    __init(__s, traits_type::length(__s));
  }

  template <__enable_if_t<__is_allocator<_Allocator>::value, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr basic_string(const _CharT* __s, const _Allocator& __a)
      : __r_(__default_init_tag(), __a) {
    ((void)0);
    __init(__s, traits_type::length(__s));
  }


  basic_string(nullptr_t) = delete;


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr basic_string(const _CharT* __s, size_type __n)
      : __r_(__default_init_tag(), __default_init_tag()) {
    ((void)0);
    __init(__s, __n);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
  basic_string(const _CharT* __s, size_type __n, const _Allocator& __a)
      : __r_(__default_init_tag(), __a) {
    ((void)0);

    __init(__s, __n);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr basic_string(size_type __n, _CharT __c)
      : __r_(__default_init_tag(), __default_init_tag()) {
    __init(__n, __c);
  }


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
  basic_string(basic_string&& __str, size_type __pos, const _Allocator& __alloc = _Allocator())
      : basic_string(std::move(__str), __pos, npos, __alloc) {}

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
  basic_string(basic_string&& __str, size_type __pos, size_type __n, const _Allocator& __alloc = _Allocator())
      : __r_(__default_init_tag(), __alloc) {
    if (__pos > __str.size())
      __throw_out_of_range();

    auto __len = std::min<size_type>(__n, __str.size() - __pos);
    if (__alloc_traits::is_always_equal::value || __alloc == __str.__alloc()) {
      __r_.first() = __str.__r_.first();
      __str.__default_init();

      _Traits::move(data(), data() + __pos, __len);
      __set_size(__len);
      _Traits::assign(data()[__len], value_type());
    } else {

      __init(__str.data() + __pos, __len);
    }
  }


  template <__enable_if_t<__is_allocator<_Allocator>::value, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr basic_string(size_type __n, _CharT __c, const _Allocator& __a)
      : __r_(__default_init_tag(), __a) {
    __init(__n, __c);
  }

  constexpr
  basic_string(const basic_string& __str, size_type __pos, size_type __n, const _Allocator& __a = _Allocator())
      : __r_(__default_init_tag(), __a) {
    size_type __str_sz = __str.size();
    if (__pos > __str_sz)
      __throw_out_of_range();
    __init(__str.data() + __pos, std::min(__n, __str_sz - __pos));
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
  basic_string(const basic_string& __str, size_type __pos, const _Allocator& __a = _Allocator())
      : __r_(__default_init_tag(), __a) {
    size_type __str_sz = __str.size();
    if (__pos > __str_sz)
      __throw_out_of_range();
    __init(__str.data() + __pos, __str_sz - __pos);
  }

  template <class _Tp,
            __enable_if_t<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value &&
                              !__is_same_uncvref<_Tp, basic_string>::value,
                          int> = 0>
  inline __attribute__((__visibility__("hidden"))) constexpr
  basic_string(const _Tp& __t, size_type __pos, size_type __n, const allocator_type& __a = allocator_type())
      : __r_(__default_init_tag(), __a) {
    __self_view __sv0 = __t;
    __self_view __sv = __sv0.substr(__pos, __n);
    __init(__sv.data(), __sv.size());
  }

  template <class _Tp,
            __enable_if_t<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value &&
                              !__is_same_uncvref<_Tp, basic_string>::value,
                          int> = 0>
  inline __attribute__((__visibility__("hidden"))) constexpr explicit basic_string(const _Tp& __t)
      : __r_(__default_init_tag(), __default_init_tag()) {
    __self_view __sv = __t;
    __init(__sv.data(), __sv.size());
  }

  template <class _Tp,
            __enable_if_t<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value &&
                              !__is_same_uncvref<_Tp, basic_string>::value,
                          int> = 0>
  inline __attribute__((__visibility__("hidden"))) constexpr explicit basic_string(
      const _Tp& __t, const allocator_type& __a)
      : __r_(__default_init_tag(), __a) {
    __self_view __sv = __t;
    __init(__sv.data(), __sv.size());
  }

  template <class _InputIterator, __enable_if_t<__has_input_iterator_category<_InputIterator>::value, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr basic_string(_InputIterator __first, _InputIterator __last)
      : __r_(__default_init_tag(), __default_init_tag()) {
    __init(__first, __last);
  }

  template <class _InputIterator, __enable_if_t<__has_input_iterator_category<_InputIterator>::value, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
  basic_string(_InputIterator __first, _InputIterator __last, const allocator_type& __a)
      : __r_(__default_init_tag(), __a) {
    __init(__first, __last);
  }


  template <_ContainerCompatibleRange<_CharT> _Range>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
  basic_string(from_range_t, _Range&& __range, const allocator_type& __a = allocator_type())
      : __r_(__default_init_tag(), __a) {
    if constexpr (ranges::forward_range<_Range> || ranges::sized_range<_Range>) {
      __init_with_size(ranges::begin(__range), ranges::end(__range), ranges::distance(__range));
    } else {
      __init_with_sentinel(ranges::begin(__range), ranges::end(__range));
    }
  }



  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr basic_string(initializer_list<_CharT> __il)
      : __r_(__default_init_tag(), __default_init_tag()) {
    __init(__il.begin(), __il.end());
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr basic_string(initializer_list<_CharT> __il, const _Allocator& __a)
      : __r_(__default_init_tag(), __a) {
    __init(__il.begin(), __il.end());
  }


  inline constexpr ~basic_string() {
    if (__is_long())
      __alloc_traits::deallocate(__alloc(), __get_long_pointer(), __get_long_cap());
  }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    operator __self_view() const noexcept { return __self_view(data(), size()); }

    constexpr basic_string& operator=(const basic_string& __str);

    template <class _Tp, __enable_if_t<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value &&
                                           !__is_same_uncvref<_Tp, basic_string>::value, int> = 0>
    constexpr basic_string& operator=(const _Tp& __t) {
      __self_view __sv = __t;
      return assign(__sv);
    }


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr basic_string& operator=(basic_string&& __str)
      noexcept((__noexcept_move_assign_container<_Allocator, __alloc_traits>::value)) {
    __move_assign(__str, integral_constant<bool, __alloc_traits::propagate_on_container_move_assignment::value>());
    return *this;
  }

     __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    basic_string& operator=(initializer_list<value_type> __il) {return assign(__il.begin(), __il.size());}

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    basic_string& operator=(const value_type* __s) {return assign(__s);}

    basic_string& operator=(nullptr_t) = delete;

    constexpr basic_string& operator=(value_type __c);

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    iterator begin() noexcept
        {return __make_iterator(__get_pointer());}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    const_iterator begin() const noexcept
        {return __make_const_iterator(__get_pointer());}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    iterator end() noexcept
        {return __make_iterator(__get_pointer() + size());}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    const_iterator end() const noexcept
        {return __make_const_iterator(__get_pointer() + size());}

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    reverse_iterator rbegin() noexcept
        {return reverse_iterator(end());}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    const_reverse_iterator rbegin() const noexcept
        {return const_reverse_iterator(end());}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    reverse_iterator rend() noexcept
        {return reverse_iterator(begin());}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    const_reverse_iterator rend() const noexcept
        {return const_reverse_iterator(begin());}

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    const_iterator cbegin() const noexcept
        {return begin();}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    const_iterator cend() const noexcept
        {return end();}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    const_reverse_iterator crbegin() const noexcept
        {return rbegin();}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    const_reverse_iterator crend() const noexcept
        {return rend();}

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr size_type size() const noexcept
        {return __is_long() ? __get_long_size() : __get_short_size();}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr size_type length() const noexcept {return size();}

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr size_type max_size() const noexcept {
    size_type __m = __alloc_traits::max_size(__alloc());
    if (__m <= std::numeric_limits<size_type>::max() / 2) {
      return __m - __alignment;
    } else {
    bool __uses_lsb = __endian_factor == 2;
      return __uses_lsb ? __m - __alignment : (__m / 2) - __alignment;
    }
  }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr size_type capacity() const noexcept {
        return (__is_long() ? __get_long_cap() : static_cast<size_type>(__min_cap)) - 1;
    }

    constexpr void resize(size_type __n, value_type __c);
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr void resize(size_type __n) { resize(__n, value_type()); }

    constexpr void reserve(size_type __requested_capacity);


    template <class _Op>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    void resize_and_overwrite(size_type __n, _Op __op) {
      __resize_default_init(__n);
      __erase_to_end(std::move(__op)(data(), static_cast<::std::__decay_t<decltype((__n))> >(__n)));
    }


    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr void __resize_default_init(size_type __n);

    __attribute__((__deprecated__)) __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) void reserve() noexcept { shrink_to_fit(); }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr void shrink_to_fit() noexcept;
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr void clear() noexcept;

    [[__nodiscard__]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    bool empty() const noexcept {return size() == 0;}

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr const_reference operator[](size_type __pos) const noexcept {
    ((void)0);
    return *(data() + __pos);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr reference operator[](size_type __pos) noexcept {
    ((void)0);
    return *(__get_pointer() + __pos);
  }

    constexpr const_reference at(size_type __n) const;
    constexpr reference at(size_type __n);

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr basic_string& operator+=(const basic_string& __str) {
        return append(__str);
    }

    template <class _Tp,
              __enable_if_t<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value &&
                                !__is_same_uncvref<_Tp, basic_string >::value,
                            int> = 0>
    inline __attribute__((__visibility__("hidden"))) constexpr basic_string&
    operator+=(const _Tp& __t) {
        __self_view __sv = __t; return append(__sv);
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr basic_string& operator+=(const value_type* __s) {
        return append(__s);
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr basic_string& operator+=(value_type __c) {
        push_back(__c);
        return *this;
    }


    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    basic_string& operator+=(initializer_list<value_type> __il) { return append(__il); }


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr basic_string& append(const basic_string& __str) {
        return append(__str.data(), __str.size());
  }

  template <class _Tp,
            __enable_if_t<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value &&
                              !__is_same_uncvref<_Tp, basic_string>::value,
                          int> = 0>
  inline __attribute__((__visibility__("hidden"))) constexpr basic_string&
  append(const _Tp& __t) {
        __self_view __sv = __t;
        return append(__sv.data(), __sv.size());
  }

    constexpr basic_string& append(const basic_string& __str, size_type __pos, size_type __n=npos);

    template <class _Tp,
              __enable_if_t<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value &&
                                !__is_same_uncvref<_Tp, basic_string>::value,
                            int> = 0>
    inline __attribute__((__visibility__("hidden"))) constexpr

        basic_string&
        append(const _Tp& __t, size_type __pos, size_type __n = npos);

    constexpr basic_string& append(const value_type* __s, size_type __n);
    constexpr basic_string& append(const value_type* __s);
    constexpr basic_string& append(size_type __n, value_type __c);

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    void __append_default_init(size_type __n);

    template <class _InputIterator, __enable_if_t<__has_exactly_input_iterator_category<_InputIterator>::value, int> = 0>
    inline __attribute__((__visibility__("hidden"))) __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr basic_string&
    append(_InputIterator __first, _InputIterator __last) {
        const basic_string __temp(__first, __last, __alloc());
        append(__temp.data(), __temp.size());
        return *this;
    }

    template <class _ForwardIterator, __enable_if_t<__has_forward_iterator_category<_ForwardIterator>::value, int> = 0>
    inline __attribute__((__visibility__("hidden"))) __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr basic_string&
    append(_ForwardIterator __first, _ForwardIterator __last);


    template <_ContainerCompatibleRange<_CharT> _Range>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    constexpr basic_string& append_range(_Range&& __range) {
      insert_range(end(), std::forward<_Range>(__range));
      return *this;
    }



    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    basic_string& append(initializer_list<value_type> __il) {return append(__il.begin(), __il.size());}


    constexpr void push_back(value_type __c);
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr void pop_back();

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr reference front() noexcept {
    ((void)0);
    return *__get_pointer();
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr const_reference front() const noexcept {
    ((void)0);
    return *data();
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr reference back() noexcept {
    ((void)0);
    return *(__get_pointer() + size() - 1);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr const_reference back() const noexcept {
    ((void)0);
    return *(data() + size() - 1);
  }

  template <class _Tp, __enable_if_t<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value, int> = 0>
  inline __attribute__((__visibility__("hidden"))) constexpr basic_string&
  assign(const _Tp& __t) {
    __self_view __sv = __t;
    return assign(__sv.data(), __sv.size());
  }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    basic_string& assign(const basic_string& __str) { return *this = __str; }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    basic_string& assign(basic_string&& __str)
        noexcept((__noexcept_move_assign_container<_Allocator, __alloc_traits>::value))
        {*this = std::move(__str); return *this;}

    constexpr basic_string& assign(const basic_string& __str, size_type __pos, size_type __n=npos);

    template <class _Tp,
              __enable_if_t<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value &&
                                !__is_same_uncvref<_Tp, basic_string>::value,
                            int> = 0>
    inline __attribute__((__visibility__("hidden"))) constexpr basic_string&
    assign(const _Tp& __t, size_type __pos, size_type __n = npos);

    constexpr basic_string& assign(const value_type* __s, size_type __n);
    constexpr basic_string& assign(const value_type* __s);
    constexpr basic_string& assign(size_type __n, value_type __c);
    template <class _InputIterator, __enable_if_t<__has_exactly_input_iterator_category<_InputIterator>::value, int> = 0>
    inline __attribute__((__visibility__("hidden"))) constexpr basic_string&
    assign(_InputIterator __first, _InputIterator __last);

    template <class _ForwardIterator, __enable_if_t<__has_forward_iterator_category<_ForwardIterator>::value, int> = 0>
    inline __attribute__((__visibility__("hidden"))) constexpr basic_string&
    assign(_ForwardIterator __first, _ForwardIterator __last);


    template <_ContainerCompatibleRange<_CharT> _Range>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    constexpr basic_string& assign_range(_Range&& __range) {
      if constexpr (__string_is_trivial_iterator<ranges::iterator_t<_Range>>::value &&
          (ranges::forward_range<_Range> || ranges::sized_range<_Range>)) {
        size_type __n = static_cast<size_type>(ranges::distance(__range));
        __assign_trivial(ranges::begin(__range), ranges::end(__range), __n);

      } else {
        __assign_with_sentinel(ranges::begin(__range), ranges::end(__range));
      }

      return *this;
    }



    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    basic_string& assign(initializer_list<value_type> __il) {return assign(__il.begin(), __il.size());}


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr basic_string&
  insert(size_type __pos1, const basic_string& __str) {
    return insert(__pos1, __str.data(), __str.size());
  }

  template <class _Tp, __enable_if_t<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value, int> = 0>
  inline __attribute__((__visibility__("hidden"))) constexpr basic_string&
  insert(size_type __pos1, const _Tp& __t) {
    __self_view __sv = __t;
    return insert(__pos1, __sv.data(), __sv.size());
  }

  template <class _Tp,
            __enable_if_t<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value &&
                              !__is_same_uncvref<_Tp, basic_string>::value,
                          int> = 0>
  inline __attribute__((__visibility__("hidden"))) constexpr basic_string&
  insert(size_type __pos1, const _Tp& __t, size_type __pos2, size_type __n = npos);

  constexpr basic_string&
  insert(size_type __pos1, const basic_string& __str, size_type __pos2, size_type __n = npos);
  constexpr basic_string& insert(size_type __pos, const value_type* __s, size_type __n);
  constexpr basic_string& insert(size_type __pos, const value_type* __s);
  constexpr basic_string& insert(size_type __pos, size_type __n, value_type __c);
  constexpr iterator insert(const_iterator __pos, value_type __c);


    template <_ContainerCompatibleRange<_CharT> _Range>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    constexpr iterator insert_range(const_iterator __position, _Range&& __range) {
      if constexpr (ranges::forward_range<_Range> || ranges::sized_range<_Range>) {
        auto __n = static_cast<size_type>(ranges::distance(__range));
        return __insert_with_size(__position, ranges::begin(__range), ranges::end(__range), __n);

      } else {
        basic_string __temp(from_range, std::forward<_Range>(__range), __alloc());
        return insert(__position, __temp.data(), __temp.data() + __temp.size());
      }
    }


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr iterator
  insert(const_iterator __pos, size_type __n, value_type __c) {
    difference_type __p = __pos - begin();
    insert(static_cast<size_type>(__p), __n, __c);
    return begin() + __p;
  }

  template <class _InputIterator, __enable_if_t<__has_exactly_input_iterator_category<_InputIterator>::value, int> = 0>
  inline __attribute__((__visibility__("hidden"))) constexpr iterator
  insert(const_iterator __pos, _InputIterator __first, _InputIterator __last);

  template <class _ForwardIterator, __enable_if_t<__has_forward_iterator_category<_ForwardIterator>::value, int> = 0>
  inline __attribute__((__visibility__("hidden"))) constexpr iterator
  insert(const_iterator __pos, _ForwardIterator __first, _ForwardIterator __last);


    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    iterator insert(const_iterator __pos, initializer_list<value_type> __il)
                    {return insert(__pos, __il.begin(), __il.end());}


    constexpr basic_string& erase(size_type __pos = 0, size_type __n = npos);
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    iterator erase(const_iterator __pos);
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    iterator erase(const_iterator __first, const_iterator __last);

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr basic_string&
  replace(size_type __pos1, size_type __n1, const basic_string& __str) {
    return replace(__pos1, __n1, __str.data(), __str.size());
  }

  template <class _Tp, __enable_if_t<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value, int> = 0>
  inline __attribute__((__visibility__("hidden"))) constexpr basic_string&
  replace(size_type __pos1, size_type __n1, const _Tp& __t) {
    __self_view __sv = __t;
    return replace(__pos1, __n1, __sv.data(), __sv.size());
  }

  constexpr basic_string&
  replace(size_type __pos1, size_type __n1, const basic_string& __str, size_type __pos2, size_type __n2 = npos);

  template <class _Tp,
            __enable_if_t<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value &&
                              !__is_same_uncvref<_Tp, basic_string>::value,
                          int> = 0>
  inline __attribute__((__visibility__("hidden"))) constexpr basic_string&
  replace(size_type __pos1, size_type __n1, const _Tp& __t, size_type __pos2, size_type __n2 = npos);

  constexpr basic_string&
  replace(size_type __pos, size_type __n1, const value_type* __s, size_type __n2);
  constexpr basic_string& replace(size_type __pos, size_type __n1, const value_type* __s);
  constexpr basic_string& replace(size_type __pos, size_type __n1, size_type __n2, value_type __c);

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr basic_string&
  replace(const_iterator __i1, const_iterator __i2, const basic_string& __str) {
    return replace(
        static_cast<size_type>(__i1 - begin()), static_cast<size_type>(__i2 - __i1), __str.data(), __str.size());
  }

  template <class _Tp, __enable_if_t<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value, int> = 0>
  inline __attribute__((__visibility__("hidden"))) constexpr basic_string&
  replace(const_iterator __i1, const_iterator __i2, const _Tp& __t) {
    __self_view __sv = __t;
    return replace(__i1 - begin(), __i2 - __i1, __sv);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr basic_string&
  replace(const_iterator __i1, const_iterator __i2, const value_type* __s, size_type __n) {
    return replace(static_cast<size_type>(__i1 - begin()), static_cast<size_type>(__i2 - __i1), __s, __n);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr basic_string&
  replace(const_iterator __i1, const_iterator __i2, const value_type* __s) {
    return replace(static_cast<size_type>(__i1 - begin()), static_cast<size_type>(__i2 - __i1), __s);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr basic_string&
  replace(const_iterator __i1, const_iterator __i2, size_type __n, value_type __c) {
    return replace(static_cast<size_type>(__i1 - begin()), static_cast<size_type>(__i2 - __i1), __n, __c);
  }

  template <class _InputIterator, __enable_if_t<__has_input_iterator_category<_InputIterator>::value, int> = 0>
  inline __attribute__((__visibility__("hidden"))) constexpr basic_string&
  replace(const_iterator __i1, const_iterator __i2, _InputIterator __j1, _InputIterator __j2);


  template <_ContainerCompatibleRange<_CharT> _Range>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
  constexpr basic_string& replace_with_range(const_iterator __i1, const_iterator __i2, _Range&& __range) {
    basic_string __temp(from_range, std::forward<_Range>(__range), __alloc());
    return replace(__i1, __i2, __temp);
  }



    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    basic_string& replace(const_iterator __i1, const_iterator __i2, initializer_list<value_type> __il)
        {return replace(__i1, __i2, __il.begin(), __il.end());}


    constexpr size_type copy(value_type* __s, size_type __n, size_type __pos = 0) const;







    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    basic_string substr(size_type __pos = 0, size_type __n = npos) const& {
      return basic_string(*this, __pos, __n);
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    basic_string substr(size_type __pos = 0, size_type __n = npos) && {
      return basic_string(std::move(*this), __pos, __n);
    }


    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    void swap(basic_string& __str)

        noexcept;





    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    const value_type* c_str() const noexcept {return data();}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    const value_type* data() const noexcept {return std::__to_address(__get_pointer());}

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    value_type* data() noexcept {return std::__to_address(__get_pointer());}


    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    allocator_type get_allocator() const noexcept {return __alloc();}

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    size_type find(const basic_string& __str, size_type __pos = 0) const noexcept;

    template <class _Tp, __enable_if_t<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value, int> = 0>
    inline __attribute__((__visibility__("hidden"))) constexpr size_type
    find(const _Tp& __t, size_type __pos = 0) const noexcept;

    constexpr size_type find(const value_type* __s, size_type __pos, size_type __n) const noexcept;
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    size_type find(const value_type* __s, size_type __pos = 0) const noexcept;
    constexpr size_type find(value_type __c, size_type __pos = 0) const noexcept;

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    size_type rfind(const basic_string& __str, size_type __pos = npos) const noexcept;

    template <class _Tp, __enable_if_t<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value, int> = 0>
    inline __attribute__((__visibility__("hidden"))) constexpr size_type
    rfind(const _Tp& __t, size_type __pos = npos) const noexcept;

    constexpr
    size_type rfind(const value_type* __s, size_type __pos, size_type __n) const noexcept;
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    size_type rfind(const value_type* __s, size_type __pos = npos) const noexcept;
    constexpr size_type rfind(value_type __c, size_type __pos = npos) const noexcept;

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    size_type find_first_of(const basic_string& __str, size_type __pos = 0) const noexcept;

    template <class _Tp, __enable_if_t<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value, int> = 0>
    inline __attribute__((__visibility__("hidden"))) constexpr size_type
    find_first_of(const _Tp& __t, size_type __pos = 0) const noexcept;

    constexpr
    size_type find_first_of(const value_type* __s, size_type __pos, size_type __n) const noexcept;
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    size_type find_first_of(const value_type* __s, size_type __pos = 0) const noexcept;
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    size_type find_first_of(value_type __c, size_type __pos = 0) const noexcept;

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    size_type find_last_of(const basic_string& __str, size_type __pos = npos) const noexcept;

    template <class _Tp, __enable_if_t<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value, int> = 0>
    inline __attribute__((__visibility__("hidden"))) constexpr size_type
    find_last_of(const _Tp& __t, size_type __pos = npos) const noexcept;

    constexpr
    size_type find_last_of(const value_type* __s, size_type __pos, size_type __n) const noexcept;
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    size_type find_last_of(const value_type* __s, size_type __pos = npos) const noexcept;
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    size_type find_last_of(value_type __c, size_type __pos = npos) const noexcept;

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    size_type find_first_not_of(const basic_string& __str, size_type __pos = 0) const noexcept;

    template <class _Tp, __enable_if_t<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value, int> = 0>
    inline __attribute__((__visibility__("hidden"))) constexpr size_type
    find_first_not_of(const _Tp& __t, size_type __pos = 0) const noexcept;

    constexpr
    size_type find_first_not_of(const value_type* __s, size_type __pos, size_type __n) const noexcept;
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    size_type find_first_not_of(const value_type* __s, size_type __pos = 0) const noexcept;
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    size_type find_first_not_of(value_type __c, size_type __pos = 0) const noexcept;

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    size_type find_last_not_of(const basic_string& __str, size_type __pos = npos) const noexcept;

    template <class _Tp, __enable_if_t<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value, int> = 0>
    inline __attribute__((__visibility__("hidden"))) constexpr size_type
    find_last_not_of(const _Tp& __t, size_type __pos = npos) const noexcept;

    constexpr
    size_type find_last_not_of(const value_type* __s, size_type __pos, size_type __n) const noexcept;
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    size_type find_last_not_of(const value_type* __s, size_type __pos = npos) const noexcept;
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    size_type find_last_not_of(value_type __c, size_type __pos = npos) const noexcept;

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    int compare(const basic_string& __str) const noexcept;

    template <class _Tp, __enable_if_t<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value, int> = 0>
    inline __attribute__((__visibility__("hidden"))) constexpr int
    compare(const _Tp& __t) const noexcept;

    template <class _Tp, __enable_if_t<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value, int> = 0>
    inline __attribute__((__visibility__("hidden"))) constexpr int
    compare(size_type __pos1, size_type __n1, const _Tp& __t) const;

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    int compare(size_type __pos1, size_type __n1, const basic_string& __str) const;
    constexpr
    int compare(size_type __pos1, size_type __n1, const basic_string& __str, size_type __pos2,
                size_type __n2 = npos) const;

    template <class _Tp,
              __enable_if_t<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value &&
                                !__is_same_uncvref<_Tp, basic_string>::value,
                            int> = 0>
    inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr int
    compare(size_type __pos1, size_type __n1, const _Tp& __t, size_type __pos2, size_type __n2 = npos) const;

    constexpr int compare(const value_type* __s) const noexcept;
    constexpr int compare(size_type __pos1, size_type __n1, const value_type* __s) const;
    constexpr
    int compare(size_type __pos1, size_type __n1, const value_type* __s, size_type __n2) const;


    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    bool starts_with(__self_view __sv) const noexcept
    { return __self_view(data(), size()).starts_with(__sv); }

    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    bool starts_with(value_type __c) const noexcept
    { return !empty() && _Traits::eq(front(), __c); }

    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    bool starts_with(const value_type* __s) const noexcept
    { return starts_with(__self_view(__s)); }

    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    bool ends_with(__self_view __sv) const noexcept
    { return __self_view(data(), size()).ends_with( __sv); }

    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    bool ends_with(value_type __c) const noexcept
    { return !empty() && _Traits::eq(back(), __c); }

    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    bool ends_with(const value_type* __s) const noexcept
    { return ends_with(__self_view(__s)); }



    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    bool contains(__self_view __sv) const noexcept
    { return __self_view(data(), size()).contains(__sv); }

    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    bool contains(value_type __c) const noexcept
    { return __self_view(data(), size()).contains(__c); }

    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    bool contains(const value_type* __s) const
    { return __self_view(data(), size()).contains(__s); }


    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr bool __invariants() const;

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr void __clear_and_shrink() noexcept;

private:
    template<class _Alloc>
    inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    bool friend operator==(const basic_string<char, char_traits<char>, _Alloc>& __lhs,
                           const basic_string<char, char_traits<char>, _Alloc>& __rhs) noexcept;

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr void __shrink_or_extend(size_type __target_capacity);

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    bool __is_long() const noexcept {
        if (__libcpp_is_constant_evaluated())
            return true;
        return __r_.first().__s.__is_long_;
    }

    static __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr void __begin_lifetime(pointer __begin, size_type __n) {

        if (__libcpp_is_constant_evaluated()) {
            for (size_type __i = 0; __i != __n; ++__i)
                std::construct_at(std::addressof(__begin[__i]));
        }




    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr void __default_init() {
        __r_.first() = __rep();
        if (__libcpp_is_constant_evaluated()) {
            size_type __sz = __recommend(0) + 1;
            pointer __ptr = __alloc_traits::allocate(__alloc(), __sz);
            __begin_lifetime(__ptr, __sz);
            __set_long_pointer(__ptr);
            __set_long_cap(__sz);
            __set_long_size(0);
        }
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr void __deallocate_constexpr() {
        if (__libcpp_is_constant_evaluated() && __get_pointer() != nullptr)
            __alloc_traits::deallocate(__alloc(), __get_pointer(), __get_long_cap());
    }

    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) static bool __fits_in_sso(size_type __sz) {

        return !__libcpp_is_constant_evaluated() && (__sz < __min_cap);
    }

    template <class _Iterator, class _Sentinel>
    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    void __assign_trivial(_Iterator __first, _Sentinel __last, size_type __n);

    template <class _Iterator, class _Sentinel>
    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    void __assign_with_sentinel(_Iterator __first, _Sentinel __last);

    template <class _ForwardIterator, class _Sentinel>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    iterator __insert_from_safe_copy(size_type __n, size_type __ip, _ForwardIterator __first, _Sentinel __last) {
        size_type __sz = size();
        size_type __cap = capacity();
        value_type* __p;
        if (__cap - __sz >= __n)
        {
            __p = std::__to_address(__get_pointer());
            size_type __n_move = __sz - __ip;
            if (__n_move != 0)
                traits_type::move(__p + __ip + __n, __p + __ip, __n_move);
        }
        else
        {
            __grow_by_without_replace(__cap, __sz + __n - __cap, __sz, __ip, 0, __n);
            __p = std::__to_address(__get_long_pointer());
        }
        __sz += __n;
        __set_size(__sz);
        traits_type::assign(__p[__sz], value_type());
        for (__p += __ip; __first != __last; ++__p, ++__first)
            traits_type::assign(*__p, *__first);

        return begin() + __ip;
    }

    template<class _Iterator, class _Sentinel>
    constexpr
    iterator __insert_with_size(const_iterator __pos, _Iterator __first, _Sentinel __last, size_type __n);

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr allocator_type& __alloc() noexcept { return __r_.second(); }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr const allocator_type& __alloc() const noexcept { return __r_.second(); }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    void __set_short_size(size_type __s) noexcept {
        ((void)0);

        __r_.first().__s.__size_ = __s;
        __r_.first().__s.__is_long_ = false;
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    size_type __get_short_size() const noexcept {
        ((void)0);

        return __r_.first().__s.__size_;
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    void __set_long_size(size_type __s) noexcept
        {__r_.first().__l.__size_ = __s;}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    size_type __get_long_size() const noexcept
        {return __r_.first().__l.__size_;}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    void __set_size(size_type __s) noexcept
        {if (__is_long()) __set_long_size(__s); else __set_short_size(__s);}

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    void __set_long_cap(size_type __s) noexcept {
        __r_.first().__l.__cap_ = __s / __endian_factor;
        __r_.first().__l.__is_long_ = true;
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    size_type __get_long_cap() const noexcept {
        return __r_.first().__l.__cap_ * __endian_factor;
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    void __set_long_pointer(pointer __p) noexcept
        {__r_.first().__l.__data_ = __p;}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    pointer __get_long_pointer() noexcept
        {return __r_.first().__l.__data_;}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    const_pointer __get_long_pointer() const noexcept
        {return __r_.first().__l.__data_;}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    pointer __get_short_pointer() noexcept
        {return pointer_traits<pointer>::pointer_to(__r_.first().__s.__data_[0]);}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    const_pointer __get_short_pointer() const noexcept
        {return pointer_traits<const_pointer>::pointer_to(__r_.first().__s.__data_[0]);}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    pointer __get_pointer() noexcept
        {return __is_long() ? __get_long_pointer() : __get_short_pointer();}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    const_pointer __get_pointer() const noexcept
        {return __is_long() ? __get_long_pointer() : __get_short_pointer();}

    template <size_type __a> static
        __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
        size_type __align_it(size_type __s) noexcept
            {return (__s + (__a-1)) & ~(__a-1);}
    enum {__alignment = 16};
    static __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    size_type __recommend(size_type __s) noexcept
    {
        if (__s < __min_cap) {
            if (__libcpp_is_constant_evaluated())
                return static_cast<size_type>(__min_cap);
            else
                return static_cast<size_type>(__min_cap) - 1;
        }
        size_type __guess = __align_it<sizeof(value_type) < __alignment ?
                     __alignment/sizeof(value_type) : 1 > (__s+1) - 1;
        if (__guess == __min_cap) ++__guess;
        return __guess;
    }

    inline constexpr
    void __init(const value_type* __s, size_type __sz, size_type __reserve);
    inline constexpr
    void __init(const value_type* __s, size_type __sz);
    inline constexpr
    void __init(size_type __n, value_type __c);
# 1906 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/string" 3
    constexpr void __init_copy_ctor_external(const value_type* __s, size_type __sz);

    template <class _InputIterator, __enable_if_t<__has_exactly_input_iterator_category<_InputIterator>::value, int> = 0>
    inline constexpr void __init(_InputIterator __first, _InputIterator __last);

    template <class _ForwardIterator, __enable_if_t<__has_forward_iterator_category<_ForwardIterator>::value, int> = 0>
    inline constexpr void __init(_ForwardIterator __first, _ForwardIterator __last);

    template <class _InputIterator, class _Sentinel>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    void __init_with_sentinel(_InputIterator __first, _Sentinel __last);
    template <class _InputIterator, class _Sentinel>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    void __init_with_size(_InputIterator __first, _Sentinel __last, size_type __sz);

    constexpr



    __attribute__((__deprecated__("use __grow_by_without_replace")))
    void __grow_by(size_type __old_cap, size_type __delta_cap, size_type __old_sz,
                   size_type __n_copy, size_type __n_del, size_type __n_add = 0);
    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    void __grow_by_without_replace(size_type __old_cap, size_type __delta_cap, size_type __old_sz,
                   size_type __n_copy, size_type __n_del, size_type __n_add = 0);
    constexpr
    void __grow_by_and_replace(size_type __old_cap, size_type __delta_cap, size_type __old_sz,
                               size_type __n_copy, size_type __n_del,
                               size_type __n_add, const value_type* __p_new_stuff);




    template <bool __is_short>
    constexpr basic_string& __assign_no_alias(const value_type* __s, size_type __n);

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr void __erase_to_end(size_type __pos) {
    __null_terminate_at(std::__to_address(__get_pointer()), __pos);
  }



    constexpr void __erase_external_with_move(size_type __pos, size_type __n);

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    void __copy_assign_alloc(const basic_string& __str)
        {__copy_assign_alloc(__str, integral_constant<bool,
                      __alloc_traits::propagate_on_container_copy_assignment::value>());}

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    void __copy_assign_alloc(const basic_string& __str, true_type)
        {
            if (__alloc() == __str.__alloc())
                __alloc() = __str.__alloc();
            else
            {
                if (!__str.__is_long())
                {
                    __clear_and_shrink();
                    __alloc() = __str.__alloc();
                }
                else
                {
                    allocator_type __a = __str.__alloc();
                    auto __allocation = std::__allocate_at_least(__a, __str.__get_long_cap());
                    __begin_lifetime(__allocation.ptr, __allocation.count);
                    if (__is_long())
                        __alloc_traits::deallocate(__alloc(), __get_long_pointer(), __get_long_cap());
                    __alloc() = std::move(__a);
                    __set_long_pointer(__allocation.ptr);
                    __set_long_cap(__allocation.count);
                    __set_long_size(__str.size());
                }
            }
        }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    void __copy_assign_alloc(const basic_string&, false_type) noexcept
        {}


    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    void __move_assign(basic_string& __str, false_type)
        noexcept(__alloc_traits::is_always_equal::value);
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    void __move_assign(basic_string& __str, true_type)

        noexcept;





    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    void
    __move_assign_alloc(basic_string& __str)
        noexcept(!__alloc_traits::propagate_on_container_move_assignment::value || is_nothrow_move_assignable<allocator_type>::value)


    {__move_assign_alloc(__str, integral_constant<bool,
                      __alloc_traits::propagate_on_container_move_assignment::value>());}

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    void __move_assign_alloc(basic_string& __c, true_type)
        noexcept(is_nothrow_move_assignable<allocator_type>::value)
        {
            __alloc() = std::move(__c.__alloc());
        }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    void __move_assign_alloc(basic_string&, false_type)
        noexcept
        {}

    constexpr basic_string& __assign_external(const value_type* __s);
    constexpr basic_string& __assign_external(const value_type* __s, size_type __n);


    inline basic_string& __assign_short(const value_type* __s, size_type __n) {
      pointer __p = __is_long()
                        ? (__set_long_size(__n), __get_long_pointer())
                        : (__set_short_size(__n), __get_short_pointer());
      traits_type::move(std::__to_address(__p), __s, __n);
      traits_type::assign(__p[__n], value_type());
      return *this;
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    basic_string& __null_terminate_at(value_type* __p, size_type __newsz) {
      __set_size(__newsz);
      traits_type::assign(__p[__newsz], value_type());
      return *this;
    }

    template <class _Tp>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr bool __addr_in_range(const _Tp& __v) const {
      return std::__is_pointer_in_range(data(), data() + size() + 1, std::addressof(__v));
    }

    [[noreturn]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    void __throw_length_error() const {
        std::__throw_length_error("basic_string");
    }

    [[noreturn]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    void __throw_out_of_range() const {
        std::__throw_out_of_range("basic_string");
    }

    friend constexpr basic_string operator+<>(const basic_string&, const basic_string&);
    friend constexpr basic_string operator+<>(const value_type*, const basic_string&);
    friend constexpr basic_string operator+<>(value_type, const basic_string&);
    friend constexpr basic_string operator+<>(const basic_string&, const value_type*);
    friend constexpr basic_string operator+<>(const basic_string&, value_type);
};
# 2071 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/string" 3
    extern template __attribute__((__visibility__("default"))) basic_string<char>& basic_string<char>::replace(size_type, size_type, value_type const*, size_type); extern template __attribute__((__visibility__("default"))) basic_string<char>::size_type basic_string<char>::rfind(value_type const*, size_type, size_type) const; extern template __attribute__((__visibility__("default"))) void basic_string<char>::__init(value_type const*, size_type, size_type); extern template __attribute__((__visibility__("default"))) basic_string<char>::basic_string(basic_string const&); extern template __attribute__((__visibility__("default"))) basic_string<char>& basic_string<char>::replace(size_type, size_type, value_type const*); extern template __attribute__((__visibility__("default"))) basic_string<char>::basic_string(basic_string const&, allocator<char> const&); extern template __attribute__((__visibility__("default"))) basic_string<char>::size_type basic_string<char>::find_last_not_of(value_type const*, size_type, size_type) const; extern template __attribute__((__visibility__("default"))) basic_string<char>::~basic_string(); extern template __attribute__((__visibility__("default"))) basic_string<char>::size_type basic_string<char>::find_first_not_of(value_type const*, size_type, size_type) const; extern template __attribute__((__visibility__("default"))) basic_string<char>& basic_string<char>::insert(size_type, size_type, value_type); extern template __attribute__((__visibility__("default"))) basic_string<char>& basic_string<char>::operator=(value_type); extern template __attribute__((__visibility__("default"))) void basic_string<char>::__init(value_type const*, size_type); extern template __attribute__((__visibility__("default"))) const char& basic_string<char>::at(size_type) const; extern template __attribute__((__visibility__("default"))) basic_string<char>& basic_string<char>::insert(size_type, value_type const*, size_type); extern template __attribute__((__visibility__("default"))) basic_string<char>::size_type basic_string<char>::find_first_of(value_type const*, size_type, size_type) const; extern template __attribute__((__visibility__("default"))) basic_string<char>& basic_string<char>::replace(size_type, size_type, size_type, value_type); extern template __attribute__((__visibility__("default"))) basic_string<char>& basic_string<char>::assign(value_type const*, size_type); extern template __attribute__((__visibility__("default"))) void basic_string<char>::reserve(size_type); extern template __attribute__((__visibility__("default"))) basic_string<char>& basic_string<char>::append(value_type const*, size_type); extern template __attribute__((__visibility__("default"))) basic_string<char>& basic_string<char>::assign(basic_string const&, size_type, size_type); extern template __attribute__((__visibility__("default"))) basic_string<char>::size_type basic_string<char>::copy(value_type*, size_type, size_type) const; extern template __attribute__((__visibility__("default"))) basic_string<char>::basic_string(basic_string const&, size_type, size_type, allocator<char> const&); extern template __attribute__((__visibility__("default"))) basic_string<char>::size_type basic_string<char>::find(value_type, size_type) const; extern template __attribute__((__visibility__("default"))) void basic_string<char>::__init(size_type, value_type); extern template __attribute__((__visibility__("default"))) basic_string<char>& basic_string<char>::insert(size_type, value_type const*); extern template __attribute__((__visibility__("default"))) basic_string<char>::size_type basic_string<char>::find_last_of(value_type const*, size_type, size_type) const; extern template __attribute__((__visibility__("default"))) void basic_string<char>::__grow_by(size_type, size_type, size_type, size_type, size_type, size_type); extern template __attribute__((__visibility__("default"))) void basic_string<char>::__grow_by_and_replace(size_type, size_type, size_type, size_type, size_type, size_type, value_type const*); extern template __attribute__((__visibility__("default"))) void basic_string<char>::push_back(value_type); extern template __attribute__((__visibility__("default"))) basic_string<char>& basic_string<char>::append(size_type, value_type); extern template __attribute__((__visibility__("default"))) basic_string<char>::size_type basic_string<char>::rfind(value_type, size_type) const; extern template __attribute__((__visibility__("default"))) const basic_string<char>::size_type basic_string<char>::npos; extern template __attribute__((__visibility__("default"))) basic_string<char>& basic_string<char>::assign(size_type, value_type); extern template __attribute__((__visibility__("default"))) basic_string<char>& basic_string<char>::erase(size_type, size_type); extern template __attribute__((__visibility__("default"))) basic_string<char>& basic_string<char>::append(basic_string const&, size_type, size_type); extern template __attribute__((__visibility__("default"))) int basic_string<char>::compare(value_type const*) const; extern template __attribute__((__visibility__("default"))) int basic_string<char>::compare(size_type, size_type, value_type const*) const; extern template __attribute__((__visibility__("default"))) char& basic_string<char>::at(size_type); extern template __attribute__((__visibility__("default"))) basic_string<char>& basic_string<char>::assign(value_type const*); extern template __attribute__((__visibility__("default"))) basic_string<char>::size_type basic_string<char>::find(value_type const*, size_type, size_type) const; extern template __attribute__((__visibility__("default"))) int basic_string<char>::compare(size_type, size_type, basic_string const&, size_type, size_type) const; extern template __attribute__((__visibility__("default"))) int basic_string<char>::compare(size_type, size_type, value_type const*, size_type) const; extern template __attribute__((__visibility__("default"))) basic_string<char>& basic_string<char>::operator=(basic_string const&); extern template __attribute__((__visibility__("default"))) basic_string<char>& basic_string<char>::append(value_type const*); extern template __attribute__((__visibility__("default"))) basic_string<char>& basic_string<char>::replace(size_type, size_type, basic_string const&, size_type, size_type); extern template __attribute__((__visibility__("default"))) basic_string<char>::iterator basic_string<char>::insert(basic_string::const_iterator, value_type); extern template __attribute__((__visibility__("default"))) void basic_string<char>::resize(size_type, value_type); extern template __attribute__((__visibility__("default"))) basic_string<char>& basic_string<char>::insert(size_type, basic_string const&, size_type, size_type);

        extern template __attribute__((__visibility__("default"))) basic_string<wchar_t>& basic_string<wchar_t>::replace(size_type, size_type, value_type const*, size_type); extern template __attribute__((__visibility__("default"))) basic_string<wchar_t>::size_type basic_string<wchar_t>::rfind(value_type const*, size_type, size_type) const; extern template __attribute__((__visibility__("default"))) void basic_string<wchar_t>::__init(value_type const*, size_type, size_type); extern template __attribute__((__visibility__("default"))) basic_string<wchar_t>::basic_string(basic_string const&); extern template __attribute__((__visibility__("default"))) basic_string<wchar_t>& basic_string<wchar_t>::replace(size_type, size_type, value_type const*); extern template __attribute__((__visibility__("default"))) basic_string<wchar_t>::basic_string(basic_string const&, allocator<wchar_t> const&); extern template __attribute__((__visibility__("default"))) basic_string<wchar_t>::size_type basic_string<wchar_t>::find_last_not_of(value_type const*, size_type, size_type) const; extern template __attribute__((__visibility__("default"))) basic_string<wchar_t>::~basic_string(); extern template __attribute__((__visibility__("default"))) basic_string<wchar_t>::size_type basic_string<wchar_t>::find_first_not_of(value_type const*, size_type, size_type) const; extern template __attribute__((__visibility__("default"))) basic_string<wchar_t>& basic_string<wchar_t>::insert(size_type, size_type, value_type); extern template __attribute__((__visibility__("default"))) basic_string<wchar_t>& basic_string<wchar_t>::operator=(value_type); extern template __attribute__((__visibility__("default"))) void basic_string<wchar_t>::__init(value_type const*, size_type); extern template __attribute__((__visibility__("default"))) const wchar_t& basic_string<wchar_t>::at(size_type) const; extern template __attribute__((__visibility__("default"))) basic_string<wchar_t>& basic_string<wchar_t>::insert(size_type, value_type const*, size_type); extern template __attribute__((__visibility__("default"))) basic_string<wchar_t>::size_type basic_string<wchar_t>::find_first_of(value_type const*, size_type, size_type) const; extern template __attribute__((__visibility__("default"))) basic_string<wchar_t>& basic_string<wchar_t>::replace(size_type, size_type, size_type, value_type); extern template __attribute__((__visibility__("default"))) basic_string<wchar_t>& basic_string<wchar_t>::assign(value_type const*, size_type); extern template __attribute__((__visibility__("default"))) void basic_string<wchar_t>::reserve(size_type); extern template __attribute__((__visibility__("default"))) basic_string<wchar_t>& basic_string<wchar_t>::append(value_type const*, size_type); extern template __attribute__((__visibility__("default"))) basic_string<wchar_t>& basic_string<wchar_t>::assign(basic_string const&, size_type, size_type); extern template __attribute__((__visibility__("default"))) basic_string<wchar_t>::size_type basic_string<wchar_t>::copy(value_type*, size_type, size_type) const; extern template __attribute__((__visibility__("default"))) basic_string<wchar_t>::basic_string(basic_string const&, size_type, size_type, allocator<wchar_t> const&); extern template __attribute__((__visibility__("default"))) basic_string<wchar_t>::size_type basic_string<wchar_t>::find(value_type, size_type) const; extern template __attribute__((__visibility__("default"))) void basic_string<wchar_t>::__init(size_type, value_type); extern template __attribute__((__visibility__("default"))) basic_string<wchar_t>& basic_string<wchar_t>::insert(size_type, value_type const*); extern template __attribute__((__visibility__("default"))) basic_string<wchar_t>::size_type basic_string<wchar_t>::find_last_of(value_type const*, size_type, size_type) const; extern template __attribute__((__visibility__("default"))) void basic_string<wchar_t>::__grow_by(size_type, size_type, size_type, size_type, size_type, size_type); extern template __attribute__((__visibility__("default"))) void basic_string<wchar_t>::__grow_by_and_replace(size_type, size_type, size_type, size_type, size_type, size_type, value_type const*); extern template __attribute__((__visibility__("default"))) void basic_string<wchar_t>::push_back(value_type); extern template __attribute__((__visibility__("default"))) basic_string<wchar_t>& basic_string<wchar_t>::append(size_type, value_type); extern template __attribute__((__visibility__("default"))) basic_string<wchar_t>::size_type basic_string<wchar_t>::rfind(value_type, size_type) const; extern template __attribute__((__visibility__("default"))) const basic_string<wchar_t>::size_type basic_string<wchar_t>::npos; extern template __attribute__((__visibility__("default"))) basic_string<wchar_t>& basic_string<wchar_t>::assign(size_type, value_type); extern template __attribute__((__visibility__("default"))) basic_string<wchar_t>& basic_string<wchar_t>::erase(size_type, size_type); extern template __attribute__((__visibility__("default"))) basic_string<wchar_t>& basic_string<wchar_t>::append(basic_string const&, size_type, size_type); extern template __attribute__((__visibility__("default"))) int basic_string<wchar_t>::compare(value_type const*) const; extern template __attribute__((__visibility__("default"))) int basic_string<wchar_t>::compare(size_type, size_type, value_type const*) const; extern template __attribute__((__visibility__("default"))) wchar_t& basic_string<wchar_t>::at(size_type); extern template __attribute__((__visibility__("default"))) basic_string<wchar_t>& basic_string<wchar_t>::assign(value_type const*); extern template __attribute__((__visibility__("default"))) basic_string<wchar_t>::size_type basic_string<wchar_t>::find(value_type const*, size_type, size_type) const; extern template __attribute__((__visibility__("default"))) int basic_string<wchar_t>::compare(size_type, size_type, basic_string const&, size_type, size_type) const; extern template __attribute__((__visibility__("default"))) int basic_string<wchar_t>::compare(size_type, size_type, value_type const*, size_type) const; extern template __attribute__((__visibility__("default"))) basic_string<wchar_t>& basic_string<wchar_t>::operator=(basic_string const&); extern template __attribute__((__visibility__("default"))) basic_string<wchar_t>& basic_string<wchar_t>::append(value_type const*); extern template __attribute__((__visibility__("default"))) basic_string<wchar_t>& basic_string<wchar_t>::replace(size_type, size_type, basic_string const&, size_type, size_type); extern template __attribute__((__visibility__("default"))) basic_string<wchar_t>::iterator basic_string<wchar_t>::insert(basic_string::const_iterator, value_type); extern template __attribute__((__visibility__("default"))) void basic_string<wchar_t>::resize(size_type, value_type); extern template __attribute__((__visibility__("default"))) basic_string<wchar_t>& basic_string<wchar_t>::insert(size_type, basic_string const&, size_type, size_type);






template<class _InputIterator,
         class _CharT = __iter_value_type<_InputIterator>,
         class _Allocator = allocator<_CharT>,
         class = enable_if_t<__has_input_iterator_category<_InputIterator>::value>,
         class = enable_if_t<__is_allocator<_Allocator>::value>
         >
basic_string(_InputIterator, _InputIterator, _Allocator = _Allocator())
  -> basic_string<_CharT, char_traits<_CharT>, _Allocator>;

template<class _CharT,
         class _Traits,
         class _Allocator = allocator<_CharT>,
         class = enable_if_t<__is_allocator<_Allocator>::value>
         >
explicit basic_string(basic_string_view<_CharT, _Traits>, const _Allocator& = _Allocator())
  -> basic_string<_CharT, _Traits, _Allocator>;

template<class _CharT,
         class _Traits,
         class _Allocator = allocator<_CharT>,
         class = enable_if_t<__is_allocator<_Allocator>::value>,
         class _Sz = typename allocator_traits<_Allocator>::size_type
         >
basic_string(basic_string_view<_CharT, _Traits>, _Sz, _Sz, const _Allocator& = _Allocator())
  -> basic_string<_CharT, _Traits, _Allocator>;



template <ranges::input_range _Range,
          class _Allocator = allocator<ranges::range_value_t<_Range>>,
          class = enable_if_t<__is_allocator<_Allocator>::value>
          >
basic_string(from_range_t, _Range&&, _Allocator = _Allocator())
  -> basic_string<ranges::range_value_t<_Range>, char_traits<ranges::range_value_t<_Range>>, _Allocator>;


template <class _CharT, class _Traits, class _Allocator>
constexpr
void basic_string<_CharT, _Traits, _Allocator>::__init(const value_type* __s,
                                                       size_type __sz,
                                                       size_type __reserve)
{
    if (__libcpp_is_constant_evaluated())
        __r_.first() = __rep();
    if (__reserve > max_size())
        __throw_length_error();
    pointer __p;
    if (__fits_in_sso(__reserve))
    {
        __set_short_size(__sz);
        __p = __get_short_pointer();
    }
    else
    {
        auto __allocation = std::__allocate_at_least(__alloc(), __recommend(__reserve) + 1);
        __p = __allocation.ptr;
        __begin_lifetime(__p, __allocation.count);
        __set_long_pointer(__p);
        __set_long_cap(__allocation.count);
        __set_long_size(__sz);
    }
    traits_type::copy(std::__to_address(__p), __s, __sz);
    traits_type::assign(__p[__sz], value_type());
}

template <class _CharT, class _Traits, class _Allocator>
constexpr
void
basic_string<_CharT, _Traits, _Allocator>::__init(const value_type* __s, size_type __sz)
{
    if (__libcpp_is_constant_evaluated())
        __r_.first() = __rep();
    if (__sz > max_size())
        __throw_length_error();
    pointer __p;
    if (__fits_in_sso(__sz))
    {
        __set_short_size(__sz);
        __p = __get_short_pointer();
    }
    else
    {
        auto __allocation = std::__allocate_at_least(__alloc(), __recommend(__sz) + 1);
        __p = __allocation.ptr;
        __begin_lifetime(__p, __allocation.count);
        __set_long_pointer(__p);
        __set_long_cap(__allocation.count);
        __set_long_size(__sz);
    }
    traits_type::copy(std::__to_address(__p), __s, __sz);
    traits_type::assign(__p[__sz], value_type());
}

template <class _CharT, class _Traits, class _Allocator>
constexpr
void basic_string<_CharT, _Traits, _Allocator>::__init_copy_ctor_external(
    const value_type* __s, size_type __sz) {
  if (__libcpp_is_constant_evaluated())
    __r_.first() = __rep();

  pointer __p;
  if (__fits_in_sso(__sz)) {
    __p = __get_short_pointer();
    __set_short_size(__sz);
  } else {
    if (__sz > max_size())
      __throw_length_error();
    auto __allocation = std::__allocate_at_least(__alloc(), __recommend(__sz) + 1);
    __p = __allocation.ptr;
    __begin_lifetime(__p, __allocation.count);
    __set_long_pointer(__p);
    __set_long_cap(__allocation.count);
    __set_long_size(__sz);
  }
  traits_type::copy(std::__to_address(__p), __s, __sz + 1);
}

template <class _CharT, class _Traits, class _Allocator>
constexpr
void
basic_string<_CharT, _Traits, _Allocator>::__init(size_type __n, value_type __c)
{
    if (__libcpp_is_constant_evaluated())
        __r_.first() = __rep();

    if (__n > max_size())
        __throw_length_error();
    pointer __p;
    if (__fits_in_sso(__n))
    {
        __set_short_size(__n);
        __p = __get_short_pointer();
    }
    else
    {
        auto __allocation = std::__allocate_at_least(__alloc(), __recommend(__n) + 1);
        __p = __allocation.ptr;
        __begin_lifetime(__p, __allocation.count);
        __set_long_pointer(__p);
        __set_long_cap(__allocation.count);
        __set_long_size(__n);
    }
    traits_type::assign(std::__to_address(__p), __n, __c);
    traits_type::assign(__p[__n], value_type());
}

template <class _CharT, class _Traits, class _Allocator>
template <class _InputIterator, __enable_if_t<__has_exactly_input_iterator_category<_InputIterator>::value, int> >
constexpr
void basic_string<_CharT, _Traits, _Allocator>::__init(_InputIterator __first, _InputIterator __last)
{
  __init_with_sentinel(std::move(__first), std::move(__last));
}

template <class _CharT, class _Traits, class _Allocator>
template <class _InputIterator, class _Sentinel>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
void basic_string<_CharT, _Traits, _Allocator>::__init_with_sentinel(_InputIterator __first, _Sentinel __last) {
    __default_init();





    for (; __first != __last; ++__first)
        push_back(*__first);
# 2255 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/string" 3
}

template <class _CharT, class _Traits, class _Allocator>
template <class _ForwardIterator, __enable_if_t<__has_forward_iterator_category<_ForwardIterator>::value, int> >
constexpr void
basic_string<_CharT, _Traits, _Allocator>::__init(_ForwardIterator __first, _ForwardIterator __last)
{
  size_type __sz = static_cast<size_type>(std::distance(__first, __last));
  __init_with_size(__first, __last, __sz);
}

template <class _CharT, class _Traits, class _Allocator>
template <class _InputIterator, class _Sentinel>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
void basic_string<_CharT, _Traits, _Allocator>::__init_with_size(
    _InputIterator __first, _Sentinel __last, size_type __sz) {
    if (__libcpp_is_constant_evaluated())
        __r_.first() = __rep();

    if (__sz > max_size())
        __throw_length_error();

    pointer __p;
    if (__fits_in_sso(__sz))
    {
        __set_short_size(__sz);
        __p = __get_short_pointer();

    }
    else
    {
        auto __allocation = std::__allocate_at_least(__alloc(), __recommend(__sz) + 1);
        __p = __allocation.ptr;
        __begin_lifetime(__p, __allocation.count);
        __set_long_pointer(__p);
        __set_long_cap(__allocation.count);
        __set_long_size(__sz);
    }





    for (; __first != __last; ++__first, (void) ++__p)
        traits_type::assign(*__p, *__first);
    traits_type::assign(*__p, value_type());
# 2310 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/string" 3
}

template <class _CharT, class _Traits, class _Allocator>
constexpr
void
basic_string<_CharT, _Traits, _Allocator>::__grow_by_and_replace
    (size_type __old_cap, size_type __delta_cap, size_type __old_sz,
     size_type __n_copy, size_type __n_del, size_type __n_add, const value_type* __p_new_stuff)
{
    size_type __ms = max_size();
    if (__delta_cap > __ms - __old_cap - 1)
        __throw_length_error();
    pointer __old_p = __get_pointer();
    size_type __cap = __old_cap < __ms / 2 - __alignment ?
                          __recommend(std::max(__old_cap + __delta_cap, 2 * __old_cap)) :
                          __ms - 1;
    auto __allocation = std::__allocate_at_least(__alloc(), __cap + 1);
    pointer __p = __allocation.ptr;
    __begin_lifetime(__p, __allocation.count);
    if (__n_copy != 0)
        traits_type::copy(std::__to_address(__p),
                          std::__to_address(__old_p), __n_copy);
    if (__n_add != 0)
        traits_type::copy(std::__to_address(__p) + __n_copy, __p_new_stuff, __n_add);
    size_type __sec_cp_sz = __old_sz - __n_del - __n_copy;
    if (__sec_cp_sz != 0)
        traits_type::copy(std::__to_address(__p) + __n_copy + __n_add,
                          std::__to_address(__old_p) + __n_copy + __n_del, __sec_cp_sz);
    if (__old_cap+1 != __min_cap || __libcpp_is_constant_evaluated())
        __alloc_traits::deallocate(__alloc(), __old_p, __old_cap+1);
    __set_long_pointer(__p);
    __set_long_cap(__allocation.count);
    __old_sz = __n_copy + __n_add + __sec_cp_sz;
    __set_long_size(__old_sz);
    traits_type::assign(__p[__old_sz], value_type());
}




template <class _CharT, class _Traits, class _Allocator>
void
constexpr



    __attribute__((__deprecated__("use __grow_by_without_replace")))
basic_string<_CharT, _Traits, _Allocator>::__grow_by(size_type __old_cap, size_type __delta_cap, size_type __old_sz,
                                                     size_type __n_copy, size_type __n_del, size_type __n_add)
{
    size_type __ms = max_size();
    if (__delta_cap > __ms - __old_cap)
        __throw_length_error();
    pointer __old_p = __get_pointer();
    size_type __cap = __old_cap < __ms / 2 - __alignment ?
                          __recommend(std::max(__old_cap + __delta_cap, 2 * __old_cap)) :
                          __ms - 1;
    auto __allocation = std::__allocate_at_least(__alloc(), __cap + 1);
    pointer __p = __allocation.ptr;
    __begin_lifetime(__p, __allocation.count);
    if (__n_copy != 0)
        traits_type::copy(std::__to_address(__p),
                          std::__to_address(__old_p), __n_copy);
    size_type __sec_cp_sz = __old_sz - __n_del - __n_copy;
    if (__sec_cp_sz != 0)
        traits_type::copy(std::__to_address(__p) + __n_copy + __n_add,
                          std::__to_address(__old_p) + __n_copy + __n_del,
                          __sec_cp_sz);
    if (__libcpp_is_constant_evaluated() || __old_cap + 1 != __min_cap)
        __alloc_traits::deallocate(__alloc(), __old_p, __old_cap + 1);
    __set_long_pointer(__p);
    __set_long_cap(__allocation.count);
}

template <class _CharT, class _Traits, class _Allocator>
void constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
basic_string<_CharT, _Traits, _Allocator>::__grow_by_without_replace(
    size_type __old_cap,
    size_type __delta_cap,
    size_type __old_sz,
    size_type __n_copy,
    size_type __n_del,
    size_type __n_add) {
#pragma GCC diagnostic push
# 2393 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/string" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
# 2393 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/string" 3
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
    __grow_by(__old_cap, __delta_cap, __old_sz, __n_copy, __n_del, __n_add);
#pragma GCC diagnostic pop
    __set_long_size(__old_sz - __n_del + __n_add);
}



template <class _CharT, class _Traits, class _Allocator>
template <bool __is_short>
constexpr
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::__assign_no_alias(
    const value_type* __s, size_type __n) {
  size_type __cap = __is_short ? static_cast<size_type>(__min_cap) : __get_long_cap();
  if (__n < __cap) {
    pointer __p = __is_short ? __get_short_pointer() : __get_long_pointer();
    __is_short ? __set_short_size(__n) : __set_long_size(__n);
    traits_type::copy(std::__to_address(__p), __s, __n);
    traits_type::assign(__p[__n], value_type());
  } else {
    size_type __sz = __is_short ? __get_short_size() : __get_long_size();
    __grow_by_and_replace(__cap - 1, __n - __cap + 1, __sz, 0, __sz, __n, __s);
  }
  return *this;
}

template <class _CharT, class _Traits, class _Allocator>
constexpr
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::__assign_external(
    const value_type* __s, size_type __n) {
  size_type __cap = capacity();
  if (__cap >= __n) {
    value_type* __p = std::__to_address(__get_pointer());
    traits_type::move(__p, __s, __n);
    return __null_terminate_at(__p, __n);
  } else {
    size_type __sz = size();
    __grow_by_and_replace(__cap, __n - __cap, __sz, 0, __sz, __n, __s);
    return *this;
  }
}

template <class _CharT, class _Traits, class _Allocator>
constexpr
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::assign(const value_type* __s, size_type __n)
{
    ((void)0);
    return (__builtin_constant_p(__n) && __fits_in_sso(__n))
               ? __assign_short(__s, __n)
               : __assign_external(__s, __n);
}

template <class _CharT, class _Traits, class _Allocator>
constexpr
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::assign(size_type __n, value_type __c)
{
    size_type __cap = capacity();
    if (__cap < __n)
    {
        size_type __sz = size();
        __grow_by_without_replace(__cap, __n - __cap, __sz, 0, __sz);
    }
    value_type* __p = std::__to_address(__get_pointer());
    traits_type::assign(__p, __n, __c);
    return __null_terminate_at(__p, __n);
}

template <class _CharT, class _Traits, class _Allocator>
constexpr
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::operator=(value_type __c)
{
    pointer __p;
    if (__is_long())
    {
        __p = __get_long_pointer();
        __set_long_size(1);
    }
    else
    {
        __p = __get_short_pointer();
        __set_short_size(1);
    }
    traits_type::assign(*__p, __c);
    traits_type::assign(*++__p, value_type());
    return *this;
}

template <class _CharT, class _Traits, class _Allocator>
constexpr
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::operator=(const basic_string& __str)
{
  if (this != std::addressof(__str)) {
    __copy_assign_alloc(__str);
    if (!__is_long()) {
      if (!__str.__is_long()) {
        __r_.first() = __str.__r_.first();
      } else {
        return __assign_no_alias<true>(__str.data(), __str.size());
      }
    } else {
      return __assign_no_alias<false>(__str.data(), __str.size());
    }
  }
  return *this;
}



template <class _CharT, class _Traits, class _Allocator>
inline constexpr
void
basic_string<_CharT, _Traits, _Allocator>::__move_assign(basic_string& __str, false_type)
    noexcept(__alloc_traits::is_always_equal::value)
{
    if (__alloc() != __str.__alloc())
        assign(__str);
    else
        __move_assign(__str, true_type());
}

template <class _CharT, class _Traits, class _Allocator>
inline constexpr
void
basic_string<_CharT, _Traits, _Allocator>::__move_assign(basic_string& __str, true_type)

    noexcept



{
  if (__is_long()) {
    __alloc_traits::deallocate(__alloc(), __get_long_pointer(),
                               __get_long_cap());






  }
  __move_assign_alloc(__str);
  __r_.first() = __str.__r_.first();
  if (__libcpp_is_constant_evaluated()) {
    __str.__default_init();
  } else {
    __str.__set_short_size(0);
    traits_type::assign(__str.__get_short_pointer()[0], value_type());
  }
}



template <class _CharT, class _Traits, class _Allocator>
template<class _InputIterator, __enable_if_t<__has_exactly_input_iterator_category<_InputIterator>::value, int> >
constexpr basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::assign(_InputIterator __first, _InputIterator __last)
{
  __assign_with_sentinel(__first, __last);
  return *this;
}

template <class _CharT, class _Traits, class _Allocator>
template <class _InputIterator, class _Sentinel>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
void
basic_string<_CharT, _Traits, _Allocator>::__assign_with_sentinel(_InputIterator __first, _Sentinel __last) {
  const basic_string __temp(__init_with_sentinel_tag(), std::move(__first), std::move(__last), __alloc());
  assign(__temp.data(), __temp.size());
}

template <class _CharT, class _Traits, class _Allocator>
template<class _ForwardIterator, __enable_if_t<__has_forward_iterator_category<_ForwardIterator>::value, int> >
constexpr basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::assign(_ForwardIterator __first, _ForwardIterator __last)
{
  if (__string_is_trivial_iterator<_ForwardIterator>::value) {
    size_type __n = static_cast<size_type>(std::distance(__first, __last));
    __assign_trivial(__first, __last, __n);
  } else {
    __assign_with_sentinel(__first, __last);
  }

  return *this;
}

template <class _CharT, class _Traits, class _Allocator>
template <class _Iterator, class _Sentinel>
constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
void
basic_string<_CharT, _Traits, _Allocator>::__assign_trivial(_Iterator __first, _Sentinel __last, size_type __n) {
  ((void)0);


  size_type __cap = capacity();
  if (__cap < __n) {






    size_type __sz = size();
    __grow_by_without_replace(__cap, __n - __cap, __sz, 0, __sz);
    }
    pointer __p = __get_pointer();
    for (; __first != __last; ++__p, (void) ++__first)
        traits_type::assign(*__p, *__first);
    traits_type::assign(*__p, value_type());
    __set_size(__n);
}

template <class _CharT, class _Traits, class _Allocator>
constexpr
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::assign(const basic_string& __str, size_type __pos, size_type __n)
{
    size_type __sz = __str.size();
    if (__pos > __sz)
        __throw_out_of_range();
    return assign(__str.data() + __pos, std::min(__n, __sz - __pos));
}

template <class _CharT, class _Traits, class _Allocator>
template <class _Tp,
          __enable_if_t<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value &&
                            !__is_same_uncvref<_Tp, basic_string<_CharT, _Traits, _Allocator> >::value,
                        int> >
constexpr basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::assign(const _Tp& __t, size_type __pos, size_type __n) {
    __self_view __sv = __t;
    size_type __sz = __sv.size();
    if (__pos > __sz)
        __throw_out_of_range();
    return assign(__sv.data() + __pos, std::min(__n, __sz - __pos));
}

template <class _CharT, class _Traits, class _Allocator>
constexpr
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::__assign_external(const value_type* __s) {
  return __assign_external(__s, traits_type::length(__s));
}

template <class _CharT, class _Traits, class _Allocator>
constexpr
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::assign(const value_type* __s)
{
    ((void)0);
    return __builtin_constant_p(*__s)
               ? (__fits_in_sso(traits_type::length(__s))
                      ? __assign_short(__s, traits_type::length(__s))
                      : __assign_external(__s, traits_type::length(__s)))
               : __assign_external(__s);
}


template <class _CharT, class _Traits, class _Allocator>
constexpr
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::append(const value_type* __s, size_type __n)
{
    ((void)0);
    size_type __cap = capacity();
    size_type __sz = size();
    if (__cap - __sz >= __n)
    {
        if (__n)
        {
            value_type* __p = std::__to_address(__get_pointer());
            traits_type::copy(__p + __sz, __s, __n);
            __sz += __n;
            __set_size(__sz);
            traits_type::assign(__p[__sz], value_type());
        }
    }
    else
        __grow_by_and_replace(__cap, __sz + __n - __cap, __sz, __sz, 0, __n, __s);
    return *this;
}

template <class _CharT, class _Traits, class _Allocator>
constexpr
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::append(size_type __n, value_type __c)
{
    if (__n)
    {
        size_type __cap = capacity();
        size_type __sz = size();
        if (__cap - __sz < __n)
            __grow_by_without_replace(__cap, __sz + __n - __cap, __sz, __sz, 0);
        pointer __p = __get_pointer();
        traits_type::assign(std::__to_address(__p) + __sz, __n, __c);
        __sz += __n;
        __set_size(__sz);
        traits_type::assign(__p[__sz], value_type());
    }
    return *this;
}

template <class _CharT, class _Traits, class _Allocator>
constexpr inline void
basic_string<_CharT, _Traits, _Allocator>::__append_default_init(size_type __n)
{
    if (__n)
    {
        size_type __cap = capacity();
        size_type __sz = size();
        if (__cap - __sz < __n)
            __grow_by_without_replace(__cap, __sz + __n - __cap, __sz, __sz, 0);
        pointer __p = __get_pointer();
        __sz += __n;
        __set_size(__sz);
        traits_type::assign(__p[__sz], value_type());
    }
}

template <class _CharT, class _Traits, class _Allocator>
constexpr
void
basic_string<_CharT, _Traits, _Allocator>::push_back(value_type __c)
{
    bool __is_short = !__is_long();
    size_type __cap;
    size_type __sz;
    if (__is_short)
    {
        __cap = __min_cap - 1;
        __sz = __get_short_size();
    }
    else
    {
        __cap = __get_long_cap() - 1;
        __sz = __get_long_size();
    }
    if (__sz == __cap)
    {
        __grow_by_without_replace(__cap, 1, __sz, __sz, 0);
        __is_short = false;
    }
    pointer __p = __get_pointer();
    if (__is_short)
    {
        __p = __get_short_pointer() + __sz;
        __set_short_size(__sz+1);
    }
    else
    {
        __p = __get_long_pointer() + __sz;
        __set_long_size(__sz+1);
    }
    traits_type::assign(*__p, __c);
    traits_type::assign(*++__p, value_type());
}

template <class _CharT, class _Traits, class _Allocator>
template<class _ForwardIterator, __enable_if_t<__has_forward_iterator_category<_ForwardIterator>::value, int> >
constexpr basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::append(
    _ForwardIterator __first, _ForwardIterator __last)
{
    size_type __sz = size();
    size_type __cap = capacity();
    size_type __n = static_cast<size_type>(std::distance(__first, __last));
    if (__n)
    {
        if (__string_is_trivial_iterator<_ForwardIterator>::value &&
            !__addr_in_range(*__first))
        {
            if (__cap - __sz < __n)
              __grow_by_without_replace(__cap, __sz + __n - __cap, __sz, __sz, 0);
            pointer __p = __get_pointer() + __sz;
            for (; __first != __last; ++__p, (void) ++__first)
                traits_type::assign(*__p, *__first);
            traits_type::assign(*__p, value_type());
            __set_size(__sz + __n);
        }
        else
        {
            const basic_string __temp(__first, __last, __alloc());
            append(__temp.data(), __temp.size());
        }
    }
    return *this;
}

template <class _CharT, class _Traits, class _Allocator>
constexpr
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::append(const basic_string& __str, size_type __pos, size_type __n)
{
    size_type __sz = __str.size();
    if (__pos > __sz)
        __throw_out_of_range();
    return append(__str.data() + __pos, std::min(__n, __sz - __pos));
}

template <class _CharT, class _Traits, class _Allocator>
template <class _Tp,
          __enable_if_t<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value &&
                            !__is_same_uncvref<_Tp, basic_string<_CharT, _Traits, _Allocator> >::value,
                        int> >
constexpr basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::append(const _Tp& __t, size_type __pos, size_type __n) {
    __self_view __sv = __t;
    size_type __sz = __sv.size();
    if (__pos > __sz)
        __throw_out_of_range();
    return append(__sv.data() + __pos, std::min(__n, __sz - __pos));
}

template <class _CharT, class _Traits, class _Allocator>
constexpr
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::append(const value_type* __s)
{
    ((void)0);
    return append(__s, traits_type::length(__s));
}



template <class _CharT, class _Traits, class _Allocator>
constexpr
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos, const value_type* __s, size_type __n)
{
    ((void)0);
    size_type __sz = size();
    if (__pos > __sz)
        __throw_out_of_range();
    size_type __cap = capacity();
    if (__libcpp_is_constant_evaluated()) {
        if (__cap - __sz >= __n)
            __grow_by_and_replace(__cap, 0, __sz, __pos, 0, __n, __s);
        else
            __grow_by_and_replace(__cap, __sz + __n - __cap, __sz, __pos, 0, __n, __s);
        return *this;
    }
    if (__cap - __sz >= __n)
    {
        if (__n)
        {
            value_type* __p = std::__to_address(__get_pointer());
            size_type __n_move = __sz - __pos;
            if (__n_move != 0)
            {
                if (__p + __pos <= __s && __s < __p + __sz)
                    __s += __n;
                traits_type::move(__p + __pos + __n, __p + __pos, __n_move);
            }
            traits_type::move(__p + __pos, __s, __n);
            __sz += __n;
            __set_size(__sz);
            traits_type::assign(__p[__sz], value_type());
        }
    }
    else
        __grow_by_and_replace(__cap, __sz + __n - __cap, __sz, __pos, 0, __n, __s);
    return *this;
}

template <class _CharT, class _Traits, class _Allocator>
constexpr
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos, size_type __n, value_type __c)
{
    size_type __sz = size();
    if (__pos > __sz)
        __throw_out_of_range();
    if (__n)
    {
        size_type __cap = capacity();
        value_type* __p;
        if (__cap - __sz >= __n)
        {
            __p = std::__to_address(__get_pointer());
            size_type __n_move = __sz - __pos;
            if (__n_move != 0)
                traits_type::move(__p + __pos + __n, __p + __pos, __n_move);
        }
        else
        {
            __grow_by_without_replace(__cap, __sz + __n - __cap, __sz, __pos, 0, __n);
            __p = std::__to_address(__get_long_pointer());
        }
        traits_type::assign(__p + __pos, __n, __c);
        __sz += __n;
        __set_size(__sz);
        traits_type::assign(__p[__sz], value_type());
    }
    return *this;
}

template <class _CharT, class _Traits, class _Allocator>
template<class _InputIterator, __enable_if_t<__has_exactly_input_iterator_category<_InputIterator>::value, int> >
constexpr typename basic_string<_CharT, _Traits, _Allocator>::iterator
basic_string<_CharT, _Traits, _Allocator>::insert(const_iterator __pos, _InputIterator __first, _InputIterator __last)
{
  const basic_string __temp(__first, __last, __alloc());
  return insert(__pos, __temp.data(), __temp.data() + __temp.size());
}

template <class _CharT, class _Traits, class _Allocator>
template<class _ForwardIterator, __enable_if_t<__has_forward_iterator_category<_ForwardIterator>::value, int> >
constexpr typename basic_string<_CharT, _Traits, _Allocator>::iterator
basic_string<_CharT, _Traits, _Allocator>::insert(const_iterator __pos, _ForwardIterator __first, _ForwardIterator __last)
{
    auto __n = static_cast<size_type>(std::distance(__first, __last));
    return __insert_with_size(__pos, __first, __last, __n);
}

template <class _CharT, class _Traits, class _Allocator>
template<class _Iterator, class _Sentinel>
constexpr
typename basic_string<_CharT, _Traits, _Allocator>::iterator
basic_string<_CharT, _Traits, _Allocator>::__insert_with_size(
    const_iterator __pos, _Iterator __first, _Sentinel __last, size_type __n) {
    size_type __ip = static_cast<size_type>(__pos - begin());
    if (__n == 0)
        return begin() + __ip;

    if (__string_is_trivial_iterator<_Iterator>::value && !__addr_in_range(*__first))
    {
        return __insert_from_safe_copy(__n, __ip, __first, __last);
    }
    else
    {
        const basic_string __temp(__init_with_sentinel_tag(), __first, __last, __alloc());
        return __insert_from_safe_copy(__n, __ip, __temp.begin(), __temp.end());
    }
}

template <class _CharT, class _Traits, class _Allocator>
constexpr
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos1, const basic_string& __str,
                                                  size_type __pos2, size_type __n)
{
    size_type __str_sz = __str.size();
    if (__pos2 > __str_sz)
        __throw_out_of_range();
    return insert(__pos1, __str.data() + __pos2, std::min(__n, __str_sz - __pos2));
}

template <class _CharT, class _Traits, class _Allocator>
template <class _Tp,
          __enable_if_t<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value &&
                            !__is_same_uncvref<_Tp, basic_string<_CharT, _Traits, _Allocator> >::value,
                        int> >
constexpr basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos1, const _Tp& __t, size_type __pos2, size_type __n) {
    __self_view __sv = __t;
    size_type __str_sz = __sv.size();
    if (__pos2 > __str_sz)
        __throw_out_of_range();
    return insert(__pos1, __sv.data() + __pos2, std::min(__n, __str_sz - __pos2));
}

template <class _CharT, class _Traits, class _Allocator>
constexpr
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos, const value_type* __s)
{
    ((void)0);
    return insert(__pos, __s, traits_type::length(__s));
}

template <class _CharT, class _Traits, class _Allocator>
constexpr
typename basic_string<_CharT, _Traits, _Allocator>::iterator
basic_string<_CharT, _Traits, _Allocator>::insert(const_iterator __pos, value_type __c)
{
    size_type __ip = static_cast<size_type>(__pos - begin());
    size_type __sz = size();
    size_type __cap = capacity();
    value_type* __p;
    if (__cap == __sz)
    {
        __grow_by_without_replace(__cap, 1, __sz, __ip, 0, 1);
        __p = std::__to_address(__get_long_pointer());
    }
    else
    {
        __p = std::__to_address(__get_pointer());
        size_type __n_move = __sz - __ip;
        if (__n_move != 0)
            traits_type::move(__p + __ip + 1, __p + __ip, __n_move);
    }
    traits_type::assign(__p[__ip], __c);
    traits_type::assign(__p[++__sz], value_type());
    __set_size(__sz);
    return begin() + static_cast<difference_type>(__ip);
}



template <class _CharT, class _Traits, class _Allocator>
constexpr
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos, size_type __n1, const value_type* __s, size_type __n2)
    __attribute__((__no_sanitize__("unsigned-integer-overflow")))
{
    ((void)0);
    size_type __sz = size();
    if (__pos > __sz)
        __throw_out_of_range();
    __n1 = std::min(__n1, __sz - __pos);
    size_type __cap = capacity();
    if (__cap - __sz + __n1 >= __n2)
    {
        value_type* __p = std::__to_address(__get_pointer());
        if (__n1 != __n2)
        {
            size_type __n_move = __sz - __pos - __n1;
            if (__n_move != 0)
            {
                if (__n1 > __n2)
                {
                    traits_type::move(__p + __pos, __s, __n2);
                    traits_type::move(__p + __pos + __n2, __p + __pos + __n1, __n_move);
                    return __null_terminate_at(__p, __sz + (__n2 - __n1));
                }
                if (std::__is_pointer_in_range(__p + __pos + 1, __p + __sz, __s))
                {
                    if (__p + __pos + __n1 <= __s)
                        __s += __n2 - __n1;
                    else
                    {
                        traits_type::move(__p + __pos, __s, __n1);
                        __pos += __n1;
                        __s += __n2;
                        __n2 -= __n1;
                        __n1 = 0;
                    }
                }
                traits_type::move(__p + __pos + __n2, __p + __pos + __n1, __n_move);
            }
        }
        traits_type::move(__p + __pos, __s, __n2);
        return __null_terminate_at(__p, __sz + (__n2 - __n1));
    }
    else
        __grow_by_and_replace(__cap, __sz - __n1 + __n2 - __cap, __sz, __pos, __n1, __n2, __s);
    return *this;
}

template <class _CharT, class _Traits, class _Allocator>
constexpr
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos, size_type __n1, size_type __n2, value_type __c)
{
    size_type __sz = size();
    if (__pos > __sz)
        __throw_out_of_range();
    __n1 = std::min(__n1, __sz - __pos);
    size_type __cap = capacity();
    value_type* __p;
    if (__cap - __sz + __n1 >= __n2)
    {
        __p = std::__to_address(__get_pointer());
        if (__n1 != __n2)
        {
            size_type __n_move = __sz - __pos - __n1;
            if (__n_move != 0)
                traits_type::move(__p + __pos + __n2, __p + __pos + __n1, __n_move);
        }
    }
    else
    {
        __grow_by_without_replace(__cap, __sz - __n1 + __n2 - __cap, __sz, __pos, __n1, __n2);
        __p = std::__to_address(__get_long_pointer());
    }
    traits_type::assign(__p + __pos, __n2, __c);
    return __null_terminate_at(__p, __sz - (__n1 - __n2));
}

template <class _CharT, class _Traits, class _Allocator>
template<class _InputIterator, __enable_if_t<__has_input_iterator_category<_InputIterator>::value, int> >
constexpr basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::replace(const_iterator __i1, const_iterator __i2,
                                                   _InputIterator __j1, _InputIterator __j2)
{
    const basic_string __temp(__j1, __j2, __alloc());
    return replace(__i1, __i2, __temp);
}

template <class _CharT, class _Traits, class _Allocator>
constexpr
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos1, size_type __n1, const basic_string& __str,
                                                   size_type __pos2, size_type __n2)
{
    size_type __str_sz = __str.size();
    if (__pos2 > __str_sz)
        __throw_out_of_range();
    return replace(__pos1, __n1, __str.data() + __pos2, std::min(__n2, __str_sz - __pos2));
}

template <class _CharT, class _Traits, class _Allocator>
template <class _Tp,
          __enable_if_t<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value &&
                            !__is_same_uncvref<_Tp, basic_string<_CharT, _Traits, _Allocator> >::value,
                        int> >
constexpr basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::replace(
    size_type __pos1, size_type __n1, const _Tp& __t, size_type __pos2, size_type __n2) {
    __self_view __sv = __t;
    size_type __str_sz = __sv.size();
    if (__pos2 > __str_sz)
        __throw_out_of_range();
    return replace(__pos1, __n1, __sv.data() + __pos2, std::min(__n2, __str_sz - __pos2));
}

template <class _CharT, class _Traits, class _Allocator>
constexpr
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos, size_type __n1, const value_type* __s)
{
    ((void)0);
    return replace(__pos, __n1, __s, traits_type::length(__s));
}





template <class _CharT, class _Traits, class _Allocator>
constexpr
void
basic_string<_CharT, _Traits, _Allocator>::__erase_external_with_move(
    size_type __pos, size_type __n)
{
    if (__n)
    {
        size_type __sz = size();
        value_type* __p = std::__to_address(__get_pointer());
        __n = std::min(__n, __sz - __pos);
        size_type __n_move = __sz - __pos - __n;
        if (__n_move != 0)
            traits_type::move(__p + __pos, __p + __pos + __n, __n_move);
        __null_terminate_at(__p, __sz - __n);
    }
}

template <class _CharT, class _Traits, class _Allocator>
constexpr
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::erase(size_type __pos,
                                                 size_type __n) {
  if (__pos > size())
    __throw_out_of_range();
  if (__n == npos) {
    __erase_to_end(__pos);
  } else {
    __erase_external_with_move(__pos, __n);
  }
  return *this;
}

template <class _CharT, class _Traits, class _Allocator>
inline constexpr
typename basic_string<_CharT, _Traits, _Allocator>::iterator
basic_string<_CharT, _Traits, _Allocator>::erase(const_iterator __pos)
{
  ((void)0);

  iterator __b = begin();
  size_type __r = static_cast<size_type>(__pos - __b);
  erase(__r, 1);
  return __b + static_cast<difference_type>(__r);
}

template <class _CharT, class _Traits, class _Allocator>
inline constexpr
typename basic_string<_CharT, _Traits, _Allocator>::iterator
basic_string<_CharT, _Traits, _Allocator>::erase(const_iterator __first, const_iterator __last)
{
  ((void)0);
  iterator __b = begin();
  size_type __r = static_cast<size_type>(__first - __b);
  erase(__r, static_cast<size_type>(__last - __first));
  return __b + static_cast<difference_type>(__r);
}

template <class _CharT, class _Traits, class _Allocator>
inline constexpr
void
basic_string<_CharT, _Traits, _Allocator>::pop_back()
{
    ((void)0);
    __erase_to_end(size() - 1);
}

template <class _CharT, class _Traits, class _Allocator>
inline constexpr
void
basic_string<_CharT, _Traits, _Allocator>::clear() noexcept
{
    if (__is_long())
    {
        traits_type::assign(*__get_long_pointer(), value_type());
        __set_long_size(0);
    }
    else
    {
        traits_type::assign(*__get_short_pointer(), value_type());
        __set_short_size(0);
    }
}

template <class _CharT, class _Traits, class _Allocator>
constexpr
void
basic_string<_CharT, _Traits, _Allocator>::resize(size_type __n, value_type __c)
{
    size_type __sz = size();
    if (__n > __sz)
        append(__n - __sz, __c);
    else
        __erase_to_end(__n);
}

template <class _CharT, class _Traits, class _Allocator>
constexpr inline void
basic_string<_CharT, _Traits, _Allocator>::__resize_default_init(size_type __n)
{
    size_type __sz = size();
    if (__n > __sz) {
       __append_default_init(__n - __sz);
    } else
        __erase_to_end(__n);
}

template <class _CharT, class _Traits, class _Allocator>
constexpr
void
basic_string<_CharT, _Traits, _Allocator>::reserve(size_type __requested_capacity)
{
    if (__requested_capacity > max_size())
        __throw_length_error();




    if (__requested_capacity <= capacity())
        return;

    size_type __target_capacity = std::max(__requested_capacity, size());
    __target_capacity = __recommend(__target_capacity);
    if (__target_capacity == capacity()) return;

    __shrink_or_extend(__target_capacity);
}

template <class _CharT, class _Traits, class _Allocator>
inline constexpr
void
basic_string<_CharT, _Traits, _Allocator>::shrink_to_fit() noexcept
{
    size_type __target_capacity = __recommend(size());
    if (__target_capacity == capacity()) return;

    __shrink_or_extend(__target_capacity);
}

template <class _CharT, class _Traits, class _Allocator>
inline constexpr
void
basic_string<_CharT, _Traits, _Allocator>::__shrink_or_extend(size_type __target_capacity)
{
    size_type __cap = capacity();
    size_type __sz = size();

    pointer __new_data, __p;
    bool __was_long, __now_long;
    if (__fits_in_sso(__target_capacity))
    {
        __was_long = true;
        __now_long = false;
        __new_data = __get_short_pointer();
        __p = __get_long_pointer();
    }
    else
    {
        if (__target_capacity > __cap) {
            auto __allocation = std::__allocate_at_least(__alloc(), __target_capacity + 1);
            __new_data = __allocation.ptr;
            __target_capacity = __allocation.count - 1;
        }
        else
        {




                auto __allocation = std::__allocate_at_least(__alloc(), __target_capacity + 1);
                __new_data = __allocation.ptr;
                __target_capacity = __allocation.count - 1;







            if (__new_data == nullptr)
                return;

        }
        __begin_lifetime(__new_data, __target_capacity + 1);
        __now_long = true;
        __was_long = __is_long();
        __p = __get_pointer();
    }
    traits_type::copy(std::__to_address(__new_data),
                      std::__to_address(__p), size()+1);
    if (__was_long)
        __alloc_traits::deallocate(__alloc(), __p, __cap+1);
    if (__now_long)
    {
        __set_long_cap(__target_capacity+1);
        __set_long_size(__sz);
        __set_long_pointer(__new_data);
    }
    else
        __set_short_size(__sz);
}

template <class _CharT, class _Traits, class _Allocator>
constexpr
typename basic_string<_CharT, _Traits, _Allocator>::const_reference
basic_string<_CharT, _Traits, _Allocator>::at(size_type __n) const
{
    if (__n >= size())
        __throw_out_of_range();
    return (*this)[__n];
}

template <class _CharT, class _Traits, class _Allocator>
constexpr
typename basic_string<_CharT, _Traits, _Allocator>::reference
basic_string<_CharT, _Traits, _Allocator>::at(size_type __n)
{
    if (__n >= size())
        __throw_out_of_range();
    return (*this)[__n];
}

template <class _CharT, class _Traits, class _Allocator>
constexpr
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::copy(value_type* __s, size_type __n, size_type __pos) const
{
    size_type __sz = size();
    if (__pos > __sz)
        __throw_out_of_range();
    size_type __rlen = std::min(__n, __sz - __pos);
    traits_type::copy(__s, data() + __pos, __rlen);
    return __rlen;
}

template <class _CharT, class _Traits, class _Allocator>
inline constexpr
void
basic_string<_CharT, _Traits, _Allocator>::swap(basic_string& __str)

        noexcept




{
    ((void)0);



    std::swap(__r_.first(), __str.__r_.first());
    std::__swap_allocator(__alloc(), __str.__alloc());
}



template <class _Traits>
struct __attribute__((__visibility__("hidden"))) __traits_eq
{
    typedef typename _Traits::char_type char_type;
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    bool operator()(const char_type& __x, const char_type& __y) noexcept
        {return _Traits::eq(__x, __y);}
};

template<class _CharT, class _Traits, class _Allocator>
constexpr
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find(const value_type* __s,
                                                size_type __pos,
                                                size_type __n) const noexcept
{
    ((void)0);
    return std::__str_find<value_type, size_type, traits_type, npos>
        (data(), size(), __s, __pos, __n);
}

template<class _CharT, class _Traits, class _Allocator>
inline constexpr
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find(const basic_string& __str,
                                                size_type __pos) const noexcept
{
    return std::__str_find<value_type, size_type, traits_type, npos>
        (data(), size(), __str.data(), __pos, __str.size());
}

template<class _CharT, class _Traits, class _Allocator>
template <class _Tp, __enable_if_t<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value, int> >
constexpr typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find(const _Tp &__t,
                                                size_type __pos) const noexcept
{
    __self_view __sv = __t;
    return std::__str_find<value_type, size_type, traits_type, npos>
        (data(), size(), __sv.data(), __pos, __sv.size());
}

template<class _CharT, class _Traits, class _Allocator>
inline constexpr
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find(const value_type* __s,
                                                size_type __pos) const noexcept
{
    ((void)0);
    return std::__str_find<value_type, size_type, traits_type, npos>
        (data(), size(), __s, __pos, traits_type::length(__s));
}

template<class _CharT, class _Traits, class _Allocator>
constexpr
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find(value_type __c,
                                                size_type __pos) const noexcept
{
    return std::__str_find<value_type, size_type, traits_type, npos>
        (data(), size(), __c, __pos);
}



template<class _CharT, class _Traits, class _Allocator>
constexpr
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::rfind(const value_type* __s,
                                                 size_type __pos,
                                                 size_type __n) const noexcept
{
    ((void)0);
    return std::__str_rfind<value_type, size_type, traits_type, npos>
        (data(), size(), __s, __pos, __n);
}

template<class _CharT, class _Traits, class _Allocator>
inline constexpr
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::rfind(const basic_string& __str,
                                                 size_type __pos) const noexcept
{
    return std::__str_rfind<value_type, size_type, traits_type, npos>
        (data(), size(), __str.data(), __pos, __str.size());
}

template<class _CharT, class _Traits, class _Allocator>
template <class _Tp, __enable_if_t<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value, int> >
constexpr typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::rfind(const _Tp& __t,
                                                size_type __pos) const noexcept
{
    __self_view __sv = __t;
    return std::__str_rfind<value_type, size_type, traits_type, npos>
        (data(), size(), __sv.data(), __pos, __sv.size());
}

template<class _CharT, class _Traits, class _Allocator>
inline constexpr
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::rfind(const value_type* __s,
                                                 size_type __pos) const noexcept
{
    ((void)0);
    return std::__str_rfind<value_type, size_type, traits_type, npos>
        (data(), size(), __s, __pos, traits_type::length(__s));
}

template<class _CharT, class _Traits, class _Allocator>
constexpr
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::rfind(value_type __c,
                                                 size_type __pos) const noexcept
{
    return std::__str_rfind<value_type, size_type, traits_type, npos>
        (data(), size(), __c, __pos);
}



template<class _CharT, class _Traits, class _Allocator>
constexpr
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_first_of(const value_type* __s,
                                                         size_type __pos,
                                                         size_type __n) const noexcept
{
    ((void)0);
    return std::__str_find_first_of<value_type, size_type, traits_type, npos>
        (data(), size(), __s, __pos, __n);
}

template<class _CharT, class _Traits, class _Allocator>
inline constexpr
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_first_of(const basic_string& __str,
                                                         size_type __pos) const noexcept
{
    return std::__str_find_first_of<value_type, size_type, traits_type, npos>
        (data(), size(), __str.data(), __pos, __str.size());
}

template<class _CharT, class _Traits, class _Allocator>
template <class _Tp, __enable_if_t<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value, int> >
constexpr typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_first_of(const _Tp& __t,
                                                size_type __pos) const noexcept
{
    __self_view __sv = __t;
    return std::__str_find_first_of<value_type, size_type, traits_type, npos>
        (data(), size(), __sv.data(), __pos, __sv.size());
}

template<class _CharT, class _Traits, class _Allocator>
inline constexpr
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_first_of(const value_type* __s,
                                                         size_type __pos) const noexcept
{
    ((void)0);
    return std::__str_find_first_of<value_type, size_type, traits_type, npos>
        (data(), size(), __s, __pos, traits_type::length(__s));
}

template<class _CharT, class _Traits, class _Allocator>
inline constexpr
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_first_of(value_type __c,
                                                         size_type __pos) const noexcept
{
    return find(__c, __pos);
}



template<class _CharT, class _Traits, class _Allocator>
inline constexpr
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_last_of(const value_type* __s,
                                                        size_type __pos,
                                                        size_type __n) const noexcept
{
    ((void)0);
    return std::__str_find_last_of<value_type, size_type, traits_type, npos>
        (data(), size(), __s, __pos, __n);
}

template<class _CharT, class _Traits, class _Allocator>
inline constexpr
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_last_of(const basic_string& __str,
                                                        size_type __pos) const noexcept
{
    return std::__str_find_last_of<value_type, size_type, traits_type, npos>
        (data(), size(), __str.data(), __pos, __str.size());
}

template<class _CharT, class _Traits, class _Allocator>
template <class _Tp, __enable_if_t<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value, int> >
constexpr typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_last_of(const _Tp& __t,
                                                size_type __pos) const noexcept
{
    __self_view __sv = __t;
    return std::__str_find_last_of<value_type, size_type, traits_type, npos>
        (data(), size(), __sv.data(), __pos, __sv.size());
}

template<class _CharT, class _Traits, class _Allocator>
inline constexpr
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_last_of(const value_type* __s,
                                                        size_type __pos) const noexcept
{
    ((void)0);
    return std::__str_find_last_of<value_type, size_type, traits_type, npos>
        (data(), size(), __s, __pos, traits_type::length(__s));
}

template<class _CharT, class _Traits, class _Allocator>
inline constexpr
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_last_of(value_type __c,
                                                        size_type __pos) const noexcept
{
    return rfind(__c, __pos);
}



template<class _CharT, class _Traits, class _Allocator>
constexpr
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_first_not_of(const value_type* __s,
                                                             size_type __pos,
                                                             size_type __n) const noexcept
{
    ((void)0);
    return std::__str_find_first_not_of<value_type, size_type, traits_type, npos>
        (data(), size(), __s, __pos, __n);
}

template<class _CharT, class _Traits, class _Allocator>
inline constexpr
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_first_not_of(const basic_string& __str,
                                                             size_type __pos) const noexcept
{
    return std::__str_find_first_not_of<value_type, size_type, traits_type, npos>
        (data(), size(), __str.data(), __pos, __str.size());
}

template<class _CharT, class _Traits, class _Allocator>
template <class _Tp, __enable_if_t<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value, int> >
constexpr typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_first_not_of(const _Tp& __t,
                                                size_type __pos) const noexcept
{
    __self_view __sv = __t;
    return std::__str_find_first_not_of<value_type, size_type, traits_type, npos>
        (data(), size(), __sv.data(), __pos, __sv.size());
}

template<class _CharT, class _Traits, class _Allocator>
inline constexpr
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_first_not_of(const value_type* __s,
                                                             size_type __pos) const noexcept
{
    ((void)0);
    return std::__str_find_first_not_of<value_type, size_type, traits_type, npos>
        (data(), size(), __s, __pos, traits_type::length(__s));
}

template<class _CharT, class _Traits, class _Allocator>
inline constexpr
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_first_not_of(value_type __c,
                                                             size_type __pos) const noexcept
{
    return std::__str_find_first_not_of<value_type, size_type, traits_type, npos>
        (data(), size(), __c, __pos);
}



template<class _CharT, class _Traits, class _Allocator>
constexpr
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_last_not_of(const value_type* __s,
                                                            size_type __pos,
                                                            size_type __n) const noexcept
{
    ((void)0);
    return std::__str_find_last_not_of<value_type, size_type, traits_type, npos>
        (data(), size(), __s, __pos, __n);
}

template<class _CharT, class _Traits, class _Allocator>
inline constexpr
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_last_not_of(const basic_string& __str,
                                                            size_type __pos) const noexcept
{
    return std::__str_find_last_not_of<value_type, size_type, traits_type, npos>
        (data(), size(), __str.data(), __pos, __str.size());
}

template<class _CharT, class _Traits, class _Allocator>
template <class _Tp, __enable_if_t<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value, int> >
constexpr typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_last_not_of(const _Tp& __t,
                                                size_type __pos) const noexcept
{
    __self_view __sv = __t;
    return std::__str_find_last_not_of<value_type, size_type, traits_type, npos>
        (data(), size(), __sv.data(), __pos, __sv.size());
}

template<class _CharT, class _Traits, class _Allocator>
inline constexpr
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_last_not_of(const value_type* __s,
                                                            size_type __pos) const noexcept
{
    ((void)0);
    return std::__str_find_last_not_of<value_type, size_type, traits_type, npos>
        (data(), size(), __s, __pos, traits_type::length(__s));
}

template<class _CharT, class _Traits, class _Allocator>
inline constexpr
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_last_not_of(value_type __c,
                                                            size_type __pos) const noexcept
{
    return std::__str_find_last_not_of<value_type, size_type, traits_type, npos>
        (data(), size(), __c, __pos);
}



template <class _CharT, class _Traits, class _Allocator>
template <class _Tp, __enable_if_t<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value, int> >
constexpr int
basic_string<_CharT, _Traits, _Allocator>::compare(const _Tp& __t) const noexcept
{
    __self_view __sv = __t;
    size_t __lhs_sz = size();
    size_t __rhs_sz = __sv.size();
    int __result = traits_type::compare(data(), __sv.data(),
                                        std::min(__lhs_sz, __rhs_sz));
    if (__result != 0)
        return __result;
    if (__lhs_sz < __rhs_sz)
        return -1;
    if (__lhs_sz > __rhs_sz)
        return 1;
    return 0;
}

template <class _CharT, class _Traits, class _Allocator>
inline constexpr
int
basic_string<_CharT, _Traits, _Allocator>::compare(const basic_string& __str) const noexcept
{
    return compare(__self_view(__str));
}

template <class _CharT, class _Traits, class _Allocator>
inline constexpr
int
basic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,
                                                   size_type __n1,
                                                   const value_type* __s,
                                                   size_type __n2) const
{
    ((void)0);
    size_type __sz = size();
    if (__pos1 > __sz || __n2 == npos)
        __throw_out_of_range();
    size_type __rlen = std::min(__n1, __sz - __pos1);
    int __r = traits_type::compare(data() + __pos1, __s, std::min(__rlen, __n2));
    if (__r == 0)
    {
        if (__rlen < __n2)
            __r = -1;
        else if (__rlen > __n2)
            __r = 1;
    }
    return __r;
}

template <class _CharT, class _Traits, class _Allocator>
template <class _Tp, __enable_if_t<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value, int> >
constexpr int
basic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,
                                                   size_type __n1,
                                                   const _Tp& __t) const
{
    __self_view __sv = __t;
    return compare(__pos1, __n1, __sv.data(), __sv.size());
}

template <class _CharT, class _Traits, class _Allocator>
inline constexpr
int
basic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,
                                                   size_type __n1,
                                                   const basic_string& __str) const
{
    return compare(__pos1, __n1, __str.data(), __str.size());
}

template <class _CharT, class _Traits, class _Allocator>
template <class _Tp,
          __enable_if_t<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value &&
                            !__is_same_uncvref<_Tp, basic_string<_CharT, _Traits, _Allocator> >::value,
                        int> >
constexpr int basic_string<_CharT, _Traits, _Allocator>::compare(
    size_type __pos1, size_type __n1, const _Tp& __t, size_type __pos2, size_type __n2) const {
    __self_view __sv = __t;
    return __self_view(*this).substr(__pos1, __n1).compare(__sv.substr(__pos2, __n2));
}

template <class _CharT, class _Traits, class _Allocator>
constexpr
int
basic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,
                                                   size_type __n1,
                                                   const basic_string& __str,
                                                   size_type __pos2,
                                                   size_type __n2) const
{
    return compare(__pos1, __n1, __self_view(__str), __pos2, __n2);
}

template <class _CharT, class _Traits, class _Allocator>
constexpr
int
basic_string<_CharT, _Traits, _Allocator>::compare(const value_type* __s) const noexcept
{
    ((void)0);
    return compare(0, npos, __s, traits_type::length(__s));
}

template <class _CharT, class _Traits, class _Allocator>
constexpr
int
basic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,
                                                   size_type __n1,
                                                   const value_type* __s) const
{
    ((void)0);
    return compare(__pos1, __n1, __s, traits_type::length(__s));
}



template<class _CharT, class _Traits, class _Allocator>
inline constexpr
bool
basic_string<_CharT, _Traits, _Allocator>::__invariants() const
{
    if (size() > capacity())
        return false;
    if (capacity() < __min_cap - 1)
        return false;
    if (data() == nullptr)
        return false;
    if (!_Traits::eq(data()[size()], value_type()))
        return false;
    return true;
}



template<class _CharT, class _Traits, class _Allocator>
inline constexpr
void
basic_string<_CharT, _Traits, _Allocator>::__clear_and_shrink() noexcept
{
    clear();
    if(__is_long())
    {
        __alloc_traits::deallocate(__alloc(), __get_long_pointer(), capacity() + 1);
        __default_init();
    }
}



template<class _CharT, class _Traits, class _Allocator>
inline constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
bool
operator==(const basic_string<_CharT, _Traits, _Allocator>& __lhs,
           const basic_string<_CharT, _Traits, _Allocator>& __rhs) noexcept
{

    return basic_string_view<_CharT, _Traits>(__lhs) == basic_string_view<_CharT, _Traits>(__rhs);






}

template<class _Allocator>
inline constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
bool
operator==(const basic_string<char, char_traits<char>, _Allocator>& __lhs,
           const basic_string<char, char_traits<char>, _Allocator>& __rhs) noexcept
{
    size_t __lhs_sz = __lhs.size();
    if (__lhs_sz != __rhs.size())
        return false;
    const char* __lp = __lhs.data();
    const char* __rp = __rhs.data();
    if (__lhs.__is_long())
        return char_traits<char>::compare(__lp, __rp, __lhs_sz) == 0;
    for (; __lhs_sz != 0; --__lhs_sz, ++__lp, ++__rp)
        if (*__lp != *__rp)
            return false;
    return true;
}
# 3926 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/string" 3
template<class _CharT, class _Traits, class _Allocator>
inline constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
bool
operator==(const basic_string<_CharT,_Traits,_Allocator>& __lhs,
           const _CharT* __rhs) noexcept
{

    return basic_string_view<_CharT, _Traits>(__lhs) == basic_string_view<_CharT, _Traits>(__rhs);







}



template <class _CharT, class _Traits, class _Allocator>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr auto operator<=>(
    const basic_string<_CharT, _Traits, _Allocator>& __lhs,
    const basic_string<_CharT, _Traits, _Allocator>& __rhs) noexcept {
    return basic_string_view<_CharT, _Traits>(__lhs) <=> basic_string_view<_CharT, _Traits>(__rhs);
}

template <class _CharT, class _Traits, class _Allocator>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr auto
operator<=>(const basic_string<_CharT, _Traits, _Allocator>& __lhs, const _CharT* __rhs) {
    return basic_string_view<_CharT, _Traits>(__lhs) <=> basic_string_view<_CharT, _Traits>(__rhs);
}
# 4106 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/string" 3
template<class _CharT, class _Traits, class _Allocator>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
basic_string<_CharT, _Traits, _Allocator>
operator+(const basic_string<_CharT, _Traits, _Allocator>& __lhs,
          const basic_string<_CharT, _Traits, _Allocator>& __rhs)
{
    using _String = basic_string<_CharT, _Traits, _Allocator>;
    auto __lhs_sz = __lhs.size();
    auto __rhs_sz = __rhs.size();
    _String __r(__uninitialized_size_tag(),
                __lhs_sz + __rhs_sz,
                _String::__alloc_traits::select_on_container_copy_construction(__lhs.get_allocator()));
    auto __ptr = std::__to_address(__r.__get_pointer());
    _Traits::copy(__ptr, __lhs.data(), __lhs_sz);
    _Traits::copy(__ptr + __lhs_sz, __rhs.data(), __rhs_sz);
    _Traits::assign(__ptr + __lhs_sz + __rhs_sz, 1, _CharT());
    return __r;
}

template<class _CharT, class _Traits, class _Allocator>
__attribute__((__visibility__("hidden"))) constexpr
basic_string<_CharT, _Traits, _Allocator>
operator+(const _CharT* __lhs , const basic_string<_CharT,_Traits,_Allocator>& __rhs)
{
    using _String = basic_string<_CharT, _Traits, _Allocator>;
    auto __lhs_sz = _Traits::length(__lhs);
    auto __rhs_sz = __rhs.size();
    _String __r(__uninitialized_size_tag(),
                __lhs_sz + __rhs_sz,
                _String::__alloc_traits::select_on_container_copy_construction(__rhs.get_allocator()));
    auto __ptr = std::__to_address(__r.__get_pointer());
    _Traits::copy(__ptr, __lhs, __lhs_sz);
    _Traits::copy(__ptr + __lhs_sz, __rhs.data(), __rhs_sz);
    _Traits::assign(__ptr + __lhs_sz + __rhs_sz, 1, _CharT());
    return __r;
}

template<class _CharT, class _Traits, class _Allocator>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
basic_string<_CharT, _Traits, _Allocator>
operator+(_CharT __lhs, const basic_string<_CharT,_Traits,_Allocator>& __rhs)
{
    using _String = basic_string<_CharT, _Traits, _Allocator>;
    typename _String::size_type __rhs_sz = __rhs.size();
    _String __r(__uninitialized_size_tag(),
                __rhs_sz + 1,
                _String::__alloc_traits::select_on_container_copy_construction(__rhs.get_allocator()));
    auto __ptr = std::__to_address(__r.__get_pointer());
    _Traits::assign(__ptr, 1, __lhs);
    _Traits::copy(__ptr + 1, __rhs.data(), __rhs_sz);
    _Traits::assign(__ptr + 1 + __rhs_sz, 1, _CharT());
    return __r;
}

template<class _CharT, class _Traits, class _Allocator>
inline constexpr
basic_string<_CharT, _Traits, _Allocator>
operator+(const basic_string<_CharT, _Traits, _Allocator>& __lhs, const _CharT* __rhs)
{
    using _String = basic_string<_CharT, _Traits, _Allocator>;
    typename _String::size_type __lhs_sz = __lhs.size();
    typename _String::size_type __rhs_sz = _Traits::length(__rhs);
    _String __r(__uninitialized_size_tag(),
                __lhs_sz + __rhs_sz,
                _String::__alloc_traits::select_on_container_copy_construction(__lhs.get_allocator()));
    auto __ptr = std::__to_address(__r.__get_pointer());
    _Traits::copy(__ptr, __lhs.data(), __lhs_sz);
    _Traits::copy(__ptr + __lhs_sz, __rhs, __rhs_sz);
    _Traits::assign(__ptr + __lhs_sz + __rhs_sz, 1, _CharT());
    return __r;
}

template<class _CharT, class _Traits, class _Allocator>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
basic_string<_CharT, _Traits, _Allocator>
operator+(const basic_string<_CharT, _Traits, _Allocator>& __lhs, _CharT __rhs)
{
    using _String = basic_string<_CharT, _Traits, _Allocator>;
    typename _String::size_type __lhs_sz = __lhs.size();
    _String __r(__uninitialized_size_tag(),
                __lhs_sz + 1,
                _String::__alloc_traits::select_on_container_copy_construction(__lhs.get_allocator()));
    auto __ptr = std::__to_address(__r.__get_pointer());
    _Traits::copy(__ptr, __lhs.data(), __lhs_sz);
    _Traits::assign(__ptr + __lhs_sz, 1, __rhs);
    _Traits::assign(__ptr + 1 + __lhs_sz, 1, _CharT());
    return __r;
}



template<class _CharT, class _Traits, class _Allocator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
basic_string<_CharT, _Traits, _Allocator>
operator+(basic_string<_CharT, _Traits, _Allocator>&& __lhs, const basic_string<_CharT, _Traits, _Allocator>& __rhs)
{
    return std::move(__lhs.append(__rhs));
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
basic_string<_CharT, _Traits, _Allocator>
operator+(const basic_string<_CharT, _Traits, _Allocator>& __lhs, basic_string<_CharT, _Traits, _Allocator>&& __rhs)
{
    return std::move(__rhs.insert(0, __lhs));
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
basic_string<_CharT, _Traits, _Allocator>
operator+(basic_string<_CharT, _Traits, _Allocator>&& __lhs, basic_string<_CharT, _Traits, _Allocator>&& __rhs)
{
    return std::move(__lhs.append(__rhs));
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
basic_string<_CharT, _Traits, _Allocator>
operator+(const _CharT* __lhs , basic_string<_CharT,_Traits,_Allocator>&& __rhs)
{
    return std::move(__rhs.insert(0, __lhs));
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
basic_string<_CharT, _Traits, _Allocator>
operator+(_CharT __lhs, basic_string<_CharT,_Traits,_Allocator>&& __rhs)
{
    __rhs.insert(__rhs.begin(), __lhs);
    return std::move(__rhs);
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
basic_string<_CharT, _Traits, _Allocator>
operator+(basic_string<_CharT, _Traits, _Allocator>&& __lhs, const _CharT* __rhs)
{
    return std::move(__lhs.append(__rhs));
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
basic_string<_CharT, _Traits, _Allocator>
operator+(basic_string<_CharT, _Traits, _Allocator>&& __lhs, _CharT __rhs)
{
    __lhs.push_back(__rhs);
    return std::move(__lhs);
}





template<class _CharT, class _Traits, class _Allocator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
void
swap(basic_string<_CharT, _Traits, _Allocator>& __lhs,
     basic_string<_CharT, _Traits, _Allocator>& __rhs)
     noexcept(noexcept(__lhs.swap(__rhs)))
{
    __lhs.swap(__rhs);
}

__attribute__((__visibility__("default"))) int stoi (const string& __str, size_t* __idx = nullptr, int __base = 10);
__attribute__((__visibility__("default"))) long stol (const string& __str, size_t* __idx = nullptr, int __base = 10);
__attribute__((__visibility__("default"))) unsigned long stoul (const string& __str, size_t* __idx = nullptr, int __base = 10);
__attribute__((__visibility__("default"))) long long stoll (const string& __str, size_t* __idx = nullptr, int __base = 10);
__attribute__((__visibility__("default"))) unsigned long long stoull(const string& __str, size_t* __idx = nullptr, int __base = 10);

__attribute__((__visibility__("default"))) float stof (const string& __str, size_t* __idx = nullptr);
__attribute__((__visibility__("default"))) double stod (const string& __str, size_t* __idx = nullptr);
__attribute__((__visibility__("default"))) long double stold(const string& __str, size_t* __idx = nullptr);

__attribute__((__visibility__("default"))) string to_string(int __val);
__attribute__((__visibility__("default"))) string to_string(unsigned __val);
__attribute__((__visibility__("default"))) string to_string(long __val);
__attribute__((__visibility__("default"))) string to_string(unsigned long __val);
__attribute__((__visibility__("default"))) string to_string(long long __val);
__attribute__((__visibility__("default"))) string to_string(unsigned long long __val);
__attribute__((__visibility__("default"))) string to_string(float __val);
__attribute__((__visibility__("default"))) string to_string(double __val);
__attribute__((__visibility__("default"))) string to_string(long double __val);


__attribute__((__visibility__("default"))) int stoi (const wstring& __str, size_t* __idx = nullptr, int __base = 10);
__attribute__((__visibility__("default"))) long stol (const wstring& __str, size_t* __idx = nullptr, int __base = 10);
__attribute__((__visibility__("default"))) unsigned long stoul (const wstring& __str, size_t* __idx = nullptr, int __base = 10);
__attribute__((__visibility__("default"))) long long stoll (const wstring& __str, size_t* __idx = nullptr, int __base = 10);
__attribute__((__visibility__("default"))) unsigned long long stoull(const wstring& __str, size_t* __idx = nullptr, int __base = 10);

__attribute__((__visibility__("default"))) float stof (const wstring& __str, size_t* __idx = nullptr);
__attribute__((__visibility__("default"))) double stod (const wstring& __str, size_t* __idx = nullptr);
__attribute__((__visibility__("default"))) long double stold(const wstring& __str, size_t* __idx = nullptr);

__attribute__((__visibility__("default"))) wstring to_wstring(int __val);
__attribute__((__visibility__("default"))) wstring to_wstring(unsigned __val);
__attribute__((__visibility__("default"))) wstring to_wstring(long __val);
__attribute__((__visibility__("default"))) wstring to_wstring(unsigned long __val);
__attribute__((__visibility__("default"))) wstring to_wstring(long long __val);
__attribute__((__visibility__("default"))) wstring to_wstring(unsigned long long __val);
__attribute__((__visibility__("default"))) wstring to_wstring(float __val);
__attribute__((__visibility__("default"))) wstring to_wstring(double __val);
__attribute__((__visibility__("default"))) wstring to_wstring(long double __val);


template<class _CharT, class _Traits, class _Allocator>
__attribute__((__visibility__("default")))
const typename basic_string<_CharT, _Traits, _Allocator>::size_type
               basic_string<_CharT, _Traits, _Allocator>::npos;

template <class _CharT, class _Allocator>
struct __string_hash : public __unary_function<basic_string<_CharT, char_traits<_CharT>, _Allocator>, size_t> {
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) size_t
    operator()(const basic_string<_CharT, char_traits<_CharT>, _Allocator>& __val) const noexcept {
        return std::__do_string_hash(__val.data(), __val.data() + __val.size());
    }
};

template <class _Allocator>
struct hash<basic_string<char, char_traits<char>, _Allocator> > : __string_hash<char, _Allocator> {};


template <class _Allocator>
struct hash<basic_string<char8_t, char_traits<char8_t>, _Allocator> > : __string_hash<char8_t, _Allocator> {};


template <class _Allocator>
struct hash<basic_string<char16_t, char_traits<char16_t>, _Allocator> > : __string_hash<char16_t, _Allocator> {};

template <class _Allocator>
struct hash<basic_string<char32_t, char_traits<char32_t>, _Allocator> > : __string_hash<char32_t, _Allocator> {};


template <class _Allocator>
struct hash<basic_string<wchar_t, char_traits<wchar_t>, _Allocator> > : __string_hash<wchar_t, _Allocator> {};


template<class _CharT, class _Traits, class _Allocator>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os,
           const basic_string<_CharT, _Traits, _Allocator>& __str);

template<class _CharT, class _Traits, class _Allocator>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) basic_istream<_CharT, _Traits>&
operator>>(basic_istream<_CharT, _Traits>& __is,
           basic_string<_CharT, _Traits, _Allocator>& __str);

template<class _CharT, class _Traits, class _Allocator>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) basic_istream<_CharT, _Traits>&
getline(basic_istream<_CharT, _Traits>& __is,
        basic_string<_CharT, _Traits, _Allocator>& __str, _CharT __dlm);

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
basic_istream<_CharT, _Traits>&
getline(basic_istream<_CharT, _Traits>& __is,
        basic_string<_CharT, _Traits, _Allocator>& __str);

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
basic_istream<_CharT, _Traits>&
getline(basic_istream<_CharT, _Traits>&& __is,
        basic_string<_CharT, _Traits, _Allocator>& __str, _CharT __dlm);

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
basic_istream<_CharT, _Traits>&
getline(basic_istream<_CharT, _Traits>&& __is,
        basic_string<_CharT, _Traits, _Allocator>& __str);


template <class _CharT, class _Traits, class _Allocator, class _Up>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    typename basic_string<_CharT, _Traits, _Allocator>::size_type
    erase(basic_string<_CharT, _Traits, _Allocator>& __str, const _Up& __v) {
  auto __old_size = __str.size();
  __str.erase(std::remove(__str.begin(), __str.end(), __v), __str.end());
  return __old_size - __str.size();
}

template <class _CharT, class _Traits, class _Allocator, class _Predicate>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    typename basic_string<_CharT, _Traits, _Allocator>::size_type
    erase_if(basic_string<_CharT, _Traits, _Allocator>& __str,
             _Predicate __pred) {
  auto __old_size = __str.size();
  __str.erase(std::remove_if(__str.begin(), __str.end(), __pred),
              __str.end());
  return __old_size - __str.size();
}




inline namespace literals
{
  inline namespace string_literals
  {
    inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    basic_string<char> operator""s( const char *__str, size_t __len )
    {
        return basic_string<char> (__str, __len);
    }


    inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    basic_string<wchar_t> operator""s( const wchar_t *__str, size_t __len )
    {
        return basic_string<wchar_t> (__str, __len);
    }



    inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    basic_string<char8_t> operator""s(const char8_t *__str, size_t __len)
    {
        return basic_string<char8_t> (__str, __len);
    }


    inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    basic_string<char16_t> operator""s( const char16_t *__str, size_t __len )
    {
        return basic_string<char16_t> (__str, __len);
    }

    inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    basic_string<char32_t> operator""s( const char32_t *__str, size_t __len )
    {
        return basic_string<char32_t> (__str, __len);
    }
  }
}


template <>
inline constexpr bool __format::__enable_insertable<std::basic_string<char>> = true;

template <>
inline constexpr bool __format::__enable_insertable<std::basic_string<wchar_t>> = true;





}}
# 40 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__format/parser_std_format_spec.h" 2 3
# 44 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__format/parser_std_format_spec.h" 3



# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__undef_macros" 1 3
# 48 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__format/parser_std_format_spec.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {



namespace __format_spec {

[[noreturn]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) inline void
__throw_invalid_option_format_error(const char* __id, const char* __option) {
  std::__throw_format_error(
      (string("The format specifier for ") + __id + " does not allow the " + __option + " option").c_str());
}

[[noreturn]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) inline void __throw_invalid_type_format_error(const char* __id) {
  std::__throw_format_error(
      (string("The type option contains an invalid value for ") + __id + " formatting argument").c_str());
}

template <contiguous_iterator _Iterator, class _ParseContext>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr __format::__parse_number_result<_Iterator>
__parse_arg_id(_Iterator __begin, _Iterator __end, _ParseContext& __ctx) {
  using _CharT = iter_value_t<_Iterator>;


  if (__begin == __end)
    std::__throw_format_error("End of input while parsing an argument index");

  __format::__parse_number_result __r = __format::__parse_arg_id(__begin, __end, __ctx);

  if (__r.__last == __end || *__r.__last != _CharT('}'))
    std::__throw_format_error("The argument index is invalid");

  ++__r.__last;
  return __r;
}

template <class _Context>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr uint32_t
__substitute_arg_id(basic_format_arg<_Context> __format_arg) {
# 95 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__format/parser_std_format_spec.h" 3
  return std::__visit_format_arg(
      [](auto __arg) -> uint32_t {
        using _Type = decltype(__arg);
        if constexpr (same_as<_Type, monostate>)
          std::__throw_format_error("The argument index value is too large for the number of arguments supplied");
# 111 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__format/parser_std_format_spec.h" 3
        if constexpr (same_as<_Type, int> || same_as<_Type, unsigned int> ||
                      same_as<_Type, long long> || same_as<_Type, unsigned long long>) {
          if constexpr (signed_integral<_Type>) {
            if (__arg < 0)
              std::__throw_format_error("An argument index may not have a negative value");
          }

          using _CT = common_type_t<_Type, decltype(__format::__number_max)>;
          if (static_cast<_CT>(__arg) > static_cast<_CT>(__format::__number_max))
            std::__throw_format_error("The value of the argument index exceeds its maximum value");

          return __arg;
        } else
          std::__throw_format_error("Replacement argument isn't a standard signed or unsigned integer type");
      },
      __format_arg);
}






struct __fields {
  uint16_t __sign_ : 1 {false};
  uint16_t __alternate_form_ : 1 {false};
  uint16_t __zero_padding_ : 1 {false};
  uint16_t __precision_ : 1 {false};
  uint16_t __locale_specific_form_ : 1 {false};
  uint16_t __type_ : 1 {false};






  uint16_t __use_range_fill_ : 1 {false};
  uint16_t __clear_brackets_ : 1 {false};
  uint16_t __consume_all_ : 1 {false};
};



inline constexpr __fields __fields_bool{.__locale_specific_form_ = true, .__type_ = true, .__consume_all_ = true};
inline constexpr __fields __fields_integral{
    .__sign_ = true,
    .__alternate_form_ = true,
    .__zero_padding_ = true,
    .__locale_specific_form_ = true,
    .__type_ = true,
    .__consume_all_ = true};
inline constexpr __fields __fields_floating_point{
    .__sign_ = true,
    .__alternate_form_ = true,
    .__zero_padding_ = true,
    .__precision_ = true,
    .__locale_specific_form_ = true,
    .__type_ = true,
    .__consume_all_ = true};
inline constexpr __fields __fields_string{.__precision_ = true, .__type_ = true, .__consume_all_ = true};
inline constexpr __fields __fields_pointer{.__zero_padding_ = true, .__type_ = true, .__consume_all_ = true};


inline constexpr __fields __fields_tuple{.__use_range_fill_ = true, .__clear_brackets_ = true};
inline constexpr __fields __fields_range{.__use_range_fill_ = true, .__clear_brackets_ = true};
inline constexpr __fields __fields_fill_align_width{};


enum class __alignment : uint8_t {

  __default,
  __left,
  __center,
  __right,
  __zero_padding
};

enum class __sign : uint8_t {





  __default,
  __minus,
  __plus,
  __space
};

enum class __type : uint8_t {
  __default = 0,
  __string,
  __binary_lower_case,
  __binary_upper_case,
  __octal,
  __decimal,
  __hexadecimal_lower_case,
  __hexadecimal_upper_case,
  __pointer_lower_case,
  __pointer_upper_case,
  __char,
  __hexfloat_lower_case,
  __hexfloat_upper_case,
  __scientific_lower_case,
  __scientific_upper_case,
  __fixed_lower_case,
  __fixed_upper_case,
  __general_lower_case,
  __general_upper_case,
  __debug
};

__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) inline constexpr uint32_t __create_type_mask(__type __t) {
  uint32_t __shift = static_cast<uint32_t>(__t);
  if (__shift == 0)
    return 1;

  if (__shift > 31)
    std::__throw_format_error("The type does not fit in the mask");

  return 1 << __shift;
}

inline constexpr uint32_t __type_mask_integer =
    __create_type_mask(__type::__binary_lower_case) |
    __create_type_mask(__type::__binary_upper_case) |
    __create_type_mask(__type::__decimal) |
    __create_type_mask(__type::__octal) |
    __create_type_mask(__type::__hexadecimal_lower_case) |
    __create_type_mask(__type::__hexadecimal_upper_case);

struct __std {
  __alignment __alignment_ : 3;
  __sign __sign_ : 2;
  bool __alternate_form_ : 1;
  bool __locale_specific_form_ : 1;
  __type __type_;
};

struct __chrono {
  __alignment __alignment_ : 3;
  bool __locale_specific_form_ : 1;
  bool __hour_ : 1;
  bool __weekday_name_ : 1;
  bool __weekday_ : 1;
  bool __day_of_year_ : 1;
  bool __week_of_year_ : 1;
  bool __month_name_ : 1;
};





template <class _CharT>
struct __code_point;

template <>
struct __code_point<char> {
  char __data[4] = {' '};
};


template <>
struct __code_point<wchar_t> {
  wchar_t __data[4 / sizeof(wchar_t)] = {L' '};
};
# 289 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__format/parser_std_format_spec.h" 3
template <class _CharT>
struct __parsed_specifications {
  union {






    __alignment __alignment_ : 3;
    __std __std_;
    __chrono __chrono_;
  };





  int32_t __width_;





  int32_t __precision_;

  __code_point<_CharT> __fill_;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr bool __has_width() const { return __width_ > 0; }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr bool __has_precision() const { return __precision_ >= 0; }
};



static_assert(sizeof(__parsed_specifications<char>) == 16);
static_assert(is_trivially_copyable_v<__parsed_specifications<char>>);

static_assert(sizeof(__parsed_specifications<wchar_t>) == 16);
static_assert(is_trivially_copyable_v<__parsed_specifications<wchar_t>>);
# 339 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__format/parser_std_format_spec.h" 3
template <class _CharT>
class __parser {
public:
# 355 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__format/parser_std_format_spec.h" 3
  template <class _ParseContext>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr typename _ParseContext::iterator __parse(_ParseContext& __ctx, __fields __fields) {
    auto __begin = __ctx.begin();
    auto __end = __ctx.end();
    if (__begin == __end)
      return __begin;

    if (__parse_fill_align(__begin, __end, __fields.__use_range_fill_) && __begin == __end)
      return __begin;

    if (__fields.__sign_) {
      if (__parse_sign(__begin) && __begin == __end)
        return __begin;
    } else if (std::is_constant_evaluated() && __parse_sign(__begin)) {
      std::__throw_format_error("The format specification does not allow the sign option");
    }

    if (__fields.__alternate_form_) {
      if (__parse_alternate_form(__begin) && __begin == __end)
        return __begin;
    } else if (std::is_constant_evaluated() && __parse_alternate_form(__begin)) {
      std::__throw_format_error("The format specifier does not allow the alternate form option");
    }

    if (__fields.__zero_padding_) {
      if (__parse_zero_padding(__begin) && __begin == __end)
        return __begin;
    } else if (std::is_constant_evaluated() && __parse_zero_padding(__begin)) {
      std::__throw_format_error("The format specifier does not allow the zero-padding option");
    }

    if (__parse_width(__begin, __end, __ctx) && __begin == __end)
      return __begin;

    if (__fields.__precision_) {
      if (__parse_precision(__begin, __end, __ctx) && __begin == __end)
        return __begin;
    } else if (std::is_constant_evaluated() && __parse_precision(__begin, __end, __ctx)) {
      std::__throw_format_error("The format specifier does not allow the precision option");
    }

    if (__fields.__locale_specific_form_) {
      if (__parse_locale_specific_form(__begin) && __begin == __end)
        return __begin;
    } else if (std::is_constant_evaluated() && __parse_locale_specific_form(__begin)) {
      std::__throw_format_error("The format specifier does not allow the locale-specific form option");
    }

    if (__fields.__clear_brackets_) {
      if (__parse_clear_brackets(__begin) && __begin == __end)
        return __begin;
    } else if (std::is_constant_evaluated() && __parse_clear_brackets(__begin)) {
      std::__throw_format_error("The format specifier does not allow the n option");
    }

    if (__fields.__type_)
      __parse_type(__begin);

    if (!__fields.__consume_all_)
      return __begin;

    if (__begin != __end && *__begin != _CharT('}'))
      std::__throw_format_error("The format specifier should consume the input or end with a '}'");

    return __begin;
  }
# 452 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__format/parser_std_format_spec.h" 3
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr void
  __validate(__fields __fields, const char* __id, uint32_t __type_mask = -1) const {
    if (!__fields.__sign_ && __sign_ != __sign::__default) {
      if (std::is_constant_evaluated())
        std::__throw_format_error("The format specifier does not allow the sign option");
      else
        __format_spec::__throw_invalid_option_format_error(__id, "sign");
    }

    if (!__fields.__alternate_form_ && __alternate_form_) {
      if (std::is_constant_evaluated())
        std::__throw_format_error("The format specifier does not allow the alternate form option");
      else
        __format_spec::__throw_invalid_option_format_error(__id, "alternate form");
    }

    if (!__fields.__zero_padding_ && __alignment_ == __alignment::__zero_padding) {
      if (std::is_constant_evaluated())
        std::__throw_format_error("The format specifier does not allow the zero-padding option");
      else
        __format_spec::__throw_invalid_option_format_error(__id, "zero-padding");
    }

    if (!__fields.__precision_ && __precision_ != -1) {
      if (std::is_constant_evaluated())
        std::__throw_format_error("The format specifier does not allow the precision option");
      else
        __format_spec::__throw_invalid_option_format_error(__id, "precision");
    }

    if (!__fields.__locale_specific_form_ && __locale_specific_form_) {
      if (std::is_constant_evaluated())
        std::__throw_format_error("The format specifier does not allow the locale-specific form option");
      else
        __format_spec::__throw_invalid_option_format_error(__id, "locale-specific form");
    }

    if ((__create_type_mask(__type_) & __type_mask) == 0) {
      if (std::is_constant_evaluated())
        std::__throw_format_error("The format specifier uses an invalid value for the type option");
      else
        __format_spec::__throw_invalid_type_format_error(__id);
    }
  }


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
  __parsed_specifications<_CharT> __get_parsed_std_specifications(auto& __ctx) const {
    return __parsed_specifications<_CharT>{
        .__std_ = __std{.__alignment_ = __alignment_,
                        .__sign_ = __sign_,
                        .__alternate_form_ = __alternate_form_,
                        .__locale_specific_form_ = __locale_specific_form_,
                        .__type_ = __type_},
        .__width_{__get_width(__ctx)},
        .__precision_{__get_precision(__ctx)},
        .__fill_{__fill_}};
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) __parsed_specifications<_CharT> __get_parsed_chrono_specifications(auto& __ctx) const {
    return __parsed_specifications<_CharT>{
        .__chrono_ =
            __chrono{.__alignment_ = __alignment_,
                     .__locale_specific_form_ = __locale_specific_form_,
                     .__hour_ = __hour_,
                     .__weekday_name_ = __weekday_name_,
                     .__weekday_ = __weekday_,
                     .__day_of_year_ = __day_of_year_,
                     .__week_of_year_ = __week_of_year_,
                     .__month_name_ = __month_name_},
        .__width_{__get_width(__ctx)},
        .__precision_{__get_precision(__ctx)},
        .__fill_{__fill_}};
  }

  __alignment __alignment_ : 3 {__alignment::__default};
  __sign __sign_ : 2 {__sign::__default};
  bool __alternate_form_ : 1 {false};
  bool __locale_specific_form_ : 1 {false};
  bool __clear_brackets_ : 1 {false};
  __type __type_{__type::__default};



  bool __hour_ : 1 {false};

  bool __weekday_name_ : 1 {false};
  bool __weekday_ : 1 {false};

  bool __day_of_year_ : 1 {false};
  bool __week_of_year_ : 1 {false};

  bool __month_name_ : 1 {false};

  uint8_t __reserved_0_ : 2 {0};
  uint8_t __reserved_1_ : 6 {0};


  bool __width_as_arg_ : 1 {false};
  bool __precision_as_arg_ : 1 {false};


  int32_t __width_{0};


  int32_t __precision_{-1};

  __code_point<_CharT> __fill_{};

private:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr bool __parse_alignment(_CharT __c) {
    switch (__c) {
    case _CharT('<'):
      __alignment_ = __alignment::__left;
      return true;

    case _CharT('^'):
      __alignment_ = __alignment::__center;
      return true;

    case _CharT('>'):
      __alignment_ = __alignment::__right;
      return true;
    }
    return false;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr void __validate_fill_character(_CharT __fill, bool __use_range_fill) {


    if (__use_range_fill && (__fill == _CharT('{') || __fill == _CharT('}') || __fill == _CharT(':')))
      std::__throw_format_error("The fill option contains an invalid value");
    else if (__fill == _CharT('{') || __fill == _CharT('}'))
      std::__throw_format_error("The fill option contains an invalid value");
  }



  template <contiguous_iterator _Iterator>
    requires same_as<_CharT, char>

          || (same_as<_CharT, wchar_t> && sizeof(wchar_t) == 2)

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr bool __parse_fill_align(_Iterator& __begin, _Iterator __end, bool __use_range_fill) {
    ((void)0);


    __unicode::__code_point_view<_CharT> __view{__begin, __end};
    __unicode::__consume_result __consumed = __view.__consume();
    if (__consumed.__status != __unicode::__consume_result::__ok)
      std::__throw_format_error("The format specifier contains malformed Unicode characters");

    if (__view.__position() < __end && __parse_alignment(*__view.__position())) {
      ptrdiff_t __code_units = __view.__position() - __begin;
      if (__code_units == 1)



        __validate_fill_character(*__begin, __use_range_fill);

      std::copy_n(__begin, __code_units, std::addressof(__fill_.__data[0]));
      __begin += __code_units + 1;
      return true;
    }

    if (!__parse_alignment(*__begin))
      return false;

    ++__begin;
    return true;
  }


  template <contiguous_iterator _Iterator>
    requires(same_as<_CharT, wchar_t> && sizeof(wchar_t) == 4)
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr bool __parse_fill_align(_Iterator& __begin, _Iterator __end, bool __use_range_fill) {
    ((void)0);


    if (__begin + 1 != __end && __parse_alignment(*(__begin + 1))) {
      if (!__unicode::__is_scalar_value(*__begin))
        std::__throw_format_error("The fill option contains an invalid value");

      __validate_fill_character(*__begin, __use_range_fill);

      __fill_.__data[0] = *__begin;
      __begin += 2;
      return true;
    }

    if (!__parse_alignment(*__begin))
      return false;

    ++__begin;
    return true;
  }
# 677 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__format/parser_std_format_spec.h" 3
  template <contiguous_iterator _Iterator>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr bool __parse_sign(_Iterator& __begin) {
    switch (*__begin) {
    case _CharT('-'):
      __sign_ = __sign::__minus;
      break;
    case _CharT('+'):
      __sign_ = __sign::__plus;
      break;
    case _CharT(' '):
      __sign_ = __sign::__space;
      break;
    default:
      return false;
    }
    ++__begin;
    return true;
  }

  template <contiguous_iterator _Iterator>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr bool __parse_alternate_form(_Iterator& __begin) {
    if (*__begin != _CharT('#'))
      return false;

    __alternate_form_ = true;
    ++__begin;
    return true;
  }

  template <contiguous_iterator _Iterator>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr bool __parse_zero_padding(_Iterator& __begin) {
    if (*__begin != _CharT('0'))
      return false;

    if (__alignment_ == __alignment::__default)
      __alignment_ = __alignment::__zero_padding;
    ++__begin;
    return true;
  }

  template <contiguous_iterator _Iterator>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr bool __parse_width(_Iterator& __begin, _Iterator __end, auto& __ctx) {
    if (*__begin == _CharT('0'))
      std::__throw_format_error("The width option should not have a leading zero");

    if (*__begin == _CharT('{')) {
      __format::__parse_number_result __r = __format_spec::__parse_arg_id(++__begin, __end, __ctx);
      __width_as_arg_ = true;
      __width_ = __r.__value;
      __begin = __r.__last;
      return true;
    }

    if (*__begin < _CharT('0') || *__begin > _CharT('9'))
      return false;

    __format::__parse_number_result __r = __format::__parse_number(__begin, __end);
    __width_ = __r.__value;
    ((void)0);

    __begin = __r.__last;
    return true;
  }

  template <contiguous_iterator _Iterator>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr bool __parse_precision(_Iterator& __begin, _Iterator __end, auto& __ctx) {
    if (*__begin != _CharT('.'))
      return false;

    ++__begin;
    if (__begin == __end)
      std::__throw_format_error("End of input while parsing format specifier precision");

    if (*__begin == _CharT('{')) {
      __format::__parse_number_result __arg_id = __format_spec::__parse_arg_id(++__begin, __end, __ctx);
      __precision_as_arg_ = true;
      __precision_ = __arg_id.__value;
      __begin = __arg_id.__last;
      return true;
    }

    if (*__begin < _CharT('0') || *__begin > _CharT('9'))
      std::__throw_format_error("The precision option does not contain a value or an argument index");

    __format::__parse_number_result __r = __format::__parse_number(__begin, __end);
    __precision_ = __r.__value;
    __precision_as_arg_ = false;
    __begin = __r.__last;
    return true;
  }

  template <contiguous_iterator _Iterator>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr bool __parse_locale_specific_form(_Iterator& __begin) {
    if (*__begin != _CharT('L'))
      return false;

    __locale_specific_form_ = true;
    ++__begin;
    return true;
  }

  template <contiguous_iterator _Iterator>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr bool __parse_clear_brackets(_Iterator& __begin) {
    if (*__begin != _CharT('n'))
      return false;

    __clear_brackets_ = true;
    ++__begin;
    return true;
  }

  template <contiguous_iterator _Iterator>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr void __parse_type(_Iterator& __begin) {





    switch (*__begin) {
    case 'A':
      __type_ = __type::__hexfloat_upper_case;
      break;
    case 'B':
      __type_ = __type::__binary_upper_case;
      break;
    case 'E':
      __type_ = __type::__scientific_upper_case;
      break;
    case 'F':
      __type_ = __type::__fixed_upper_case;
      break;
    case 'G':
      __type_ = __type::__general_upper_case;
      break;
    case 'X':
      __type_ = __type::__hexadecimal_upper_case;
      break;
    case 'a':
      __type_ = __type::__hexfloat_lower_case;
      break;
    case 'b':
      __type_ = __type::__binary_lower_case;
      break;
    case 'c':
      __type_ = __type::__char;
      break;
    case 'd':
      __type_ = __type::__decimal;
      break;
    case 'e':
      __type_ = __type::__scientific_lower_case;
      break;
    case 'f':
      __type_ = __type::__fixed_lower_case;
      break;
    case 'g':
      __type_ = __type::__general_lower_case;
      break;
    case 'o':
      __type_ = __type::__octal;
      break;
    case 'p':
      __type_ = __type::__pointer_lower_case;
      break;
    case 'P':
      __type_ = __type::__pointer_upper_case;
      break;
    case 's':
      __type_ = __type::__string;
      break;
    case 'x':
      __type_ = __type::__hexadecimal_lower_case;
      break;

    case '?':
      __type_ = __type::__debug;
      break;

    default:
      return;
    }
    ++__begin;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
  int32_t __get_width(auto& __ctx) const {
    if (!__width_as_arg_)
      return __width_;

    return __format_spec::__substitute_arg_id(__ctx.arg(__width_));
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
  int32_t __get_precision(auto& __ctx) const {
    if (!__precision_as_arg_)
      return __precision_;

    return __format_spec::__substitute_arg_id(__ctx.arg(__precision_));
  }
};


static_assert(sizeof(__parser<char>) == 16);

static_assert(sizeof(__parser<wchar_t>) == 16);


__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr void __process_display_type_string(__format_spec::__type __type) {
  switch (__type) {
  case __format_spec::__type::__default:
  case __format_spec::__type::__string:
  case __format_spec::__type::__debug:
    break;

  default:
    std::__throw_format_error("The type option contains an invalid value for a string formatting argument");
  }
}

template <class _CharT>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr void __process_display_type_bool_string(__parser<_CharT>& __parser, const char* __id) {
  __parser.__validate(__format_spec::__fields_bool, __id);
  if (__parser.__alignment_ == __alignment::__default)
    __parser.__alignment_ = __alignment::__left;
}

template <class _CharT>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr void __process_display_type_char(__parser<_CharT>& __parser, const char* __id) {
  __format_spec::__process_display_type_bool_string(__parser, __id);
}

template <class _CharT>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr void __process_parsed_bool(__parser<_CharT>& __parser, const char* __id) {
  switch (__parser.__type_) {
  case __format_spec::__type::__default:
  case __format_spec::__type::__string:
    __format_spec::__process_display_type_bool_string(__parser, __id);
    break;

  case __format_spec::__type::__binary_lower_case:
  case __format_spec::__type::__binary_upper_case:
  case __format_spec::__type::__octal:
  case __format_spec::__type::__decimal:
  case __format_spec::__type::__hexadecimal_lower_case:
  case __format_spec::__type::__hexadecimal_upper_case:
    break;

  default:
    __format_spec::__throw_invalid_type_format_error(__id);
  }
}

template <class _CharT>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr void __process_parsed_char(__parser<_CharT>& __parser, const char* __id) {
  switch (__parser.__type_) {
  case __format_spec::__type::__default:
  case __format_spec::__type::__char:
  case __format_spec::__type::__debug:
    __format_spec::__process_display_type_char(__parser, __id);
    break;

  case __format_spec::__type::__binary_lower_case:
  case __format_spec::__type::__binary_upper_case:
  case __format_spec::__type::__octal:
  case __format_spec::__type::__decimal:
  case __format_spec::__type::__hexadecimal_lower_case:
  case __format_spec::__type::__hexadecimal_upper_case:
    break;

  default:
    __format_spec::__throw_invalid_type_format_error(__id);
  }
}

template <class _CharT>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr void __process_parsed_integer(__parser<_CharT>& __parser, const char* __id) {
  switch (__parser.__type_) {
  case __format_spec::__type::__default:
  case __format_spec::__type::__binary_lower_case:
  case __format_spec::__type::__binary_upper_case:
  case __format_spec::__type::__octal:
  case __format_spec::__type::__decimal:
  case __format_spec::__type::__hexadecimal_lower_case:
  case __format_spec::__type::__hexadecimal_upper_case:
    break;

  case __format_spec::__type::__char:
    __format_spec::__process_display_type_char(__parser, __id);
    break;

  default:
    __format_spec::__throw_invalid_type_format_error(__id);
  }
}

template <class _CharT>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr void __process_parsed_floating_point(__parser<_CharT>& __parser, const char* __id) {
  switch (__parser.__type_) {
  case __format_spec::__type::__default:
  case __format_spec::__type::__hexfloat_lower_case:
  case __format_spec::__type::__hexfloat_upper_case:

    break;
  case __format_spec::__type::__scientific_lower_case:
  case __format_spec::__type::__scientific_upper_case:
  case __format_spec::__type::__fixed_lower_case:
  case __format_spec::__type::__fixed_upper_case:
  case __format_spec::__type::__general_lower_case:
  case __format_spec::__type::__general_upper_case:
    if (!__parser.__precision_as_arg_ && __parser.__precision_ == -1)

      __parser.__precision_ = 6;
    break;

  default:
    __format_spec::__throw_invalid_type_format_error(__id);
  }
}

__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr void __process_display_type_pointer(__format_spec::__type __type, const char* __id) {
  switch (__type) {
  case __format_spec::__type::__default:
  case __format_spec::__type::__pointer_lower_case:
  case __format_spec::__type::__pointer_upper_case:
    break;

  default:
    __format_spec::__throw_invalid_type_format_error(__id);
  }
}

template <contiguous_iterator _Iterator>
struct __column_width_result {

  size_t __width_;



  _Iterator __last_;
};

template <contiguous_iterator _Iterator>
__column_width_result(size_t, _Iterator) -> __column_width_result<_Iterator>;
# 1030 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__format/parser_std_format_spec.h" 3
enum class __column_width_rounding { __down, __up };



namespace __detail {
template <contiguous_iterator _Iterator>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr __column_width_result<_Iterator> __estimate_column_width_grapheme_clustering(
    _Iterator __first, _Iterator __last, size_t __maximum, __column_width_rounding __rounding) noexcept {
  using _CharT = iter_value_t<_Iterator>;
  __unicode::__extended_grapheme_cluster_view<_CharT> __view{__first, __last};

  __column_width_result<_Iterator> __result{0, __first};
  while (__result.__last_ != __last && __result.__width_ <= __maximum) {
    typename __unicode::__extended_grapheme_cluster_view<_CharT>::__cluster __cluster = __view.__consume();
    int __width = __width_estimation_table::__estimated_width(__cluster.__code_point_);






    if (__rounding == __column_width_rounding::__down && __result.__width_ + __width > __maximum)
      return __result;

    __result.__width_ += __width;
    __result.__last_ = __cluster.__last_;
  }

  return __result;
}

}
# 1092 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__format/parser_std_format_spec.h" 3
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr bool __is_ascii(char32_t __c) { return __c < 0x80; }
# 1108 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__format/parser_std_format_spec.h" 3
template <class _CharT, class _Iterator = typename basic_string_view<_CharT>::const_iterator>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr __column_width_result<_Iterator> __estimate_column_width(
    basic_string_view<_CharT> __str, size_t __maximum, __column_width_rounding __rounding) noexcept {







  if (__str.empty() || __maximum == 0)
    return {0, __str.begin()};
# 1128 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__format/parser_std_format_spec.h" 3
  auto __it = __str.begin();
  if (__format_spec::__is_ascii(*__it)) {
    do {
      --__maximum;
      ++__it;
      if (__it == __str.end())
        return {__str.size(), __str.end()};

      if (__maximum == 0) {
        if (__format_spec::__is_ascii(*__it))
          return {static_cast<size_t>(__it - __str.begin()), __it};

        break;
      }
    } while (__format_spec::__is_ascii(*__it));
    --__it;
    ++__maximum;
  }

  ptrdiff_t __ascii_size = __it - __str.begin();
  __column_width_result __result =
      __detail::__estimate_column_width_grapheme_clustering(__it, __str.end(), __maximum, __rounding);

  __result.__width_ += __ascii_size;
  return __result;
}
# 1167 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__format/parser_std_format_spec.h" 3
}



}}
# 23 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__format/formatter_output.h" 2 3
# 35 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__format/formatter_output.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {



namespace __formatter {

__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr char __hex_to_upper(char __c) {
  switch (__c) {
  case 'a':
    return 'A';
  case 'b':
    return 'B';
  case 'c':
    return 'C';
  case 'd':
    return 'D';
  case 'e':
    return 'E';
  case 'f':
    return 'F';
  }
  return __c;
}

struct __attribute__((__visibility__("default"))) __padding_size_result {
  size_t __before_;
  size_t __after_;
};

__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr __padding_size_result
__padding_size(size_t __size, size_t __width, __format_spec::__alignment __align) {
  ((void)0);
  ((void)0);


  size_t __fill = __width - __size;
  switch (__align) {
  case __format_spec::__alignment::__zero_padding:
    __libcpp_unreachable();

  case __format_spec::__alignment::__left:
    return {0, __fill};

  case __format_spec::__alignment::__center: {



    size_t __before = __fill / 2;
    size_t __after = __fill - __before;
    return {__before, __after};
  }
  case __format_spec::__alignment::__default:
  case __format_spec::__alignment::__right:
    return {__fill, 0};
  }
  __libcpp_unreachable();
}




template <__fmt_char_type _CharT, __fmt_char_type _OutCharT = _CharT>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) auto __copy(basic_string_view<_CharT> __str, output_iterator<const _OutCharT&> auto __out_it)
    -> decltype(__out_it) {
  if constexpr (std::same_as<decltype(__out_it), std::back_insert_iterator<__format::__output_buffer<_OutCharT>>>) {
    __out_it.__get_container()->__copy(__str);
    return __out_it;
  } else if constexpr (std::same_as<decltype(__out_it),
                                      typename __format::__retarget_buffer<_OutCharT>::__iterator>) {
    __out_it.__buffer_->__copy(__str);
    return __out_it;
  } else {
    return std::ranges::copy(__str, std::move(__out_it)).out;
  }
}

template <__fmt_char_type _CharT, __fmt_char_type _OutCharT = _CharT>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) auto
__copy(const _CharT* __first, const _CharT* __last, output_iterator<const _OutCharT&> auto __out_it)
    -> decltype(__out_it) {
  return __formatter::__copy(basic_string_view{__first, __last}, std::move(__out_it));
}

template <__fmt_char_type _CharT, __fmt_char_type _OutCharT = _CharT>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) auto __copy(const _CharT* __first, size_t __n, output_iterator<const _OutCharT&> auto __out_it)
    -> decltype(__out_it) {
  return __formatter::__copy(basic_string_view{__first, __n}, std::move(__out_it));
}




template <__fmt_char_type _CharT, __fmt_char_type _OutCharT = _CharT, class _UnaryOperation>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) auto
__transform(const _CharT* __first,
            const _CharT* __last,
            output_iterator<const _OutCharT&> auto __out_it,
            _UnaryOperation __operation) -> decltype(__out_it) {
  if constexpr (std::same_as<decltype(__out_it), std::back_insert_iterator<__format::__output_buffer<_OutCharT>>>) {
    __out_it.__get_container()->__transform(__first, __last, std::move(__operation));
    return __out_it;
  } else if constexpr (std::same_as<decltype(__out_it),
                                      typename __format::__retarget_buffer<_OutCharT>::__iterator>) {
    __out_it.__buffer_->__transform(__first, __last, std::move(__operation));
    return __out_it;
  } else {
    return std::ranges::transform(__first, __last, std::move(__out_it), __operation).out;
  }
}




template <__fmt_char_type _CharT, output_iterator<const _CharT&> _OutIt>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) _OutIt __fill(_OutIt __out_it, size_t __n, _CharT __value) {
  if constexpr (std::same_as<decltype(__out_it), std::back_insert_iterator<__format::__output_buffer<_CharT>>>) {
    __out_it.__get_container()->__fill(__n, __value);
    return __out_it;
  } else if constexpr (std::same_as<decltype(__out_it), typename __format::__retarget_buffer<_CharT>::__iterator>) {
    __out_it.__buffer_->__fill(__n, __value);
    return __out_it;
  } else {
    return std::ranges::fill_n(std::move(__out_it), __n, __value);
  }
}


template <__fmt_char_type _CharT, output_iterator<const _CharT&> _OutIt>
  requires(same_as<_CharT, char>)
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) _OutIt __fill(_OutIt __out_it, size_t __n, __format_spec::__code_point<_CharT> __value) {
  std::size_t __bytes = std::countl_one(static_cast<unsigned char>(__value.__data[0]));
  if (__bytes == 0)
    return __formatter::__fill(std::move(__out_it), __n, __value.__data[0]);

  for (size_t __i = 0; __i < __n; ++__i)
    __out_it = __formatter::__copy(
        std::addressof(__value.__data[0]), std::addressof(__value.__data[0]) + __bytes, std::move(__out_it));
  return __out_it;
}


template <__fmt_char_type _CharT, output_iterator<const _CharT&> _OutIt>
  requires(same_as<_CharT, wchar_t> && sizeof(wchar_t) == 2)
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) _OutIt __fill(_OutIt __out_it, size_t __n, __format_spec::__code_point<_CharT> __value) {
  if (!__unicode::__is_high_surrogate(__value.__data[0]))
    return __formatter::__fill(std::move(__out_it), __n, __value.__data[0]);

  for (size_t __i = 0; __i < __n; ++__i)
    __out_it = __formatter::__copy(
        std::addressof(__value.__data[0]), std::addressof(__value.__data[0]) + 2, std::move(__out_it));
  return __out_it;
}

template <__fmt_char_type _CharT, output_iterator<const _CharT&> _OutIt>
  requires(same_as<_CharT, wchar_t> && sizeof(wchar_t) == 4)
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) _OutIt __fill(_OutIt __out_it, size_t __n, __format_spec::__code_point<_CharT> __value) {
  return __formatter::__fill(std::move(__out_it), __n, __value.__data[0]);
}
# 224 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__format/formatter_output.h" 3
template <class _CharT, class _ParserCharT>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) auto
__write(basic_string_view<_CharT> __str,
        output_iterator<const _CharT&> auto __out_it,
        __format_spec::__parsed_specifications<_ParserCharT> __specs,
        ptrdiff_t __size) -> decltype(__out_it) {
  if (__size >= __specs.__width_)
    return __formatter::__copy(__str, std::move(__out_it));

  __padding_size_result __padding = __formatter::__padding_size(__size, __specs.__width_, __specs.__std_.__alignment_);
  __out_it = __formatter::__fill(std::move(__out_it), __padding.__before_, __specs.__fill_);
  __out_it = __formatter::__copy(__str, std::move(__out_it));
  return __formatter::__fill(std::move(__out_it), __padding.__after_, __specs.__fill_);
}

template <contiguous_iterator _Iterator, class _ParserCharT>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) auto
__write(_Iterator __first,
        _Iterator __last,
        output_iterator<const iter_value_t<_Iterator>&> auto __out_it,
        __format_spec::__parsed_specifications<_ParserCharT> __specs,
        ptrdiff_t __size) -> decltype(__out_it) {
  ((void)0);
  return __formatter::__write(basic_string_view{__first, __last}, std::move(__out_it), __specs, __size);
}




template <contiguous_iterator _Iterator, class _ParserCharT>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) auto
__write(_Iterator __first,
        _Iterator __last,
        output_iterator<const iter_value_t<_Iterator>&> auto __out_it,
        __format_spec::__parsed_specifications<_ParserCharT> __specs) -> decltype(__out_it) {
  ((void)0);
  return __formatter::__write(__first, __last, std::move(__out_it), __specs, __last - __first);
}

template <class _CharT, class _ParserCharT, class _UnaryOperation>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) auto __write_transformed(const _CharT* __first, const _CharT* __last,
                                               output_iterator<const _CharT&> auto __out_it,
                                               __format_spec::__parsed_specifications<_ParserCharT> __specs,
                                               _UnaryOperation __op) -> decltype(__out_it) {
  ((void)0);

  ptrdiff_t __size = __last - __first;
  if (__size >= __specs.__width_)
    return __formatter::__transform(__first, __last, std::move(__out_it), __op);

  __padding_size_result __padding = __formatter::__padding_size(__size, __specs.__width_, __specs.__alignment_);
  __out_it = __formatter::__fill(std::move(__out_it), __padding.__before_, __specs.__fill_);
  __out_it = __formatter::__transform(__first, __last, std::move(__out_it), __op);
  return __formatter::__fill(std::move(__out_it), __padding.__after_, __specs.__fill_);
}







template <class _CharT>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) auto __write_string_no_precision(
    basic_string_view<_CharT> __str,
    output_iterator<const _CharT&> auto __out_it,
    __format_spec::__parsed_specifications<_CharT> __specs) -> decltype(__out_it) {
  ((void)0);


  if (!__specs.__has_width())
    return __formatter::__copy(__str, std::move(__out_it));




  size_t __size =
      __format_spec::__estimate_column_width(__str, __specs.__width_, __format_spec::__column_width_rounding::__up)
          .__width_;
  return __formatter::__write(__str, std::move(__out_it), __specs, __size);
}

template <class _CharT>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) int __truncate(basic_string_view<_CharT>& __str, int __precision) {
  __format_spec::__column_width_result __result =
      __format_spec::__estimate_column_width(__str, __precision, __format_spec::__column_width_rounding::__down);
  __str = basic_string_view<_CharT>{__str.begin(), __result.__last_};
  return __result.__width_;
}

}



}}
# 22 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__format/formatter_integral.h" 2 3




# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/array" 1 3
# 159 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/array" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Tp, size_t _Size>
struct array
{

    typedef array __self;
    typedef _Tp value_type;
    typedef value_type& reference;
    typedef const value_type& const_reference;
    typedef value_type* iterator;
    typedef const value_type* const_iterator;
    typedef value_type* pointer;
    typedef const value_type* const_pointer;
    typedef size_t size_type;
    typedef ptrdiff_t difference_type;
    typedef std::reverse_iterator<iterator> reverse_iterator;
    typedef std::reverse_iterator<const_iterator> const_reverse_iterator;

    _Tp __elems_[_Size];


    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    void fill(const value_type& __u) {
        std::fill_n(data(), _Size, __u);
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    void swap(array& __a) noexcept(__is_nothrow_swappable<_Tp>::value) {
        std::swap_ranges(data(), data() + _Size, __a.data());
    }


    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    iterator begin() noexcept {return iterator(data());}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    const_iterator begin() const noexcept {return const_iterator(data());}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    iterator end() noexcept {return iterator(data() + _Size);}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    const_iterator end() const noexcept {return const_iterator(data() + _Size);}

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    reverse_iterator rbegin() noexcept {return reverse_iterator(end());}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    const_reverse_iterator rbegin() const noexcept {return const_reverse_iterator(end());}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    reverse_iterator rend() noexcept {return reverse_iterator(begin());}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    const_reverse_iterator rend() const noexcept {return const_reverse_iterator(begin());}

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    const_iterator cbegin() const noexcept {return begin();}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    const_iterator cend() const noexcept {return end();}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    const_reverse_iterator crbegin() const noexcept {return rbegin();}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    const_reverse_iterator crend() const noexcept {return rend();}


    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    constexpr size_type size() const noexcept {return _Size;}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    constexpr size_type max_size() const noexcept {return _Size;}
    [[__nodiscard__]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    constexpr bool empty() const noexcept {return _Size == 0;}


    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    reference operator[](size_type __n) noexcept {
        ((void)0);
        return __elems_[__n];
    }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    const_reference operator[](size_type __n) const noexcept {
        ((void)0);
        return __elems_[__n];
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr reference at(size_type __n)
    {
        if (__n >= _Size)
            __throw_out_of_range("array::at");
        return __elems_[__n];
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr const_reference at(size_type __n) const
    {
        if (__n >= _Size)
            __throw_out_of_range("array::at");
        return __elems_[__n];
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr reference front() noexcept {return (*this)[0];}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr const_reference front() const noexcept {return (*this)[0];}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr reference back() noexcept {return (*this)[_Size - 1];}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr const_reference back() const noexcept {return (*this)[_Size - 1];}

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    value_type* data() noexcept {return __elems_;}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    const value_type* data() const noexcept {return __elems_;}
};

template <class _Tp>
struct array<_Tp, 0>
{

    typedef array __self;
    typedef _Tp value_type;
    typedef value_type& reference;
    typedef const value_type& const_reference;
    typedef value_type* iterator;
    typedef const value_type* const_iterator;
    typedef value_type* pointer;
    typedef const value_type* const_pointer;
    typedef size_t size_type;
    typedef ptrdiff_t difference_type;
    typedef std::reverse_iterator<iterator> reverse_iterator;
    typedef std::reverse_iterator<const_iterator> const_reverse_iterator;

    typedef __conditional_t<is_const<_Tp>::value, const char, char> _CharType;

    struct _ArrayInStructT { _Tp __data_[1]; };
    alignas(_ArrayInStructT) _CharType __elems_[sizeof(_ArrayInStructT)];

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    value_type* data() noexcept {return nullptr;}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    const value_type* data() const noexcept {return nullptr;}


    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    void fill(const value_type&) {
      static_assert(!is_const<_Tp>::value,
                    "cannot fill zero-sized array of type 'const T'");
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    void swap(array&) noexcept {
      static_assert(!is_const<_Tp>::value,
                    "cannot swap zero-sized array of type 'const T'");
    }


    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    iterator begin() noexcept {return iterator(data());}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    const_iterator begin() const noexcept {return const_iterator(data());}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    iterator end() noexcept {return iterator(data());}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    const_iterator end() const noexcept {return const_iterator(data());}

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    reverse_iterator rbegin() noexcept {return reverse_iterator(end());}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    const_reverse_iterator rbegin() const noexcept {return const_reverse_iterator(end());}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    reverse_iterator rend() noexcept {return reverse_iterator(begin());}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    const_reverse_iterator rend() const noexcept {return const_reverse_iterator(begin());}

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    const_iterator cbegin() const noexcept {return begin();}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    const_iterator cend() const noexcept {return end();}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    const_reverse_iterator crbegin() const noexcept {return rbegin();}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    const_reverse_iterator crend() const noexcept {return rend();}


    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    constexpr size_type size() const noexcept {return 0; }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    constexpr size_type max_size() const noexcept {return 0;}
    [[__nodiscard__]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    constexpr bool empty() const noexcept {return true;}


    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    reference operator[](size_type) noexcept {
      ((void)0);
      __libcpp_unreachable();
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    const_reference operator[](size_type) const noexcept {
      ((void)0);
      __libcpp_unreachable();
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    reference at(size_type) {
      __throw_out_of_range("array<T, 0>::at");
      __libcpp_unreachable();
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    const_reference at(size_type) const {
      __throw_out_of_range("array<T, 0>::at");
      __libcpp_unreachable();
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    reference front() noexcept {
      ((void)0);
      __libcpp_unreachable();
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    const_reference front() const noexcept {
      ((void)0);
      __libcpp_unreachable();
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    reference back() noexcept {
      ((void)0);
      __libcpp_unreachable();
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    const_reference back() const noexcept {
      ((void)0);
      __libcpp_unreachable();
    }
};



template<class _Tp, class... _Args,
         class = enable_if_t<__all<_IsSame<_Tp, _Args>::value...>::value>
         >
array(_Tp, _Args...)
  -> array<_Tp, 1 + sizeof...(_Args)>;


template <class _Tp, size_t _Size>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
constexpr bool
operator==(const array<_Tp, _Size>& __x, const array<_Tp, _Size>& __y)
{
    return std::equal(__x.begin(), __x.end(), __y.begin());
}
# 438 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/array" 3
template <class _Tp, size_t _Size>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr __synth_three_way_result<_Tp>
operator<=>(const array<_Tp, _Size>& __x, const array<_Tp, _Size>& __y) {
    return std::lexicographical_compare_three_way(
        __x.begin(), __x.end(), __y.begin(), __y.end(), std::__synth_three_way<_Tp, _Tp>);
}



template <class _Tp, size_t _Size, __enable_if_t<_Size == 0 || __is_swappable<_Tp>::value, int> = 0>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
void
swap(array<_Tp, _Size>& __x, array<_Tp, _Size>& __y)
                                  noexcept(noexcept(__x.swap(__y)))
{
    __x.swap(__y);
}

template <class _Tp, size_t _Size>
struct tuple_size<array<_Tp, _Size> >
    : public integral_constant<size_t, _Size> {};

template <size_t _Ip, class _Tp, size_t _Size>
struct tuple_element<_Ip, array<_Tp, _Size> >
{
    static_assert(_Ip < _Size, "Index out of bounds in std::tuple_element<> (std::array)");
    typedef _Tp type;
};

template <size_t _Ip, class _Tp, size_t _Size>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
_Tp&
get(array<_Tp, _Size>& __a) noexcept
{
    static_assert(_Ip < _Size, "Index out of bounds in std::get<> (std::array)");
    return __a.__elems_[_Ip];
}

template <size_t _Ip, class _Tp, size_t _Size>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
const _Tp&
get(const array<_Tp, _Size>& __a) noexcept
{
    static_assert(_Ip < _Size, "Index out of bounds in std::get<> (const std::array)");
    return __a.__elems_[_Ip];
}

template <size_t _Ip, class _Tp, size_t _Size>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
_Tp&&
get(array<_Tp, _Size>&& __a) noexcept
{
    static_assert(_Ip < _Size, "Index out of bounds in std::get<> (std::array &&)");
    return std::move(__a.__elems_[_Ip]);
}

template <size_t _Ip, class _Tp, size_t _Size>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
const _Tp&&
get(const array<_Tp, _Size>&& __a) noexcept
{
    static_assert(_Ip < _Size, "Index out of bounds in std::get<> (const std::array &&)");
    return std::move(__a.__elems_[_Ip]);
}



template <typename _Tp, size_t _Size, size_t... _Index>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr array<remove_cv_t<_Tp>, _Size>
__to_array_lvalue_impl(_Tp (&__arr)[_Size], index_sequence<_Index...>) {
  return {{__arr[_Index]...}};
}

template <typename _Tp, size_t _Size, size_t... _Index>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr array<remove_cv_t<_Tp>, _Size>
__to_array_rvalue_impl(_Tp(&&__arr)[_Size], index_sequence<_Index...>) {
  return {{std::move(__arr[_Index])...}};
}

template <typename _Tp, size_t _Size>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr array<remove_cv_t<_Tp>, _Size>
to_array(_Tp (&__arr)[_Size]) noexcept(is_nothrow_constructible_v<_Tp, _Tp&>) {
  static_assert(
      !is_array_v<_Tp>,
      "[array.creation]/1: to_array does not accept multidimensional arrays.");
  static_assert(
      is_constructible_v<_Tp, _Tp&>,
      "[array.creation]/1: to_array requires copy constructible elements.");
  return std::__to_array_lvalue_impl(__arr, make_index_sequence<_Size>());
}

template <typename _Tp, size_t _Size>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr array<remove_cv_t<_Tp>, _Size>
to_array(_Tp(&&__arr)[_Size]) noexcept(is_nothrow_move_constructible_v<_Tp>) {
  static_assert(
      !is_array_v<_Tp>,
      "[array.creation]/4: to_array does not accept multidimensional arrays.");
  static_assert(
      is_move_constructible_v<_Tp>,
      "[array.creation]/4: to_array requires move constructible elements.");
  return std::__to_array_rvalue_impl(std::move(__arr),
                                       make_index_sequence<_Size>());
}



}}
# 27 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__format/formatter_integral.h" 2 3





# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/locale" 1 3
# 200 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/locale" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__iterator/istreambuf_iterator.h" 1 3
# 14 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__iterator/istreambuf_iterator.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__iterator/default_sentinel.h" 1 3
# 17 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__iterator/default_sentinel.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {



struct default_sentinel_t { };
inline constexpr default_sentinel_t default_sentinel{};



}}
# 15 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__iterator/istreambuf_iterator.h" 2 3
# 21 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__iterator/istreambuf_iterator.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

#pragma GCC diagnostic push
# 25 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__iterator/istreambuf_iterator.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
# 25 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__iterator/istreambuf_iterator.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
template<class _CharT, class _Traits>
class istreambuf_iterator

    : public iterator<input_iterator_tag, _CharT,
                      typename _Traits::off_type, _CharT*,
                      _CharT>

{
#pragma GCC diagnostic pop
public:
    typedef input_iterator_tag iterator_category;
    typedef _CharT value_type;
    typedef typename _Traits::off_type difference_type;
    typedef _CharT* pointer;
    typedef _CharT reference;
    typedef _CharT char_type;
    typedef _Traits traits_type;
    typedef typename _Traits::int_type int_type;
    typedef basic_streambuf<_CharT,_Traits> streambuf_type;
    typedef basic_istream<_CharT,_Traits> istream_type;
private:
    mutable streambuf_type* __sbuf_;

    class __proxy
    {
        char_type __keep_;
        streambuf_type* __sbuf_;
        __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
        explicit __proxy(char_type __c, streambuf_type* __s)
            : __keep_(__c), __sbuf_(__s) {}
        friend class istreambuf_iterator;
    public:
        __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) char_type operator*() const {return __keep_;}
    };

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    bool __test_for_eof() const
    {
        if (__sbuf_ && traits_type::eq_int_type(__sbuf_->sgetc(), traits_type::eof()))
            __sbuf_ = nullptr;
        return __sbuf_ == nullptr;
    }
public:
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr istreambuf_iterator() noexcept : __sbuf_(nullptr) {}

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr istreambuf_iterator(default_sentinel_t) noexcept
        : istreambuf_iterator() {}

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) istreambuf_iterator(istream_type& __s) noexcept
        : __sbuf_(__s.rdbuf()) {}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) istreambuf_iterator(streambuf_type* __s) noexcept
        : __sbuf_(__s) {}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) istreambuf_iterator(const __proxy& __p) noexcept
        : __sbuf_(__p.__sbuf_) {}

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) char_type operator*() const
        {return static_cast<char_type>(__sbuf_->sgetc());}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) istreambuf_iterator& operator++()
        {
            __sbuf_->sbumpc();
            return *this;
        }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) __proxy operator++(int)
        {
            return __proxy(__sbuf_->sbumpc(), __sbuf_);
        }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) bool equal(const istreambuf_iterator& __b) const
        {return __test_for_eof() == __b.__test_for_eof();}


    friend __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) bool operator==(const istreambuf_iterator& __i, default_sentinel_t) {
      return __i.__test_for_eof();
    }

};

template <class _CharT, class _Traits>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
bool operator==(const istreambuf_iterator<_CharT,_Traits>& __a,
                const istreambuf_iterator<_CharT,_Traits>& __b)
                {return __a.equal(__b);}
# 117 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__iterator/istreambuf_iterator.h" 3
}}
# 201 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/locale" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__iterator/ostreambuf_iterator.h" 1 3
# 21 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__iterator/ostreambuf_iterator.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

#pragma GCC diagnostic push
# 25 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__iterator/ostreambuf_iterator.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
# 25 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__iterator/ostreambuf_iterator.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
template <class _CharT, class _Traits>
class ostreambuf_iterator

    : public iterator<output_iterator_tag, void, void, void, void>

{
#pragma GCC diagnostic pop
public:
    typedef output_iterator_tag iterator_category;
    typedef void value_type;

    typedef ptrdiff_t difference_type;



    typedef void pointer;
    typedef void reference;
    typedef _CharT char_type;
    typedef _Traits traits_type;
    typedef basic_streambuf<_CharT, _Traits> streambuf_type;
    typedef basic_ostream<_CharT, _Traits> ostream_type;

private:
    streambuf_type* __sbuf_;
public:
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) ostreambuf_iterator(ostream_type& __s) noexcept
        : __sbuf_(__s.rdbuf()) {}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) ostreambuf_iterator(streambuf_type* __s) noexcept
        : __sbuf_(__s) {}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) ostreambuf_iterator& operator=(_CharT __c)
        {
            if (__sbuf_ && traits_type::eq_int_type(__sbuf_->sputc(__c), traits_type::eof()))
                __sbuf_ = nullptr;
            return *this;
        }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) ostreambuf_iterator& operator*() {return *this;}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) ostreambuf_iterator& operator++() {return *this;}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) ostreambuf_iterator& operator++(int) {return *this;}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) bool failed() const noexcept {return __sbuf_ == nullptr;}

    template <class _Ch, class _Tr>
    friend
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    ostreambuf_iterator<_Ch, _Tr>
    __pad_and_output(ostreambuf_iterator<_Ch, _Tr> __s,
                     const _Ch* __ob, const _Ch* __op, const _Ch* __oe,
                     ios_base& __iob, _Ch __fl);
};

}}
# 202 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/locale" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__locale" 1 3
# 15 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__locale" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__memory/shared_ptr.h" 1 3
# 22 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__memory/shared_ptr.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__memory/allocation_guard.h" 1 3
# 21 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__memory/allocation_guard.h" 3



# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__undef_macros" 1 3
# 25 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__memory/allocation_guard.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 47 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__memory/allocation_guard.h" 3
template<class _Alloc>
struct __allocation_guard {
    using _Pointer = typename allocator_traits<_Alloc>::pointer;
    using _Size = typename allocator_traits<_Alloc>::size_type;

    template<class _AllocT>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    explicit __allocation_guard(_AllocT __alloc, _Size __n)
        : __alloc_(std::move(__alloc))
        , __n_(__n)
        , __ptr_(allocator_traits<_Alloc>::allocate(__alloc_, __n_))
    { }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    ~__allocation_guard() noexcept {
        __destroy();
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) __allocation_guard(const __allocation_guard&) = delete;
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) __allocation_guard(__allocation_guard&& __other) noexcept
        : __alloc_(std::move(__other.__alloc_))
        , __n_(__other.__n_)
        , __ptr_(__other.__ptr_) {
      __other.__ptr_ = nullptr;
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) __allocation_guard& operator=(const __allocation_guard& __other) = delete;
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) __allocation_guard& operator=(__allocation_guard&& __other) noexcept {
        if (std::addressof(__other) != this) {
            __destroy();

            __alloc_ = std::move(__other.__alloc_);
            __n_ = __other.__n_;
            __ptr_ = __other.__ptr_;
            __other.__ptr_ = nullptr;
        }

        return *this;
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    _Pointer __release_ptr() noexcept {
        _Pointer __tmp = __ptr_;
        __ptr_ = nullptr;
        return __tmp;
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    _Pointer __get() const noexcept {
        return __ptr_;
    }

private:
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    void __destroy() noexcept {
        if (__ptr_ != nullptr) {
            allocator_traits<_Alloc>::deallocate(__alloc_, __ptr_, __n_);
        }
    }

    _Alloc __alloc_;
    _Size __n_;
    _Pointer __ptr_;
};

}}
# 23 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__memory/shared_ptr.h" 2 3

# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__memory/allocator_destructor.h" 1 3
# 17 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__memory/allocator_destructor.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Alloc>
class __allocator_destructor
{
    typedef __attribute__((__nodebug__)) allocator_traits<_Alloc> __alloc_traits;
public:
    typedef __attribute__((__nodebug__)) typename __alloc_traits::pointer pointer;
    typedef __attribute__((__nodebug__)) typename __alloc_traits::size_type size_type;
private:
    _Alloc& __alloc_;
    size_type __s_;
public:
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) __allocator_destructor(_Alloc& __a, size_type __s)
             noexcept
        : __alloc_(__a), __s_(__s) {}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    void operator()(pointer __p) noexcept
        {__alloc_traits::deallocate(__alloc_, __p, __s_);}
};

}}
# 25 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__memory/shared_ptr.h" 2 3
# 55 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__memory/shared_ptr.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/typeinfo" 1 3
# 70 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/typeinfo" 3






namespace std
{
# 195 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/typeinfo" 3
struct __type_info_implementations {
  struct __string_impl_base {
    typedef const char* __type_name_t;
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) __attribute__((__always_inline__))
    constexpr static const char* __type_name_to_string(__type_name_t __v) noexcept {
      return __v;
    }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) __attribute__((__always_inline__))
    constexpr static __type_name_t __string_to_type_name(const char* __v) noexcept {
      return __v;
    }
  };

  struct __unique_impl : __string_impl_base {
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) __attribute__((__always_inline__))
    static size_t __hash(__type_name_t __v) noexcept {
      return reinterpret_cast<size_t>(__v);
    }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) __attribute__((__always_inline__))
    static bool __eq(__type_name_t __lhs, __type_name_t __rhs) noexcept {
      return __lhs == __rhs;
    }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) __attribute__((__always_inline__))
    static bool __lt(__type_name_t __lhs, __type_name_t __rhs) noexcept {
      return __lhs < __rhs;
    }
  };

  struct __non_unique_impl : __string_impl_base {
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) __attribute__((__always_inline__))
    static size_t __hash(__type_name_t __ptr) noexcept {
      size_t __hash = 5381;
      while (unsigned char __c = static_cast<unsigned char>(*__ptr++))
        __hash = (__hash * 33) ^ __c;
      return __hash;
    }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) __attribute__((__always_inline__))
    static bool __eq(__type_name_t __lhs, __type_name_t __rhs) noexcept {
      return __lhs == __rhs || __builtin_strcmp(__lhs, __rhs) == 0;
    }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) __attribute__((__always_inline__))
    static bool __lt(__type_name_t __lhs, __type_name_t __rhs) noexcept {
      return __builtin_strcmp(__lhs, __rhs) < 0;
    }
  };

  struct __non_unique_arm_rtti_bit_impl {
    typedef uintptr_t __type_name_t;

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) __attribute__((__always_inline__))
    static const char* __type_name_to_string(__type_name_t __v) noexcept {
      return reinterpret_cast<const char*>(__v &
          ~__non_unique_rtti_bit::value);
    }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) __attribute__((__always_inline__))
    static __type_name_t __string_to_type_name(const char* __v) noexcept {
      return reinterpret_cast<__type_name_t>(__v);
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) __attribute__((__always_inline__))
    static size_t __hash(__type_name_t __v) noexcept {
      if (__is_type_name_unique(__v))
        return __v;
      return __non_unique_impl::__hash(__type_name_to_string(__v));
    }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) __attribute__((__always_inline__))
    static bool __eq(__type_name_t __lhs, __type_name_t __rhs) noexcept {
      if (__lhs == __rhs)
        return true;
      if (__is_type_name_unique(__lhs) || __is_type_name_unique(__rhs))


        return false;
      return __builtin_strcmp(__type_name_to_string(__lhs), __type_name_to_string(__rhs)) == 0;
    }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) __attribute__((__always_inline__))
    static bool __lt(__type_name_t __lhs, __type_name_t __rhs) noexcept {
      if (__is_type_name_unique(__lhs) || __is_type_name_unique(__rhs))
        return __lhs < __rhs;
      return __builtin_strcmp(__type_name_to_string(__lhs), __type_name_to_string(__rhs)) < 0;
    }

   private:


    typedef integral_constant<__type_name_t,
      (1ULL << ((8 * sizeof(__type_name_t)) - 1))> __non_unique_rtti_bit;

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    static bool __is_type_name_unique(__type_name_t __lhs) noexcept {
      return !(__lhs & __non_unique_rtti_bit::value);
    }
  };

  typedef

    __unique_impl







     __impl;
};

class __attribute__((__visibility__("default"))) type_info
{
  type_info& operator=(const type_info&);
  type_info(const type_info&);

 protected:
    typedef __type_info_implementations::__impl __impl;

    __impl::__type_name_t __type_name;

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    explicit type_info(const char* __n)
      : __type_name(__impl::__string_to_type_name(__n)) {}

public:

    virtual ~type_info();

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    const char* name() const noexcept
    {
      return __impl::__type_name_to_string(__type_name);
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    bool before(const type_info& __arg) const noexcept
    {
      return __impl::__lt(__type_name, __arg.__type_name);
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    size_t hash_code() const noexcept
    {
      return __impl::__hash(__type_name);
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    bool operator==(const type_info& __arg) const noexcept
    {


      if (__libcpp_is_constant_evaluated()) {
        return this == &__arg;
      }
      return __impl::__eq(__type_name, __arg.__type_name);
    }






};


class __attribute__((__visibility__("default"))) bad_cast
    : public exception
{
 public:
  bad_cast() noexcept;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) bad_cast(const bad_cast&) noexcept = default;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) bad_cast& operator=(const bad_cast&) noexcept = default;
  ~bad_cast() noexcept override;
  const char* what() const noexcept override;
};

class __attribute__((__visibility__("default"))) bad_typeid
    : public exception
{
 public:
  bad_typeid() noexcept;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) bad_typeid(const bad_typeid&) noexcept = default;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) bad_typeid& operator=(const bad_typeid&) noexcept = default;
  ~bad_typeid() noexcept override;
  const char* what() const noexcept override;
};

}
# 407 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/typeinfo" 3
namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
[[noreturn]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
void __throw_bad_cast()
{



    ::std::__libcpp_verbose_abort("bad_cast was thrown in -fno-exceptions mode");

}
}}
# 56 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__memory/shared_ptr.h" 2 3
# 62 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__memory/shared_ptr.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 77 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__memory/shared_ptr.h" 3
template <class _ValueType>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
_ValueType __libcpp_relaxed_load(_ValueType const* __value) {



    return __atomic_load_n(__value, 0);



}

template <class _ValueType>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
_ValueType __libcpp_acquire_load(_ValueType const* __value) {



    return __atomic_load_n(__value, 2);



}

template <class _Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) _Tp
__libcpp_atomic_refcount_increment(_Tp& __t) noexcept
{

    return __atomic_add_fetch(&__t, 1, 0);



}

template <class _Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) _Tp
__libcpp_atomic_refcount_decrement(_Tp& __t) noexcept
{

    return __atomic_add_fetch(&__t, -1, 4);



}

class __attribute__((__visibility__("default"))) bad_weak_ptr
    : public std::exception
{
public:
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) bad_weak_ptr() noexcept = default;
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) bad_weak_ptr(const bad_weak_ptr&) noexcept = default;
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) bad_weak_ptr& operator=(const bad_weak_ptr&) noexcept = default;
    ~bad_weak_ptr() noexcept override;
    const char* what() const noexcept override;
};

[[noreturn]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
void __throw_bad_weak_ptr()
{



    ::std::__libcpp_verbose_abort("bad_weak_ptr was thrown in -fno-exceptions mode");

}

template<class _Tp> class weak_ptr;

class __attribute__((__visibility__("default"))) __shared_count
{
    __shared_count(const __shared_count&);
    __shared_count& operator=(const __shared_count&);

protected:
    long __shared_owners_;
    virtual ~__shared_count();
private:
    virtual void __on_zero_shared() noexcept = 0;

public:
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    explicit __shared_count(long __refs = 0) noexcept
        : __shared_owners_(__refs) {}





    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    void __add_shared() noexcept {
      __libcpp_atomic_refcount_increment(__shared_owners_);
    }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    bool __release_shared() noexcept {
      if (__libcpp_atomic_refcount_decrement(__shared_owners_) == -1) {
        __on_zero_shared();
        return true;
      }
      return false;
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    long use_count() const noexcept {
        return __libcpp_relaxed_load(&__shared_owners_) + 1;
    }
};

class __attribute__((__visibility__("default"))) __shared_weak_count
    : private __shared_count
{
    long __shared_weak_owners_;

public:
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    explicit __shared_weak_count(long __refs = 0) noexcept
        : __shared_count(__refs),
          __shared_weak_owners_(__refs) {}
protected:
    ~__shared_weak_count() override;

public:





    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    void __add_shared() noexcept {
      __shared_count::__add_shared();
    }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    void __add_weak() noexcept {
      __libcpp_atomic_refcount_increment(__shared_weak_owners_);
    }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    void __release_shared() noexcept {
      if (__shared_count::__release_shared())
        __release_weak();
    }

    void __release_weak() noexcept;
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    long use_count() const noexcept {return __shared_count::use_count();}
    __shared_weak_count* lock() noexcept;

    virtual const void* __get_deleter(const type_info&) const noexcept;
private:
    virtual void __on_zero_shared_weak() noexcept = 0;
};

template <class _Tp, class _Dp, class _Alloc>
class __shared_ptr_pointer
    : public __shared_weak_count
{
    __compressed_pair<__compressed_pair<_Tp, _Dp>, _Alloc> __data_;
public:
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    __shared_ptr_pointer(_Tp __p, _Dp __d, _Alloc __a)
        : __data_(__compressed_pair<_Tp, _Dp>(__p, std::move(__d)), std::move(__a)) {}


    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) const void* __get_deleter(const type_info&) const noexcept override;


private:
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) void __on_zero_shared() noexcept override;
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) void __on_zero_shared_weak() noexcept override;
};



template <class _Tp, class _Dp, class _Alloc>
const void*
__shared_ptr_pointer<_Tp, _Dp, _Alloc>::__get_deleter(const type_info& __t) const noexcept
{
    return __t == typeid(_Dp) ? std::addressof(__data_.first().second()) : nullptr;
}



template <class _Tp, class _Dp, class _Alloc>
void
__shared_ptr_pointer<_Tp, _Dp, _Alloc>::__on_zero_shared() noexcept
{
    __data_.first().second()(__data_.first().first());
    __data_.first().second().~_Dp();
}

template <class _Tp, class _Dp, class _Alloc>
void
__shared_ptr_pointer<_Tp, _Dp, _Alloc>::__on_zero_shared_weak() noexcept
{
    typedef typename __allocator_traits_rebind<_Alloc, __shared_ptr_pointer>::type _Al;
    typedef allocator_traits<_Al> _ATraits;
    typedef pointer_traits<typename _ATraits::pointer> _PTraits;

    _Al __a(__data_.second());
    __data_.second().~_Alloc();
    __a.deallocate(_PTraits::pointer_to(*this), 1);
}




struct __for_overwrite_tag {};

template <class _Tp, class _Alloc>
struct __shared_ptr_emplace
    : __shared_weak_count
{
    template <class... _Args, class _Allocator = _Alloc, __enable_if_t<is_same<typename _Allocator::value_type, __for_overwrite_tag>::value, int> = 0>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    explicit __shared_ptr_emplace(_Alloc __a, _Args&& ...)
        : __storage_(std::move(__a))
    {
        static_assert(sizeof...(_Args) == 0, "No argument should be provided to the control block when using _for_overwrite");
        ::new ((void*)__get_elem()) _Tp;
    }

    template <class... _Args, class _Allocator = _Alloc, __enable_if_t<!is_same<typename _Allocator::value_type, __for_overwrite_tag>::value, int> = 0>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    explicit __shared_ptr_emplace(_Alloc __a, _Args&& ...__args)
        : __storage_(std::move(__a))
    {
        using _TpAlloc = typename __allocator_traits_rebind<_Alloc, _Tp>::type;
        _TpAlloc __tmp(*__get_alloc());
        allocator_traits<_TpAlloc>::construct(__tmp, __get_elem(), std::forward<_Args>(__args)...);
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    _Alloc* __get_alloc() noexcept { return __storage_.__get_alloc(); }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    _Tp* __get_elem() noexcept { return __storage_.__get_elem(); }

private:
    template <class _Allocator = _Alloc, __enable_if_t<is_same<typename _Allocator::value_type, __for_overwrite_tag>::value, int> = 0>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) void __on_zero_shared_impl() noexcept {
        __get_elem()->~_Tp();
    }

    template <class _Allocator = _Alloc, __enable_if_t<!is_same<typename _Allocator::value_type, __for_overwrite_tag>::value, int> = 0>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) void __on_zero_shared_impl() noexcept {
        using _TpAlloc = typename __allocator_traits_rebind<_Allocator, _Tp>::type;
        _TpAlloc __tmp(*__get_alloc());
        allocator_traits<_TpAlloc>::destroy(__tmp, __get_elem());
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) void __on_zero_shared() noexcept override {
        __on_zero_shared_impl();
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) void __on_zero_shared_weak() noexcept override {
        using _ControlBlockAlloc = typename __allocator_traits_rebind<_Alloc, __shared_ptr_emplace>::type;
        using _ControlBlockPointer = typename allocator_traits<_ControlBlockAlloc>::pointer;
        _ControlBlockAlloc __tmp(*__get_alloc());
        __storage_.~_Storage();
        allocator_traits<_ControlBlockAlloc>::deallocate(__tmp,
            pointer_traits<_ControlBlockPointer>::pointer_to(*this), 1);
    }
# 347 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__memory/shared_ptr.h" 3
    using _CompressedPair = __compressed_pair<_Alloc, _Tp>;
    struct alignas(_CompressedPair) _Storage {
        char __blob_[sizeof(_CompressedPair)];

        __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) explicit _Storage(_Alloc&& __a) {
            ::new ((void*)__get_alloc()) _Alloc(std::move(__a));
        }
        __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) ~_Storage() {
            __get_alloc()->~_Alloc();
        }
        __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) _Alloc* __get_alloc() noexcept {
            _CompressedPair *__as_pair = reinterpret_cast<_CompressedPair*>(__blob_);
            typename _CompressedPair::_Base1* __first = _CompressedPair::__get_first_base(__as_pair);
            _Alloc *__alloc = reinterpret_cast<_Alloc*>(__first);
            return __alloc;
        }
        __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) __attribute__((__no_sanitize__("cfi"))) _Tp* __get_elem() noexcept {
            _CompressedPair *__as_pair = reinterpret_cast<_CompressedPair*>(__blob_);
            typename _CompressedPair::_Base2* __second = _CompressedPair::__get_second_base(__as_pair);
            _Tp *__elem = reinterpret_cast<_Tp*>(__second);
            return __elem;
        }
    };

    static_assert(alignof(_Storage) == alignof(_CompressedPair), "");
    static_assert(sizeof(_Storage) == sizeof(_CompressedPair), "");
    _Storage __storage_;
};

struct __shared_ptr_dummy_rebind_allocator_type;
template <>
class allocator<__shared_ptr_dummy_rebind_allocator_type>
{
public:
    template <class _Other>
    struct rebind
    {
        typedef allocator<_Other> other;
    };
};

template<class _Tp> class enable_shared_from_this;





template <class _Yp, class _Tp>
struct __bounded_convertible_to_unbounded : false_type {};

template <class _Up, std::size_t _Np, class _Tp>
struct __bounded_convertible_to_unbounded<_Up[_Np], _Tp>
        : is_same<__remove_cv_t<_Tp>, _Up[]> {};

template <class _Yp, class _Tp>
struct __compatible_with
    : _Or<
        is_convertible<_Yp*, _Tp*>,
        __bounded_convertible_to_unbounded<_Yp, _Tp>
    > {};
# 419 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__memory/shared_ptr.h" 3
template <class _Yp, class _Tp, class = void>
struct __raw_pointer_compatible_with : _And<
        _Not<is_array<_Tp>>,
        is_convertible<_Yp*, _Tp*>
        > {};

template <class _Yp, class _Up, std::size_t _Np>
struct __raw_pointer_compatible_with<_Yp, _Up[_Np], __enable_if_t<
            is_convertible<_Yp(*)[_Np], _Up(*)[_Np]>::value> >
        : true_type {};

template <class _Yp, class _Up>
struct __raw_pointer_compatible_with<_Yp, _Up[], __enable_if_t<
            is_convertible<_Yp(*)[], _Up(*)[]>::value> >
        : true_type {};
# 442 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__memory/shared_ptr.h" 3
template <class _Ptr, class = void>
struct __is_deletable : false_type { };
template <class _Ptr>
struct __is_deletable<_Ptr, decltype(delete std::declval<_Ptr>())> : true_type { };

template <class _Ptr, class = void>
struct __is_array_deletable : false_type { };
template <class _Ptr>
struct __is_array_deletable<_Ptr, decltype(delete[] std::declval<_Ptr>())> : true_type { };

template <class _Dp, class _Pt,
    class = decltype(std::declval<_Dp>()(std::declval<_Pt>()))>
true_type __well_formed_deleter_test(int);

template <class, class>
false_type __well_formed_deleter_test(...);

template <class _Dp, class _Pt>
struct __well_formed_deleter : decltype(std::__well_formed_deleter_test<_Dp, _Pt>(0)) {};

template<class _Dp, class _Yp, class _Tp>
struct __shared_ptr_deleter_ctor_reqs
{
    static const bool value = __raw_pointer_compatible_with<_Yp, _Tp>::value &&
                              is_move_constructible<_Dp>::value &&
                              __well_formed_deleter<_Dp, _Yp*>::value;
};







template<class _Tp>
class shared_ptr
{
public:

    typedef weak_ptr<_Tp> weak_type;
    typedef remove_extent_t<_Tp> element_type;




private:
    element_type* __ptr_;
    __shared_weak_count* __cntrl_;

public:
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    constexpr shared_ptr() noexcept
        : __ptr_(nullptr),
          __cntrl_(nullptr)
    { }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    constexpr shared_ptr(nullptr_t) noexcept
        : __ptr_(nullptr),
          __cntrl_(nullptr)
    { }

    template<class _Yp, class = __enable_if_t<
        _And<
            __raw_pointer_compatible_with<_Yp, _Tp>




            , _If<is_array<_Tp>::value, __is_array_deletable<_Yp*>, __is_deletable<_Yp*> >

        >::value
    > >
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) explicit shared_ptr(_Yp* __p) : __ptr_(__p) {
        unique_ptr<_Yp> __hold(__p);
        typedef typename __shared_ptr_default_allocator<_Yp>::type _AllocT;
        typedef __shared_ptr_pointer<_Yp*, __shared_ptr_default_delete<_Tp, _Yp>, _AllocT> _CntrlBlk;
        __cntrl_ = new _CntrlBlk(__p, __shared_ptr_default_delete<_Tp, _Yp>(), _AllocT());
        __hold.release();
        __enable_weak_this(__p, __p);
    }

    template<class _Yp, class _Dp, class = __enable_if_t<__shared_ptr_deleter_ctor_reqs<_Dp, _Yp, _Tp>::value> >
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    shared_ptr(_Yp* __p, _Dp __d)
        : __ptr_(__p)
    {




            typedef typename __shared_ptr_default_allocator<_Yp>::type _AllocT;
            typedef __shared_ptr_pointer<_Yp*, _Dp, _AllocT> _CntrlBlk;

            __cntrl_ = new _CntrlBlk(__p, std::move(__d), _AllocT());



            __enable_weak_this(__p, __p);
# 549 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__memory/shared_ptr.h" 3
    }

    template<class _Yp, class _Dp, class _Alloc, class = __enable_if_t<__shared_ptr_deleter_ctor_reqs<_Dp, _Yp, _Tp>::value> >
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    shared_ptr(_Yp* __p, _Dp __d, _Alloc __a)
        : __ptr_(__p)
    {




            typedef __shared_ptr_pointer<_Yp*, _Dp, _Alloc> _CntrlBlk;
            typedef typename __allocator_traits_rebind<_Alloc, _CntrlBlk>::type _A2;
            typedef __allocator_destructor<_A2> _D2;
            _A2 __a2(__a);
            unique_ptr<_CntrlBlk, _D2> __hold2(__a2.allocate(1), _D2(__a2, 1));
            ::new ((void*)std::addressof(*__hold2.get()))

                _CntrlBlk(__p, std::move(__d), __a);



            __cntrl_ = std::addressof(*__hold2.release());
            __enable_weak_this(__p, __p);
# 581 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__memory/shared_ptr.h" 3
    }

    template<class _Dp>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    shared_ptr(nullptr_t __p, _Dp __d)
        : __ptr_(nullptr)
    {




            typedef typename __shared_ptr_default_allocator<_Tp>::type _AllocT;
            typedef __shared_ptr_pointer<nullptr_t, _Dp, _AllocT> _CntrlBlk;

            __cntrl_ = new _CntrlBlk(__p, std::move(__d), _AllocT());
# 607 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__memory/shared_ptr.h" 3
    }

    template<class _Dp, class _Alloc>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    shared_ptr(nullptr_t __p, _Dp __d, _Alloc __a)
        : __ptr_(nullptr)
    {




            typedef __shared_ptr_pointer<nullptr_t, _Dp, _Alloc> _CntrlBlk;
            typedef typename __allocator_traits_rebind<_Alloc, _CntrlBlk>::type _A2;
            typedef __allocator_destructor<_A2> _D2;
            _A2 __a2(__a);
            unique_ptr<_CntrlBlk, _D2> __hold2(__a2.allocate(1), _D2(__a2, 1));
            ::new ((void*)std::addressof(*__hold2.get()))

                _CntrlBlk(__p, std::move(__d), __a);



            __cntrl_ = std::addressof(*__hold2.release());
# 638 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__memory/shared_ptr.h" 3
    }

    template<class _Yp>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    shared_ptr(const shared_ptr<_Yp>& __r, element_type *__p) noexcept
        : __ptr_(__p),
          __cntrl_(__r.__cntrl_)
    {
        if (__cntrl_)
            __cntrl_->__add_shared();
    }




    template <class _Yp>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) shared_ptr(shared_ptr<_Yp>&& __r, element_type* __p) noexcept
        : __ptr_(__p),
          __cntrl_(__r.__cntrl_) {
      __r.__ptr_ = nullptr;
      __r.__cntrl_ = nullptr;
    }


    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    shared_ptr(const shared_ptr& __r) noexcept
        : __ptr_(__r.__ptr_),
          __cntrl_(__r.__cntrl_)
    {
        if (__cntrl_)
            __cntrl_->__add_shared();
    }

    template<class _Yp, class = __enable_if_t<__compatible_with<_Yp, _Tp>::value> >
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    shared_ptr(const shared_ptr<_Yp>& __r) noexcept
        : __ptr_(__r.__ptr_),
          __cntrl_(__r.__cntrl_)
    {
        if (__cntrl_)
            __cntrl_->__add_shared();
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    shared_ptr(shared_ptr&& __r) noexcept
        : __ptr_(__r.__ptr_),
          __cntrl_(__r.__cntrl_)
    {
        __r.__ptr_ = nullptr;
        __r.__cntrl_ = nullptr;
    }

    template<class _Yp, class = __enable_if_t<__compatible_with<_Yp, _Tp>::value> >
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    shared_ptr(shared_ptr<_Yp>&& __r) noexcept
        : __ptr_(__r.__ptr_),
          __cntrl_(__r.__cntrl_)
    {
        __r.__ptr_ = nullptr;
        __r.__cntrl_ = nullptr;
    }

    template<class _Yp, class = __enable_if_t<__compatible_with<_Yp, _Tp>::value> >
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    explicit shared_ptr(const weak_ptr<_Yp>& __r)
        : __ptr_(__r.__ptr_),
          __cntrl_(__r.__cntrl_ ? __r.__cntrl_->lock() : __r.__cntrl_)
    {
        if (__cntrl_ == nullptr)
            __throw_bad_weak_ptr();
    }
# 723 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__memory/shared_ptr.h" 3
    template <class _Yp, class _Dp, class = __enable_if_t<
        !is_lvalue_reference<_Dp>::value &&
         __compatible_with<_Yp, _Tp>::value &&
         is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value
    > >
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    shared_ptr(unique_ptr<_Yp, _Dp>&& __r)
        : __ptr_(__r.get())
    {

        if (__ptr_ == nullptr)
            __cntrl_ = nullptr;
        else

        {
            typedef typename __shared_ptr_default_allocator<_Yp>::type _AllocT;
            typedef __shared_ptr_pointer<typename unique_ptr<_Yp, _Dp>::pointer, _Dp, _AllocT> _CntrlBlk;
            __cntrl_ = new _CntrlBlk(__r.get(), std::move(__r.get_deleter()), _AllocT());
            __enable_weak_this(__r.get(), __r.get());
        }
        __r.release();
    }

    template <class _Yp, class _Dp, class = void, class = __enable_if_t<
        is_lvalue_reference<_Dp>::value &&
         __compatible_with<_Yp, _Tp>::value &&
        is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value
    > >
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    shared_ptr(unique_ptr<_Yp, _Dp>&& __r)
        : __ptr_(__r.get())
    {

        if (__ptr_ == nullptr)
            __cntrl_ = nullptr;
        else

        {
            typedef typename __shared_ptr_default_allocator<_Yp>::type _AllocT;
            typedef __shared_ptr_pointer<typename unique_ptr<_Yp, _Dp>::pointer,
                                        reference_wrapper<__libcpp_remove_reference_t<_Dp> >,
                                        _AllocT> _CntrlBlk;
            __cntrl_ = new _CntrlBlk(__r.get(), std::ref(__r.get_deleter()), _AllocT());
            __enable_weak_this(__r.get(), __r.get());
        }
        __r.release();
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    ~shared_ptr()
    {
        if (__cntrl_)
            __cntrl_->__release_shared();
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    shared_ptr<_Tp>& operator=(const shared_ptr& __r) noexcept
    {
        shared_ptr(__r).swap(*this);
        return *this;
    }

    template<class _Yp, class = __enable_if_t<__compatible_with<_Yp, _Tp>::value> >
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    shared_ptr<_Tp>& operator=(const shared_ptr<_Yp>& __r) noexcept
    {
        shared_ptr(__r).swap(*this);
        return *this;
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    shared_ptr<_Tp>& operator=(shared_ptr&& __r) noexcept
    {
        shared_ptr(std::move(__r)).swap(*this);
        return *this;
    }

    template<class _Yp, class = __enable_if_t<__compatible_with<_Yp, _Tp>::value> >
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    shared_ptr<_Tp>& operator=(shared_ptr<_Yp>&& __r)
    {
        shared_ptr(std::move(__r)).swap(*this);
        return *this;
    }
# 821 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__memory/shared_ptr.h" 3
    template <class _Yp, class _Dp, class = __enable_if_t<_And<
        __compatible_with<_Yp, _Tp>,
        is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>
    >::value> >
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    shared_ptr<_Tp>& operator=(unique_ptr<_Yp, _Dp>&& __r)
    {
        shared_ptr(std::move(__r)).swap(*this);
        return *this;
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    void swap(shared_ptr& __r) noexcept
    {
        std::swap(__ptr_, __r.__ptr_);
        std::swap(__cntrl_, __r.__cntrl_);
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    void reset() noexcept
    {
        shared_ptr().swap(*this);
    }

    template<class _Yp, class = __enable_if_t<
        __raw_pointer_compatible_with<_Yp, _Tp>::value
    > >
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    void reset(_Yp* __p)
    {
        shared_ptr(__p).swap(*this);
    }

    template<class _Yp, class _Dp, class = __enable_if_t<
        __shared_ptr_deleter_ctor_reqs<_Dp, _Yp, _Tp>::value> >
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    void reset(_Yp* __p, _Dp __d)
    {
        shared_ptr(__p, __d).swap(*this);
    }

    template<class _Yp, class _Dp, class _Alloc, class = __enable_if_t<
        __shared_ptr_deleter_ctor_reqs<_Dp, _Yp, _Tp>::value> >
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    void reset(_Yp* __p, _Dp __d, _Alloc __a)
    {
        shared_ptr(__p, __d, __a).swap(*this);
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    element_type* get() const noexcept
    {
        return __ptr_;
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    __add_lvalue_reference_t<element_type> operator*() const noexcept
    {
        return *__ptr_;
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    element_type* operator->() const noexcept
    {
        static_assert(!is_array<_Tp>::value,
                      "std::shared_ptr<T>::operator-> is only valid when T is not an array type.");
        return __ptr_;
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    long use_count() const noexcept
    {
        return __cntrl_ ? __cntrl_->use_count() : 0;
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    bool unique() const noexcept
    {
        return use_count() == 1;
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    explicit operator bool() const noexcept
    {
        return get() != nullptr;
    }

    template <class _Up>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    bool owner_before(shared_ptr<_Up> const& __p) const noexcept
    {
        return __cntrl_ < __p.__cntrl_;
    }

    template <class _Up>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    bool owner_before(weak_ptr<_Up> const& __p) const noexcept
    {
        return __cntrl_ < __p.__cntrl_;
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    bool __owner_equivalent(const shared_ptr& __p) const
    {
        return __cntrl_ == __p.__cntrl_;
    }


    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    __add_lvalue_reference_t<element_type> operator[](ptrdiff_t __i) const
    {
            static_assert(is_array<_Tp>::value,
                          "std::shared_ptr<T>::operator[] is only valid when T is an array type.");
            return __ptr_[__i];
    }



    template <class _Dp>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    _Dp* __get_deleter() const noexcept
    {
        return static_cast<_Dp*>(__cntrl_
                    ? const_cast<void *>(__cntrl_->__get_deleter(typeid(_Dp)))
                      : nullptr);
    }


    template<class _Yp, class _CntrlBlk>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    static shared_ptr<_Tp> __create_with_control_block(_Yp* __p, _CntrlBlk* __cntrl) noexcept
    {
        shared_ptr<_Tp> __r;
        __r.__ptr_ = __p;
        __r.__cntrl_ = __cntrl;
        __r.__enable_weak_this(__r.__ptr_, __r.__ptr_);
        return __r;
    }

private:
    template <class _Yp, bool = is_function<_Yp>::value>
    struct __shared_ptr_default_allocator
    {
        typedef allocator<_Yp> type;
    };

    template <class _Yp>
    struct __shared_ptr_default_allocator<_Yp, true>
    {
        typedef allocator<__shared_ptr_dummy_rebind_allocator_type> type;
    };

    template <class _Yp, class _OrigPtr, class = __enable_if_t<
        is_convertible<_OrigPtr*, const enable_shared_from_this<_Yp>*>::value
    > >
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    void __enable_weak_this(const enable_shared_from_this<_Yp>* __e, _OrigPtr* __ptr) noexcept
    {
        typedef __remove_cv_t<_Yp> _RawYp;
        if (__e && __e->__weak_this_.expired())
        {
            __e->__weak_this_ = shared_ptr<_RawYp>(*this,
                const_cast<_RawYp*>(static_cast<const _Yp*>(__ptr)));
        }
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) void __enable_weak_this(...) noexcept { }

    template <class, class _Yp>
    struct __shared_ptr_default_delete
        : default_delete<_Yp>
    { };

    template <class _Yp, class _Un, size_t _Sz>
    struct __shared_ptr_default_delete<_Yp[_Sz], _Un>
        : default_delete<_Yp[]>
    { };

    template <class _Yp, class _Un>
    struct __shared_ptr_default_delete<_Yp[], _Un>
        : default_delete<_Yp[]>
    { };

    template <class _Up> friend class shared_ptr;
    template <class _Up> friend class weak_ptr;
};


template<class _Tp>
shared_ptr(weak_ptr<_Tp>) -> shared_ptr<_Tp>;
template<class _Tp, class _Dp>
shared_ptr(unique_ptr<_Tp, _Dp>) -> shared_ptr<_Tp>;





template<class _Tp, class _Alloc, class ..._Args, class = __enable_if_t<!is_array<_Tp>::value> >
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
shared_ptr<_Tp> allocate_shared(const _Alloc& __a, _Args&& ...__args)
{
    using _ControlBlock = __shared_ptr_emplace<_Tp, _Alloc>;
    using _ControlBlockAllocator = typename __allocator_traits_rebind<_Alloc, _ControlBlock>::type;
    __allocation_guard<_ControlBlockAllocator> __guard(__a, 1);
    ::new ((void*)std::addressof(*__guard.__get())) _ControlBlock(__a, std::forward<_Args>(__args)...);
    auto __control_block = __guard.__release_ptr();
    return shared_ptr<_Tp>::__create_with_control_block((*__control_block).__get_elem(), std::addressof(*__control_block));
}

template<class _Tp, class ..._Args, class = __enable_if_t<!is_array<_Tp>::value> >
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
shared_ptr<_Tp> make_shared(_Args&& ...__args)
{
    return std::allocate_shared<_Tp>(allocator<_Tp>(), std::forward<_Args>(__args)...);
}



template<class _Tp, class _Alloc, __enable_if_t<!is_array<_Tp>::value, int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
shared_ptr<_Tp> allocate_shared_for_overwrite(const _Alloc& __a)
{
    using _ForOverwriteAllocator = __allocator_traits_rebind_t<_Alloc, __for_overwrite_tag>;
    _ForOverwriteAllocator __alloc(__a);
    return std::allocate_shared<_Tp>(__alloc);
}

template<class _Tp, __enable_if_t<!is_array<_Tp>::value, int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
shared_ptr<_Tp> make_shared_for_overwrite()
{
    return std::allocate_shared_for_overwrite<_Tp>(allocator<_Tp>());
}





template <size_t _Alignment>
struct __sp_aligned_storage {
    alignas(_Alignment) char __storage[_Alignment];
};

template <class _Tp, class _Alloc>
struct __unbounded_array_control_block;

template <class _Tp, class _Alloc>
struct __unbounded_array_control_block<_Tp[], _Alloc> : __shared_weak_count
{
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    _Tp* __get_data() noexcept { return __data_; }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    explicit __unbounded_array_control_block(_Alloc const& __alloc, size_t __count, _Tp const& __arg)
        : __alloc_(__alloc), __count_(__count)
    {
        std::__uninitialized_allocator_fill_n_multidimensional(__alloc_, std::begin(__data_), __count_, __arg);
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    explicit __unbounded_array_control_block(_Alloc const& __alloc, size_t __count)
        : __alloc_(__alloc), __count_(__count)
    {

        if constexpr (is_same_v<typename _Alloc::value_type, __for_overwrite_tag>) {


            std::uninitialized_default_construct_n(std::begin(__data_), __count_);
        } else {
            std::__uninitialized_allocator_value_construct_n_multidimensional(__alloc_, std::begin(__data_), __count_);
        }



    }



    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    static constexpr size_t __bytes_for(size_t __elements) {






        size_t __bytes = __elements == 0 ? sizeof(__unbounded_array_control_block)
                                         : (__elements - 1) * sizeof(_Tp) + sizeof(__unbounded_array_control_block);
        constexpr size_t __align = alignof(_Tp);
        return (__bytes + __align - 1) & ~(__align - 1);
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__))
    ~__unbounded_array_control_block() override { }

private:
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) void __on_zero_shared() noexcept override {

        if constexpr (is_same_v<typename _Alloc::value_type, __for_overwrite_tag>) {
            std::__reverse_destroy(__data_, __data_ + __count_);
        } else {
            __allocator_traits_rebind_t<_Alloc, _Tp> __value_alloc(__alloc_);
            std::__allocator_destroy_multidimensional(__value_alloc, __data_, __data_ + __count_);
        }




    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) void __on_zero_shared_weak() noexcept override {
        using _AlignedStorage = __sp_aligned_storage<alignof(__unbounded_array_control_block)>;
        using _StorageAlloc = __allocator_traits_rebind_t<_Alloc, _AlignedStorage>;
        using _PointerTraits = pointer_traits<typename allocator_traits<_StorageAlloc>::pointer>;

        _StorageAlloc __tmp(__alloc_);
        __alloc_.~_Alloc();
        size_t __size = __unbounded_array_control_block::__bytes_for(__count_);
        _AlignedStorage* __storage = reinterpret_cast<_AlignedStorage*>(this);
        allocator_traits<_StorageAlloc>::deallocate(__tmp, _PointerTraits::pointer_to(*__storage), __size);
    }

    [[__no_unique_address__]] _Alloc __alloc_;
    size_t __count_;
    union {
        _Tp __data_[1];
    };
};

template<class _Array, class _Alloc, class... _Arg>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
shared_ptr<_Array> __allocate_shared_unbounded_array(const _Alloc& __a, size_t __n, _Arg&& ...__arg)
{
    static_assert(__libcpp_is_unbounded_array<_Array>::value);




    using _ControlBlock = __unbounded_array_control_block<_Array, _Alloc>;
    using _AlignedStorage = __sp_aligned_storage<alignof(_ControlBlock)>;
    using _StorageAlloc = __allocator_traits_rebind_t<_Alloc, _AlignedStorage>;
    __allocation_guard<_StorageAlloc> __guard(__a, _ControlBlock::__bytes_for(__n) / sizeof(_AlignedStorage));
    _ControlBlock* __control_block = reinterpret_cast<_ControlBlock*>(std::addressof(*__guard.__get()));
    std::__construct_at(__control_block, __a, __n, std::forward<_Arg>(__arg)...);
    __guard.__release_ptr();
    return shared_ptr<_Array>::__create_with_control_block(__control_block->__get_data(), __control_block);
}

template <class _Tp, class _Alloc>
struct __bounded_array_control_block;

template <class _Tp, size_t _Count, class _Alloc>
struct __bounded_array_control_block<_Tp[_Count], _Alloc>
    : __shared_weak_count
{
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    _Tp* __get_data() noexcept { return __data_; }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    explicit __bounded_array_control_block(_Alloc const& __alloc, _Tp const& __arg) : __alloc_(__alloc) {
        std::__uninitialized_allocator_fill_n_multidimensional(__alloc_, std::addressof(__data_[0]), _Count, __arg);
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    explicit __bounded_array_control_block(_Alloc const& __alloc) : __alloc_(__alloc) {

        if constexpr (is_same_v<typename _Alloc::value_type, __for_overwrite_tag>) {


            std::uninitialized_default_construct_n(std::addressof(__data_[0]), _Count);
        } else {
            std::__uninitialized_allocator_value_construct_n_multidimensional(__alloc_, std::addressof(__data_[0]), _Count);
        }



    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__))
    ~__bounded_array_control_block() override { }

private:
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) void __on_zero_shared() noexcept override {

        if constexpr (is_same_v<typename _Alloc::value_type, __for_overwrite_tag>) {
            std::__reverse_destroy(__data_, __data_ + _Count);
        } else {
            __allocator_traits_rebind_t<_Alloc, _Tp> __value_alloc(__alloc_);
            std::__allocator_destroy_multidimensional(__value_alloc, __data_, __data_ + _Count);
        }




    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) void __on_zero_shared_weak() noexcept override {
        using _ControlBlockAlloc = __allocator_traits_rebind_t<_Alloc, __bounded_array_control_block>;
        using _PointerTraits = pointer_traits<typename allocator_traits<_ControlBlockAlloc>::pointer>;

        _ControlBlockAlloc __tmp(__alloc_);
        __alloc_.~_Alloc();
        allocator_traits<_ControlBlockAlloc>::deallocate(__tmp, _PointerTraits::pointer_to(*this), sizeof(*this));
    }

    [[__no_unique_address__]] _Alloc __alloc_;
    union {
        _Tp __data_[_Count];
    };
};

template<class _Array, class _Alloc, class... _Arg>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
shared_ptr<_Array> __allocate_shared_bounded_array(const _Alloc& __a, _Arg&& ...__arg)
{
    static_assert(__libcpp_is_bounded_array<_Array>::value);
    using _ControlBlock = __bounded_array_control_block<_Array, _Alloc>;
    using _ControlBlockAlloc = __allocator_traits_rebind_t<_Alloc, _ControlBlock>;

    __allocation_guard<_ControlBlockAlloc> __guard(__a, 1);
    _ControlBlock* __control_block = reinterpret_cast<_ControlBlock*>(std::addressof(*__guard.__get()));
    std::__construct_at(__control_block, __a, std::forward<_Arg>(__arg)...);
    __guard.__release_ptr();
    return shared_ptr<_Array>::__create_with_control_block(__control_block->__get_data(), __control_block);
}






template<class _Tp, class _Alloc, class = __enable_if_t<is_bounded_array<_Tp>::value>>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
shared_ptr<_Tp> allocate_shared(const _Alloc& __a)
{
    return std::__allocate_shared_bounded_array<_Tp>(__a);
}

template<class _Tp, class _Alloc, class = __enable_if_t<is_bounded_array<_Tp>::value>>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
shared_ptr<_Tp> allocate_shared(const _Alloc& __a, const remove_extent_t<_Tp>& __u)
{
    return std::__allocate_shared_bounded_array<_Tp>(__a, __u);
}

template<class _Tp, class _Alloc, __enable_if_t<is_bounded_array<_Tp>::value, int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
shared_ptr<_Tp> allocate_shared_for_overwrite(const _Alloc& __a)
{
    using _ForOverwriteAllocator = __allocator_traits_rebind_t<_Alloc, __for_overwrite_tag>;
    _ForOverwriteAllocator __alloc(__a);
    return std::__allocate_shared_bounded_array<_Tp>(__alloc);
}

template<class _Tp, class = __enable_if_t<is_bounded_array<_Tp>::value>>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
shared_ptr<_Tp> make_shared()
{
    return std::__allocate_shared_bounded_array<_Tp>(allocator<_Tp>());
}

template<class _Tp, class = __enable_if_t<is_bounded_array<_Tp>::value>>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
shared_ptr<_Tp> make_shared(const remove_extent_t<_Tp>& __u)
{
    return std::__allocate_shared_bounded_array<_Tp>(allocator<_Tp>(), __u);
}

template<class _Tp, __enable_if_t<is_bounded_array<_Tp>::value, int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
shared_ptr<_Tp> make_shared_for_overwrite()
{
    return std::__allocate_shared_bounded_array<_Tp>(allocator<__for_overwrite_tag>());
}


template<class _Tp, class _Alloc, class = __enable_if_t<is_unbounded_array<_Tp>::value>>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
shared_ptr<_Tp> allocate_shared(const _Alloc& __a, size_t __n)
{
    return std::__allocate_shared_unbounded_array<_Tp>(__a, __n);
}

template<class _Tp, class _Alloc, class = __enable_if_t<is_unbounded_array<_Tp>::value>>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
shared_ptr<_Tp> allocate_shared(const _Alloc& __a, size_t __n, const remove_extent_t<_Tp>& __u)
{
    return std::__allocate_shared_unbounded_array<_Tp>(__a, __n, __u);
}

template<class _Tp, class _Alloc, __enable_if_t<is_unbounded_array<_Tp>::value, int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
shared_ptr<_Tp> allocate_shared_for_overwrite(const _Alloc& __a, size_t __n)
{
    using _ForOverwriteAllocator = __allocator_traits_rebind_t<_Alloc, __for_overwrite_tag>;
    _ForOverwriteAllocator __alloc(__a);
    return std::__allocate_shared_unbounded_array<_Tp>(__alloc, __n);
}

template<class _Tp, class = __enable_if_t<is_unbounded_array<_Tp>::value>>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
shared_ptr<_Tp> make_shared(size_t __n)
{
    return std::__allocate_shared_unbounded_array<_Tp>(allocator<_Tp>(), __n);
}

template<class _Tp, class = __enable_if_t<is_unbounded_array<_Tp>::value>>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
shared_ptr<_Tp> make_shared(size_t __n, const remove_extent_t<_Tp>& __u)
{
    return std::__allocate_shared_unbounded_array<_Tp>(allocator<_Tp>(), __n, __u);
}

template<class _Tp, __enable_if_t<is_unbounded_array<_Tp>::value, int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
shared_ptr<_Tp> make_shared_for_overwrite(size_t __n)
{
    return std::__allocate_shared_unbounded_array<_Tp>(allocator<__for_overwrite_tag>(), __n);
}



template<class _Tp, class _Up>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
bool
operator==(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) noexcept
{
    return __x.get() == __y.get();
}
# 1402 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__memory/shared_ptr.h" 3
template<class _Tp, class _Up>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) strong_ordering
operator<=>(shared_ptr<_Tp> const& __x, shared_ptr<_Up> const& __y) noexcept
{
    return compare_three_way()(__x.get(), __y.get());
}


template<class _Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
bool
operator==(const shared_ptr<_Tp>& __x, nullptr_t) noexcept
{
    return !__x;
}
# 1511 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__memory/shared_ptr.h" 3
template<class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) strong_ordering
operator<=>(shared_ptr<_Tp> const& __x, nullptr_t) noexcept
{
    return compare_three_way()(__x.get(), static_cast<typename shared_ptr<_Tp>::element_type*>(nullptr));
}


template<class _Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
void
swap(shared_ptr<_Tp>& __x, shared_ptr<_Tp>& __y) noexcept
{
    __x.swap(__y);
}

template<class _Tp, class _Up>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
shared_ptr<_Tp>
static_pointer_cast(const shared_ptr<_Up>& __r) noexcept
{
    return shared_ptr<_Tp>(__r,
                           static_cast<
                               typename shared_ptr<_Tp>::element_type*>(__r.get()));
}




template <class _Tp, class _Up>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) shared_ptr<_Tp> static_pointer_cast(shared_ptr<_Up>&& __r) noexcept {
  return shared_ptr<_Tp>(std::move(__r), static_cast<typename shared_ptr<_Tp>::element_type*>(__r.get()));
}


template<class _Tp, class _Up>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
shared_ptr<_Tp>
dynamic_pointer_cast(const shared_ptr<_Up>& __r) noexcept
{
    typedef typename shared_ptr<_Tp>::element_type _ET;
    _ET* __p = dynamic_cast<_ET*>(__r.get());
    return __p ? shared_ptr<_Tp>(__r, __p) : shared_ptr<_Tp>();
}




template <class _Tp, class _Up>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) shared_ptr<_Tp> dynamic_pointer_cast(shared_ptr<_Up>&& __r) noexcept {
  auto* __p = dynamic_cast<typename shared_ptr<_Tp>::element_type*>(__r.get());
  return __p ? shared_ptr<_Tp>(std::move(__r), __p) : shared_ptr<_Tp>();
}


template<class _Tp, class _Up>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) shared_ptr<_Tp>
const_pointer_cast(const shared_ptr<_Up>& __r) noexcept
{
    typedef typename shared_ptr<_Tp>::element_type _RTp;
    return shared_ptr<_Tp>(__r, const_cast<_RTp*>(__r.get()));
}




template <class _Tp, class _Up>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) shared_ptr<_Tp> const_pointer_cast(shared_ptr<_Up>&& __r) noexcept {
  return shared_ptr<_Tp>(std::move(__r), const_cast<typename shared_ptr<_Tp>::element_type*>(__r.get()));
}


template<class _Tp, class _Up>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) shared_ptr<_Tp>
reinterpret_pointer_cast(const shared_ptr<_Up>& __r) noexcept
{
    return shared_ptr<_Tp>(__r,
                           reinterpret_cast<
                               typename shared_ptr<_Tp>::element_type*>(__r.get()));
}




template <class _Tp, class _Up>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) shared_ptr<_Tp> reinterpret_pointer_cast(shared_ptr<_Up>&& __r) noexcept {
  return shared_ptr<_Tp>(std::move(__r), reinterpret_cast<typename shared_ptr<_Tp>::element_type*>(__r.get()));
}




template<class _Dp, class _Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
_Dp*
get_deleter(const shared_ptr<_Tp>& __p) noexcept
{
    return __p.template __get_deleter<_Dp>();
}



template<class _Tp>
class weak_ptr
{
public:

    typedef remove_extent_t<_Tp> element_type;




private:
    element_type* __ptr_;
    __shared_weak_count* __cntrl_;

public:
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    constexpr weak_ptr() noexcept;

    template<class _Yp, __enable_if_t<__compatible_with<_Yp, _Tp>::value, int> = 0>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) weak_ptr(shared_ptr<_Yp> const& __r) noexcept;

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    weak_ptr(weak_ptr const& __r) noexcept;

    template<class _Yp, __enable_if_t<__compatible_with<_Yp, _Tp>::value, int> = 0>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) weak_ptr(weak_ptr<_Yp> const& __r) noexcept;

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    weak_ptr(weak_ptr&& __r) noexcept;

    template<class _Yp, __enable_if_t<__compatible_with<_Yp, _Tp>::value, int> = 0>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) weak_ptr(weak_ptr<_Yp>&& __r) noexcept;

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) ~weak_ptr();

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    weak_ptr& operator=(weak_ptr const& __r) noexcept;
    template<class _Yp, __enable_if_t<__compatible_with<_Yp, _Tp>::value, int> = 0>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) weak_ptr&
        operator=(weak_ptr<_Yp> const& __r) noexcept;

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    weak_ptr& operator=(weak_ptr&& __r) noexcept;
    template<class _Yp, __enable_if_t<__compatible_with<_Yp, _Tp>::value, int> = 0>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) weak_ptr&
        operator=(weak_ptr<_Yp>&& __r) noexcept;

    template<class _Yp, __enable_if_t<__compatible_with<_Yp, _Tp>::value, int> = 0>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) weak_ptr&
        operator=(shared_ptr<_Yp> const& __r) noexcept;

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    void swap(weak_ptr& __r) noexcept;
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    void reset() noexcept;

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    long use_count() const noexcept
        {return __cntrl_ ? __cntrl_->use_count() : 0;}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    bool expired() const noexcept
        {return __cntrl_ == nullptr || __cntrl_->use_count() == 0;}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) shared_ptr<_Tp> lock() const noexcept;
    template<class _Up>
        __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
        bool owner_before(const shared_ptr<_Up>& __r) const noexcept
        {return __cntrl_ < __r.__cntrl_;}
    template<class _Up>
        __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
        bool owner_before(const weak_ptr<_Up>& __r) const noexcept
        {return __cntrl_ < __r.__cntrl_;}

    template <class _Up> friend class weak_ptr;
    template <class _Up> friend class shared_ptr;
};


template<class _Tp>
weak_ptr(shared_ptr<_Tp>) -> weak_ptr<_Tp>;


template<class _Tp>
inline
constexpr
weak_ptr<_Tp>::weak_ptr() noexcept
    : __ptr_(nullptr),
      __cntrl_(nullptr)
{
}

template<class _Tp>
inline
weak_ptr<_Tp>::weak_ptr(weak_ptr const& __r) noexcept
    : __ptr_(__r.__ptr_),
      __cntrl_(__r.__cntrl_)
{
    if (__cntrl_)
        __cntrl_->__add_weak();
}

template<class _Tp>
template<class _Yp, __enable_if_t<__compatible_with<_Yp, _Tp>::value, int> >
inline
weak_ptr<_Tp>::weak_ptr(shared_ptr<_Yp> const& __r)
                         noexcept
    : __ptr_(__r.__ptr_),
      __cntrl_(__r.__cntrl_)
{
    if (__cntrl_)
        __cntrl_->__add_weak();
}

template<class _Tp>
template<class _Yp, __enable_if_t<__compatible_with<_Yp, _Tp>::value, int> >
inline
weak_ptr<_Tp>::weak_ptr(weak_ptr<_Yp> const& __r)
         noexcept
    : __ptr_(__r.__ptr_),
      __cntrl_(__r.__cntrl_)
{
    if (__cntrl_)
        __cntrl_->__add_weak();
}

template<class _Tp>
inline
weak_ptr<_Tp>::weak_ptr(weak_ptr&& __r) noexcept
    : __ptr_(__r.__ptr_),
      __cntrl_(__r.__cntrl_)
{
    __r.__ptr_ = nullptr;
    __r.__cntrl_ = nullptr;
}

template<class _Tp>
template<class _Yp, __enable_if_t<__compatible_with<_Yp, _Tp>::value, int> >
inline
weak_ptr<_Tp>::weak_ptr(weak_ptr<_Yp>&& __r)
         noexcept
    : __ptr_(__r.__ptr_),
      __cntrl_(__r.__cntrl_)
{
    __r.__ptr_ = nullptr;
    __r.__cntrl_ = nullptr;
}

template<class _Tp>
weak_ptr<_Tp>::~weak_ptr()
{
    if (__cntrl_)
        __cntrl_->__release_weak();
}

template<class _Tp>
inline
weak_ptr<_Tp>&
weak_ptr<_Tp>::operator=(weak_ptr const& __r) noexcept
{
    weak_ptr(__r).swap(*this);
    return *this;
}

template<class _Tp>
template<class _Yp, __enable_if_t<__compatible_with<_Yp, _Tp>::value, int> >
inline
weak_ptr<_Tp>&
weak_ptr<_Tp>::operator=(weak_ptr<_Yp> const& __r) noexcept
{
    weak_ptr(__r).swap(*this);
    return *this;
}

template<class _Tp>
inline
weak_ptr<_Tp>&
weak_ptr<_Tp>::operator=(weak_ptr&& __r) noexcept
{
    weak_ptr(std::move(__r)).swap(*this);
    return *this;
}

template<class _Tp>
template<class _Yp, __enable_if_t<__compatible_with<_Yp, _Tp>::value, int> >
inline
weak_ptr<_Tp>&
weak_ptr<_Tp>::operator=(weak_ptr<_Yp>&& __r) noexcept
{
    weak_ptr(std::move(__r)).swap(*this);
    return *this;
}

template<class _Tp>
template<class _Yp, __enable_if_t<__compatible_with<_Yp, _Tp>::value, int> >
inline
weak_ptr<_Tp>&
weak_ptr<_Tp>::operator=(shared_ptr<_Yp> const& __r) noexcept
{
    weak_ptr(__r).swap(*this);
    return *this;
}

template<class _Tp>
inline
void
weak_ptr<_Tp>::swap(weak_ptr& __r) noexcept
{
    std::swap(__ptr_, __r.__ptr_);
    std::swap(__cntrl_, __r.__cntrl_);
}

template<class _Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
void
swap(weak_ptr<_Tp>& __x, weak_ptr<_Tp>& __y) noexcept
{
    __x.swap(__y);
}

template<class _Tp>
inline
void
weak_ptr<_Tp>::reset() noexcept
{
    weak_ptr().swap(*this);
}

template<class _Tp>
shared_ptr<_Tp>
weak_ptr<_Tp>::lock() const noexcept
{
    shared_ptr<_Tp> __r;
    __r.__cntrl_ = __cntrl_ ? __cntrl_->lock() : __cntrl_;
    if (__r.__cntrl_)
        __r.__ptr_ = __ptr_;
    return __r;
}


template <class _Tp = void> struct owner_less;





template <class _Tp>
struct owner_less<shared_ptr<_Tp> >
    : __binary_function<shared_ptr<_Tp>, shared_ptr<_Tp>, bool>
{
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    bool operator()(shared_ptr<_Tp> const& __x, shared_ptr<_Tp> const& __y) const noexcept
        {return __x.owner_before(__y);}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    bool operator()(shared_ptr<_Tp> const& __x, weak_ptr<_Tp> const& __y) const noexcept
        {return __x.owner_before(__y);}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    bool operator()( weak_ptr<_Tp> const& __x, shared_ptr<_Tp> const& __y) const noexcept
        {return __x.owner_before(__y);}
};

template <class _Tp>
struct owner_less<weak_ptr<_Tp> >
    : __binary_function<weak_ptr<_Tp>, weak_ptr<_Tp>, bool>
{
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    bool operator()( weak_ptr<_Tp> const& __x, weak_ptr<_Tp> const& __y) const noexcept
        {return __x.owner_before(__y);}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    bool operator()(shared_ptr<_Tp> const& __x, weak_ptr<_Tp> const& __y) const noexcept
        {return __x.owner_before(__y);}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    bool operator()( weak_ptr<_Tp> const& __x, shared_ptr<_Tp> const& __y) const noexcept
        {return __x.owner_before(__y);}
};


template <>
struct owner_less<void>
{
    template <class _Tp, class _Up>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    bool operator()( shared_ptr<_Tp> const& __x, shared_ptr<_Up> const& __y) const noexcept
        {return __x.owner_before(__y);}
    template <class _Tp, class _Up>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    bool operator()( shared_ptr<_Tp> const& __x, weak_ptr<_Up> const& __y) const noexcept
        {return __x.owner_before(__y);}
    template <class _Tp, class _Up>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    bool operator()( weak_ptr<_Tp> const& __x, shared_ptr<_Up> const& __y) const noexcept
        {return __x.owner_before(__y);}
    template <class _Tp, class _Up>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    bool operator()( weak_ptr<_Tp> const& __x, weak_ptr<_Up> const& __y) const noexcept
        {return __x.owner_before(__y);}
    typedef void is_transparent;
};


template<class _Tp>
class enable_shared_from_this
{
    mutable weak_ptr<_Tp> __weak_this_;
protected:
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    enable_shared_from_this() noexcept {}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    enable_shared_from_this(enable_shared_from_this const&) noexcept {}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    enable_shared_from_this& operator=(enable_shared_from_this const&) noexcept
        {return *this;}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    ~enable_shared_from_this() {}
public:
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    shared_ptr<_Tp> shared_from_this()
        {return shared_ptr<_Tp>(__weak_this_);}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    shared_ptr<_Tp const> shared_from_this() const
        {return shared_ptr<const _Tp>(__weak_this_);}


    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    weak_ptr<_Tp> weak_from_this() noexcept
       { return __weak_this_; }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    weak_ptr<const _Tp> weak_from_this() const noexcept
        { return __weak_this_; }


    template <class _Up> friend class shared_ptr;
};

template <class _Tp> struct hash;

template <class _Tp>
struct hash<shared_ptr<_Tp> >
{





    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    size_t operator()(const shared_ptr<_Tp>& __ptr) const noexcept
    {
        return hash<typename shared_ptr<_Tp>::element_type*>()(__ptr.get());
    }
};

template<class _CharT, class _Traits, class _Yp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os, shared_ptr<_Yp> const& __p);




class __attribute__((__visibility__("default"))) __sp_mut
{
    void* __lx_;
public:
    void lock() noexcept;
    void unlock() noexcept;

private:
    constexpr __sp_mut(void*) noexcept;
    __sp_mut(const __sp_mut&);
    __sp_mut& operator=(const __sp_mut&);

    friend __attribute__((__visibility__("default"))) __sp_mut& __get_sp_mut(const void*);
};

__attribute__((__visibility__("default")))
__sp_mut& __get_sp_mut(const void*);

template <class _Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
bool
atomic_is_lock_free(const shared_ptr<_Tp>*)
{
    return false;
}

template <class _Tp>

__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) shared_ptr<_Tp>
atomic_load(const shared_ptr<_Tp>* __p)
{
    __sp_mut& __m = std::__get_sp_mut(__p);
    __m.lock();
    shared_ptr<_Tp> __q = *__p;
    __m.unlock();
    return __q;
}

template <class _Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))

shared_ptr<_Tp>
atomic_load_explicit(const shared_ptr<_Tp>* __p, memory_order)
{
    return std::atomic_load(__p);
}

template <class _Tp>

__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) void
atomic_store(shared_ptr<_Tp>* __p, shared_ptr<_Tp> __r)
{
    __sp_mut& __m = std::__get_sp_mut(__p);
    __m.lock();
    __p->swap(__r);
    __m.unlock();
}

template <class _Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))

void
atomic_store_explicit(shared_ptr<_Tp>* __p, shared_ptr<_Tp> __r, memory_order)
{
    std::atomic_store(__p, __r);
}

template <class _Tp>

__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) shared_ptr<_Tp>
atomic_exchange(shared_ptr<_Tp>* __p, shared_ptr<_Tp> __r)
{
    __sp_mut& __m = std::__get_sp_mut(__p);
    __m.lock();
    __p->swap(__r);
    __m.unlock();
    return __r;
}

template <class _Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))

shared_ptr<_Tp>
atomic_exchange_explicit(shared_ptr<_Tp>* __p, shared_ptr<_Tp> __r, memory_order)
{
    return std::atomic_exchange(__p, __r);
}

template <class _Tp>

__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) bool
atomic_compare_exchange_strong(shared_ptr<_Tp>* __p, shared_ptr<_Tp>* __v, shared_ptr<_Tp> __w)
{
    shared_ptr<_Tp> __temp;
    __sp_mut& __m = std::__get_sp_mut(__p);
    __m.lock();
    if (__p->__owner_equivalent(*__v))
    {
        std::swap(__temp, *__p);
        *__p = __w;
        __m.unlock();
        return true;
    }
    std::swap(__temp, *__v);
    *__v = *__p;
    __m.unlock();
    return false;
}

template <class _Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))

bool
atomic_compare_exchange_weak(shared_ptr<_Tp>* __p, shared_ptr<_Tp>* __v, shared_ptr<_Tp> __w)
{
    return std::atomic_compare_exchange_strong(__p, __v, __w);
}

template <class _Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))

bool
atomic_compare_exchange_strong_explicit(shared_ptr<_Tp>* __p, shared_ptr<_Tp>* __v,
                                        shared_ptr<_Tp> __w, memory_order, memory_order)
{
    return std::atomic_compare_exchange_strong(__p, __v, __w);
}

template <class _Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))

bool
atomic_compare_exchange_weak_explicit(shared_ptr<_Tp>* __p, shared_ptr<_Tp>* __v,
                                      shared_ptr<_Tp> __w, memory_order, memory_order)
{
    return std::atomic_compare_exchange_weak(__p, __v, __w);
}



}}
# 16 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__locale" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__mutex/once_flag.h" 1 3
# 26 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__mutex/once_flag.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

struct once_flag;



template <class _Callable, class... _Args>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) void call_once(once_flag&, _Callable&&, _Args&&...);
# 47 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__mutex/once_flag.h" 3
struct once_flag {
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr once_flag() noexcept : __state_(_Unset) {}
  once_flag(const once_flag&) = delete;
  once_flag& operator=(const once_flag&) = delete;




  typedef unsigned long _State_type;


  static const _State_type _Unset = 0;
  static const _State_type _Pending = 1;
  static const _State_type _Complete = ~_State_type(0);

private:
  _State_type __state_;


  template <class _Callable, class... _Args>
  friend void call_once(once_flag&, _Callable&&, _Args&&...);







};



template <class _Fp>
class __call_once_param {
  _Fp& __f_;

public:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) explicit __call_once_param(_Fp& __f) : __f_(__f) {}

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) void operator()() {
    typedef typename __make_tuple_indices<tuple_size<_Fp>::value, 1>::type _Index;
    __execute(_Index());
  }

private:
  template <size_t... _Indices>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) void __execute(__tuple_indices<_Indices...>) {
    std::__invoke(std::get<0>(std::move(__f_)), std::get<_Indices>(std::move(__f_))...);
  }
};
# 112 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__mutex/once_flag.h" 3
template <class _Fp>
void __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) __call_once_proxy(void* __vp) {
  __call_once_param<_Fp>* __p = static_cast<__call_once_param<_Fp>*>(__vp);
  (*__p)();
}

__attribute__((__visibility__("default"))) void __call_once(volatile once_flag::_State_type&, void*, void (*)(void*));



template <class _Callable, class... _Args>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) void call_once(once_flag& __flag, _Callable&& __func, _Args&&... __args) {
  if (__libcpp_acquire_load(&__flag.__state_) != once_flag::_Complete) {
    typedef tuple<_Callable&&, _Args&&...> _Gp;
    _Gp __f(std::forward<_Callable>(__func), std::forward<_Args>(__args)...);
    __call_once_param<_Gp> __p(__f);
    std::__call_once(__flag.__state_, &__p, &__call_once_proxy<_Gp>);
  }
}
# 152 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__mutex/once_flag.h" 3
}}
# 17 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__locale" 2 3


# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/clocale" 1 3
# 40 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/clocale" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/locale.h" 1 3
# 44 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/locale.h" 3



# 1 "/usr/include/locale.h" 1 3 4
# 28 "/usr/include/locale.h" 3 4
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/stddef.h" 1 3 4
# 15 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/stddef.h" 3


# 1 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/stddef.h" 1 3
# 74 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/stddef.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/__stddef_null.h" 1 3
# 75 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/stddef.h" 2 3
# 18 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/stddef.h" 2 3
# 29 "/usr/include/locale.h" 2 3 4
# 1 "/usr/include/bits/locale.h" 1 3 4
# 30 "/usr/include/locale.h" 2 3 4

extern "C" {
# 51 "/usr/include/locale.h" 3 4
struct lconv
{


  char *decimal_point;
  char *thousands_sep;





  char *grouping;





  char *int_curr_symbol;
  char *currency_symbol;
  char *mon_decimal_point;
  char *mon_thousands_sep;
  char *mon_grouping;
  char *positive_sign;
  char *negative_sign;
  char int_frac_digits;
  char frac_digits;

  char p_cs_precedes;

  char p_sep_by_space;

  char n_cs_precedes;

  char n_sep_by_space;






  char p_sign_posn;
  char n_sign_posn;


  char int_p_cs_precedes;

  char int_p_sep_by_space;

  char int_n_cs_precedes;

  char int_n_sep_by_space;






  char int_p_sign_posn;
  char int_n_sign_posn;
# 118 "/usr/include/locale.h" 3 4
};



extern char *setlocale (int __category, const char *__locale) throw ();


extern struct lconv *localeconv (void) throw ();
# 141 "/usr/include/locale.h" 3 4
extern locale_t newlocale (int __category_mask, const char *__locale,
      locale_t __base) throw ();
# 176 "/usr/include/locale.h" 3 4
extern locale_t duplocale (locale_t __dataset) throw ();



extern void freelocale (locale_t __dataset) throw ();






extern locale_t uselocale (locale_t __dataset) throw ();







}
# 48 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/locale.h" 2 3
# 41 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/clocale" 2 3
# 52 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/clocale" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

using ::lconv __attribute__((__using_if_exists__));
using ::setlocale __attribute__((__using_if_exists__));
using ::localeconv __attribute__((__using_if_exists__));

}}
# 20 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__locale" 2 3
# 57 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__locale" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

class __attribute__((__visibility__("default"))) locale;

template <class _Facet>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
bool
has_facet(const locale&) noexcept;

template <class _Facet>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
const _Facet&
use_facet(const locale&);

class __attribute__((__visibility__("default"))) locale
{
public:

    class __attribute__((__visibility__("default"))) facet;
    class __attribute__((__visibility__("default"))) id;

    typedef int category;

    static const category
        none = 0,
        collate = (1 << 3),
        ctype = (1 << 0),
        monetary = (1 << 4),
        numeric = (1 << 1),
        time = (1 << 2),
        messages = (1 << 5),
        all = collate | ctype | monetary | numeric | time | messages;


    locale() noexcept;
    locale(const locale&) noexcept;
    explicit locale(const char*);
    explicit locale(const string&);
    locale(const locale&, const char*, category);
    locale(const locale&, const string&, category);
    template <class _Facet>
        __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) locale(const locale&, _Facet*);
    locale(const locale&, const locale&, category);

    ~locale();

    const locale& operator=(const locale&) noexcept;

    template <class _Facet>
      inline __attribute__((__visibility__("hidden")))
      locale combine(const locale&) const;


    string name() const;
    bool operator==(const locale&) const;



    template <class _CharT, class _Traits, class _Allocator>
      inline __attribute__((__visibility__("hidden")))
      bool operator()(const basic_string<_CharT, _Traits, _Allocator>&,
                      const basic_string<_CharT, _Traits, _Allocator>&) const;


    static locale global(const locale&);
    static const locale& classic();

private:
    class __imp;
    __imp* __locale_;

    void __install_ctor(const locale&, facet*, long);
    static locale& __global();
    bool has_facet(id&) const;
    const facet* use_facet(id&) const;

    template <class _Facet> friend bool has_facet(const locale&) noexcept;
    template <class _Facet> friend const _Facet& use_facet(const locale&);
};

class __attribute__((__visibility__("default"))) locale::facet
    : public __shared_count
{
protected:
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    explicit facet(size_t __refs = 0)
        : __shared_count(static_cast<long>(__refs)-1) {}

    ~facet() override;



private:
    void __on_zero_shared() noexcept override;
};

class __attribute__((__visibility__("default"))) locale::id
{
    once_flag __flag_;
    int32_t __id_;

    static int32_t __next_id;
public:
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr id() :__id_(0) {}
    void operator=(const id&) = delete;
    id(const id&) = delete;

public:
    long __get();

    friend class locale;
    friend class locale::__imp;
};

template <class _Facet>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
locale::locale(const locale& __other, _Facet* __f)
{
    __install_ctor(__other, __f, __f ? __f->id.__get() : 0);
}

template <class _Facet>
locale
locale::combine(const locale& __other) const
{
    if (!std::has_facet<_Facet>(__other))
        __throw_runtime_error("locale::combine: locale missing facet");

    return locale(*this, &const_cast<_Facet&>(std::use_facet<_Facet>(__other)));
}

template <class _Facet>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
bool
has_facet(const locale& __l) noexcept
{
    return __l.has_facet(_Facet::id);
}

template <class _Facet>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
const _Facet&
use_facet(const locale& __l)
{
    return static_cast<const _Facet&>(*__l.use_facet(_Facet::id));
}



template <class _CharT>
class collate
    : public locale::facet
{
public:
    typedef _CharT char_type;
    typedef basic_string<char_type> string_type;

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    explicit collate(size_t __refs = 0)
        : locale::facet(__refs) {}

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    int compare(const char_type* __lo1, const char_type* __hi1,
                const char_type* __lo2, const char_type* __hi2) const
    {
        return do_compare(__lo1, __hi1, __lo2, __hi2);
    }



    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    __attribute__((__always_inline__))
    string_type transform(const char_type* __lo, const char_type* __hi) const
    {
        return do_transform(__lo, __hi);
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    long hash(const char_type* __lo, const char_type* __hi) const
    {
        return do_hash(__lo, __hi);
    }

    static locale::id id;

protected:
    ~collate() override;
    virtual int do_compare(const char_type* __lo1, const char_type* __hi1,
                           const char_type* __lo2, const char_type* __hi2) const;
    virtual string_type do_transform(const char_type* __lo, const char_type* __hi) const
        {return string_type(__lo, __hi);}
    virtual long do_hash(const char_type* __lo, const char_type* __hi) const;
};

template <class _CharT> locale::id collate<_CharT>::id;

template <class _CharT>
collate<_CharT>::~collate()
{
}

template <class _CharT>
int
collate<_CharT>::do_compare(const char_type* __lo1, const char_type* __hi1,
                            const char_type* __lo2, const char_type* __hi2) const
{
    for (; __lo2 != __hi2; ++__lo1, ++__lo2)
    {
        if (__lo1 == __hi1 || *__lo1 < *__lo2)
            return -1;
        if (*__lo2 < *__lo1)
            return 1;
    }
    return __lo1 != __hi1;
}

template <class _CharT>
long
collate<_CharT>::do_hash(const char_type* __lo, const char_type* __hi) const
{
    size_t __h = 0;
    const size_t __sr = 8 * sizeof(size_t) - 8;
    const size_t __mask = size_t(0xF) << (__sr + 4);
    for(const char_type* __p = __lo; __p != __hi; ++__p)
    {
        __h = (__h << 4) + static_cast<size_t>(*__p);
        size_t __g = __h & __mask;
        __h ^= __g | (__g >> __sr);
    }
    return static_cast<long>(__h);
}

extern template class __attribute__((__visibility__("default"))) collate<char>;

extern template class __attribute__((__visibility__("default"))) collate<wchar_t>;




template <class _CharT> class collate_byname;

template <>
class __attribute__((__visibility__("default"))) collate_byname<char>
    : public collate<char>
{
    locale_t __l_;
public:
    typedef char char_type;
    typedef basic_string<char_type> string_type;

    explicit collate_byname(const char* __n, size_t __refs = 0);
    explicit collate_byname(const string& __n, size_t __refs = 0);

protected:
    ~collate_byname() override;
    int do_compare(const char_type* __lo1, const char_type* __hi1,
                   const char_type* __lo2, const char_type* __hi2) const override;
    string_type do_transform(const char_type* __lo, const char_type* __hi) const override;
};


template <>
class __attribute__((__visibility__("default"))) collate_byname<wchar_t>
    : public collate<wchar_t>
{
    locale_t __l_;
public:
    typedef wchar_t char_type;
    typedef basic_string<char_type> string_type;

    explicit collate_byname(const char* __n, size_t __refs = 0);
    explicit collate_byname(const string& __n, size_t __refs = 0);

protected:
    ~collate_byname() override;

    int do_compare(const char_type* __lo1, const char_type* __hi1,
                   const char_type* __lo2, const char_type* __hi2) const override;
    string_type do_transform(const char_type* __lo, const char_type* __hi) const override;
};


template <class _CharT, class _Traits, class _Allocator>
bool
locale::operator()(const basic_string<_CharT, _Traits, _Allocator>& __x,
                   const basic_string<_CharT, _Traits, _Allocator>& __y) const
{
    return std::use_facet<std::collate<_CharT> >(*this).compare(
                                       __x.data(), __x.data() + __x.size(),
                                       __y.data(), __y.data() + __y.size()) < 0;
}



class __attribute__((__visibility__("default"))) ctype_base
{
public:
# 376 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__locale" 3
    typedef unsigned short mask;
    static const mask space = _ISspace;
    static const mask print = _ISprint;
    static const mask cntrl = _IScntrl;
    static const mask upper = _ISupper;
    static const mask lower = _ISlower;
    static const mask alpha = _ISalpha;
    static const mask digit = _ISdigit;
    static const mask punct = _ISpunct;
    static const mask xdigit = _ISxdigit;
    static const mask blank = _ISblank;



    static const mask __regex_word = 0x80;
# 495 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__locale" 3
    static const mask alnum = alpha | digit;
    static const mask graph = alnum | punct;

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) ctype_base() {}

    static_assert((__regex_word & ~(std::make_unsigned<mask>::type)(space | print | cntrl | upper | lower | alpha |
                                                                    digit | punct | xdigit | blank)) == __regex_word,
                  "__regex_word can't overlap other bits");
};

template <class _CharT> class ctype;


template <>
class __attribute__((__visibility__("default"))) ctype<wchar_t>
    : public locale::facet,
      public ctype_base
{
public:
    typedef wchar_t char_type;

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    explicit ctype(size_t __refs = 0)
        : locale::facet(__refs) {}

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    bool is(mask __m, char_type __c) const
    {
        return do_is(__m, __c);
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    const char_type* is(const char_type* __low, const char_type* __high, mask* __vec) const
    {
        return do_is(__low, __high, __vec);
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    const char_type* scan_is(mask __m, const char_type* __low, const char_type* __high) const
    {
        return do_scan_is(__m, __low, __high);
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    const char_type* scan_not(mask __m, const char_type* __low, const char_type* __high) const
    {
        return do_scan_not(__m, __low, __high);
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    char_type toupper(char_type __c) const
    {
        return do_toupper(__c);
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    const char_type* toupper(char_type* __low, const char_type* __high) const
    {
        return do_toupper(__low, __high);
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    char_type tolower(char_type __c) const
    {
        return do_tolower(__c);
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    const char_type* tolower(char_type* __low, const char_type* __high) const
    {
        return do_tolower(__low, __high);
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    char_type widen(char __c) const
    {
        return do_widen(__c);
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    const char* widen(const char* __low, const char* __high, char_type* __to) const
    {
        return do_widen(__low, __high, __to);
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    char narrow(char_type __c, char __dfault) const
    {
        return do_narrow(__c, __dfault);
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    const char_type* narrow(const char_type* __low, const char_type* __high, char __dfault, char* __to) const
    {
        return do_narrow(__low, __high, __dfault, __to);
    }

    static locale::id id;

protected:
    ~ctype() override;
    virtual bool do_is(mask __m, char_type __c) const;
    virtual const char_type* do_is(const char_type* __low, const char_type* __high, mask* __vec) const;
    virtual const char_type* do_scan_is(mask __m, const char_type* __low, const char_type* __high) const;
    virtual const char_type* do_scan_not(mask __m, const char_type* __low, const char_type* __high) const;
    virtual char_type do_toupper(char_type) const;
    virtual const char_type* do_toupper(char_type* __low, const char_type* __high) const;
    virtual char_type do_tolower(char_type) const;
    virtual const char_type* do_tolower(char_type* __low, const char_type* __high) const;
    virtual char_type do_widen(char) const;
    virtual const char* do_widen(const char* __low, const char* __high, char_type* __dest) const;
    virtual char do_narrow(char_type, char __dfault) const;
    virtual const char_type* do_narrow(const char_type* __low, const char_type* __high, char __dfault, char* __dest) const;
};


template <>
class __attribute__((__visibility__("default"))) ctype<char>
    : public locale::facet, public ctype_base
{
    const mask* __tab_;
    bool __del_;
public:
    typedef char char_type;

    explicit ctype(const mask* __tab = nullptr, bool __del = false, size_t __refs = 0);

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    bool is(mask __m, char_type __c) const
    {
        return (((__c) & ~0x7f) == 0) ? (__tab_[static_cast<int>(__c)] & __m) !=0 : false;
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    const char_type* is(const char_type* __low, const char_type* __high, mask* __vec) const
    {
        for (; __low != __high; ++__low, ++__vec)
            *__vec = (((*__low) & ~0x7f) == 0) ? __tab_[static_cast<int>(*__low)] : 0;
        return __low;
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    const char_type* scan_is (mask __m, const char_type* __low, const char_type* __high) const
    {
        for (; __low != __high; ++__low)
            if ((((*__low) & ~0x7f) == 0) && (__tab_[static_cast<int>(*__low)] & __m))
                break;
        return __low;
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    const char_type* scan_not(mask __m, const char_type* __low, const char_type* __high) const
    {
        for (; __low != __high; ++__low)
            if (!(((*__low) & ~0x7f) == 0) || !(__tab_[static_cast<int>(*__low)] & __m))
                break;
        return __low;
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    char_type toupper(char_type __c) const
    {
        return do_toupper(__c);
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    const char_type* toupper(char_type* __low, const char_type* __high) const
    {
        return do_toupper(__low, __high);
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    char_type tolower(char_type __c) const
    {
        return do_tolower(__c);
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    const char_type* tolower(char_type* __low, const char_type* __high) const
    {
        return do_tolower(__low, __high);
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    char_type widen(char __c) const
    {
        return do_widen(__c);
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    const char* widen(const char* __low, const char* __high, char_type* __to) const
    {
        return do_widen(__low, __high, __to);
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    char narrow(char_type __c, char __dfault) const
    {
        return do_narrow(__c, __dfault);
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    const char* narrow(const char_type* __low, const char_type* __high, char __dfault, char* __to) const
    {
        return do_narrow(__low, __high, __dfault, __to);
    }

    static locale::id id;




    static const size_t table_size = 256;

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) const mask* table() const noexcept {return __tab_;}
    static const mask* classic_table() noexcept;

    static const int* __classic_upper_table() noexcept;
    static const int* __classic_lower_table() noexcept;
# 724 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__locale" 3
protected:
    ~ctype() override;
    virtual char_type do_toupper(char_type __c) const;
    virtual const char_type* do_toupper(char_type* __low, const char_type* __high) const;
    virtual char_type do_tolower(char_type __c) const;
    virtual const char_type* do_tolower(char_type* __low, const char_type* __high) const;
    virtual char_type do_widen(char __c) const;
    virtual const char* do_widen(const char* __low, const char* __high, char_type* __to) const;
    virtual char do_narrow(char_type __c, char __dfault) const;
    virtual const char* do_narrow(const char_type* __low, const char_type* __high, char __dfault, char* __to) const;
};



template <class _CharT> class ctype_byname;

template <>
class __attribute__((__visibility__("default"))) ctype_byname<char>
    : public ctype<char>
{
    locale_t __l_;

public:
    explicit ctype_byname(const char*, size_t = 0);
    explicit ctype_byname(const string&, size_t = 0);

protected:
    ~ctype_byname() override;
    char_type do_toupper(char_type) const override;
    const char_type* do_toupper(char_type* __low, const char_type* __high) const override;
    char_type do_tolower(char_type) const override;
    const char_type* do_tolower(char_type* __low, const char_type* __high) const override;
};


template <>
class __attribute__((__visibility__("default"))) ctype_byname<wchar_t>
    : public ctype<wchar_t>
{
    locale_t __l_;

public:
    explicit ctype_byname(const char*, size_t = 0);
    explicit ctype_byname(const string&, size_t = 0);

protected:
    ~ctype_byname() override;
    bool do_is(mask __m, char_type __c) const override;
    const char_type* do_is(const char_type* __low, const char_type* __high, mask* __vec) const override;
    const char_type* do_scan_is(mask __m, const char_type* __low, const char_type* __high) const override;
    const char_type* do_scan_not(mask __m, const char_type* __low, const char_type* __high) const override;
    char_type do_toupper(char_type) const override;
    const char_type* do_toupper(char_type* __low, const char_type* __high) const override;
    char_type do_tolower(char_type) const override;
    const char_type* do_tolower(char_type* __low, const char_type* __high) const override;
    char_type do_widen(char) const override;
    const char* do_widen(const char* __low, const char* __high, char_type* __dest) const override;
    char do_narrow(char_type, char __dfault) const override;
    const char_type* do_narrow(const char_type* __low, const char_type* __high, char __dfault, char* __dest) const override;
};


template <class _CharT>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
bool
isspace(_CharT __c, const locale& __loc)
{
    return std::use_facet<ctype<_CharT> >(__loc).is(ctype_base::space, __c);
}

template <class _CharT>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
bool
isprint(_CharT __c, const locale& __loc)
{
    return std::use_facet<ctype<_CharT> >(__loc).is(ctype_base::print, __c);
}

template <class _CharT>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
bool
iscntrl(_CharT __c, const locale& __loc)
{
    return std::use_facet<ctype<_CharT> >(__loc).is(ctype_base::cntrl, __c);
}

template <class _CharT>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
bool
isupper(_CharT __c, const locale& __loc)
{
    return std::use_facet<ctype<_CharT> >(__loc).is(ctype_base::upper, __c);
}

template <class _CharT>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
bool
islower(_CharT __c, const locale& __loc)
{
    return std::use_facet<ctype<_CharT> >(__loc).is(ctype_base::lower, __c);
}

template <class _CharT>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
bool
isalpha(_CharT __c, const locale& __loc)
{
    return std::use_facet<ctype<_CharT> >(__loc).is(ctype_base::alpha, __c);
}

template <class _CharT>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
bool
isdigit(_CharT __c, const locale& __loc)
{
    return std::use_facet<ctype<_CharT> >(__loc).is(ctype_base::digit, __c);
}

template <class _CharT>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
bool
ispunct(_CharT __c, const locale& __loc)
{
    return std::use_facet<ctype<_CharT> >(__loc).is(ctype_base::punct, __c);
}

template <class _CharT>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
bool
isxdigit(_CharT __c, const locale& __loc)
{
    return std::use_facet<ctype<_CharT> >(__loc).is(ctype_base::xdigit, __c);
}

template <class _CharT>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
bool
isalnum(_CharT __c, const locale& __loc)
{
    return std::use_facet<ctype<_CharT> >(__loc).is(ctype_base::alnum, __c);
}

template <class _CharT>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
bool
isgraph(_CharT __c, const locale& __loc)
{
    return std::use_facet<ctype<_CharT> >(__loc).is(ctype_base::graph, __c);
}

template <class _CharT>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) bool isblank(_CharT __c, const locale& __loc) {
    return std::use_facet<ctype<_CharT> >(__loc).is(ctype_base::blank, __c);
}

template <class _CharT>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
_CharT
toupper(_CharT __c, const locale& __loc)
{
    return std::use_facet<ctype<_CharT> >(__loc).toupper(__c);
}

template <class _CharT>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
_CharT
tolower(_CharT __c, const locale& __loc)
{
    return std::use_facet<ctype<_CharT> >(__loc).tolower(__c);
}



class __attribute__((__visibility__("default"))) codecvt_base
{
public:
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) codecvt_base() {}
    enum result {ok, partial, error, noconv};
};



template <class _InternT, class _ExternT, class _StateT> class codecvt;



template <>
class __attribute__((__visibility__("default"))) codecvt<char, char, mbstate_t>
    : public locale::facet,
      public codecvt_base
{
public:
    typedef char intern_type;
    typedef char extern_type;
    typedef mbstate_t state_type;

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    explicit codecvt(size_t __refs = 0)
        : locale::facet(__refs) {}

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    result out(state_type& __st,
               const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,
               extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const
    {
        return do_out(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    result unshift(state_type& __st,
                   extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const
    {
        return do_unshift(__st, __to, __to_end, __to_nxt);
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    result in(state_type& __st,
              const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,
              intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const
    {
        return do_in(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    int encoding() const noexcept
    {
        return do_encoding();
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    bool always_noconv() const noexcept
    {
        return do_always_noconv();
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    int length(state_type& __st, const extern_type* __frm, const extern_type* __end, size_t __mx) const
    {
        return do_length(__st, __frm, __end, __mx);
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    int max_length() const noexcept
    {
        return do_max_length();
    }

    static locale::id id;

protected:
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    explicit codecvt(const char*, size_t __refs = 0)
        : locale::facet(__refs) {}

    ~codecvt() override;

    virtual result do_out(state_type& __st,
                          const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,
                          extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;
    virtual result do_in(state_type& __st,
                         const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,
                         intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const;
    virtual result do_unshift(state_type& __st,
                              extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;
    virtual int do_encoding() const noexcept;
    virtual bool do_always_noconv() const noexcept;
    virtual int do_length(state_type& __st, const extern_type* __frm, const extern_type* __end, size_t __mx) const;
    virtual int do_max_length() const noexcept;
};




template <>
class __attribute__((__visibility__("default"))) codecvt<wchar_t, char, mbstate_t>
    : public locale::facet,
      public codecvt_base
{
    locale_t __l_;
public:
    typedef wchar_t intern_type;
    typedef char extern_type;
    typedef mbstate_t state_type;

    explicit codecvt(size_t __refs = 0);

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    result out(state_type& __st,
               const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,
               extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const
    {
        return do_out(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    result unshift(state_type& __st,
                   extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const
    {
        return do_unshift(__st, __to, __to_end, __to_nxt);
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    result in(state_type& __st,
              const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,
              intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const
    {
        return do_in(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    int encoding() const noexcept
    {
        return do_encoding();
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    bool always_noconv() const noexcept
    {
        return do_always_noconv();
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    int length(state_type& __st, const extern_type* __frm, const extern_type* __end, size_t __mx) const
    {
        return do_length(__st, __frm, __end, __mx);
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    int max_length() const noexcept
    {
        return do_max_length();
    }

    static locale::id id;

protected:
    explicit codecvt(const char*, size_t __refs = 0);

    ~codecvt() override;

    virtual result do_out(state_type& __st,
                          const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,
                          extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;
    virtual result do_in(state_type& __st,
                         const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,
                         intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const;
    virtual result do_unshift(state_type& __st,
                              extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;
    virtual int do_encoding() const noexcept;
    virtual bool do_always_noconv() const noexcept;
    virtual int do_length(state_type&, const extern_type* __frm, const extern_type* __end, size_t __mx) const;
    virtual int do_max_length() const noexcept;
};




template <>
class __attribute__((__deprecated__)) __attribute__((__visibility__("default"))) codecvt<char16_t, char, mbstate_t>
    : public locale::facet,
      public codecvt_base
{
public:
    typedef char16_t intern_type;
    typedef char extern_type;
    typedef mbstate_t state_type;

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    explicit codecvt(size_t __refs = 0)
        : locale::facet(__refs) {}

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    result out(state_type& __st,
               const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,
               extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const
    {
        return do_out(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    result unshift(state_type& __st,
                   extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const
    {
        return do_unshift(__st, __to, __to_end, __to_nxt);
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    result in(state_type& __st,
              const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,
              intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const
    {
        return do_in(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    int encoding() const noexcept
    {
        return do_encoding();
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    bool always_noconv() const noexcept
    {
        return do_always_noconv();
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    int length(state_type& __st, const extern_type* __frm, const extern_type* __end, size_t __mx) const
    {
        return do_length(__st, __frm, __end, __mx);
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    int max_length() const noexcept
    {
        return do_max_length();
    }

    static locale::id id;

protected:
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    explicit codecvt(const char*, size_t __refs = 0)
        : locale::facet(__refs) {}

    ~codecvt() override;

    virtual result do_out(state_type& __st,
                          const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,
                          extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;
    virtual result do_in(state_type& __st,
                         const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,
                         intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const;
    virtual result do_unshift(state_type& __st,
                              extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;
    virtual int do_encoding() const noexcept;
    virtual bool do_always_noconv() const noexcept;
    virtual int do_length(state_type&, const extern_type* __frm, const extern_type* __end, size_t __mx) const;
    virtual int do_max_length() const noexcept;
};





template <>
class __attribute__((__visibility__("default"))) codecvt<char16_t, char8_t, mbstate_t>
    : public locale::facet,
      public codecvt_base
{
public:
    typedef char16_t intern_type;
    typedef char8_t extern_type;
    typedef mbstate_t state_type;

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    explicit codecvt(size_t __refs = 0)
        : locale::facet(__refs) {}

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    result out(state_type& __st,
               const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,
               extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const
    {
        return do_out(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    result unshift(state_type& __st,
                   extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const
    {
        return do_unshift(__st, __to, __to_end, __to_nxt);
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    result in(state_type& __st,
              const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,
              intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const
    {
        return do_in(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    int encoding() const noexcept
    {
        return do_encoding();
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    bool always_noconv() const noexcept
    {
        return do_always_noconv();
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    int length(state_type& __st, const extern_type* __frm, const extern_type* __end, size_t __mx) const
    {
        return do_length(__st, __frm, __end, __mx);
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    int max_length() const noexcept
    {
        return do_max_length();
    }

    static locale::id id;

protected:
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    explicit codecvt(const char*, size_t __refs = 0)
        : locale::facet(__refs) {}

    ~codecvt() override;

    virtual result do_out(state_type& __st,
                          const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,
                          extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;
    virtual result do_in(state_type& __st,
                         const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,
                         intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const;
    virtual result do_unshift(state_type& __st,
                              extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;
    virtual int do_encoding() const noexcept;
    virtual bool do_always_noconv() const noexcept;
    virtual int do_length(state_type&, const extern_type* __frm, const extern_type* __end, size_t __mx) const;
    virtual int do_max_length() const noexcept;
};





template <>
class __attribute__((__deprecated__)) __attribute__((__visibility__("default"))) codecvt<char32_t, char, mbstate_t>
    : public locale::facet,
      public codecvt_base
{
public:
    typedef char32_t intern_type;
    typedef char extern_type;
    typedef mbstate_t state_type;

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    explicit codecvt(size_t __refs = 0)
        : locale::facet(__refs) {}

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    result out(state_type& __st,
               const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,
               extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const
    {
        return do_out(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    result unshift(state_type& __st,
                   extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const
    {
        return do_unshift(__st, __to, __to_end, __to_nxt);
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    result in(state_type& __st,
              const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,
              intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const
    {
        return do_in(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    int encoding() const noexcept
    {
        return do_encoding();
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    bool always_noconv() const noexcept
    {
        return do_always_noconv();
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    int length(state_type& __st, const extern_type* __frm, const extern_type* __end, size_t __mx) const
    {
        return do_length(__st, __frm, __end, __mx);
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    int max_length() const noexcept
    {
        return do_max_length();
    }

    static locale::id id;

protected:
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    explicit codecvt(const char*, size_t __refs = 0)
        : locale::facet(__refs) {}

    ~codecvt() override;

    virtual result do_out(state_type& __st,
                          const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,
                          extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;
    virtual result do_in(state_type& __st,
                         const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,
                         intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const;
    virtual result do_unshift(state_type& __st,
                              extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;
    virtual int do_encoding() const noexcept;
    virtual bool do_always_noconv() const noexcept;
    virtual int do_length(state_type&, const extern_type* __frm, const extern_type* __end, size_t __mx) const;
    virtual int do_max_length() const noexcept;
};





template <>
class __attribute__((__visibility__("default"))) codecvt<char32_t, char8_t, mbstate_t>
    : public locale::facet,
      public codecvt_base
{
public:
    typedef char32_t intern_type;
    typedef char8_t extern_type;
    typedef mbstate_t state_type;

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    explicit codecvt(size_t __refs = 0)
        : locale::facet(__refs) {}

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    result out(state_type& __st,
               const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,
               extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const
    {
        return do_out(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    result unshift(state_type& __st,
                   extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const
    {
        return do_unshift(__st, __to, __to_end, __to_nxt);
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    result in(state_type& __st,
              const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,
              intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const
    {
        return do_in(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    int encoding() const noexcept
    {
        return do_encoding();
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    bool always_noconv() const noexcept
    {
        return do_always_noconv();
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    int length(state_type& __st, const extern_type* __frm, const extern_type* __end, size_t __mx) const
    {
        return do_length(__st, __frm, __end, __mx);
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    int max_length() const noexcept
    {
        return do_max_length();
    }

    static locale::id id;

protected:
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    explicit codecvt(const char*, size_t __refs = 0)
        : locale::facet(__refs) {}

    ~codecvt() override;

    virtual result do_out(state_type& __st,
                          const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,
                          extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;
    virtual result do_in(state_type& __st,
                         const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,
                         intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const;
    virtual result do_unshift(state_type& __st,
                              extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;
    virtual int do_encoding() const noexcept;
    virtual bool do_always_noconv() const noexcept;
    virtual int do_length(state_type&, const extern_type* __frm, const extern_type* __end, size_t __mx) const;
    virtual int do_max_length() const noexcept;
};





template <class _InternT, class _ExternT, class _StateT>
class codecvt_byname
    : public codecvt<_InternT, _ExternT, _StateT>
{
public:
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    explicit codecvt_byname(const char* __nm, size_t __refs = 0)
        : codecvt<_InternT, _ExternT, _StateT>(__nm, __refs) {}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    explicit codecvt_byname(const string& __nm, size_t __refs = 0)
        : codecvt<_InternT, _ExternT, _StateT>(__nm.c_str(), __refs) {}
protected:
    ~codecvt_byname() override;
};

#pragma GCC diagnostic push
# 1448 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__locale" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
# 1448 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__locale" 3
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
template <class _InternT, class _ExternT, class _StateT>
codecvt_byname<_InternT, _ExternT, _StateT>::~codecvt_byname()
{
}
#pragma GCC diagnostic pop

extern template class __attribute__((__visibility__("default"))) codecvt_byname<char, char, mbstate_t>;

extern template class __attribute__((__visibility__("default"))) codecvt_byname<wchar_t, char, mbstate_t>;

extern template class __attribute__((__deprecated__)) __attribute__((__visibility__("default"))) codecvt_byname<char16_t, char, mbstate_t>;
extern template class __attribute__((__deprecated__)) __attribute__((__visibility__("default"))) codecvt_byname<char32_t, char, mbstate_t>;

extern template class __attribute__((__visibility__("default"))) codecvt_byname<char16_t, char8_t, mbstate_t>;
extern template class __attribute__((__visibility__("default"))) codecvt_byname<char32_t, char8_t, mbstate_t>;


template <size_t _Np>
struct __narrow_to_utf8
{
    template <class _OutputIterator, class _CharT>
    _OutputIterator
    operator()(_OutputIterator __s, const _CharT* __wb, const _CharT* __we) const;
};

template <>
struct __narrow_to_utf8<8>
{
    template <class _OutputIterator, class _CharT>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    _OutputIterator
    operator()(_OutputIterator __s, const _CharT* __wb, const _CharT* __we) const
    {
        for (; __wb < __we; ++__wb, ++__s)
            *__s = *__wb;
        return __s;
    }
};

#pragma GCC diagnostic push
# 1488 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__locale" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
# 1488 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__locale" 3
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
template <>
struct __attribute__((__visibility__("default"))) __narrow_to_utf8<16>
    : public codecvt<char16_t, char, mbstate_t>
{
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    __narrow_to_utf8() : codecvt<char16_t, char, mbstate_t>(1) {}
#pragma GCC diagnostic pop

    ~__narrow_to_utf8() override;

    template <class _OutputIterator, class _CharT>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    _OutputIterator
    operator()(_OutputIterator __s, const _CharT* __wb, const _CharT* __we) const
    {
        result __r = ok;
        mbstate_t __mb;
        while (__wb < __we && __r != error)
        {
            const int __sz = 32;
            char __buf[__sz];
            char* __bn;
            const char16_t* __wn = (const char16_t*)__wb;
            __r = do_out(__mb, (const char16_t*)__wb, (const char16_t*)__we, __wn,
                         __buf, __buf+__sz, __bn);
            if (__r == codecvt_base::error || __wn == (const char16_t*)__wb)
                __throw_runtime_error("locale not supported");
            for (const char* __p = __buf; __p < __bn; ++__p, ++__s)
                *__s = *__p;
            __wb = (const _CharT*)__wn;
        }
        return __s;
    }
};

#pragma GCC diagnostic push
# 1524 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__locale" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
# 1524 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__locale" 3
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
template <>
struct __attribute__((__visibility__("default"))) __narrow_to_utf8<32>
    : public codecvt<char32_t, char, mbstate_t>
{
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    __narrow_to_utf8() : codecvt<char32_t, char, mbstate_t>(1) {}
#pragma GCC diagnostic pop

    ~__narrow_to_utf8() override;

    template <class _OutputIterator, class _CharT>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    _OutputIterator
    operator()(_OutputIterator __s, const _CharT* __wb, const _CharT* __we) const
    {
        result __r = ok;
        mbstate_t __mb;
        while (__wb < __we && __r != error)
        {
            const int __sz = 32;
            char __buf[__sz];
            char* __bn;
            const char32_t* __wn = (const char32_t*)__wb;
            __r = do_out(__mb, (const char32_t*)__wb, (const char32_t*)__we, __wn,
                         __buf, __buf+__sz, __bn);
            if (__r == codecvt_base::error || __wn == (const char32_t*)__wb)
                __throw_runtime_error("locale not supported");
            for (const char* __p = __buf; __p < __bn; ++__p, ++__s)
                *__s = *__p;
            __wb = (const _CharT*)__wn;
        }
        return __s;
    }
};

template <size_t _Np>
struct __widen_from_utf8
{
    template <class _OutputIterator>
    _OutputIterator
    operator()(_OutputIterator __s, const char* __nb, const char* __ne) const;
};

template <>
struct __widen_from_utf8<8>
{
    template <class _OutputIterator>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    _OutputIterator
    operator()(_OutputIterator __s, const char* __nb, const char* __ne) const
    {
        for (; __nb < __ne; ++__nb, ++__s)
            *__s = *__nb;
        return __s;
    }
};

#pragma GCC diagnostic push
# 1582 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__locale" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
# 1582 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__locale" 3
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
template <>
struct __attribute__((__visibility__("default"))) __widen_from_utf8<16>
    : public codecvt<char16_t, char, mbstate_t>
{
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    __widen_from_utf8() : codecvt<char16_t, char, mbstate_t>(1) {}
#pragma GCC diagnostic pop

    ~__widen_from_utf8() override;

    template <class _OutputIterator>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    _OutputIterator
    operator()(_OutputIterator __s, const char* __nb, const char* __ne) const
    {
        result __r = ok;
        mbstate_t __mb;
        while (__nb < __ne && __r != error)
        {
            const int __sz = 32;
            char16_t __buf[__sz];
            char16_t* __bn;
            const char* __nn = __nb;
            __r = do_in(__mb, __nb, __ne - __nb > __sz ? __nb+__sz : __ne, __nn,
                        __buf, __buf+__sz, __bn);
            if (__r == codecvt_base::error || __nn == __nb)
                __throw_runtime_error("locale not supported");
            for (const char16_t* __p = __buf; __p < __bn; ++__p, ++__s)
                *__s = *__p;
            __nb = __nn;
        }
        return __s;
    }
};

#pragma GCC diagnostic push
# 1618 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__locale" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
# 1618 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__locale" 3
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
template <>
struct __attribute__((__visibility__("default"))) __widen_from_utf8<32>
    : public codecvt<char32_t, char, mbstate_t>
{
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    __widen_from_utf8() : codecvt<char32_t, char, mbstate_t>(1) {}
#pragma GCC diagnostic pop

    ~__widen_from_utf8() override;

    template <class _OutputIterator>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    _OutputIterator
    operator()(_OutputIterator __s, const char* __nb, const char* __ne) const
    {
        result __r = ok;
        mbstate_t __mb;
        while (__nb < __ne && __r != error)
        {
            const int __sz = 32;
            char32_t __buf[__sz];
            char32_t* __bn;
            const char* __nn = __nb;
            __r = do_in(__mb, __nb, __ne - __nb > __sz ? __nb+__sz : __ne, __nn,
                        __buf, __buf+__sz, __bn);
            if (__r == codecvt_base::error || __nn == __nb)
                __throw_runtime_error("locale not supported");
            for (const char32_t* __p = __buf; __p < __bn; ++__p, ++__s)
                *__s = *__p;
            __nb = __nn;
        }
        return __s;
    }
};



template <class _CharT> class numpunct;

template <>
class __attribute__((__visibility__("default"))) numpunct<char>
    : public locale::facet
{
public:
    typedef char char_type;
    typedef basic_string<char_type> string_type;

    explicit numpunct(size_t __refs = 0);

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) char_type decimal_point() const {return do_decimal_point();}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) char_type thousands_sep() const {return do_thousands_sep();}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) string grouping() const {return do_grouping();}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) string_type truename() const {return do_truename();}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) string_type falsename() const {return do_falsename();}

    static locale::id id;

protected:
    ~numpunct() override;
    virtual char_type do_decimal_point() const;
    virtual char_type do_thousands_sep() const;
    virtual string do_grouping() const;
    virtual string_type do_truename() const;
    virtual string_type do_falsename() const;

    char_type __decimal_point_;
    char_type __thousands_sep_;
    string __grouping_;
};


template <>
class __attribute__((__visibility__("default"))) numpunct<wchar_t>
    : public locale::facet
{
public:
    typedef wchar_t char_type;
    typedef basic_string<char_type> string_type;

    explicit numpunct(size_t __refs = 0);

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) char_type decimal_point() const {return do_decimal_point();}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) char_type thousands_sep() const {return do_thousands_sep();}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) string grouping() const {return do_grouping();}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) string_type truename() const {return do_truename();}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) string_type falsename() const {return do_falsename();}

    static locale::id id;

protected:
    ~numpunct() override;
    virtual char_type do_decimal_point() const;
    virtual char_type do_thousands_sep() const;
    virtual string do_grouping() const;
    virtual string_type do_truename() const;
    virtual string_type do_falsename() const;

    char_type __decimal_point_;
    char_type __thousands_sep_;
    string __grouping_;
};




template <class _CharT> class numpunct_byname;

template <>
class __attribute__((__visibility__("default"))) numpunct_byname<char>
: public numpunct<char>
{
public:
    typedef char char_type;
    typedef basic_string<char_type> string_type;

    explicit numpunct_byname(const char* __nm, size_t __refs = 0);
    explicit numpunct_byname(const string& __nm, size_t __refs = 0);

protected:
    ~numpunct_byname() override;

private:
    void __init(const char*);
};


template <>
class __attribute__((__visibility__("default"))) numpunct_byname<wchar_t>
: public numpunct<wchar_t>
{
public:
    typedef wchar_t char_type;
    typedef basic_string<char_type> string_type;

    explicit numpunct_byname(const char* __nm, size_t __refs = 0);
    explicit numpunct_byname(const string& __nm, size_t __refs = 0);

protected:
    ~numpunct_byname() override;

private:
    void __init(const char*);
};


}}
# 203 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/locale" 2 3






# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/ios" 1 3
# 223 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/ios" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__system_error/error_category.h" 1 3
# 19 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__system_error/error_category.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

class __attribute__((__visibility__("default"))) error_condition;
class __attribute__((__visibility__("default"))) error_code;

class __attribute__((__visibility__("hidden"))) __do_message;

class __attribute__((__visibility__("default"))) error_category {
public:
  virtual ~error_category() noexcept;




  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr error_category() noexcept = default;

  error_category(const error_category&) = delete;
  error_category& operator=(const error_category&) = delete;

  virtual const char* name() const noexcept = 0;
  virtual error_condition default_error_condition(int __ev) const noexcept;
  virtual bool equivalent(int __code, const error_condition& __condition) const noexcept;
  virtual bool equivalent(const error_code& __code, int __condition) const noexcept;
  virtual string message(int __ev) const = 0;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) bool operator==(const error_category& __rhs) const noexcept { return this == &__rhs; }



  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) strong_ordering operator<=>(const error_category& __rhs) const noexcept {
    return compare_three_way()(this, std::addressof(__rhs));
  }
# 62 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__system_error/error_category.h" 3
  friend class __attribute__((__visibility__("hidden"))) __do_message;
};

class __attribute__((__visibility__("hidden"))) __do_message : public error_category {
public:
  string message(int __ev) const override;
};

__attribute__((__visibility__("default"))) const error_category& generic_category() noexcept;
__attribute__((__visibility__("default"))) const error_category& system_category() noexcept;

}}
# 224 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/ios" 2 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__system_error/error_code.h" 1 3
# 19 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__system_error/error_code.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__system_error/error_condition.h" 1 3
# 24 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__system_error/error_condition.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Tp>
struct is_error_condition_enum : public false_type {};


template <class _Tp>
inline constexpr bool is_error_condition_enum_v = is_error_condition_enum<_Tp>::value;


template <>
struct is_error_condition_enum<errc> : true_type {};






namespace __adl_only {


void make_error_condition() = delete;
}

class __attribute__((__visibility__("default"))) error_condition {
  int __val_;
  const error_category* __cat_;

public:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) error_condition() noexcept : __val_(0), __cat_(&generic_category()) {}

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) error_condition(int __val, const error_category& __cat) noexcept
      : __val_(__val),
        __cat_(&__cat) {}

  template <class _Ep, __enable_if_t<is_error_condition_enum<_Ep>::value, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) error_condition(_Ep __e) noexcept {
    using __adl_only::make_error_condition;
    *this = make_error_condition(__e);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) void assign(int __val, const error_category& __cat) noexcept {
    __val_ = __val;
    __cat_ = &__cat;
  }

  template <class _Ep, __enable_if_t<is_error_condition_enum<_Ep>::value, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) error_condition& operator=(_Ep __e) noexcept {
    using __adl_only::make_error_condition;
    *this = make_error_condition(__e);
    return *this;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) void clear() noexcept {
    __val_ = 0;
    __cat_ = &generic_category();
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) int value() const noexcept { return __val_; }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) const error_category& category() const noexcept { return *__cat_; }
  string message() const;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) explicit operator bool() const noexcept { return __val_ != 0; }
};

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) error_condition make_error_condition(errc __e) noexcept {
  return error_condition(static_cast<int>(__e), generic_category());
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) bool operator==(const error_condition& __x, const error_condition& __y) noexcept {
  return __x.category() == __y.category() && __x.value() == __y.value();
}
# 112 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__system_error/error_condition.h" 3
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) strong_ordering
operator<=>(const error_condition& __x, const error_condition& __y) noexcept {
  if (auto __c = __x.category() <=> __y.category(); __c != 0)
    return __c;
  return __x.value() <=> __y.value();
}



template <>
struct hash<error_condition> : public __unary_function<error_condition, size_t> {
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) size_t operator()(const error_condition& __ec) const noexcept {
    return static_cast<size_t>(__ec.value());
  }
};

}}
# 20 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__system_error/error_code.h" 2 3
# 25 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__system_error/error_code.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Tp>
struct is_error_code_enum : public false_type {};


template <class _Tp>
inline constexpr bool is_error_code_enum_v = is_error_code_enum<_Tp>::value;


namespace __adl_only {


void make_error_code() = delete;
}

class __attribute__((__visibility__("default"))) error_code {
  int __val_;
  const error_category* __cat_;

public:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) error_code() noexcept : __val_(0), __cat_(&system_category()) {}

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) error_code(int __val, const error_category& __cat) noexcept : __val_(__val), __cat_(&__cat) {}

  template <class _Ep, __enable_if_t<is_error_code_enum<_Ep>::value, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) error_code(_Ep __e) noexcept {
    using __adl_only::make_error_code;
    *this = make_error_code(__e);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) void assign(int __val, const error_category& __cat) noexcept {
    __val_ = __val;
    __cat_ = &__cat;
  }

  template <class _Ep, __enable_if_t<is_error_code_enum<_Ep>::value, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) error_code& operator=(_Ep __e) noexcept {
    using __adl_only::make_error_code;
    *this = make_error_code(__e);
    return *this;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) void clear() noexcept {
    __val_ = 0;
    __cat_ = &system_category();
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) int value() const noexcept { return __val_; }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) const error_category& category() const noexcept { return *__cat_; }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) error_condition default_error_condition() const noexcept {
    return __cat_->default_error_condition(__val_);
  }

  string message() const;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) explicit operator bool() const noexcept { return __val_ != 0; }
};

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) error_code make_error_code(errc __e) noexcept {
  return error_code(static_cast<int>(__e), generic_category());
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) bool operator==(const error_code& __x, const error_code& __y) noexcept {
  return __x.category() == __y.category() && __x.value() == __y.value();
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) bool operator==(const error_code& __x, const error_condition& __y) noexcept {
  return __x.category().equivalent(__x.value(), __y) || __y.category().equivalent(__x, __y.value());
}
# 126 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__system_error/error_code.h" 3
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) strong_ordering operator<=>(const error_code& __x, const error_code& __y) noexcept {
  if (auto __c = __x.category() <=> __y.category(); __c != 0)
    return __c;
  return __x.value() <=> __y.value();
}



template <>
struct hash<error_code> : public __unary_function<error_code, size_t> {
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) size_t operator()(const error_code& __ec) const noexcept {
    return static_cast<size_t>(__ec.value());
  }
};

}}
# 225 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/ios" 2 3

# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__system_error/system_error.h" 1 3
# 22 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__system_error/system_error.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

class __attribute__((__visibility__("default"))) system_error : public runtime_error {
  error_code __ec_;

public:
  system_error(error_code __ec, const string& __what_arg);
  system_error(error_code __ec, const char* __what_arg);
  system_error(error_code __ec);
  system_error(int __ev, const error_category& __ecat, const string& __what_arg);
  system_error(int __ev, const error_category& __ecat, const char* __what_arg);
  system_error(int __ev, const error_category& __ecat);
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) system_error(const system_error&) noexcept = default;
  ~system_error() noexcept override;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) const error_code& code() const noexcept { return __ec_; }
};

[[noreturn]] __attribute__((__visibility__("default"))) void __throw_system_error(int __ev, const char* __what_arg);
[[noreturn]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) inline void __throw_system_error(error_code __ec, const char* __what_arg) {



  ::std::__libcpp_verbose_abort("system_error was thrown in -fno-exceptions mode with error %i and message \"%s\"", __ec.value(), __what_arg);


}

}}
# 227 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/ios" 2 3
# 242 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/ios" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

typedef ptrdiff_t streamsize;

class __attribute__((__visibility__("default"))) ios_base
{
public:
    class __attribute__((__visibility__("default"))) failure;

    typedef unsigned int fmtflags;
    static const fmtflags boolalpha = 0x0001;
    static const fmtflags dec = 0x0002;
    static const fmtflags fixed = 0x0004;
    static const fmtflags hex = 0x0008;
    static const fmtflags internal = 0x0010;
    static const fmtflags left = 0x0020;
    static const fmtflags oct = 0x0040;
    static const fmtflags right = 0x0080;
    static const fmtflags scientific = 0x0100;
    static const fmtflags showbase = 0x0200;
    static const fmtflags showpoint = 0x0400;
    static const fmtflags showpos = 0x0800;
    static const fmtflags skipws = 0x1000;
    static const fmtflags unitbuf = 0x2000;
    static const fmtflags uppercase = 0x4000;
    static const fmtflags adjustfield = left | right | internal;
    static const fmtflags basefield = dec | oct | hex;
    static const fmtflags floatfield = scientific | fixed;

    typedef unsigned int iostate;
    static const iostate badbit = 0x1;
    static const iostate eofbit = 0x2;
    static const iostate failbit = 0x4;
    static const iostate goodbit = 0x0;

    typedef unsigned int openmode;
    static const openmode app = 0x01;
    static const openmode ate = 0x02;
    static const openmode binary = 0x04;
    static const openmode in = 0x08;
    static const openmode out = 0x10;
    static const openmode trunc = 0x20;

    enum seekdir {beg, cur, end};
# 298 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/ios" 3
    class __attribute__((__visibility__("default"))) Init;


    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) fmtflags flags() const;
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) fmtflags flags(fmtflags __fmtfl);
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) fmtflags setf(fmtflags __fmtfl);
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) fmtflags setf(fmtflags __fmtfl, fmtflags __mask);
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) void unsetf(fmtflags __mask);

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) streamsize precision() const;
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) streamsize precision(streamsize __prec);
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) streamsize width() const;
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) streamsize width(streamsize __wide);


    locale imbue(const locale& __loc);
    locale getloc() const;


    static int xalloc();
    long& iword(int __index);
    void*& pword(int __index);


    virtual ~ios_base();


    enum event { erase_event, imbue_event, copyfmt_event };
    typedef void (*event_callback)(event, ios_base&, int __index);
    void register_callback(event_callback __fn, int __index);

    ios_base(const ios_base&) = delete;
    ios_base& operator=(const ios_base&) = delete;

    static bool sync_with_stdio(bool __sync = true);

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) iostate rdstate() const;
    void clear(iostate __state = goodbit);
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) void setstate(iostate __state);

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) bool good() const;
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) bool eof() const;
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) bool fail() const;
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) bool bad() const;

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) iostate exceptions() const;
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) void exceptions(iostate __iostate);

    void __set_badbit_and_consider_rethrow();
    void __set_failbit_and_consider_rethrow();

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    void __setstate_nothrow(iostate __state)
    {
        if (__rdbuf_)
            __rdstate_ |= __state;
        else
            __rdstate_ |= __state | ios_base::badbit;
    }

protected:
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    ios_base() {
               }

    void init(void* __sb);
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) void* rdbuf() const {return __rdbuf_;}

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    void rdbuf(void* __sb)
    {
        __rdbuf_ = __sb;
        clear();
    }

    void __call_callbacks(event);
    void copyfmt(const ios_base&);
    void move(ios_base&);
    void swap(ios_base&) noexcept;

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    void set_rdbuf(void* __sb)
    {
        __rdbuf_ = __sb;
    }

private:

    fmtflags __fmtflags_;
    streamsize __precision_;
    streamsize __width_;
    iostate __rdstate_;
    iostate __exceptions_;
    void* __rdbuf_;
    void* __loc_;
    event_callback* __fn_;
    int* __index_;
    size_t __event_size_;
    size_t __event_cap_;



    static atomic<int> __xindex_;



    long* __iarray_;
    size_t __iarray_size_;
    size_t __iarray_cap_;
    void** __parray_;
    size_t __parray_size_;
    size_t __parray_cap_;
};


enum class io_errc
{
    stream = 1
};


template <>
struct is_error_code_enum<io_errc> : public true_type { };






__attribute__((__visibility__("default"))) const error_category& iostream_category() noexcept;

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
error_code
make_error_code(io_errc __e) noexcept
{
    return error_code(static_cast<int>(__e), iostream_category());
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
error_condition
make_error_condition(io_errc __e) noexcept
{
    return error_condition(static_cast<int>(__e), iostream_category());
}

class __attribute__((__visibility__("default"))) ios_base::failure
    : public system_error
{
public:
    explicit failure(const string& __msg, const error_code& __ec = io_errc::stream);
    explicit failure(const char* __msg, const error_code& __ec = io_errc::stream);
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) failure(const failure&) noexcept = default;
    ~failure() noexcept override;
};

[[noreturn]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
void __throw_failure(char const* __msg) {



    ::std::__libcpp_verbose_abort("ios_base::failure was thrown in -fno-exceptions mode with message \"%s\"", __msg);

}

class __attribute__((__visibility__("default"))) ios_base::Init
{
public:
    Init();
    ~Init();
};



inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
ios_base::fmtflags
ios_base::flags() const
{
    return __fmtflags_;
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
ios_base::fmtflags
ios_base::flags(fmtflags __fmtfl)
{
    fmtflags __r = __fmtflags_;
    __fmtflags_ = __fmtfl;
    return __r;
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
ios_base::fmtflags
ios_base::setf(fmtflags __fmtfl)
{
    fmtflags __r = __fmtflags_;
    __fmtflags_ |= __fmtfl;
    return __r;
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
void
ios_base::unsetf(fmtflags __mask)
{
    __fmtflags_ &= ~__mask;
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
ios_base::fmtflags
ios_base::setf(fmtflags __fmtfl, fmtflags __mask)
{
    fmtflags __r = __fmtflags_;
    unsetf(__mask);
    __fmtflags_ |= __fmtfl & __mask;
    return __r;
}



inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
streamsize
ios_base::precision() const
{
    return __precision_;
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
streamsize
ios_base::precision(streamsize __prec)
{
    streamsize __r = __precision_;
    __precision_ = __prec;
    return __r;
}



inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
streamsize
ios_base::width() const
{
    return __width_;
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
streamsize
ios_base::width(streamsize __wide)
{
    streamsize __r = __width_;
    __width_ = __wide;
    return __r;
}



inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
ios_base::iostate
ios_base::rdstate() const
{
    return __rdstate_;
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
void
ios_base::setstate(iostate __state)
{
    clear(__rdstate_ | __state);
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
bool
ios_base::good() const
{
    return __rdstate_ == 0;
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
bool
ios_base::eof() const
{
    return (__rdstate_ & eofbit) != 0;
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
bool
ios_base::fail() const
{
    return (__rdstate_ & (failbit | badbit)) != 0;
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
bool
ios_base::bad() const
{
    return (__rdstate_ & badbit) != 0;
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
ios_base::iostate
ios_base::exceptions() const
{
    return __exceptions_;
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
void
ios_base::exceptions(iostate __iostate)
{
    __exceptions_ = __iostate;
    clear(__rdstate_);
}

template <class _CharT, class _Traits>
class basic_ios
    : public ios_base
{
public:

    typedef _CharT char_type;
    typedef _Traits traits_type;

    typedef typename traits_type::int_type int_type;
    typedef typename traits_type::pos_type pos_type;
    typedef typename traits_type::off_type off_type;

    static_assert((is_same<_CharT, typename traits_type::char_type>::value),
                  "traits_type::char_type must be the same type as CharT");







    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    explicit operator bool() const {return !fail();}


    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) bool operator!() const {return fail();}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) iostate rdstate() const {return ios_base::rdstate();}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) void clear(iostate __state = goodbit) {ios_base::clear(__state);}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) void setstate(iostate __state) {ios_base::setstate(__state);}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) bool good() const {return ios_base::good();}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) bool eof() const {return ios_base::eof();}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) bool fail() const {return ios_base::fail();}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) bool bad() const {return ios_base::bad();}

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) iostate exceptions() const {return ios_base::exceptions();}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) void exceptions(iostate __iostate) {ios_base::exceptions(__iostate);}


    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    explicit basic_ios(basic_streambuf<char_type,traits_type>* __sb);
    ~basic_ios() override;


    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    basic_ostream<char_type, traits_type>* tie() const;
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    basic_ostream<char_type, traits_type>* tie(basic_ostream<char_type, traits_type>* __tiestr);

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    basic_streambuf<char_type, traits_type>* rdbuf() const;
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    basic_streambuf<char_type, traits_type>* rdbuf(basic_streambuf<char_type, traits_type>* __sb);

    basic_ios& copyfmt(const basic_ios& __rhs);

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    char_type fill() const;
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    char_type fill(char_type __ch);

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    locale imbue(const locale& __loc);

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    char narrow(char_type __c, char __dfault) const;
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    char_type widen(char __c) const;

protected:
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    basic_ios() {
                }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    void init(basic_streambuf<char_type, traits_type>* __sb);

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    void move(basic_ios& __rhs);
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    void move(basic_ios&& __rhs) {move(__rhs);}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    void swap(basic_ios& __rhs) noexcept;
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    void set_rdbuf(basic_streambuf<char_type, traits_type>* __sb);
private:
    basic_ostream<char_type, traits_type>* __tie_;
    mutable int_type __fill_;
};

template <class _CharT, class _Traits>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
basic_ios<_CharT, _Traits>::basic_ios(basic_streambuf<char_type,traits_type>* __sb)
{
    init(__sb);
}

template <class _CharT, class _Traits>
basic_ios<_CharT, _Traits>::~basic_ios()
{
}

template <class _CharT, class _Traits>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
void
basic_ios<_CharT, _Traits>::init(basic_streambuf<char_type, traits_type>* __sb)
{
    ios_base::init(__sb);
    __tie_ = nullptr;
    __fill_ = traits_type::eof();
}

template <class _CharT, class _Traits>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
basic_ostream<_CharT, _Traits>*
basic_ios<_CharT, _Traits>::tie() const
{
    return __tie_;
}

template <class _CharT, class _Traits>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
basic_ostream<_CharT, _Traits>*
basic_ios<_CharT, _Traits>::tie(basic_ostream<char_type, traits_type>* __tiestr)
{
    basic_ostream<char_type, traits_type>* __r = __tie_;
    __tie_ = __tiestr;
    return __r;
}

template <class _CharT, class _Traits>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
basic_streambuf<_CharT, _Traits>*
basic_ios<_CharT, _Traits>::rdbuf() const
{
    return static_cast<basic_streambuf<char_type, traits_type>*>(ios_base::rdbuf());
}

template <class _CharT, class _Traits>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
basic_streambuf<_CharT, _Traits>*
basic_ios<_CharT, _Traits>::rdbuf(basic_streambuf<char_type, traits_type>* __sb)
{
    basic_streambuf<char_type, traits_type>* __r = rdbuf();
    ios_base::rdbuf(__sb);
    return __r;
}

template <class _CharT, class _Traits>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
locale
basic_ios<_CharT, _Traits>::imbue(const locale& __loc)
{
    locale __r = getloc();
    ios_base::imbue(__loc);
    if (rdbuf())
        rdbuf()->pubimbue(__loc);
    return __r;
}

template <class _CharT, class _Traits>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
char
basic_ios<_CharT, _Traits>::narrow(char_type __c, char __dfault) const
{
    return std::use_facet<ctype<char_type> >(getloc()).narrow(__c, __dfault);
}

template <class _CharT, class _Traits>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
_CharT
basic_ios<_CharT, _Traits>::widen(char __c) const
{
    return std::use_facet<ctype<char_type> >(getloc()).widen(__c);
}

template <class _CharT, class _Traits>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
_CharT
basic_ios<_CharT, _Traits>::fill() const
{
    if (traits_type::eq_int_type(traits_type::eof(), __fill_))
        __fill_ = widen(' ');
    return __fill_;
}

template <class _CharT, class _Traits>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
_CharT
basic_ios<_CharT, _Traits>::fill(char_type __ch)
{
    if (traits_type::eq_int_type(traits_type::eof(), __fill_))
        __fill_ = widen(' ');
    char_type __r = __fill_;
    __fill_ = __ch;
    return __r;
}

template <class _CharT, class _Traits>
basic_ios<_CharT, _Traits>&
basic_ios<_CharT, _Traits>::copyfmt(const basic_ios& __rhs)
{
    if (this != &__rhs)
    {
        __call_callbacks(erase_event);
        ios_base::copyfmt(__rhs);
        __tie_ = __rhs.__tie_;
        __fill_ = __rhs.__fill_;
        __call_callbacks(copyfmt_event);
        exceptions(__rhs.exceptions());
    }
    return *this;
}

template <class _CharT, class _Traits>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
void
basic_ios<_CharT, _Traits>::move(basic_ios& __rhs)
{
    ios_base::move(__rhs);
    __tie_ = __rhs.__tie_;
    __rhs.__tie_ = nullptr;
    __fill_ = __rhs.__fill_;
}

template <class _CharT, class _Traits>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
void
basic_ios<_CharT, _Traits>::swap(basic_ios& __rhs) noexcept
{
    ios_base::swap(__rhs);
    std::swap(__tie_, __rhs.__tie_);
    std::swap(__fill_, __rhs.__fill_);
}

template <class _CharT, class _Traits>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
void
basic_ios<_CharT, _Traits>::set_rdbuf(basic_streambuf<char_type, traits_type>* __sb)
{
    ios_base::set_rdbuf(__sb);
}

extern template class __attribute__((__visibility__("default"))) basic_ios<char>;


extern template class __attribute__((__visibility__("default"))) basic_ios<wchar_t>;


__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) inline
ios_base&
boolalpha(ios_base& __str)
{
    __str.setf(ios_base::boolalpha);
    return __str;
}

__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) inline
ios_base&
noboolalpha(ios_base& __str)
{
    __str.unsetf(ios_base::boolalpha);
    return __str;
}

__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) inline
ios_base&
showbase(ios_base& __str)
{
    __str.setf(ios_base::showbase);
    return __str;
}

__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) inline
ios_base&
noshowbase(ios_base& __str)
{
    __str.unsetf(ios_base::showbase);
    return __str;
}

__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) inline
ios_base&
showpoint(ios_base& __str)
{
    __str.setf(ios_base::showpoint);
    return __str;
}

__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) inline
ios_base&
noshowpoint(ios_base& __str)
{
    __str.unsetf(ios_base::showpoint);
    return __str;
}

__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) inline
ios_base&
showpos(ios_base& __str)
{
    __str.setf(ios_base::showpos);
    return __str;
}

__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) inline
ios_base&
noshowpos(ios_base& __str)
{
    __str.unsetf(ios_base::showpos);
    return __str;
}

__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) inline
ios_base&
skipws(ios_base& __str)
{
    __str.setf(ios_base::skipws);
    return __str;
}

__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) inline
ios_base&
noskipws(ios_base& __str)
{
    __str.unsetf(ios_base::skipws);
    return __str;
}

__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) inline
ios_base&
uppercase(ios_base& __str)
{
    __str.setf(ios_base::uppercase);
    return __str;
}

__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) inline
ios_base&
nouppercase(ios_base& __str)
{
    __str.unsetf(ios_base::uppercase);
    return __str;
}

__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) inline
ios_base&
unitbuf(ios_base& __str)
{
    __str.setf(ios_base::unitbuf);
    return __str;
}

__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) inline
ios_base&
nounitbuf(ios_base& __str)
{
    __str.unsetf(ios_base::unitbuf);
    return __str;
}

__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) inline
ios_base&
internal(ios_base& __str)
{
    __str.setf(ios_base::internal, ios_base::adjustfield);
    return __str;
}

__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) inline
ios_base&
left(ios_base& __str)
{
    __str.setf(ios_base::left, ios_base::adjustfield);
    return __str;
}

__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) inline
ios_base&
right(ios_base& __str)
{
    __str.setf(ios_base::right, ios_base::adjustfield);
    return __str;
}

__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) inline
ios_base&
dec(ios_base& __str)
{
    __str.setf(ios_base::dec, ios_base::basefield);
    return __str;
}

__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) inline
ios_base&
hex(ios_base& __str)
{
    __str.setf(ios_base::hex, ios_base::basefield);
    return __str;
}

__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) inline
ios_base&
oct(ios_base& __str)
{
    __str.setf(ios_base::oct, ios_base::basefield);
    return __str;
}

__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) inline
ios_base&
fixed(ios_base& __str)
{
    __str.setf(ios_base::fixed, ios_base::floatfield);
    return __str;
}

__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) inline
ios_base&
scientific(ios_base& __str)
{
    __str.setf(ios_base::scientific, ios_base::floatfield);
    return __str;
}

__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) inline
ios_base&
hexfloat(ios_base& __str)
{
    __str.setf(ios_base::fixed | ios_base::scientific, ios_base::floatfield);
    return __str;
}

__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) inline
ios_base&
defaultfloat(ios_base& __str)
{
    __str.unsetf(ios_base::floatfield);
    return __str;
}

}}
# 210 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/locale" 2 3


# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/streambuf" 1 3
# 120 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/streambuf" 3



# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__undef_macros" 1 3
# 124 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/streambuf" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _CharT, class _Traits>
class basic_streambuf
{
public:

    typedef _CharT char_type;
    typedef _Traits traits_type;
    typedef typename traits_type::int_type int_type;
    typedef typename traits_type::pos_type pos_type;
    typedef typename traits_type::off_type off_type;

    static_assert((is_same<_CharT, typename traits_type::char_type>::value),
                  "traits_type::char_type must be the same type as CharT");

    virtual ~basic_streambuf();


    inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    locale pubimbue(const locale& __loc) {
        imbue(__loc);
        locale __r = __loc_;
        __loc_ = __loc;
        return __r;
    }

    inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    locale getloc() const { return __loc_; }


    inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    basic_streambuf* pubsetbuf(char_type* __s, streamsize __n)
    { return setbuf(__s, __n); }

    inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    pos_type pubseekoff(off_type __off, ios_base::seekdir __way,
                        ios_base::openmode __which = ios_base::in | ios_base::out)
    { return seekoff(__off, __way, __which); }

    inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    pos_type pubseekpos(pos_type __sp,
                        ios_base::openmode __which = ios_base::in | ios_base::out)
    { return seekpos(__sp, __which); }

    inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    int pubsync() { return sync(); }



    inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    streamsize in_avail() {
        if (__ninp_ < __einp_)
            return static_cast<streamsize>(__einp_ - __ninp_);
        return showmanyc();
    }

    inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    int_type snextc() {
        if (sbumpc() == traits_type::eof())
            return traits_type::eof();
        return sgetc();
    }

    inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    int_type sbumpc() {
        if (__ninp_ == __einp_)
            return uflow();
        return traits_type::to_int_type(*__ninp_++);
    }

    inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    int_type sgetc() {
        if (__ninp_ == __einp_)
            return underflow();
        return traits_type::to_int_type(*__ninp_);
    }

    inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    streamsize sgetn(char_type* __s, streamsize __n)
    { return xsgetn(__s, __n); }


    inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    int_type sputbackc(char_type __c) {
        if (__binp_ == __ninp_ || !traits_type::eq(__c, __ninp_[-1]))
            return pbackfail(traits_type::to_int_type(__c));
        return traits_type::to_int_type(*--__ninp_);
    }

    inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    int_type sungetc() {
        if (__binp_ == __ninp_)
          return pbackfail();
        return traits_type::to_int_type(*--__ninp_);
    }


    inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    int_type sputc(char_type __c) {
        if (__nout_ == __eout_)
            return overflow(traits_type::to_int_type(__c));
        *__nout_++ = __c;
        return traits_type::to_int_type(__c);
    }

    inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    streamsize sputn(const char_type* __s, streamsize __n)
    { return xsputn(__s, __n); }

protected:
    basic_streambuf();
    basic_streambuf(const basic_streambuf& __rhs);
    basic_streambuf& operator=(const basic_streambuf& __rhs);
    void swap(basic_streambuf& __rhs);


    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) char_type* eback() const {return __binp_;}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) char_type* gptr() const {return __ninp_;}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) char_type* egptr() const {return __einp_;}

    inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    void gbump(int __n) { __ninp_ += __n; }

    inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    void setg(char_type* __gbeg, char_type* __gnext, char_type* __gend) {
        __binp_ = __gbeg;
        __ninp_ = __gnext;
        __einp_ = __gend;
    }


    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) char_type* pbase() const {return __bout_;}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) char_type* pptr() const {return __nout_;}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) char_type* epptr() const {return __eout_;}

    inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    void pbump(int __n) { __nout_ += __n; }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    void __pbump(streamsize __n) { __nout_ += __n; }

    inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    void setp(char_type* __pbeg, char_type* __pend) {
        __bout_ = __nout_ = __pbeg;
        __eout_ = __pend;
    }



    virtual void imbue(const locale& __loc);


    virtual basic_streambuf* setbuf(char_type* __s, streamsize __n);
    virtual pos_type seekoff(off_type __off, ios_base::seekdir __way,
                             ios_base::openmode __which = ios_base::in | ios_base::out);
    virtual pos_type seekpos(pos_type __sp,
                             ios_base::openmode __which = ios_base::in | ios_base::out);
    virtual int sync();


    virtual streamsize showmanyc();
    virtual streamsize xsgetn(char_type* __s, streamsize __n);
    virtual int_type underflow();
    virtual int_type uflow();


    virtual int_type pbackfail(int_type __c = traits_type::eof());


    virtual streamsize xsputn(const char_type* __s, streamsize __n);
    virtual int_type overflow(int_type __c = traits_type::eof());

private:
    locale __loc_;
    char_type* __binp_;
    char_type* __ninp_;
    char_type* __einp_;
    char_type* __bout_;
    char_type* __nout_;
    char_type* __eout_;
};

template <class _CharT, class _Traits>
basic_streambuf<_CharT, _Traits>::~basic_streambuf()
{
}

template <class _CharT, class _Traits>
basic_streambuf<_CharT, _Traits>::basic_streambuf()
    : __binp_(nullptr),
      __ninp_(nullptr),
      __einp_(nullptr),
      __bout_(nullptr),
      __nout_(nullptr),
      __eout_(nullptr)
{
}

template <class _CharT, class _Traits>
basic_streambuf<_CharT, _Traits>::basic_streambuf(const basic_streambuf& __sb)
    : __loc_(__sb.__loc_),
      __binp_(__sb.__binp_),
      __ninp_(__sb.__ninp_),
      __einp_(__sb.__einp_),
      __bout_(__sb.__bout_),
      __nout_(__sb.__nout_),
      __eout_(__sb.__eout_)
{
}

template <class _CharT, class _Traits>
basic_streambuf<_CharT, _Traits>&
basic_streambuf<_CharT, _Traits>::operator=(const basic_streambuf& __sb)
{
    __loc_ = __sb.__loc_;
    __binp_ = __sb.__binp_;
    __ninp_ = __sb.__ninp_;
    __einp_ = __sb.__einp_;
    __bout_ = __sb.__bout_;
    __nout_ = __sb.__nout_;
    __eout_ = __sb.__eout_;
    return *this;
}

template <class _CharT, class _Traits>
void
basic_streambuf<_CharT, _Traits>::swap(basic_streambuf& __sb)
{
    std::swap(__loc_, __sb.__loc_);
    std::swap(__binp_, __sb.__binp_);
    std::swap(__ninp_, __sb.__ninp_);
    std::swap(__einp_, __sb.__einp_);
    std::swap(__bout_, __sb.__bout_);
    std::swap(__nout_, __sb.__nout_);
    std::swap(__eout_, __sb.__eout_);
}

template <class _CharT, class _Traits>
void
basic_streambuf<_CharT, _Traits>::imbue(const locale&)
{
}

template <class _CharT, class _Traits>
basic_streambuf<_CharT, _Traits>*
basic_streambuf<_CharT, _Traits>::setbuf(char_type*, streamsize)
{
    return this;
}

template <class _CharT, class _Traits>
typename basic_streambuf<_CharT, _Traits>::pos_type
basic_streambuf<_CharT, _Traits>::seekoff(off_type, ios_base::seekdir,
                                          ios_base::openmode)
{
    return pos_type(off_type(-1));
}

template <class _CharT, class _Traits>
typename basic_streambuf<_CharT, _Traits>::pos_type
basic_streambuf<_CharT, _Traits>::seekpos(pos_type, ios_base::openmode)
{
    return pos_type(off_type(-1));
}

template <class _CharT, class _Traits>
int
basic_streambuf<_CharT, _Traits>::sync()
{
    return 0;
}

template <class _CharT, class _Traits>
streamsize
basic_streambuf<_CharT, _Traits>::showmanyc()
{
    return 0;
}

template <class _CharT, class _Traits>
streamsize
basic_streambuf<_CharT, _Traits>::xsgetn(char_type* __s, streamsize __n)
{
    const int_type __eof = traits_type::eof();
    int_type __c;
    streamsize __i = 0;
    while(__i < __n)
    {
        if (__ninp_ < __einp_)
        {
            const streamsize __len = std::min(static_cast<streamsize>(2147483647),
                                std::min(__einp_ - __ninp_, __n - __i));
            traits_type::copy(__s, __ninp_, __len);
            __s += __len;
            __i += __len;
            this->gbump(__len);
        }
        else if ((__c = uflow()) != __eof)
        {
            *__s = traits_type::to_char_type(__c);
            ++__s;
            ++__i;
        }
        else
            break;
    }
    return __i;
}

template <class _CharT, class _Traits>
typename basic_streambuf<_CharT, _Traits>::int_type
basic_streambuf<_CharT, _Traits>::underflow()
{
    return traits_type::eof();
}

template <class _CharT, class _Traits>
typename basic_streambuf<_CharT, _Traits>::int_type
basic_streambuf<_CharT, _Traits>::uflow()
{
    if (underflow() == traits_type::eof())
        return traits_type::eof();
    return traits_type::to_int_type(*__ninp_++);
}

template <class _CharT, class _Traits>
typename basic_streambuf<_CharT, _Traits>::int_type
basic_streambuf<_CharT, _Traits>::pbackfail(int_type)
{
    return traits_type::eof();
}

template <class _CharT, class _Traits>
streamsize
basic_streambuf<_CharT, _Traits>::xsputn(const char_type* __s, streamsize __n)
{
    streamsize __i = 0;
    int_type __eof = traits_type::eof();
    while( __i < __n)
    {
        if (__nout_ >= __eout_)
        {
            if (overflow(traits_type::to_int_type(*__s)) == __eof)
                break;
            ++__s;
            ++__i;
        }
        else
        {
            streamsize __chunk_size = std::min(__eout_ - __nout_, __n - __i);
            traits_type::copy(__nout_, __s, __chunk_size);
            __nout_ += __chunk_size;
            __s += __chunk_size;
            __i += __chunk_size;
        }
    }
    return __i;
}

template <class _CharT, class _Traits>
typename basic_streambuf<_CharT, _Traits>::int_type
basic_streambuf<_CharT, _Traits>::overflow(int_type)
{
    return traits_type::eof();
}

extern template class __attribute__((__visibility__("default"))) basic_streambuf<char>;


extern template class __attribute__((__visibility__("default"))) basic_streambuf<wchar_t>;


}}
# 213 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/locale" 2 3
# 222 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/locale" 3
# 1 "/usr/include/nl_types.h" 1 3 4
# 30 "/usr/include/nl_types.h" 3 4
extern "C" {


typedef void *nl_catd;


typedef int nl_item;





extern nl_catd catopen (const char *__cat_name, int __flag) __attribute__ ((__nonnull__ (1)));



extern char *catgets (nl_catd __catalog, int __set, int __number,
        const char *__string) throw () __attribute__ ((__nonnull__ (1)));


extern int catclose (nl_catd __catalog) throw () __attribute__ ((__nonnull__ (1)));

}
# 223 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/locale" 2 3






# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__locale_dir/locale_base_api/bsd_locale_fallbacks.h" 1 3
# 16 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__locale_dir/locale_base_api/bsd_locale_fallbacks.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__locale_dir/locale_base_api/locale_guard.h" 1 3
# 18 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__locale_dir/locale_base_api/locale_guard.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {


struct __libcpp_locale_guard {
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) __libcpp_locale_guard(locale_t& __loc) : __old_loc_(uselocale(__loc)) {}

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) ~__libcpp_locale_guard() {
    if (__old_loc_)
      uselocale(__old_loc_);
  }

  locale_t __old_loc_;

private:
  __libcpp_locale_guard(__libcpp_locale_guard const&);
  __libcpp_locale_guard& operator=(__libcpp_locale_guard const&);
};
# 78 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__locale_dir/locale_base_api/locale_guard.h" 3
}}
# 17 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__locale_dir/locale_base_api/bsd_locale_fallbacks.h" 2 3

# 1 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/stdarg.h" 1 3
# 38 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/stdarg.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/__stdarg_va_list.h" 1 3
# 12 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/__stdarg_va_list.h" 3
typedef __builtin_va_list va_list;
# 39 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/stdarg.h" 2 3




# 1 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/__stdarg_va_arg.h" 1 3
# 44 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/stdarg.h" 2 3




# 1 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/__stdarg___va_copy.h" 1 3
# 49 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/stdarg.h" 2 3




# 1 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/__stdarg_va_copy.h" 1 3
# 54 "/dev/shm/rydahl1/LLVM/install/lib/clang/18/include/stdarg.h" 2 3
# 19 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__locale_dir/locale_base_api/bsd_locale_fallbacks.h" 2 3
# 27 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__locale_dir/locale_base_api/bsd_locale_fallbacks.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
decltype((__ctype_get_mb_cur_max ())) __libcpp_mb_cur_max_l(locale_t __l)
{
    __libcpp_locale_guard __current(__l);
    return (__ctype_get_mb_cur_max ());
}


inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
wint_t __libcpp_btowc_l(int __c, locale_t __l)
{
    __libcpp_locale_guard __current(__l);
    return btowc(__c);
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
int __libcpp_wctob_l(wint_t __c, locale_t __l)
{
    __libcpp_locale_guard __current(__l);
    return wctob(__c);
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
size_t __libcpp_wcsnrtombs_l(char *__dest, const wchar_t **__src, size_t __nwc,
                         size_t __len, mbstate_t *__ps, locale_t __l)
{
    __libcpp_locale_guard __current(__l);
    return wcsnrtombs(__dest, __src, __nwc, __len, __ps);
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
size_t __libcpp_wcrtomb_l(char *__s, wchar_t __wc, mbstate_t *__ps, locale_t __l)
{
    __libcpp_locale_guard __current(__l);
    return wcrtomb(__s, __wc, __ps);
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
size_t __libcpp_mbsnrtowcs_l(wchar_t * __dest, const char **__src, size_t __nms,
                      size_t __len, mbstate_t *__ps, locale_t __l)
{
    __libcpp_locale_guard __current(__l);
    return mbsnrtowcs(__dest, __src, __nms, __len, __ps);
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
size_t __libcpp_mbrtowc_l(wchar_t *__pwc, const char *__s, size_t __n,
                   mbstate_t *__ps, locale_t __l)
{
    __libcpp_locale_guard __current(__l);
    return mbrtowc(__pwc, __s, __n, __ps);
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
int __libcpp_mbtowc_l(wchar_t *__pwc, const char *__pmb, size_t __max, locale_t __l)
{
    __libcpp_locale_guard __current(__l);
    return mbtowc(__pwc, __pmb, __max);
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
size_t __libcpp_mbrlen_l(const char *__s, size_t __n, mbstate_t *__ps, locale_t __l)
{
    __libcpp_locale_guard __current(__l);
    return mbrlen(__s, __n, __ps);
}


inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
lconv *__libcpp_localeconv_l(locale_t __l)
{
    __libcpp_locale_guard __current(__l);
    return localeconv();
}


inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
size_t __libcpp_mbsrtowcs_l(wchar_t *__dest, const char **__src, size_t __len,
                     mbstate_t *__ps, locale_t __l)
{
    __libcpp_locale_guard __current(__l);
    return mbsrtowcs(__dest, __src, __len, __ps);
}


inline __attribute__((__format__(__printf__, 4, 5)))
int __libcpp_snprintf_l(char *__s, size_t __n, locale_t __l, const char *__format, ...) {
    va_list __va;
    __builtin_va_start(__va, __format);
    __libcpp_locale_guard __current(__l);
    int __res = vsnprintf(__s, __n, __format, __va);
    __builtin_va_end(__va);
    return __res;
}

inline __attribute__((__format__(__printf__, 3, 4)))
int __libcpp_asprintf_l(char **__s, locale_t __l, const char *__format, ...) {
    va_list __va;
    __builtin_va_start(__va, __format);
    __libcpp_locale_guard __current(__l);
    int __res = vasprintf(__s, __format, __va);
    __builtin_va_end(__va);
    return __res;
}

inline __attribute__((__format__(__scanf__, 3, 4)))
int __libcpp_sscanf_l(const char *__s, locale_t __l, const char *__format, ...) {
    va_list __va;
    __builtin_va_start(__va, __format);
    __libcpp_locale_guard __current(__l);
    int __res = vsscanf(__s, __format, __va);
    __builtin_va_end(__va);
    return __res;
}

}}
# 230 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/locale" 2 3
# 234 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/locale" 3



# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__undef_macros" 1 3
# 238 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/locale" 2 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 249 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/locale" 3
   __attribute__((__visibility__("default"))) locale_t __cloc();
# 271 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/locale" 3
template <class _InputIterator, class _ForwardIterator, class _Ctype>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
_ForwardIterator
__scan_keyword(_InputIterator& __b, _InputIterator __e,
               _ForwardIterator __kb, _ForwardIterator __ke,
               const _Ctype& __ct, ios_base::iostate& __err,
               bool __case_sensitive = true)
{
    typedef typename iterator_traits<_InputIterator>::value_type _CharT;
    size_t __nkw = static_cast<size_t>(std::distance(__kb, __ke));
    const unsigned char __doesnt_match = '\0';
    const unsigned char __might_match = '\1';
    const unsigned char __does_match = '\2';
    unsigned char __statbuf[100];
    unsigned char* __status = __statbuf;
    unique_ptr<unsigned char, void(*)(void*)> __stat_hold(nullptr, free);
    if (__nkw > sizeof(__statbuf))
    {
        __status = (unsigned char*)malloc(__nkw);
        if (__status == nullptr)
            __throw_bad_alloc();
        __stat_hold.reset(__status);
    }
    size_t __n_might_match = __nkw;
    size_t __n_does_match = 0;

    unsigned char* __st = __status;
    for (_ForwardIterator __ky = __kb; __ky != __ke; ++__ky, (void) ++__st)
    {
        if (!__ky->empty())
            *__st = __might_match;
        else
        {
            *__st = __does_match;
            --__n_might_match;
            ++__n_does_match;
        }
    }

    for (size_t __indx = 0; __b != __e && __n_might_match > 0; ++__indx)
    {

        _CharT __c = *__b;
        if (!__case_sensitive)
            __c = __ct.toupper(__c);
        bool __consume = false;






        __st = __status;
        for (_ForwardIterator __ky = __kb; __ky != __ke; ++__ky, (void) ++__st)
        {
            if (*__st == __might_match)
            {
                _CharT __kc = (*__ky)[__indx];
                if (!__case_sensitive)
                    __kc = __ct.toupper(__kc);
                if (__c == __kc)
                {
                    __consume = true;
                    if (__ky->size() == __indx+1)
                    {
                        *__st = __does_match;
                        --__n_might_match;
                        ++__n_does_match;
                    }
                }
                else
                {
                    *__st = __doesnt_match;
                    --__n_might_match;
                }
            }
        }

        if (__consume)
        {
            ++__b;



            if (__n_might_match + __n_does_match > 1)
            {
                __st = __status;
                for (_ForwardIterator __ky = __kb; __ky != __ke; ++__ky, (void) ++__st)
                {
                    if (*__st == __does_match && __ky->size() != __indx+1)
                    {
                        *__st = __doesnt_match;
                        --__n_does_match;
                    }
                }
            }
        }
    }

    if (__b == __e)
        __err |= ios_base::eofbit;

    for (__st = __status; __kb != __ke; ++__kb, (void) ++__st)
        if (*__st == __does_match)
            break;
    if (__kb == __ke)
        __err |= ios_base::failbit;
    return __kb;
}

struct __attribute__((__visibility__("default"))) __num_get_base
{
    static const int __num_get_buf_sz = 40;

    static int __get_base(ios_base&);
    static const char __src[33];
};

__attribute__((__visibility__("default"))) void __check_grouping(const string& __grouping, unsigned* __g, unsigned* __g_end,
                      ios_base::iostate& __err);

template <class _CharT>
struct __num_get
    : protected __num_get_base
{
    static string __stage2_float_prep(ios_base& __iob, _CharT* __atoms, _CharT& __decimal_point,
                                      _CharT& __thousands_sep);

    static int __stage2_float_loop(_CharT __ct, bool& __in_units, char& __exp,
                                   char* __a, char*& __a_end,
                                   _CharT __decimal_point, _CharT __thousands_sep,
                                   const string& __grouping, unsigned* __g,
                                   unsigned*& __g_end, unsigned& __dc, _CharT* __atoms);

    static string __stage2_int_prep(ios_base& __iob, _CharT* __atoms, _CharT& __thousands_sep);
    static int __stage2_int_loop(_CharT __ct, int __base, char* __a, char*& __a_end,
                  unsigned& __dc, _CharT __thousands_sep, const string& __grouping,
                  unsigned* __g, unsigned*& __g_end, _CharT* __atoms);
# 444 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/locale" 3
};


template <class _CharT>
string
__num_get<_CharT>::__stage2_int_prep(ios_base& __iob, _CharT* __atoms, _CharT& __thousands_sep)
{
    locale __loc = __iob.getloc();
    std::use_facet<ctype<_CharT> >(__loc).widen(__src, __src + 26, __atoms);
    const numpunct<_CharT>& __np = std::use_facet<numpunct<_CharT> >(__loc);
    __thousands_sep = __np.thousands_sep();
    return __np.grouping();
}


template <class _CharT>
string
__num_get<_CharT>::__stage2_float_prep(ios_base& __iob, _CharT* __atoms, _CharT& __decimal_point,
                    _CharT& __thousands_sep)
{
    locale __loc = __iob.getloc();
    std::use_facet<ctype<_CharT> >(__loc).widen(__src, __src + 32, __atoms);
    const numpunct<_CharT>& __np = std::use_facet<numpunct<_CharT> >(__loc);
    __decimal_point = __np.decimal_point();
    __thousands_sep = __np.thousands_sep();
    return __np.grouping();
}

template <class _CharT>
int

__num_get<_CharT>::__stage2_int_loop(_CharT __ct, int __base, char* __a, char*& __a_end,
                  unsigned& __dc, _CharT __thousands_sep, const string& __grouping,
                  unsigned* __g, unsigned*& __g_end, _CharT* __atoms)






{
    if (__a_end == __a && (__ct == __atoms[24] || __ct == __atoms[25]))
    {
        *__a_end++ = __ct == __atoms[24] ? '+' : '-';
        __dc = 0;
        return 0;
    }
    if (__grouping.size() != 0 && __ct == __thousands_sep)
    {
        if (__g_end-__g < __num_get_buf_sz)
        {
            *__g_end++ = __dc;
            __dc = 0;
        }
        return 0;
    }
    ptrdiff_t __f = std::find(__atoms, __atoms + 26, __ct) - __atoms;
    if (__f >= 24)
        return -1;
    switch (__base)
    {
    case 8:
    case 10:
        if (__f >= __base)
            return -1;
        break;
    case 16:
        if (__f < 22)
            break;
        if (__a_end != __a && __a_end - __a <= 2 && __a_end[-1] == '0')
        {
            __dc = 0;
            *__a_end++ = __src[__f];
            return 0;
        }
        return -1;
    }
    *__a_end++ = __src[__f];
    ++__dc;
    return 0;
}

template <class _CharT>
int
__num_get<_CharT>::__stage2_float_loop(_CharT __ct, bool& __in_units, char& __exp, char* __a, char*& __a_end,
                    _CharT __decimal_point, _CharT __thousands_sep, const string& __grouping,
                    unsigned* __g, unsigned*& __g_end, unsigned& __dc, _CharT* __atoms)
{
    if (__ct == __decimal_point)
    {
        if (!__in_units)
            return -1;
        __in_units = false;
        *__a_end++ = '.';
        if (__grouping.size() != 0 && __g_end-__g < __num_get_buf_sz)
            *__g_end++ = __dc;
        return 0;
    }
    if (__ct == __thousands_sep && __grouping.size() != 0)
    {
        if (!__in_units)
            return -1;
        if (__g_end-__g < __num_get_buf_sz)
        {
            *__g_end++ = __dc;
            __dc = 0;
        }
        return 0;
    }
    ptrdiff_t __f = std::find(__atoms, __atoms + 32, __ct) - __atoms;
    if (__f >= 32)
        return -1;
    char __x = __src[__f];
    if (__x == '-' || __x == '+')
    {
        if (__a_end == __a || (std::toupper(__a_end[-1]) == std::toupper(__exp)))
        {
            *__a_end++ = __x;
            return 0;
        }
        return -1;
    }
    if (__x == 'x' || __x == 'X')
        __exp = 'P';
    else if (std::toupper(__x) == __exp)
    {
        __exp = std::tolower(__exp);
        if (__in_units)
        {
            __in_units = false;
            if (__grouping.size() != 0 && __g_end-__g < __num_get_buf_sz)
                *__g_end++ = __dc;
        }
    }
    *__a_end++ = __x;
    if (__f >= 22)
        return 0;
    ++__dc;
    return 0;
}

extern template struct __attribute__((__visibility__("default"))) __num_get<char>;

extern template struct __attribute__((__visibility__("default"))) __num_get<wchar_t>;


template <class _CharT, class _InputIterator = istreambuf_iterator<_CharT> >
class num_get
    : public locale::facet,
      private __num_get<_CharT>
{
public:
    typedef _CharT char_type;
    typedef _InputIterator iter_type;

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    explicit num_get(size_t __refs = 0)
        : locale::facet(__refs) {}

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,
                  ios_base::iostate& __err, bool& __v) const
    {
        return do_get(__b, __e, __iob, __err, __v);
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,
                  ios_base::iostate& __err, long& __v) const
    {
        return do_get(__b, __e, __iob, __err, __v);
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,
                  ios_base::iostate& __err, long long& __v) const
    {
        return do_get(__b, __e, __iob, __err, __v);
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,
                  ios_base::iostate& __err, unsigned short& __v) const
    {
        return do_get(__b, __e, __iob, __err, __v);
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,
                  ios_base::iostate& __err, unsigned int& __v) const
    {
        return do_get(__b, __e, __iob, __err, __v);
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,
                  ios_base::iostate& __err, unsigned long& __v) const
    {
        return do_get(__b, __e, __iob, __err, __v);
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,
                  ios_base::iostate& __err, unsigned long long& __v) const
    {
        return do_get(__b, __e, __iob, __err, __v);
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,
                  ios_base::iostate& __err, float& __v) const
    {
        return do_get(__b, __e, __iob, __err, __v);
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,
                  ios_base::iostate& __err, double& __v) const
    {
        return do_get(__b, __e, __iob, __err, __v);
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,
                  ios_base::iostate& __err, long double& __v) const
    {
        return do_get(__b, __e, __iob, __err, __v);
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,
                  ios_base::iostate& __err, void*& __v) const
    {
        return do_get(__b, __e, __iob, __err, __v);
    }

    static locale::id id;

protected:
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) ~num_get() override {}

    template <class _Fp>
    inline __attribute__((__visibility__("hidden")))
    iter_type __do_get_floating_point
                            (iter_type __b, iter_type __e, ios_base& __iob,
                             ios_base::iostate& __err, _Fp& __v) const;

    template <class _Signed>
    inline __attribute__((__visibility__("hidden")))
    iter_type __do_get_signed
                            (iter_type __b, iter_type __e, ios_base& __iob,
                             ios_base::iostate& __err, _Signed& __v) const;

    template <class _Unsigned>
    inline __attribute__((__visibility__("hidden")))
    iter_type __do_get_unsigned
                            (iter_type __b, iter_type __e, ios_base& __iob,
                             ios_base::iostate& __err, _Unsigned& __v) const;


    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,
                             ios_base::iostate& __err, bool& __v) const;

    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,
                             ios_base::iostate& __err, long& __v) const
    { return this->__do_get_signed ( __b, __e, __iob, __err, __v ); }

    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,
                             ios_base::iostate& __err, long long& __v) const
    { return this->__do_get_signed ( __b, __e, __iob, __err, __v ); }

    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,
                             ios_base::iostate& __err, unsigned short& __v) const
    { return this->__do_get_unsigned ( __b, __e, __iob, __err, __v ); }

    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,
                             ios_base::iostate& __err, unsigned int& __v) const
    { return this->__do_get_unsigned ( __b, __e, __iob, __err, __v ); }

    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,
                             ios_base::iostate& __err, unsigned long& __v) const
    { return this->__do_get_unsigned ( __b, __e, __iob, __err, __v ); }

    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,
                             ios_base::iostate& __err, unsigned long long& __v) const
    { return this->__do_get_unsigned ( __b, __e, __iob, __err, __v ); }

    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,
                             ios_base::iostate& __err, float& __v) const
    { return this->__do_get_floating_point ( __b, __e, __iob, __err, __v ); }

    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,
                             ios_base::iostate& __err, double& __v) const
    { return this->__do_get_floating_point ( __b, __e, __iob, __err, __v ); }

    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,
                             ios_base::iostate& __err, long double& __v) const
    { return this->__do_get_floating_point ( __b, __e, __iob, __err, __v ); }

    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,
                             ios_base::iostate& __err, void*& __v) const;
};

template <class _CharT, class _InputIterator>
locale::id
num_get<_CharT, _InputIterator>::id;

template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) _Tp
__num_get_signed_integral(const char* __a, const char* __a_end,
                          ios_base::iostate& __err, int __base)
{
    if (__a != __a_end)
    {
        __libcpp_remove_reference_t<decltype((*__errno_location ()))> __save_errno = (*__errno_location ());
        (*__errno_location ()) = 0;
        char *__p2;
        long long __ll = strtoll_l(__a, &__p2, __base, __cloc());
        __libcpp_remove_reference_t<decltype((*__errno_location ()))> __current_errno = (*__errno_location ());
        if (__current_errno == 0)
            (*__errno_location ()) = __save_errno;
        if (__p2 != __a_end)
        {
            __err = ios_base::failbit;
            return 0;
        }
        else if (__current_errno == 34 ||
                 __ll < numeric_limits<_Tp>::min() ||
                 numeric_limits<_Tp>::max() < __ll)
        {
            __err = ios_base::failbit;
            if (__ll > 0)
                return numeric_limits<_Tp>::max();
            else
                return numeric_limits<_Tp>::min();
        }
        return static_cast<_Tp>(__ll);
    }
    __err = ios_base::failbit;
    return 0;
}

template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) _Tp
__num_get_unsigned_integral(const char* __a, const char* __a_end,
                            ios_base::iostate& __err, int __base)
{
    if (__a != __a_end)
    {
        const bool __negate = *__a == '-';
        if (__negate && ++__a == __a_end) {
          __err = ios_base::failbit;
          return 0;
        }
        __libcpp_remove_reference_t<decltype((*__errno_location ()))> __save_errno = (*__errno_location ());
        (*__errno_location ()) = 0;
        char *__p2;
        unsigned long long __ll = strtoull_l(__a, &__p2, __base, __cloc());
        __libcpp_remove_reference_t<decltype((*__errno_location ()))> __current_errno = (*__errno_location ());
        if (__current_errno == 0)
            (*__errno_location ()) = __save_errno;
        if (__p2 != __a_end)
        {
            __err = ios_base::failbit;
            return 0;
        }
        else if (__current_errno == 34 || numeric_limits<_Tp>::max() < __ll)
        {
            __err = ios_base::failbit;
            return numeric_limits<_Tp>::max();
        }
        _Tp __res = static_cast<_Tp>(__ll);
        if (__negate) __res = -__res;
        return __res;
    }
    __err = ios_base::failbit;
    return 0;
}

template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
_Tp __do_strtod(const char* __a, char** __p2);

template <>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
float __do_strtod<float>(const char* __a, char** __p2) {
    return strtof_l(__a, __p2, __cloc());
}

template <>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
double __do_strtod<double>(const char* __a, char** __p2) {
    return strtod_l(__a, __p2, __cloc());
}

template <>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
long double __do_strtod<long double>(const char* __a, char** __p2) {
    return strtold_l(__a, __p2, __cloc());
}

template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
_Tp
__num_get_float(const char* __a, const char* __a_end, ios_base::iostate& __err)
{
    if (__a != __a_end)
    {
        __libcpp_remove_reference_t<decltype((*__errno_location ()))> __save_errno = (*__errno_location ());
        (*__errno_location ()) = 0;
        char *__p2;
        _Tp __ld = std::__do_strtod<_Tp>(__a, &__p2);
        __libcpp_remove_reference_t<decltype((*__errno_location ()))> __current_errno = (*__errno_location ());
        if (__current_errno == 0)
            (*__errno_location ()) = __save_errno;
        if (__p2 != __a_end)
        {
            __err = ios_base::failbit;
            return 0;
        }
        else if (__current_errno == 34)
            __err = ios_base::failbit;
        return __ld;
    }
    __err = ios_base::failbit;
    return 0;
}

template <class _CharT, class _InputIterator>
_InputIterator
num_get<_CharT, _InputIterator>::do_get(iter_type __b, iter_type __e,
                                        ios_base& __iob,
                                        ios_base::iostate& __err,
                                        bool& __v) const
{
    if ((__iob.flags() & ios_base::boolalpha) == 0)
    {
        long __lv = -1;
        __b = do_get(__b, __e, __iob, __err, __lv);
        switch (__lv)
        {
        case 0:
            __v = false;
            break;
        case 1:
            __v = true;
            break;
        default:
            __v = true;
            __err = ios_base::failbit;
            break;
        }
        return __b;
    }
    const ctype<_CharT>& __ct = std::use_facet<ctype<_CharT> >(__iob.getloc());
    const numpunct<_CharT>& __np = std::use_facet<numpunct<_CharT> >(__iob.getloc());
    typedef typename numpunct<_CharT>::string_type string_type;
    const string_type __names[2] = {__np.truename(), __np.falsename()};
    const string_type* __i = std::__scan_keyword(__b, __e, __names, __names+2,
                                                   __ct, __err);
    __v = __i == __names;
    return __b;
}



template <class _CharT, class _InputIterator>
template <class _Signed>
_InputIterator
num_get<_CharT, _InputIterator>::__do_get_signed(iter_type __b, iter_type __e,
                                        ios_base& __iob,
                                        ios_base::iostate& __err,
                                        _Signed& __v) const
{

    int __base = this->__get_base(__iob);

    char_type __thousands_sep;
    const int __atoms_size = 26;





    char_type __atoms[__atoms_size];
    string __grouping = this->__stage2_int_prep(__iob, __atoms, __thousands_sep);

    string __buf;
    __buf.resize(__buf.capacity());
    char* __a = &__buf[0];
    char* __a_end = __a;
    unsigned __g[__num_get_base::__num_get_buf_sz];
    unsigned* __g_end = __g;
    unsigned __dc = 0;
    for (; __b != __e; ++__b)
    {
        if (__a_end == __a + __buf.size())
        {
            size_t __tmp = __buf.size();
            __buf.resize(2*__buf.size());
            __buf.resize(__buf.capacity());
            __a = &__buf[0];
            __a_end = __a + __tmp;
        }
        if (this->__stage2_int_loop(*__b, __base, __a, __a_end, __dc,
                                    __thousands_sep, __grouping, __g, __g_end,
                                    __atoms))
            break;
    }
    if (__grouping.size() != 0 && __g_end-__g < __num_get_base::__num_get_buf_sz)
        *__g_end++ = __dc;

    __v = std::__num_get_signed_integral<_Signed>(__a, __a_end, __err, __base);

    __check_grouping(__grouping, __g, __g_end, __err);

    if (__b == __e)
        __err |= ios_base::eofbit;
    return __b;
}



template <class _CharT, class _InputIterator>
template <class _Unsigned>
_InputIterator
num_get<_CharT, _InputIterator>::__do_get_unsigned(iter_type __b, iter_type __e,
                                        ios_base& __iob,
                                        ios_base::iostate& __err,
                                        _Unsigned& __v) const
{

    int __base = this->__get_base(__iob);

    char_type __thousands_sep;
    const int __atoms_size = 26;





    char_type __atoms[__atoms_size];
    string __grouping = this->__stage2_int_prep(__iob, __atoms, __thousands_sep);

    string __buf;
    __buf.resize(__buf.capacity());
    char* __a = &__buf[0];
    char* __a_end = __a;
    unsigned __g[__num_get_base::__num_get_buf_sz];
    unsigned* __g_end = __g;
    unsigned __dc = 0;
    for (; __b != __e; ++__b)
    {
        if (__a_end == __a + __buf.size())
        {
            size_t __tmp = __buf.size();
            __buf.resize(2*__buf.size());
            __buf.resize(__buf.capacity());
            __a = &__buf[0];
            __a_end = __a + __tmp;
        }
        if (this->__stage2_int_loop(*__b, __base, __a, __a_end, __dc,
                                    __thousands_sep, __grouping, __g, __g_end,
                                    __atoms))
            break;
    }
    if (__grouping.size() != 0 && __g_end-__g < __num_get_base::__num_get_buf_sz)
        *__g_end++ = __dc;

    __v = std::__num_get_unsigned_integral<_Unsigned>(__a, __a_end, __err, __base);

    __check_grouping(__grouping, __g, __g_end, __err);

    if (__b == __e)
        __err |= ios_base::eofbit;
    return __b;
}



template <class _CharT, class _InputIterator>
template <class _Fp>
_InputIterator
num_get<_CharT, _InputIterator>::__do_get_floating_point(iter_type __b, iter_type __e,
                                        ios_base& __iob,
                                        ios_base::iostate& __err,
                                        _Fp& __v) const
{


    char_type __atoms[32];
    char_type __decimal_point;
    char_type __thousands_sep;
    string __grouping = this->__stage2_float_prep(__iob, __atoms,
                                                  __decimal_point,
                                                  __thousands_sep);
    string __buf;
    __buf.resize(__buf.capacity());
    char* __a = &__buf[0];
    char* __a_end = __a;
    unsigned __g[__num_get_base::__num_get_buf_sz];
    unsigned* __g_end = __g;
    unsigned __dc = 0;
    bool __in_units = true;
    char __exp = 'E';
    for (; __b != __e; ++__b)
    {
        if (__a_end == __a + __buf.size())
        {
            size_t __tmp = __buf.size();
            __buf.resize(2*__buf.size());
            __buf.resize(__buf.capacity());
            __a = &__buf[0];
            __a_end = __a + __tmp;
        }
        if (this->__stage2_float_loop(*__b, __in_units, __exp, __a, __a_end,
                                      __decimal_point, __thousands_sep,
                                      __grouping, __g, __g_end,
                                      __dc, __atoms))
            break;
    }
    if (__grouping.size() != 0 && __in_units && __g_end-__g < __num_get_base::__num_get_buf_sz)
        *__g_end++ = __dc;

    __v = std::__num_get_float<_Fp>(__a, __a_end, __err);

    __check_grouping(__grouping, __g, __g_end, __err);

    if (__b == __e)
        __err |= ios_base::eofbit;
    return __b;
}

template <class _CharT, class _InputIterator>
_InputIterator
num_get<_CharT, _InputIterator>::do_get(iter_type __b, iter_type __e,
                                        ios_base& __iob,
                                        ios_base::iostate& __err,
                                        void*& __v) const
{

    int __base = 16;

    char_type __atoms[26];
    char_type __thousands_sep = char_type();
    string __grouping;
    std::use_facet<ctype<_CharT> >(__iob.getloc()).widen(__num_get_base::__src,
                                                         __num_get_base::__src + 26, __atoms);
    string __buf;
    __buf.resize(__buf.capacity());
    char* __a = &__buf[0];
    char* __a_end = __a;
    unsigned __g[__num_get_base::__num_get_buf_sz];
    unsigned* __g_end = __g;
    unsigned __dc = 0;
    for (; __b != __e; ++__b)
    {
        if (__a_end == __a + __buf.size())
        {
            size_t __tmp = __buf.size();
            __buf.resize(2*__buf.size());
            __buf.resize(__buf.capacity());
            __a = &__buf[0];
            __a_end = __a + __tmp;
        }
        if (this->__stage2_int_loop(*__b, __base, __a, __a_end, __dc,
                                    __thousands_sep, __grouping,
                                    __g, __g_end, __atoms))
            break;
    }

    __buf.resize(__a_end - __a);
    if (__libcpp_sscanf_l(__buf.c_str(), __cloc(), "%p", &__v) != 1)
        __err = ios_base::failbit;

    if (__b == __e)
        __err |= ios_base::eofbit;
    return __b;
}

extern template class __attribute__((__visibility__("default"))) num_get<char>;

extern template class __attribute__((__visibility__("default"))) num_get<wchar_t>;


struct __attribute__((__visibility__("default"))) __num_put_base
{
protected:
    static void __format_int(char* __fmt, const char* __len, bool __signd,
                             ios_base::fmtflags __flags);
    static bool __format_float(char* __fmt, const char* __len,
                               ios_base::fmtflags __flags);
    static char* __identify_padding(char* __nb, char* __ne,
                                    const ios_base& __iob);
};

template <class _CharT>
struct __num_put
    : protected __num_put_base
{
    static void __widen_and_group_int(char* __nb, char* __np, char* __ne,
                                      _CharT* __ob, _CharT*& __op, _CharT*& __oe,
                                      const locale& __loc);
    static void __widen_and_group_float(char* __nb, char* __np, char* __ne,
                                        _CharT* __ob, _CharT*& __op, _CharT*& __oe,
                                        const locale& __loc);
};

template <class _CharT>
void
__num_put<_CharT>::__widen_and_group_int(char* __nb, char* __np, char* __ne,
                                         _CharT* __ob, _CharT*& __op, _CharT*& __oe,
                                         const locale& __loc)
{
    const ctype<_CharT>& __ct = std::use_facet<ctype<_CharT> > (__loc);
    const numpunct<_CharT>& __npt = std::use_facet<numpunct<_CharT> >(__loc);
    string __grouping = __npt.grouping();
    if (__grouping.empty())
    {
        __ct.widen(__nb, __ne, __ob);
        __oe = __ob + (__ne - __nb);
    }
    else
    {
        __oe = __ob;
        char* __nf = __nb;
        if (*__nf == '-' || *__nf == '+')
            *__oe++ = __ct.widen(*__nf++);
        if (__ne - __nf >= 2 && __nf[0] == '0' && (__nf[1] == 'x' ||
                                                   __nf[1] == 'X'))
        {
            *__oe++ = __ct.widen(*__nf++);
            *__oe++ = __ct.widen(*__nf++);
        }
        std::reverse(__nf, __ne);
        _CharT __thousands_sep = __npt.thousands_sep();
        unsigned __dc = 0;
        unsigned __dg = 0;
        for (char* __p = __nf; __p < __ne; ++__p)
        {
            if (static_cast<unsigned>(__grouping[__dg]) > 0 &&
                __dc == static_cast<unsigned>(__grouping[__dg]))
            {
                *__oe++ = __thousands_sep;
                __dc = 0;
                if (__dg < __grouping.size()-1)
                    ++__dg;
            }
            *__oe++ = __ct.widen(*__p);
            ++__dc;
        }
        std::reverse(__ob + (__nf - __nb), __oe);
    }
    if (__np == __ne)
        __op = __oe;
    else
        __op = __ob + (__np - __nb);
}

template <class _CharT>
void
__num_put<_CharT>::__widen_and_group_float(char* __nb, char* __np, char* __ne,
                                           _CharT* __ob, _CharT*& __op, _CharT*& __oe,
                                           const locale& __loc)
{
    const ctype<_CharT>& __ct = std::use_facet<ctype<_CharT> > (__loc);
    const numpunct<_CharT>& __npt = std::use_facet<numpunct<_CharT> >(__loc);
    string __grouping = __npt.grouping();
    __oe = __ob;
    char* __nf = __nb;
    if (*__nf == '-' || *__nf == '+')
        *__oe++ = __ct.widen(*__nf++);
    char* __ns;
    if (__ne - __nf >= 2 && __nf[0] == '0' && (__nf[1] == 'x' ||
                                               __nf[1] == 'X'))
    {
        *__oe++ = __ct.widen(*__nf++);
        *__oe++ = __ct.widen(*__nf++);
        for (__ns = __nf; __ns < __ne; ++__ns)
            if (!((((__cloc())))->__ctype_b[(int) (((*__ns)))] & (unsigned short int) _ISxdigit))
                break;
    }
    else
    {
        for (__ns = __nf; __ns < __ne; ++__ns)
            if (!((((__cloc())))->__ctype_b[(int) (((*__ns)))] & (unsigned short int) _ISdigit))
                break;
    }
    if (__grouping.empty())
    {
        __ct.widen(__nf, __ns, __oe);
        __oe += __ns - __nf;
    }
    else
    {
        std::reverse(__nf, __ns);
        _CharT __thousands_sep = __npt.thousands_sep();
        unsigned __dc = 0;
        unsigned __dg = 0;
        for (char* __p = __nf; __p < __ns; ++__p)
        {
            if (__grouping[__dg] > 0 && __dc == static_cast<unsigned>(__grouping[__dg]))
            {
                *__oe++ = __thousands_sep;
                __dc = 0;
                if (__dg < __grouping.size()-1)
                    ++__dg;
            }
            *__oe++ = __ct.widen(*__p);
            ++__dc;
        }
        std::reverse(__ob + (__nf - __nb), __oe);
    }
    for (__nf = __ns; __nf < __ne; ++__nf)
    {
        if (*__nf == '.')
        {
            *__oe++ = __npt.decimal_point();
            ++__nf;
            break;
        }
        else
            *__oe++ = __ct.widen(*__nf);
    }
    __ct.widen(__nf, __ne, __oe);
    __oe += __ne - __nf;
    if (__np == __ne)
        __op = __oe;
    else
        __op = __ob + (__np - __nb);
}

extern template struct __attribute__((__visibility__("default"))) __num_put<char>;

extern template struct __attribute__((__visibility__("default"))) __num_put<wchar_t>;


template <class _CharT, class _OutputIterator = ostreambuf_iterator<_CharT> >
class num_put
    : public locale::facet,
      private __num_put<_CharT>
{
public:
    typedef _CharT char_type;
    typedef _OutputIterator iter_type;

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    explicit num_put(size_t __refs = 0)
        : locale::facet(__refs) {}

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,
                  bool __v) const
    {
        return do_put(__s, __iob, __fl, __v);
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,
                  long __v) const
    {
        return do_put(__s, __iob, __fl, __v);
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,
                  long long __v) const
    {
        return do_put(__s, __iob, __fl, __v);
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,
                  unsigned long __v) const
    {
        return do_put(__s, __iob, __fl, __v);
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,
                  unsigned long long __v) const
    {
        return do_put(__s, __iob, __fl, __v);
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,
                  double __v) const
    {
        return do_put(__s, __iob, __fl, __v);
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,
                  long double __v) const
    {
        return do_put(__s, __iob, __fl, __v);
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,
                  const void* __v) const
    {
        return do_put(__s, __iob, __fl, __v);
    }

    static locale::id id;

protected:
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) ~num_put() override {}

    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,
                             bool __v) const;
    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,
                             long __v) const;
    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,
                             long long __v) const;
    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,
                             unsigned long) const;
    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,
                             unsigned long long) const;
    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,
                             double __v) const;
    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,
                             long double __v) const;
    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,
                             const void* __v) const;

    template <class _Integral>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) inline
    _OutputIterator __do_put_integral(iter_type __s, ios_base& __iob,
                                      char_type __fl, _Integral __v,
                                      char const* __len) const;

    template <class _Float>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) inline
    _OutputIterator __do_put_floating_point(iter_type __s, ios_base& __iob,
                                            char_type __fl, _Float __v,
                                            char const* __len) const;
};

template <class _CharT, class _OutputIterator>
locale::id
num_put<_CharT, _OutputIterator>::id;

template <class _CharT, class _OutputIterator>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
_OutputIterator
__pad_and_output(_OutputIterator __s,
                 const _CharT* __ob, const _CharT* __op, const _CharT* __oe,
                 ios_base& __iob, _CharT __fl)
{
    streamsize __sz = __oe - __ob;
    streamsize __ns = __iob.width();
    if (__ns > __sz)
        __ns -= __sz;
    else
        __ns = 0;
    for (;__ob < __op; ++__ob, ++__s)
        *__s = *__ob;
    for (; __ns; --__ns, ++__s)
        *__s = __fl;
    for (; __ob < __oe; ++__ob, ++__s)
        *__s = *__ob;
    __iob.width(0);
    return __s;
}

template <class _CharT, class _Traits>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
ostreambuf_iterator<_CharT, _Traits>
__pad_and_output(ostreambuf_iterator<_CharT, _Traits> __s,
                 const _CharT* __ob, const _CharT* __op, const _CharT* __oe,
                 ios_base& __iob, _CharT __fl)
{
    if (__s.__sbuf_ == nullptr)
        return __s;
    streamsize __sz = __oe - __ob;
    streamsize __ns = __iob.width();
    if (__ns > __sz)
        __ns -= __sz;
    else
        __ns = 0;
    streamsize __np = __op - __ob;
    if (__np > 0)
    {
        if (__s.__sbuf_->sputn(__ob, __np) != __np)
        {
            __s.__sbuf_ = nullptr;
            return __s;
        }
    }
    if (__ns > 0)
    {
        basic_string<_CharT, _Traits> __sp(__ns, __fl);
        if (__s.__sbuf_->sputn(__sp.data(), __ns) != __ns)
        {
            __s.__sbuf_ = nullptr;
            return __s;
        }
    }
    __np = __oe - __op;
    if (__np > 0)
    {
        if (__s.__sbuf_->sputn(__op, __np) != __np)
        {
            __s.__sbuf_ = nullptr;
            return __s;
        }
    }
    __iob.width(0);
    return __s;
}

template <class _CharT, class _OutputIterator>
_OutputIterator
num_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,
                                         char_type __fl, bool __v) const
{
    if ((__iob.flags() & ios_base::boolalpha) == 0)
        return do_put(__s, __iob, __fl, (unsigned long)__v);
    const numpunct<char_type>& __np = std::use_facet<numpunct<char_type> >(__iob.getloc());
    typedef typename numpunct<char_type>::string_type string_type;
    string_type __nm = __v ? __np.truename() : __np.falsename();
    for (typename string_type::iterator __i = __nm.begin(); __i != __nm.end(); ++__i, ++__s)
        *__s = *__i;
    return __s;
}

template <class _CharT, class _OutputIterator>
template <class _Integral>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) inline
_OutputIterator
num_put<_CharT, _OutputIterator>::__do_put_integral(iter_type __s, ios_base& __iob,
                                                    char_type __fl, _Integral __v,
                                                    char const* __len) const
{

    char __fmt[8] = {'%', 0};
    this->__format_int(__fmt+1, __len, is_signed<_Integral>::value, __iob.flags());


    using _Unsigned = typename make_unsigned<_Integral>::type;
    constexpr const unsigned __nbuf
        = (numeric_limits<_Unsigned>::digits / 3)
        + ((numeric_limits<_Unsigned>::digits % 3) != 0)
        + 2;
    char __nar[__nbuf];
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wformat-nonliteral"

    int __nc = __libcpp_snprintf_l(__nar, sizeof(__nar), __cloc(), __fmt, __v);
#pragma clang diagnostic pop
    char* __ne = __nar + __nc;
    char* __np = this->__identify_padding(__nar, __ne, __iob);

    char_type __o[2*(__nbuf-1) - 1];
    char_type* __op;
    char_type* __oe;
    this->__widen_and_group_int(__nar, __np, __ne, __o, __op, __oe, __iob.getloc());


    return std::__pad_and_output(__s, __o, __op, __oe, __iob, __fl);
}

template <class _CharT, class _OutputIterator>
_OutputIterator
num_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,
                                         char_type __fl, long __v) const
{
    return this->__do_put_integral(__s, __iob, __fl, __v, "l");
}

template <class _CharT, class _OutputIterator>
_OutputIterator
num_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,
                                         char_type __fl, long long __v) const
{
    return this->__do_put_integral(__s, __iob, __fl, __v, "ll");
}

template <class _CharT, class _OutputIterator>
_OutputIterator
num_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,
                                         char_type __fl, unsigned long __v) const
{
    return this->__do_put_integral(__s, __iob, __fl, __v, "l");
}

template <class _CharT, class _OutputIterator>
_OutputIterator
num_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,
                                         char_type __fl, unsigned long long __v) const
{
    return this->__do_put_integral(__s, __iob, __fl, __v, "ll");
}

template <class _CharT, class _OutputIterator>
template <class _Float>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) inline
_OutputIterator
num_put<_CharT, _OutputIterator>::__do_put_floating_point(iter_type __s, ios_base& __iob,
                                                          char_type __fl, _Float __v,
                                                          char const* __len) const
{

    char __fmt[8] = {'%', 0};
    bool __specify_precision = this->__format_float(__fmt+1, __len, __iob.flags());
    const unsigned __nbuf = 30;
    char __nar[__nbuf];
    char* __nb = __nar;
    int __nc;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wformat-nonliteral"

    if (__specify_precision)
        __nc = __libcpp_snprintf_l(__nb, __nbuf, __cloc(), __fmt,
                                   (int)__iob.precision(), __v);
    else
        __nc = __libcpp_snprintf_l(__nb, __nbuf, __cloc(), __fmt, __v);
    unique_ptr<char, void(*)(void*)> __nbh(nullptr, free);
    if (__nc > static_cast<int>(__nbuf-1))
    {
        if (__specify_precision)
            __nc = __libcpp_asprintf_l(&__nb, __cloc(), __fmt, (int)__iob.precision(), __v);
        else
            __nc = __libcpp_asprintf_l(&__nb, __cloc(), __fmt, __v);
        if (__nc == -1)
            __throw_bad_alloc();
        __nbh.reset(__nb);
    }
#pragma clang diagnostic pop
    char* __ne = __nb + __nc;
    char* __np = this->__identify_padding(__nb, __ne, __iob);

    char_type __o[2*(__nbuf-1) - 1];
    char_type* __ob = __o;
    unique_ptr<char_type, void(*)(void*)> __obh(0, free);
    if (__nb != __nar)
    {
        __ob = (char_type*)malloc(2*static_cast<size_t>(__nc)*sizeof(char_type));
        if (__ob == 0)
            __throw_bad_alloc();
        __obh.reset(__ob);
    }
    char_type* __op;
    char_type* __oe;
    this->__widen_and_group_float(__nb, __np, __ne, __ob, __op, __oe, __iob.getloc());


    __s = std::__pad_and_output(__s, __ob, __op, __oe, __iob, __fl);
    return __s;
}

template <class _CharT, class _OutputIterator>
_OutputIterator
num_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,
                                         char_type __fl, double __v) const
{
    return this->__do_put_floating_point(__s, __iob, __fl, __v, "");
}

template <class _CharT, class _OutputIterator>
_OutputIterator
num_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,
                                         char_type __fl, long double __v) const
{
    return this->__do_put_floating_point(__s, __iob, __fl, __v, "L");
}

template <class _CharT, class _OutputIterator>
_OutputIterator
num_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,
                                         char_type __fl, const void* __v) const
{

    const unsigned __nbuf = 20;
    char __nar[__nbuf];
    int __nc = __libcpp_snprintf_l(__nar, sizeof(__nar), __cloc(), "%p", __v);
    char* __ne = __nar + __nc;
    char* __np = this->__identify_padding(__nar, __ne, __iob);

    char_type __o[2*(__nbuf-1) - 1];
    char_type* __op;
    char_type* __oe;
    const ctype<char_type>& __ct = std::use_facet<ctype<char_type> >(__iob.getloc());
    __ct.widen(__nar, __ne, __o);
    __oe = __o + (__ne - __nar);
    if (__np == __ne)
        __op = __oe;
    else
        __op = __o + (__np - __nar);


    return std::__pad_and_output(__s, __o, __op, __oe, __iob, __fl);
}

extern template class __attribute__((__visibility__("default"))) num_put<char>;

extern template class __attribute__((__visibility__("default"))) num_put<wchar_t>;


template <class _CharT, class _InputIterator>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
int
__get_up_to_n_digits(_InputIterator& __b, _InputIterator __e,
                     ios_base::iostate& __err, const ctype<_CharT>& __ct, int __n)
{

    if (__b == __e)
    {
        __err |= ios_base::eofbit | ios_base::failbit;
        return 0;
    }

    _CharT __c = *__b;
    if (!__ct.is(ctype_base::digit, __c))
    {
        __err |= ios_base::failbit;
        return 0;
    }
    int __r = __ct.narrow(__c, 0) - '0';
    for (++__b, (void) --__n; __b != __e && __n > 0; ++__b, (void) --__n)
    {

        __c = *__b;
        if (!__ct.is(ctype_base::digit, __c))
            return __r;
        __r = __r * 10 + __ct.narrow(__c, 0) - '0';
    }
    if (__b == __e)
        __err |= ios_base::eofbit;
    return __r;
}

class __attribute__((__visibility__("default"))) time_base
{
public:
    enum dateorder {no_order, dmy, mdy, ymd, ydm};
};

template <class _CharT>
class __time_get_c_storage
{
protected:
    typedef basic_string<_CharT> string_type;

    virtual const string_type* __weeks() const;
    virtual const string_type* __months() const;
    virtual const string_type* __am_pm() const;
    virtual const string_type& __c() const;
    virtual const string_type& __r() const;
    virtual const string_type& __x() const;
    virtual const string_type& __X() const;

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    ~__time_get_c_storage() {}
};

template <> __attribute__((__visibility__("default"))) const string* __time_get_c_storage<char>::__weeks() const;
template <> __attribute__((__visibility__("default"))) const string* __time_get_c_storage<char>::__months() const;
template <> __attribute__((__visibility__("default"))) const string* __time_get_c_storage<char>::__am_pm() const;
template <> __attribute__((__visibility__("default"))) const string& __time_get_c_storage<char>::__c() const;
template <> __attribute__((__visibility__("default"))) const string& __time_get_c_storage<char>::__r() const;
template <> __attribute__((__visibility__("default"))) const string& __time_get_c_storage<char>::__x() const;
template <> __attribute__((__visibility__("default"))) const string& __time_get_c_storage<char>::__X() const;


template <> __attribute__((__visibility__("default"))) const wstring* __time_get_c_storage<wchar_t>::__weeks() const;
template <> __attribute__((__visibility__("default"))) const wstring* __time_get_c_storage<wchar_t>::__months() const;
template <> __attribute__((__visibility__("default"))) const wstring* __time_get_c_storage<wchar_t>::__am_pm() const;
template <> __attribute__((__visibility__("default"))) const wstring& __time_get_c_storage<wchar_t>::__c() const;
template <> __attribute__((__visibility__("default"))) const wstring& __time_get_c_storage<wchar_t>::__r() const;
template <> __attribute__((__visibility__("default"))) const wstring& __time_get_c_storage<wchar_t>::__x() const;
template <> __attribute__((__visibility__("default"))) const wstring& __time_get_c_storage<wchar_t>::__X() const;


template <class _CharT, class _InputIterator = istreambuf_iterator<_CharT> >
class time_get
    : public locale::facet,
      public time_base,
      private __time_get_c_storage<_CharT>
{
public:
    typedef _CharT char_type;
    typedef _InputIterator iter_type;
    typedef time_base::dateorder dateorder;
    typedef basic_string<char_type> string_type;

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    explicit time_get(size_t __refs = 0)
        : locale::facet(__refs) {}

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    dateorder date_order() const
    {
        return this->do_date_order();
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    iter_type get_time(iter_type __b, iter_type __e, ios_base& __iob,
                       ios_base::iostate& __err, tm* __tm) const
    {
        return do_get_time(__b, __e, __iob, __err, __tm);
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    iter_type get_date(iter_type __b, iter_type __e, ios_base& __iob,
                       ios_base::iostate& __err, tm* __tm) const
    {
        return do_get_date(__b, __e, __iob, __err, __tm);
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    iter_type get_weekday(iter_type __b, iter_type __e, ios_base& __iob,
                          ios_base::iostate& __err, tm* __tm) const
    {
        return do_get_weekday(__b, __e, __iob, __err, __tm);
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    iter_type get_monthname(iter_type __b, iter_type __e, ios_base& __iob,
                            ios_base::iostate& __err, tm* __tm) const
    {
        return do_get_monthname(__b, __e, __iob, __err, __tm);
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    iter_type get_year(iter_type __b, iter_type __e, ios_base& __iob,
                       ios_base::iostate& __err, tm* __tm) const
    {
        return do_get_year(__b, __e, __iob, __err, __tm);
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,
                  ios_base::iostate& __err, tm *__tm,
                  char __fmt, char __mod = 0) const
    {
        return do_get(__b, __e, __iob, __err, __tm, __fmt, __mod);
    }

    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,
                  ios_base::iostate& __err, tm* __tm,
                  const char_type* __fmtb, const char_type* __fmte) const;

    static locale::id id;

protected:
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) ~time_get() override {}

    virtual dateorder do_date_order() const;
    virtual iter_type do_get_time(iter_type __b, iter_type __e, ios_base& __iob,
                                  ios_base::iostate& __err, tm* __tm) const;
    virtual iter_type do_get_date(iter_type __b, iter_type __e, ios_base& __iob,
                                  ios_base::iostate& __err, tm* __tm) const;
    virtual iter_type do_get_weekday(iter_type __b, iter_type __e, ios_base& __iob,
                                     ios_base::iostate& __err, tm* __tm) const;
    virtual iter_type do_get_monthname(iter_type __b, iter_type __e, ios_base& __iob,
                                       ios_base::iostate& __err, tm* __tm) const;
    virtual iter_type do_get_year(iter_type __b, iter_type __e, ios_base& __iob,
                                  ios_base::iostate& __err, tm* __tm) const;
    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,
                             ios_base::iostate& __err, tm* __tm,
                             char __fmt, char __mod) const;
private:
    void __get_white_space(iter_type& __b, iter_type __e,
                           ios_base::iostate& __err, const ctype<char_type>& __ct) const;
    void __get_percent(iter_type& __b, iter_type __e, ios_base::iostate& __err,
                       const ctype<char_type>& __ct) const;

    void __get_weekdayname(int& __m,
                           iter_type& __b, iter_type __e,
                           ios_base::iostate& __err,
                           const ctype<char_type>& __ct) const;
    void __get_monthname(int& __m,
                         iter_type& __b, iter_type __e,
                         ios_base::iostate& __err,
                         const ctype<char_type>& __ct) const;
    void __get_day(int& __d,
                   iter_type& __b, iter_type __e,
                   ios_base::iostate& __err,
                   const ctype<char_type>& __ct) const;
    void __get_month(int& __m,
                     iter_type& __b, iter_type __e,
                     ios_base::iostate& __err,
                     const ctype<char_type>& __ct) const;
    void __get_year(int& __y,
                   iter_type& __b, iter_type __e,
                   ios_base::iostate& __err,
                   const ctype<char_type>& __ct) const;
    void __get_year4(int& __y,
                    iter_type& __b, iter_type __e,
                    ios_base::iostate& __err,
                    const ctype<char_type>& __ct) const;
    void __get_hour(int& __d,
                    iter_type& __b, iter_type __e,
                    ios_base::iostate& __err,
                    const ctype<char_type>& __ct) const;
    void __get_12_hour(int& __h,
                       iter_type& __b, iter_type __e,
                       ios_base::iostate& __err,
                       const ctype<char_type>& __ct) const;
    void __get_am_pm(int& __h,
                     iter_type& __b, iter_type __e,
                     ios_base::iostate& __err,
                     const ctype<char_type>& __ct) const;
    void __get_minute(int& __m,
                      iter_type& __b, iter_type __e,
                      ios_base::iostate& __err,
                      const ctype<char_type>& __ct) const;
    void __get_second(int& __s,
                      iter_type& __b, iter_type __e,
                      ios_base::iostate& __err,
                      const ctype<char_type>& __ct) const;
    void __get_weekday(int& __w,
                       iter_type& __b, iter_type __e,
                       ios_base::iostate& __err,
                       const ctype<char_type>& __ct) const;
    void __get_day_year_num(int& __w,
                            iter_type& __b, iter_type __e,
                            ios_base::iostate& __err,
                            const ctype<char_type>& __ct) const;
};

template <class _CharT, class _InputIterator>
locale::id
time_get<_CharT, _InputIterator>::id;



template <class _CharT, class _InputIterator>
void
time_get<_CharT, _InputIterator>::__get_weekdayname(int& __w,
                                                    iter_type& __b, iter_type __e,
                                                    ios_base::iostate& __err,
                                                    const ctype<char_type>& __ct) const
{

    const string_type* __wk = this->__weeks();
    ptrdiff_t __i = std::__scan_keyword(__b, __e, __wk, __wk+14, __ct, __err, false) - __wk;
    if (__i < 14)
        __w = __i % 7;
}

template <class _CharT, class _InputIterator>
void
time_get<_CharT, _InputIterator>::__get_monthname(int& __m,
                                                  iter_type& __b, iter_type __e,
                                                  ios_base::iostate& __err,
                                                  const ctype<char_type>& __ct) const
{

    const string_type* __month = this->__months();
    ptrdiff_t __i = std::__scan_keyword(__b, __e, __month, __month+24, __ct, __err, false) - __month;
    if (__i < 24)
        __m = __i % 12;
}

template <class _CharT, class _InputIterator>
void
time_get<_CharT, _InputIterator>::__get_day(int& __d,
                                            iter_type& __b, iter_type __e,
                                            ios_base::iostate& __err,
                                            const ctype<char_type>& __ct) const
{
    int __t = std::__get_up_to_n_digits(__b, __e, __err, __ct, 2);
    if (!(__err & ios_base::failbit) && 1 <= __t && __t <= 31)
        __d = __t;
    else
        __err |= ios_base::failbit;
}

template <class _CharT, class _InputIterator>
void
time_get<_CharT, _InputIterator>::__get_month(int& __m,
                                              iter_type& __b, iter_type __e,
                                              ios_base::iostate& __err,
                                              const ctype<char_type>& __ct) const
{
    int __t = std::__get_up_to_n_digits(__b, __e, __err, __ct, 2) - 1;
    if (!(__err & ios_base::failbit) && 0 <= __t && __t <= 11)
        __m = __t;
    else
        __err |= ios_base::failbit;
}

template <class _CharT, class _InputIterator>
void
time_get<_CharT, _InputIterator>::__get_year(int& __y,
                                             iter_type& __b, iter_type __e,
                                             ios_base::iostate& __err,
                                             const ctype<char_type>& __ct) const
{
    int __t = std::__get_up_to_n_digits(__b, __e, __err, __ct, 4);
    if (!(__err & ios_base::failbit))
    {
        if (__t < 69)
            __t += 2000;
        else if (69 <= __t && __t <= 99)
            __t += 1900;
        __y = __t - 1900;
    }
}

template <class _CharT, class _InputIterator>
void
time_get<_CharT, _InputIterator>::__get_year4(int& __y,
                                              iter_type& __b, iter_type __e,
                                              ios_base::iostate& __err,
                                              const ctype<char_type>& __ct) const
{
    int __t = std::__get_up_to_n_digits(__b, __e, __err, __ct, 4);
    if (!(__err & ios_base::failbit))
        __y = __t - 1900;
}

template <class _CharT, class _InputIterator>
void
time_get<_CharT, _InputIterator>::__get_hour(int& __h,
                                             iter_type& __b, iter_type __e,
                                             ios_base::iostate& __err,
                                             const ctype<char_type>& __ct) const
{
    int __t = std::__get_up_to_n_digits(__b, __e, __err, __ct, 2);
    if (!(__err & ios_base::failbit) && __t <= 23)
        __h = __t;
    else
        __err |= ios_base::failbit;
}

template <class _CharT, class _InputIterator>
void
time_get<_CharT, _InputIterator>::__get_12_hour(int& __h,
                                                iter_type& __b, iter_type __e,
                                                ios_base::iostate& __err,
                                                const ctype<char_type>& __ct) const
{
    int __t = std::__get_up_to_n_digits(__b, __e, __err, __ct, 2);
    if (!(__err & ios_base::failbit) && 1 <= __t && __t <= 12)
        __h = __t;
    else
        __err |= ios_base::failbit;
}

template <class _CharT, class _InputIterator>
void
time_get<_CharT, _InputIterator>::__get_minute(int& __m,
                                               iter_type& __b, iter_type __e,
                                               ios_base::iostate& __err,
                                               const ctype<char_type>& __ct) const
{
    int __t = std::__get_up_to_n_digits(__b, __e, __err, __ct, 2);
    if (!(__err & ios_base::failbit) && __t <= 59)
        __m = __t;
    else
        __err |= ios_base::failbit;
}

template <class _CharT, class _InputIterator>
void
time_get<_CharT, _InputIterator>::__get_second(int& __s,
                                               iter_type& __b, iter_type __e,
                                               ios_base::iostate& __err,
                                               const ctype<char_type>& __ct) const
{
    int __t = std::__get_up_to_n_digits(__b, __e, __err, __ct, 2);
    if (!(__err & ios_base::failbit) && __t <= 60)
        __s = __t;
    else
        __err |= ios_base::failbit;
}

template <class _CharT, class _InputIterator>
void
time_get<_CharT, _InputIterator>::__get_weekday(int& __w,
                                                iter_type& __b, iter_type __e,
                                                ios_base::iostate& __err,
                                                const ctype<char_type>& __ct) const
{
    int __t = std::__get_up_to_n_digits(__b, __e, __err, __ct, 1);
    if (!(__err & ios_base::failbit) && __t <= 6)
        __w = __t;
    else
        __err |= ios_base::failbit;
}

template <class _CharT, class _InputIterator>
void
time_get<_CharT, _InputIterator>::__get_day_year_num(int& __d,
                                                     iter_type& __b, iter_type __e,
                                                     ios_base::iostate& __err,
                                                     const ctype<char_type>& __ct) const
{
    int __t = std::__get_up_to_n_digits(__b, __e, __err, __ct, 3);
    if (!(__err & ios_base::failbit) && __t <= 365)
        __d = __t;
    else
        __err |= ios_base::failbit;
}

template <class _CharT, class _InputIterator>
void
time_get<_CharT, _InputIterator>::__get_white_space(iter_type& __b, iter_type __e,
                                                    ios_base::iostate& __err,
                                                    const ctype<char_type>& __ct) const
{
    for (; __b != __e && __ct.is(ctype_base::space, *__b); ++__b)
        ;
    if (__b == __e)
        __err |= ios_base::eofbit;
}

template <class _CharT, class _InputIterator>
void
time_get<_CharT, _InputIterator>::__get_am_pm(int& __h,
                                              iter_type& __b, iter_type __e,
                                              ios_base::iostate& __err,
                                              const ctype<char_type>& __ct) const
{
    const string_type* __ap = this->__am_pm();
    if (__ap[0].size() + __ap[1].size() == 0)
    {
        __err |= ios_base::failbit;
        return;
    }
    ptrdiff_t __i = std::__scan_keyword(__b, __e, __ap, __ap+2, __ct, __err, false) - __ap;
    if (__i == 0 && __h == 12)
        __h = 0;
    else if (__i == 1 && __h < 12)
        __h += 12;
}

template <class _CharT, class _InputIterator>
void
time_get<_CharT, _InputIterator>::__get_percent(iter_type& __b, iter_type __e,
                                                ios_base::iostate& __err,
                                                const ctype<char_type>& __ct) const
{
    if (__b == __e)
    {
        __err |= ios_base::eofbit | ios_base::failbit;
        return;
    }
    if (__ct.narrow(*__b, 0) != '%')
        __err |= ios_base::failbit;
    else if(++__b == __e)
        __err |= ios_base::eofbit;
}



template <class _CharT, class _InputIterator>
_InputIterator
time_get<_CharT, _InputIterator>::get(iter_type __b, iter_type __e,
                                      ios_base& __iob,
                                      ios_base::iostate& __err, tm* __tm,
                                      const char_type* __fmtb, const char_type* __fmte) const
{
    const ctype<char_type>& __ct = std::use_facet<ctype<char_type> >(__iob.getloc());
    __err = ios_base::goodbit;
    while (__fmtb != __fmte && __err == ios_base::goodbit)
    {
        if (__b == __e)
        {
            __err = ios_base::failbit;
            break;
        }
        if (__ct.narrow(*__fmtb, 0) == '%')
        {
            if (++__fmtb == __fmte)
            {
                __err = ios_base::failbit;
                break;
            }
            char __cmd = __ct.narrow(*__fmtb, 0);
            char __opt = '\0';
            if (__cmd == 'E' || __cmd == '0')
            {
                if (++__fmtb == __fmte)
                {
                    __err = ios_base::failbit;
                    break;
                }
                __opt = __cmd;
                __cmd = __ct.narrow(*__fmtb, 0);
            }
            __b = do_get(__b, __e, __iob, __err, __tm, __cmd, __opt);
            ++__fmtb;
        }
        else if (__ct.is(ctype_base::space, *__fmtb))
        {
            for (++__fmtb; __fmtb != __fmte && __ct.is(ctype_base::space, *__fmtb); ++__fmtb)
                ;
            for ( ; __b != __e && __ct.is(ctype_base::space, *__b); ++__b)
                ;
        }
        else if (__ct.toupper(*__b) == __ct.toupper(*__fmtb))
        {
            ++__b;
            ++__fmtb;
        }
        else
            __err = ios_base::failbit;
    }
    if (__b == __e)
        __err |= ios_base::eofbit;
    return __b;
}

template <class _CharT, class _InputIterator>
typename time_get<_CharT, _InputIterator>::dateorder
time_get<_CharT, _InputIterator>::do_date_order() const
{
    return mdy;
}

template <class _CharT, class _InputIterator>
_InputIterator
time_get<_CharT, _InputIterator>::do_get_time(iter_type __b, iter_type __e,
                                              ios_base& __iob,
                                              ios_base::iostate& __err,
                                              tm* __tm) const
{
    const char_type __fmt[] = {'%', 'H', ':', '%', 'M', ':', '%', 'S'};
    return get(__b, __e, __iob, __err, __tm, __fmt, __fmt + sizeof(__fmt)/sizeof(__fmt[0]));
}

template <class _CharT, class _InputIterator>
_InputIterator
time_get<_CharT, _InputIterator>::do_get_date(iter_type __b, iter_type __e,
                                              ios_base& __iob,
                                              ios_base::iostate& __err,
                                              tm* __tm) const
{
    const string_type& __fmt = this->__x();
    return get(__b, __e, __iob, __err, __tm, __fmt.data(), __fmt.data() + __fmt.size());
}

template <class _CharT, class _InputIterator>
_InputIterator
time_get<_CharT, _InputIterator>::do_get_weekday(iter_type __b, iter_type __e,
                                                 ios_base& __iob,
                                                 ios_base::iostate& __err,
                                                 tm* __tm) const
{
    const ctype<char_type>& __ct = std::use_facet<ctype<char_type> >(__iob.getloc());
    __get_weekdayname(__tm->tm_wday, __b, __e, __err, __ct);
    return __b;
}

template <class _CharT, class _InputIterator>
_InputIterator
time_get<_CharT, _InputIterator>::do_get_monthname(iter_type __b, iter_type __e,
                                                   ios_base& __iob,
                                                   ios_base::iostate& __err,
                                                   tm* __tm) const
{
    const ctype<char_type>& __ct = std::use_facet<ctype<char_type> >(__iob.getloc());
    __get_monthname(__tm->tm_mon, __b, __e, __err, __ct);
    return __b;
}

template <class _CharT, class _InputIterator>
_InputIterator
time_get<_CharT, _InputIterator>::do_get_year(iter_type __b, iter_type __e,
                                              ios_base& __iob,
                                              ios_base::iostate& __err,
                                              tm* __tm) const
{
    const ctype<char_type>& __ct = std::use_facet<ctype<char_type> >(__iob.getloc());
    __get_year(__tm->tm_year, __b, __e, __err, __ct);
    return __b;
}

template <class _CharT, class _InputIterator>
_InputIterator
time_get<_CharT, _InputIterator>::do_get(iter_type __b, iter_type __e,
                                         ios_base& __iob,
                                         ios_base::iostate& __err, tm* __tm,
                                         char __fmt, char) const
{
    __err = ios_base::goodbit;
    const ctype<char_type>& __ct = std::use_facet<ctype<char_type> >(__iob.getloc());
    switch (__fmt)
    {
    case 'a':
    case 'A':
        __get_weekdayname(__tm->tm_wday, __b, __e, __err, __ct);
        break;
    case 'b':
    case 'B':
    case 'h':
        __get_monthname(__tm->tm_mon, __b, __e, __err, __ct);
        break;
    case 'c':
        {
        const string_type& __fm = this->__c();
        __b = get(__b, __e, __iob, __err, __tm, __fm.data(), __fm.data() + __fm.size());
        }
        break;
    case 'd':
    case 'e':
        __get_day(__tm->tm_mday, __b, __e, __err, __ct);
        break;
    case 'D':
        {
        const char_type __fm[] = {'%', 'm', '/', '%', 'd', '/', '%', 'y'};
        __b = get(__b, __e, __iob, __err, __tm, __fm, __fm + sizeof(__fm)/sizeof(__fm[0]));
        }
        break;
    case 'F':
        {
        const char_type __fm[] = {'%', 'Y', '-', '%', 'm', '-', '%', 'd'};
        __b = get(__b, __e, __iob, __err, __tm, __fm, __fm + sizeof(__fm)/sizeof(__fm[0]));
        }
        break;
    case 'H':
        __get_hour(__tm->tm_hour, __b, __e, __err, __ct);
        break;
    case 'I':
        __get_12_hour(__tm->tm_hour, __b, __e, __err, __ct);
        break;
    case 'j':
        __get_day_year_num(__tm->tm_yday, __b, __e, __err, __ct);
        break;
    case 'm':
        __get_month(__tm->tm_mon, __b, __e, __err, __ct);
        break;
    case 'M':
        __get_minute(__tm->tm_min, __b, __e, __err, __ct);
        break;
    case 'n':
    case 't':
        __get_white_space(__b, __e, __err, __ct);
        break;
    case 'p':
        __get_am_pm(__tm->tm_hour, __b, __e, __err, __ct);
        break;
    case 'r':
        {
        const char_type __fm[] = {'%', 'I', ':', '%', 'M', ':', '%', 'S', ' ', '%', 'p'};
        __b = get(__b, __e, __iob, __err, __tm, __fm, __fm + sizeof(__fm)/sizeof(__fm[0]));
        }
        break;
    case 'R':
        {
        const char_type __fm[] = {'%', 'H', ':', '%', 'M'};
        __b = get(__b, __e, __iob, __err, __tm, __fm, __fm + sizeof(__fm)/sizeof(__fm[0]));
        }
        break;
    case 'S':
        __get_second(__tm->tm_sec, __b, __e, __err, __ct);
        break;
    case 'T':
        {
        const char_type __fm[] = {'%', 'H', ':', '%', 'M', ':', '%', 'S'};
        __b = get(__b, __e, __iob, __err, __tm, __fm, __fm + sizeof(__fm)/sizeof(__fm[0]));
        }
        break;
    case 'w':
        __get_weekday(__tm->tm_wday, __b, __e, __err, __ct);
        break;
    case 'x':
        return do_get_date(__b, __e, __iob, __err, __tm);
    case 'X':
        {
        const string_type& __fm = this->__X();
        __b = get(__b, __e, __iob, __err, __tm, __fm.data(), __fm.data() + __fm.size());
        }
        break;
    case 'y':
        __get_year(__tm->tm_year, __b, __e, __err, __ct);
        break;
    case 'Y':
        __get_year4(__tm->tm_year, __b, __e, __err, __ct);
        break;
    case '%':
        __get_percent(__b, __e, __err, __ct);
        break;
    default:
        __err |= ios_base::failbit;
    }
    return __b;
}

extern template class __attribute__((__visibility__("default"))) time_get<char>;

extern template class __attribute__((__visibility__("default"))) time_get<wchar_t>;


class __attribute__((__visibility__("default"))) __time_get
{
protected:
    locale_t __loc_;

    __time_get(const char* __nm);
    __time_get(const string& __nm);
    ~__time_get();
};

template <class _CharT>
class __time_get_storage
    : public __time_get
{
protected:
    typedef basic_string<_CharT> string_type;

    string_type __weeks_[14];
    string_type __months_[24];
    string_type __am_pm_[2];
    string_type __c_;
    string_type __r_;
    string_type __x_;
    string_type __X_;

    explicit __time_get_storage(const char* __nm);
    explicit __time_get_storage(const string& __nm);

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) ~__time_get_storage() {}

    time_base::dateorder __do_date_order() const;

private:
    void init(const ctype<_CharT>&);
    string_type __analyze(char __fmt, const ctype<_CharT>&);
};
# 2385 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/locale" 3
template <> __attribute__((__visibility__("default"))) time_base::dateorder __time_get_storage<char>::__do_date_order() const; template <> __attribute__((__visibility__("default"))) __time_get_storage<char>::__time_get_storage(const char*); template <> __attribute__((__visibility__("default"))) __time_get_storage<char>::__time_get_storage(const string&); template <> __attribute__((__visibility__("default"))) void __time_get_storage<char>::init(const ctype<char>&); template <> __attribute__((__visibility__("default"))) __time_get_storage<char>::string_type __time_get_storage<char>::__analyze(char, const ctype<char>&); extern template __attribute__((__visibility__("default"))) time_base::dateorder __time_get_storage<char>::__do_date_order() const; extern template __attribute__((__visibility__("default"))) __time_get_storage<char>::__time_get_storage(const char*); extern template __attribute__((__visibility__("default"))) __time_get_storage<char>::__time_get_storage(const string&); extern template __attribute__((__visibility__("default"))) void __time_get_storage<char>::init(const ctype<char>&); extern template __attribute__((__visibility__("default"))) __time_get_storage<char>::string_type __time_get_storage<char>::__analyze(char, const ctype<char>&);

template <> __attribute__((__visibility__("default"))) time_base::dateorder __time_get_storage<wchar_t>::__do_date_order() const; template <> __attribute__((__visibility__("default"))) __time_get_storage<wchar_t>::__time_get_storage(const char*); template <> __attribute__((__visibility__("default"))) __time_get_storage<wchar_t>::__time_get_storage(const string&); template <> __attribute__((__visibility__("default"))) void __time_get_storage<wchar_t>::init(const ctype<wchar_t>&); template <> __attribute__((__visibility__("default"))) __time_get_storage<wchar_t>::string_type __time_get_storage<wchar_t>::__analyze(char, const ctype<wchar_t>&); extern template __attribute__((__visibility__("default"))) time_base::dateorder __time_get_storage<wchar_t>::__do_date_order() const; extern template __attribute__((__visibility__("default"))) __time_get_storage<wchar_t>::__time_get_storage(const char*); extern template __attribute__((__visibility__("default"))) __time_get_storage<wchar_t>::__time_get_storage(const string&); extern template __attribute__((__visibility__("default"))) void __time_get_storage<wchar_t>::init(const ctype<wchar_t>&); extern template __attribute__((__visibility__("default"))) __time_get_storage<wchar_t>::string_type __time_get_storage<wchar_t>::__analyze(char, const ctype<wchar_t>&);



template <class _CharT, class _InputIterator = istreambuf_iterator<_CharT> >
class time_get_byname
    : public time_get<_CharT, _InputIterator>,
      private __time_get_storage<_CharT>
{
public:
    typedef time_base::dateorder dateorder;
    typedef _InputIterator iter_type;
    typedef _CharT char_type;
    typedef basic_string<char_type> string_type;

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    explicit time_get_byname(const char* __nm, size_t __refs = 0)
        : time_get<_CharT, _InputIterator>(__refs),
          __time_get_storage<_CharT>(__nm) {}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    explicit time_get_byname(const string& __nm, size_t __refs = 0)
        : time_get<_CharT, _InputIterator>(__refs),
          __time_get_storage<_CharT>(__nm) {}

protected:
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) ~time_get_byname() override {}

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) dateorder do_date_order() const override {return this->__do_date_order();}
private:
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) const string_type* __weeks() const override {return this->__weeks_;}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) const string_type* __months() const override {return this->__months_;}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) const string_type* __am_pm() const override {return this->__am_pm_;}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) const string_type& __c() const override {return this->__c_;}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) const string_type& __r() const override {return this->__r_;}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) const string_type& __x() const override {return this->__x_;}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) const string_type& __X() const override {return this->__X_;}
};

extern template class __attribute__((__visibility__("default"))) time_get_byname<char>;

extern template class __attribute__((__visibility__("default"))) time_get_byname<wchar_t>;


class __attribute__((__visibility__("default"))) __time_put
{
    locale_t __loc_;
protected:
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) __time_put() : __loc_(__cloc()) {}
    __time_put(const char* __nm);
    __time_put(const string& __nm);
    ~__time_put();
    void __do_put(char* __nb, char*& __ne, const tm* __tm,
                  char __fmt, char __mod) const;

    void __do_put(wchar_t* __wb, wchar_t*& __we, const tm* __tm,
                  char __fmt, char __mod) const;

};

template <class _CharT, class _OutputIterator = ostreambuf_iterator<_CharT> >
class time_put
    : public locale::facet,
      private __time_put
{
public:
    typedef _CharT char_type;
    typedef _OutputIterator iter_type;

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    explicit time_put(size_t __refs = 0)
        : locale::facet(__refs) {}

    iter_type put(iter_type __s, ios_base& __iob, char_type __fl, const tm* __tm,
                  const char_type* __pb, const char_type* __pe) const;

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,
                  const tm* __tm, char __fmt, char __mod = 0) const
    {
        return do_put(__s, __iob, __fl, __tm, __fmt, __mod);
    }

    static locale::id id;

protected:
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) ~time_put() override {}
    virtual iter_type do_put(iter_type __s, ios_base&, char_type, const tm* __tm,
                             char __fmt, char __mod) const;

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    explicit time_put(const char* __nm, size_t __refs)
        : locale::facet(__refs),
          __time_put(__nm) {}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    explicit time_put(const string& __nm, size_t __refs)
        : locale::facet(__refs),
          __time_put(__nm) {}
};

template <class _CharT, class _OutputIterator>
locale::id
time_put<_CharT, _OutputIterator>::id;

template <class _CharT, class _OutputIterator>
_OutputIterator
time_put<_CharT, _OutputIterator>::put(iter_type __s, ios_base& __iob,
                                       char_type __fl, const tm* __tm,
                                       const char_type* __pb,
                                       const char_type* __pe) const
{
    const ctype<char_type>& __ct = std::use_facet<ctype<char_type> >(__iob.getloc());
    for (; __pb != __pe; ++__pb)
    {
        if (__ct.narrow(*__pb, 0) == '%')
        {
            if (++__pb == __pe)
            {
                *__s++ = __pb[-1];
                break;
            }
            char __mod = 0;
            char __fmt = __ct.narrow(*__pb, 0);
            if (__fmt == 'E' || __fmt == 'O')
            {
                if (++__pb == __pe)
                {
                    *__s++ = __pb[-2];
                    *__s++ = __pb[-1];
                    break;
                }
                __mod = __fmt;
                __fmt = __ct.narrow(*__pb, 0);
            }
            __s = do_put(__s, __iob, __fl, __tm, __fmt, __mod);
        }
        else
            *__s++ = *__pb;
    }
    return __s;
}

template <class _CharT, class _OutputIterator>
_OutputIterator
time_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base&,
                                          char_type, const tm* __tm,
                                          char __fmt, char __mod) const
{
    char_type __nar[100];
    char_type* __nb = __nar;
    char_type* __ne = __nb + 100;
    __do_put(__nb, __ne, __tm, __fmt, __mod);
    return std::copy(__nb, __ne, __s);
}

extern template class __attribute__((__visibility__("default"))) time_put<char>;

extern template class __attribute__((__visibility__("default"))) time_put<wchar_t>;


template <class _CharT, class _OutputIterator = ostreambuf_iterator<_CharT> >
class time_put_byname
    : public time_put<_CharT, _OutputIterator>
{
public:
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    explicit time_put_byname(const char* __nm, size_t __refs = 0)
        : time_put<_CharT, _OutputIterator>(__nm, __refs) {}

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    explicit time_put_byname(const string& __nm, size_t __refs = 0)
        : time_put<_CharT, _OutputIterator>(__nm, __refs) {}

protected:
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) ~time_put_byname() override {}
};

extern template class __attribute__((__visibility__("default"))) time_put_byname<char>;

extern template class __attribute__((__visibility__("default"))) time_put_byname<wchar_t>;




class __attribute__((__visibility__("default"))) money_base
{
public:
    enum part {none, space, symbol, sign, value};
    struct pattern {char field[4];};

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) money_base() {}
};



template <class _CharT, bool _International = false>
class moneypunct
    : public locale::facet,
      public money_base
{
public:
    typedef _CharT char_type;
    typedef basic_string<char_type> string_type;

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    explicit moneypunct(size_t __refs = 0)
        : locale::facet(__refs) {}

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) char_type decimal_point() const {return do_decimal_point();}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) char_type thousands_sep() const {return do_thousands_sep();}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) string grouping() const {return do_grouping();}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) string_type curr_symbol() const {return do_curr_symbol();}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) string_type positive_sign() const {return do_positive_sign();}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) string_type negative_sign() const {return do_negative_sign();}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) int frac_digits() const {return do_frac_digits();}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) pattern pos_format() const {return do_pos_format();}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) pattern neg_format() const {return do_neg_format();}

    static locale::id id;
    static const bool intl = _International;

protected:
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) ~moneypunct() override {}

    virtual char_type do_decimal_point() const {return numeric_limits<char_type>::max();}
    virtual char_type do_thousands_sep() const {return numeric_limits<char_type>::max();}
    virtual string do_grouping() const {return string();}
    virtual string_type do_curr_symbol() const {return string_type();}
    virtual string_type do_positive_sign() const {return string_type();}
    virtual string_type do_negative_sign() const {return string_type(1, '-');}
    virtual int do_frac_digits() const {return 0;}
    virtual pattern do_pos_format() const
        {pattern __p = {{symbol, sign, none, value}}; return __p;}
    virtual pattern do_neg_format() const
        {pattern __p = {{symbol, sign, none, value}}; return __p;}
};

template <class _CharT, bool _International>
locale::id
moneypunct<_CharT, _International>::id;

template <class _CharT, bool _International>
const bool
moneypunct<_CharT, _International>::intl;

extern template class __attribute__((__visibility__("default"))) moneypunct<char, false>;
extern template class __attribute__((__visibility__("default"))) moneypunct<char, true>;

extern template class __attribute__((__visibility__("default"))) moneypunct<wchar_t, false>;
extern template class __attribute__((__visibility__("default"))) moneypunct<wchar_t, true>;




template <class _CharT, bool _International = false>
class moneypunct_byname
    : public moneypunct<_CharT, _International>
{
public:
    typedef money_base::pattern pattern;
    typedef _CharT char_type;
    typedef basic_string<char_type> string_type;

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    explicit moneypunct_byname(const char* __nm, size_t __refs = 0)
        : moneypunct<_CharT, _International>(__refs) {init(__nm);}

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    explicit moneypunct_byname(const string& __nm, size_t __refs = 0)
        : moneypunct<_CharT, _International>(__refs) {init(__nm.c_str());}

protected:
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) ~moneypunct_byname() override {}

     char_type do_decimal_point() const override {return __decimal_point_;}
     char_type do_thousands_sep() const override {return __thousands_sep_;}
     string do_grouping() const override {return __grouping_;}
     string_type do_curr_symbol() const override {return __curr_symbol_;}
     string_type do_positive_sign() const override {return __positive_sign_;}
     string_type do_negative_sign() const override {return __negative_sign_;}
     int do_frac_digits() const override {return __frac_digits_;}
     pattern do_pos_format() const override {return __pos_format_;}
     pattern do_neg_format() const override {return __neg_format_;}

private:
    char_type __decimal_point_;
    char_type __thousands_sep_;
    string __grouping_;
    string_type __curr_symbol_;
    string_type __positive_sign_;
    string_type __negative_sign_;
    int __frac_digits_;
    pattern __pos_format_;
    pattern __neg_format_;

    void init(const char*);
};

template<> __attribute__((__visibility__("default"))) void moneypunct_byname<char, false>::init(const char*);
template<> __attribute__((__visibility__("default"))) void moneypunct_byname<char, true>::init(const char*);
extern template class __attribute__((__visibility__("default"))) moneypunct_byname<char, false>;
extern template class __attribute__((__visibility__("default"))) moneypunct_byname<char, true>;


template<> __attribute__((__visibility__("default"))) void moneypunct_byname<wchar_t, false>::init(const char*);
template<> __attribute__((__visibility__("default"))) void moneypunct_byname<wchar_t, true>::init(const char*);
extern template class __attribute__((__visibility__("default"))) moneypunct_byname<wchar_t, false>;
extern template class __attribute__((__visibility__("default"))) moneypunct_byname<wchar_t, true>;




template <class _CharT>
class __money_get
{
protected:
    typedef _CharT char_type;
    typedef basic_string<char_type> string_type;

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) __money_get() {}

    static void __gather_info(bool __intl, const locale& __loc,
                              money_base::pattern& __pat, char_type& __dp,
                              char_type& __ts, string& __grp,
                              string_type& __sym, string_type& __psn,
                              string_type& __nsn, int& __fd);
};

template <class _CharT>
void
__money_get<_CharT>::__gather_info(bool __intl, const locale& __loc,
                                   money_base::pattern& __pat, char_type& __dp,
                                   char_type& __ts, string& __grp,
                                   string_type& __sym, string_type& __psn,
                                   string_type& __nsn, int& __fd)
{
    if (__intl)
    {
        const moneypunct<char_type, true>& __mp =
            std::use_facet<moneypunct<char_type, true> >(__loc);
        __pat = __mp.neg_format();
        __nsn = __mp.negative_sign();
        __psn = __mp.positive_sign();
        __dp = __mp.decimal_point();
        __ts = __mp.thousands_sep();
        __grp = __mp.grouping();
        __sym = __mp.curr_symbol();
        __fd = __mp.frac_digits();
    }
    else
    {
        const moneypunct<char_type, false>& __mp =
            std::use_facet<moneypunct<char_type, false> >(__loc);
        __pat = __mp.neg_format();
        __nsn = __mp.negative_sign();
        __psn = __mp.positive_sign();
        __dp = __mp.decimal_point();
        __ts = __mp.thousands_sep();
        __grp = __mp.grouping();
        __sym = __mp.curr_symbol();
        __fd = __mp.frac_digits();
    }
}

extern template class __attribute__((__visibility__("default"))) __money_get<char>;

extern template class __attribute__((__visibility__("default"))) __money_get<wchar_t>;


template <class _CharT, class _InputIterator = istreambuf_iterator<_CharT> >
class money_get
    : public locale::facet,
      private __money_get<_CharT>
{
public:
    typedef _CharT char_type;
    typedef _InputIterator iter_type;
    typedef basic_string<char_type> string_type;

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    explicit money_get(size_t __refs = 0)
        : locale::facet(__refs) {}

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    iter_type get(iter_type __b, iter_type __e, bool __intl, ios_base& __iob,
                  ios_base::iostate& __err, long double& __v) const
    {
        return do_get(__b, __e, __intl, __iob, __err, __v);
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    iter_type get(iter_type __b, iter_type __e, bool __intl, ios_base& __iob,
                  ios_base::iostate& __err, string_type& __v) const
    {
        return do_get(__b, __e, __intl, __iob, __err, __v);
    }

    static locale::id id;

protected:
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) ~money_get() override {}

    virtual iter_type do_get(iter_type __b, iter_type __e, bool __intl,
                             ios_base& __iob, ios_base::iostate& __err,
                             long double& __v) const;
    virtual iter_type do_get(iter_type __b, iter_type __e, bool __intl,
                             ios_base& __iob, ios_base::iostate& __err,
                             string_type& __v) const;

private:
    static bool __do_get(iter_type& __b, iter_type __e,
                         bool __intl, const locale& __loc,
                         ios_base::fmtflags __flags, ios_base::iostate& __err,
                         bool& __neg, const ctype<char_type>& __ct,
                         unique_ptr<char_type, void(*)(void*)>& __wb,
                         char_type*& __wn, char_type* __we);
};

template <class _CharT, class _InputIterator>
locale::id
money_get<_CharT, _InputIterator>::id;

__attribute__((__visibility__("default"))) void __do_nothing(void*);

template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
void
__double_or_nothing(unique_ptr<_Tp, void(*)(void*)>& __b, _Tp*& __n, _Tp*& __e)
{
    bool __owns = __b.get_deleter() != __do_nothing;
    size_t __cur_cap = static_cast<size_t>(__e-__b.get()) * sizeof(_Tp);
    size_t __new_cap = __cur_cap < numeric_limits<size_t>::max() / 2 ?
                       2 * __cur_cap : numeric_limits<size_t>::max();
    if (__new_cap == 0)
        __new_cap = sizeof(_Tp);
    size_t __n_off = static_cast<size_t>(__n - __b.get());
    _Tp* __t = (_Tp*)std::realloc(__owns ? __b.get() : 0, __new_cap);
    if (__t == 0)
        __throw_bad_alloc();
    if (__owns)
        __b.release();
    __b = unique_ptr<_Tp, void(*)(void*)>(__t, free);
    __new_cap /= sizeof(_Tp);
    __n = __b.get() + __n_off;
    __e = __b.get() + __new_cap;
}


template <class _CharT, class _InputIterator>
bool
money_get<_CharT, _InputIterator>::__do_get(iter_type& __b, iter_type __e,
                                            bool __intl, const locale& __loc,
                                            ios_base::fmtflags __flags,
                                            ios_base::iostate& __err,
                                            bool& __neg,
                                            const ctype<char_type>& __ct,
                                            unique_ptr<char_type, void(*)(void*)>& __wb,
                                            char_type*& __wn, char_type* __we)
{
    if (__b == __e) {
        __err |= ios_base::failbit;
        return false;
    }
    const unsigned __bz = 100;
    unsigned __gbuf[__bz];
    unique_ptr<unsigned, void(*)(void*)> __gb(__gbuf, __do_nothing);
    unsigned* __gn = __gb.get();
    unsigned* __ge = __gn + __bz;
    money_base::pattern __pat;
    char_type __dp;
    char_type __ts;
    string __grp;
    string_type __sym;
    string_type __psn;
    string_type __nsn;


    string_type __spaces;
    int __fd;
    __money_get<_CharT>::__gather_info(__intl, __loc, __pat, __dp, __ts, __grp,
                                       __sym, __psn, __nsn, __fd);
    const string_type* __trailing_sign = 0;
    __wn = __wb.get();
    for (unsigned __p = 0; __p < 4 && __b != __e; ++__p)
    {
        switch (__pat.field[__p])
        {
        case money_base::space:
            if (__p != 3)
            {
                if (__ct.is(ctype_base::space, *__b))
                    __spaces.push_back(*__b++);
                else
                {
                    __err |= ios_base::failbit;
                    return false;
                }
            }
            [[fallthrough]];
        case money_base::none:
            if (__p != 3)
            {
                while (__b != __e && __ct.is(ctype_base::space, *__b))
                    __spaces.push_back(*__b++);
            }
            break;
        case money_base::sign:
            if (__psn.size() > 0 && *__b == __psn[0])
            {
                ++__b;
                __neg = false;
                if (__psn.size() > 1)
                  __trailing_sign = &__psn;
                break;
            }
            if (__nsn.size() > 0 && *__b == __nsn[0])
            {
                ++__b;
                __neg = true;
                if (__nsn.size() > 1)
                    __trailing_sign = &__nsn;
                break;
            }
            if (__psn.size() > 0 && __nsn.size() > 0)
            {
                __err |= ios_base::failbit;
                return false;
            }
            if (__psn.size() == 0 && __nsn.size() == 0)

                break;
            __neg = (__nsn.size() == 0);
            break;
        case money_base::symbol:
            {
            bool __more_needed = __trailing_sign ||
                                 (__p < 2) ||
                                 (__p == 2 && __pat.field[3] != static_cast<char>(money_base::none));
            bool __sb = (__flags & ios_base::showbase) != 0;
            if (__sb || __more_needed)
            {
                typename string_type::const_iterator __sym_space_end = __sym.begin();
                if (__p > 0 && (__pat.field[__p - 1] == money_base::none ||
                                __pat.field[__p - 1] == money_base::space)) {


                    while (__sym_space_end != __sym.end() &&
                           __ct.is(ctype_base::space, *__sym_space_end))
                        ++__sym_space_end;
                    const size_t __num_spaces = __sym_space_end - __sym.begin();
                    if (__num_spaces > __spaces.size() ||
                        !std::equal(__spaces.end() - __num_spaces, __spaces.end(),
                               __sym.begin())) {



                        __sym_space_end = __sym.begin();
                    }
                }
                typename string_type::const_iterator __sym_curr_char = __sym_space_end;
                while (__sym_curr_char != __sym.end() && __b != __e &&
                       *__b == *__sym_curr_char) {
                    ++__b;
                    ++__sym_curr_char;
                }
                if (__sb && __sym_curr_char != __sym.end())
                {
                    __err |= ios_base::failbit;
                    return false;
                }
            }
            }
            break;
        case money_base::value:
            {
            unsigned __ng = 0;
            for (; __b != __e; ++__b)
            {
                char_type __c = *__b;
                if (__ct.is(ctype_base::digit, __c))
                {
                    if (__wn == __we)
                        std::__double_or_nothing(__wb, __wn, __we);
                    *__wn++ = __c;
                    ++__ng;
                }
                else if (__grp.size() > 0 && __ng > 0 && __c == __ts)
                {
                    if (__gn == __ge)
                        std::__double_or_nothing(__gb, __gn, __ge);
                    *__gn++ = __ng;
                    __ng = 0;
                }
                else
                    break;
            }
            if (__gb.get() != __gn && __ng > 0)
            {
                if (__gn == __ge)
                    std::__double_or_nothing(__gb, __gn, __ge);
                *__gn++ = __ng;
            }
            if (__fd > 0)
            {
                if (__b == __e || *__b != __dp)
                {
                    __err |= ios_base::failbit;
                    return false;
                }
                for (++__b; __fd > 0; --__fd, ++__b)
                {
                    if (__b == __e || !__ct.is(ctype_base::digit, *__b))
                    {
                        __err |= ios_base::failbit;
                        return false;
                    }
                    if (__wn == __we)
                        std::__double_or_nothing(__wb, __wn, __we);
                    *__wn++ = *__b;
                }
            }
            if (__wn == __wb.get())
            {
                __err |= ios_base::failbit;
                return false;
            }
            }
            break;
        }
    }
    if (__trailing_sign)
    {
        for (unsigned __i = 1; __i < __trailing_sign->size(); ++__i, ++__b)
        {
            if (__b == __e || *__b != (*__trailing_sign)[__i])
            {
                __err |= ios_base::failbit;
                return false;
            }
        }
    }
    if (__gb.get() != __gn)
    {
        ios_base::iostate __et = ios_base::goodbit;
        __check_grouping(__grp, __gb.get(), __gn, __et);
        if (__et)
        {
            __err |= ios_base::failbit;
            return false;
        }
    }
    return true;
}

template <class _CharT, class _InputIterator>
_InputIterator
money_get<_CharT, _InputIterator>::do_get(iter_type __b, iter_type __e,
                                          bool __intl, ios_base& __iob,
                                          ios_base::iostate& __err,
                                          long double& __v) const
{
    const int __bz = 100;
    char_type __wbuf[__bz];
    unique_ptr<char_type, void(*)(void*)> __wb(__wbuf, __do_nothing);
    char_type* __wn;
    char_type* __we = __wbuf + __bz;
    locale __loc = __iob.getloc();
    const ctype<char_type>& __ct = std::use_facet<ctype<char_type> >(__loc);
    bool __neg = false;
    if (__do_get(__b, __e, __intl, __loc, __iob.flags(), __err, __neg, __ct,
                 __wb, __wn, __we))
    {
        const char __src[] = "0123456789";
        char_type __atoms[sizeof(__src)-1];
        __ct.widen(__src, __src + (sizeof(__src)-1), __atoms);
        char __nbuf[__bz];
        char* __nc = __nbuf;
        unique_ptr<char, void(*)(void*)> __h(nullptr, free);
        if (__wn - __wb.get() > __bz-2)
        {
            __h.reset((char*)malloc(static_cast<size_t>(__wn - __wb.get() + 2)));
            if (__h.get() == nullptr)
                __throw_bad_alloc();
            __nc = __h.get();
        }
        if (__neg)
            *__nc++ = '-';
        for (const char_type* __w = __wb.get(); __w < __wn; ++__w, ++__nc)
            *__nc = __src[std::find(__atoms, std::end(__atoms), *__w) - __atoms];
        *__nc = char();
        if (sscanf(__nbuf, "%Lf", &__v) != 1)
            __throw_runtime_error("money_get error");
    }
    if (__b == __e)
        __err |= ios_base::eofbit;
    return __b;
}

template <class _CharT, class _InputIterator>
_InputIterator
money_get<_CharT, _InputIterator>::do_get(iter_type __b, iter_type __e,
                                          bool __intl, ios_base& __iob,
                                          ios_base::iostate& __err,
                                          string_type& __v) const
{
    const int __bz = 100;
    char_type __wbuf[__bz];
    unique_ptr<char_type, void(*)(void*)> __wb(__wbuf, __do_nothing);
    char_type* __wn;
    char_type* __we = __wbuf + __bz;
    locale __loc = __iob.getloc();
    const ctype<char_type>& __ct = std::use_facet<ctype<char_type> >(__loc);
    bool __neg = false;
    if (__do_get(__b, __e, __intl, __loc, __iob.flags(), __err, __neg, __ct,
                 __wb, __wn, __we))
    {
        __v.clear();
        if (__neg)
            __v.push_back(__ct.widen('-'));
        char_type __z = __ct.widen('0');
        char_type* __w;
        for (__w = __wb.get(); __w < __wn-1; ++__w)
            if (*__w != __z)
                break;
        __v.append(__w, __wn);
    }
    if (__b == __e)
        __err |= ios_base::eofbit;
    return __b;
}

extern template class __attribute__((__visibility__("default"))) money_get<char>;

extern template class __attribute__((__visibility__("default"))) money_get<wchar_t>;




template <class _CharT>
class __money_put
{
protected:
    typedef _CharT char_type;
    typedef basic_string<char_type> string_type;

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) __money_put() {}

    static void __gather_info(bool __intl, bool __neg, const locale& __loc,
                              money_base::pattern& __pat, char_type& __dp,
                              char_type& __ts, string& __grp,
                              string_type& __sym, string_type& __sn,
                              int& __fd);
    static void __format(char_type* __mb, char_type*& __mi, char_type*& __me,
                         ios_base::fmtflags __flags,
                         const char_type* __db, const char_type* __de,
                         const ctype<char_type>& __ct, bool __neg,
                         const money_base::pattern& __pat, char_type __dp,
                         char_type __ts, const string& __grp,
                         const string_type& __sym, const string_type& __sn,
                         int __fd);
};

template <class _CharT>
void
__money_put<_CharT>::__gather_info(bool __intl, bool __neg, const locale& __loc,
                                   money_base::pattern& __pat, char_type& __dp,
                                   char_type& __ts, string& __grp,
                                   string_type& __sym, string_type& __sn,
                                   int& __fd)
{
    if (__intl)
    {
        const moneypunct<char_type, true>& __mp =
            std::use_facet<moneypunct<char_type, true> >(__loc);
        if (__neg)
        {
            __pat = __mp.neg_format();
            __sn = __mp.negative_sign();
        }
        else
        {
            __pat = __mp.pos_format();
            __sn = __mp.positive_sign();
        }
        __dp = __mp.decimal_point();
        __ts = __mp.thousands_sep();
        __grp = __mp.grouping();
        __sym = __mp.curr_symbol();
        __fd = __mp.frac_digits();
    }
    else
    {
        const moneypunct<char_type, false>& __mp =
            std::use_facet<moneypunct<char_type, false> >(__loc);
        if (__neg)
        {
            __pat = __mp.neg_format();
            __sn = __mp.negative_sign();
        }
        else
        {
            __pat = __mp.pos_format();
            __sn = __mp.positive_sign();
        }
        __dp = __mp.decimal_point();
        __ts = __mp.thousands_sep();
        __grp = __mp.grouping();
        __sym = __mp.curr_symbol();
        __fd = __mp.frac_digits();
    }
}

template <class _CharT>
void
__money_put<_CharT>::__format(char_type* __mb, char_type*& __mi, char_type*& __me,
                              ios_base::fmtflags __flags,
                              const char_type* __db, const char_type* __de,
                              const ctype<char_type>& __ct, bool __neg,
                              const money_base::pattern& __pat, char_type __dp,
                              char_type __ts, const string& __grp,
                              const string_type& __sym, const string_type& __sn,
                              int __fd)
{
    __me = __mb;
    for (char __p : __pat.field)
    {
        switch (__p)
        {
        case money_base::none:
            __mi = __me;
            break;
        case money_base::space:
            __mi = __me;
            *__me++ = __ct.widen(' ');
            break;
        case money_base::sign:
            if (!__sn.empty())
                *__me++ = __sn[0];
            break;
        case money_base::symbol:
            if (!__sym.empty() && (__flags & ios_base::showbase))
                __me = std::copy(__sym.begin(), __sym.end(), __me);
            break;
        case money_base::value:
            {

            char_type* __t = __me;

            if (__neg)
                ++__db;

            const char_type* __d;
            for (__d = __db; __d < __de; ++__d)
                if (!__ct.is(ctype_base::digit, *__d))
                    break;

            if (__fd > 0)
            {
                int __f;
                for (__f = __fd; __d > __db && __f > 0; --__f)
                    *__me++ = *--__d;
                char_type __z = __f > 0 ? __ct.widen('0') : char_type();
                for (; __f > 0; --__f)
                    *__me++ = __z;
                *__me++ = __dp;
            }

            if (__d == __db)
            {
                *__me++ = __ct.widen('0');
            }
            else
            {
                unsigned __ng = 0;
                unsigned __ig = 0;
                unsigned __gl = __grp.empty() ? numeric_limits<unsigned>::max()
                                              : static_cast<unsigned>(__grp[__ig]);
                while (__d != __db)
                {
                    if (__ng == __gl)
                    {
                        *__me++ = __ts;
                        __ng = 0;
                        if (++__ig < __grp.size())
                            __gl = __grp[__ig] == numeric_limits<char>::max() ?
                                        numeric_limits<unsigned>::max() :
                                        static_cast<unsigned>(__grp[__ig]);
                    }
                    *__me++ = *--__d;
                    ++__ng;
                }
            }

            std::reverse(__t, __me);
            }
            break;
        }
    }

    if (__sn.size() > 1)
        __me = std::copy(__sn.begin()+1, __sn.end(), __me);

    if ((__flags & ios_base::adjustfield) == ios_base::left)
        __mi = __me;
    else if ((__flags & ios_base::adjustfield) != ios_base::internal)
        __mi = __mb;
}

extern template class __attribute__((__visibility__("default"))) __money_put<char>;

extern template class __attribute__((__visibility__("default"))) __money_put<wchar_t>;


template <class _CharT, class _OutputIterator = ostreambuf_iterator<_CharT> >
class money_put
    : public locale::facet,
      private __money_put<_CharT>
{
public:
    typedef _CharT char_type;
    typedef _OutputIterator iter_type;
    typedef basic_string<char_type> string_type;

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    explicit money_put(size_t __refs = 0)
        : locale::facet(__refs) {}

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    iter_type put(iter_type __s, bool __intl, ios_base& __iob, char_type __fl,
                  long double __units) const
    {
        return do_put(__s, __intl, __iob, __fl, __units);
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    iter_type put(iter_type __s, bool __intl, ios_base& __iob, char_type __fl,
                  const string_type& __digits) const
    {
        return do_put(__s, __intl, __iob, __fl, __digits);
    }

    static locale::id id;

protected:
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) ~money_put() override {}

    virtual iter_type do_put(iter_type __s, bool __intl, ios_base& __iob,
                             char_type __fl, long double __units) const;
    virtual iter_type do_put(iter_type __s, bool __intl, ios_base& __iob,
                             char_type __fl, const string_type& __digits) const;
};

template <class _CharT, class _OutputIterator>
locale::id
money_put<_CharT, _OutputIterator>::id;

template <class _CharT, class _OutputIterator>
_OutputIterator
money_put<_CharT, _OutputIterator>::do_put(iter_type __s, bool __intl,
                                           ios_base& __iob, char_type __fl,
                                           long double __units) const
{

    const size_t __bs = 100;
    char __buf[__bs];
    char* __bb = __buf;
    char_type __digits[__bs];
    char_type* __db = __digits;
    int __n = snprintf(__bb, __bs, "%.0Lf", __units);
    unique_ptr<char, void(*)(void*)> __hn(nullptr, free);
    unique_ptr<char_type, void(*)(void*)> __hd(0, free);

    if (static_cast<size_t>(__n) > __bs-1)
    {
        __n = __libcpp_asprintf_l(&__bb, __cloc(), "%.0Lf", __units);
        if (__n == -1)
            __throw_bad_alloc();
        __hn.reset(__bb);
        __hd.reset((char_type*)malloc(static_cast<size_t>(__n) * sizeof(char_type)));
        if (__hd == nullptr)
            __throw_bad_alloc();
        __db = __hd.get();
    }

    locale __loc = __iob.getloc();
    const ctype<char_type>& __ct = std::use_facet<ctype<char_type> >(__loc);
    __ct.widen(__bb, __bb + __n, __db);
    bool __neg = __n > 0 && __bb[0] == '-';
    money_base::pattern __pat;
    char_type __dp;
    char_type __ts;
    string __grp;
    string_type __sym;
    string_type __sn;
    int __fd;
    this->__gather_info(__intl, __neg, __loc, __pat, __dp, __ts, __grp, __sym, __sn, __fd);

    char_type __mbuf[__bs];
    char_type* __mb = __mbuf;
    unique_ptr<char_type, void(*)(void*)> __hw(0, free);
    size_t __exn = __n > __fd ?
                   (static_cast<size_t>(__n) - static_cast<size_t>(__fd)) * 2 +
                    __sn.size() + __sym.size() + static_cast<size_t>(__fd) + 1
                 : __sn.size() + __sym.size() + static_cast<size_t>(__fd) + 2;
    if (__exn > __bs)
    {
        __hw.reset((char_type*)malloc(__exn * sizeof(char_type)));
        __mb = __hw.get();
        if (__mb == 0)
            __throw_bad_alloc();
    }

    char_type* __mi;
    char_type* __me;
    this->__format(__mb, __mi, __me, __iob.flags(),
                   __db, __db + __n, __ct,
                   __neg, __pat, __dp, __ts, __grp, __sym, __sn, __fd);
    return std::__pad_and_output(__s, __mb, __mi, __me, __iob, __fl);
}

template <class _CharT, class _OutputIterator>
_OutputIterator
money_put<_CharT, _OutputIterator>::do_put(iter_type __s, bool __intl,
                                           ios_base& __iob, char_type __fl,
                                           const string_type& __digits) const
{

    locale __loc = __iob.getloc();
    const ctype<char_type>& __ct = std::use_facet<ctype<char_type> >(__loc);
    bool __neg = __digits.size() > 0 && __digits[0] == __ct.widen('-');
    money_base::pattern __pat;
    char_type __dp;
    char_type __ts;
    string __grp;
    string_type __sym;
    string_type __sn;
    int __fd;
    this->__gather_info(__intl, __neg, __loc, __pat, __dp, __ts, __grp, __sym, __sn, __fd);

    char_type __mbuf[100];
    char_type* __mb = __mbuf;
    unique_ptr<char_type, void(*)(void*)> __h(0, free);
    size_t __exn = static_cast<int>(__digits.size()) > __fd ?
                   (__digits.size() - static_cast<size_t>(__fd)) * 2 +
                    __sn.size() + __sym.size() + static_cast<size_t>(__fd) + 1
                 : __sn.size() + __sym.size() + static_cast<size_t>(__fd) + 2;
    if (__exn > 100)
    {
        __h.reset((char_type*)malloc(__exn * sizeof(char_type)));
        __mb = __h.get();
        if (__mb == 0)
            __throw_bad_alloc();
    }

    char_type* __mi;
    char_type* __me;
    this->__format(__mb, __mi, __me, __iob.flags(),
                   __digits.data(), __digits.data() + __digits.size(), __ct,
                   __neg, __pat, __dp, __ts, __grp, __sym, __sn, __fd);
    return std::__pad_and_output(__s, __mb, __mi, __me, __iob, __fl);
}

extern template class __attribute__((__visibility__("default"))) money_put<char>;

extern template class __attribute__((__visibility__("default"))) money_put<wchar_t>;




class __attribute__((__visibility__("default"))) messages_base
{
public:
    typedef intptr_t catalog;

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) messages_base() {}
};

template <class _CharT>
class messages
    : public locale::facet,
      public messages_base
{
public:
    typedef _CharT char_type;
    typedef basic_string<_CharT> string_type;

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    explicit messages(size_t __refs = 0)
        : locale::facet(__refs) {}

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    catalog open(const basic_string<char>& __nm, const locale& __loc) const
    {
        return do_open(__nm, __loc);
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    string_type get(catalog __c, int __set, int __msgid,
                    const string_type& __dflt) const
    {
        return do_get(__c, __set, __msgid, __dflt);
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    void close(catalog __c) const
    {
        do_close(__c);
    }

    static locale::id id;

protected:
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) ~messages() override {}

    virtual catalog do_open(const basic_string<char>&, const locale&) const;
    virtual string_type do_get(catalog, int __set, int __msgid,
                               const string_type& __dflt) const;
    virtual void do_close(catalog) const;
};

template <class _CharT>
locale::id
messages<_CharT>::id;

template <class _CharT>
typename messages<_CharT>::catalog
messages<_CharT>::do_open(const basic_string<char>& __nm, const locale&) const
{

    return (catalog)catopen(__nm.c_str(), 1);




}

template <class _CharT>
typename messages<_CharT>::string_type
messages<_CharT>::do_get(catalog __c, int __set, int __msgid,
                         const string_type& __dflt) const
{

    string __ndflt;
    __narrow_to_utf8<sizeof(char_type)*8>()(std::back_inserter(__ndflt),
                                                       __dflt.c_str(),
                                                       __dflt.c_str() + __dflt.size());
    nl_catd __cat = (nl_catd)__c;
    static_assert(sizeof(catalog) >= sizeof(nl_catd), "Unexpected nl_catd type");
    char* __n = catgets(__cat, __set, __msgid, __ndflt.c_str());
    string_type __w;
    __widen_from_utf8<sizeof(char_type)*8>()(std::back_inserter(__w),
                                                        __n, __n + std::strlen(__n));
    return __w;






}

template <class _CharT>
void
messages<_CharT>::do_close(catalog __c) const
{

    catclose((nl_catd)__c);



}

extern template class __attribute__((__visibility__("default"))) messages<char>;

extern template class __attribute__((__visibility__("default"))) messages<wchar_t>;


template <class _CharT>
class messages_byname
    : public messages<_CharT>
{
public:
    typedef messages_base::catalog catalog;
    typedef basic_string<_CharT> string_type;

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    explicit messages_byname(const char*, size_t __refs = 0)
        : messages<_CharT>(__refs) {}

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    explicit messages_byname(const string&, size_t __refs = 0)
        : messages<_CharT>(__refs) {}

protected:
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) ~messages_byname() override {}
};

extern template class __attribute__((__visibility__("default"))) messages_byname<char>;

extern template class __attribute__((__visibility__("default"))) messages_byname<wchar_t>;


template<class _Codecvt, class _Elem = wchar_t,
         class _WideAlloc = allocator<_Elem>,
         class _ByteAlloc = allocator<char> >
class __attribute__((__deprecated__)) wstring_convert
{
public:
    typedef basic_string<char, char_traits<char>, _ByteAlloc> byte_string;
    typedef basic_string<_Elem, char_traits<_Elem>, _WideAlloc> wide_string;
    typedef typename _Codecvt::state_type state_type;
    typedef typename wide_string::traits_type::int_type int_type;

private:
    byte_string __byte_err_string_;
    wide_string __wide_err_string_;
    _Codecvt* __cvtptr_;
    state_type __cvtstate_;
    size_t __cvtcount_;

    wstring_convert(const wstring_convert& __wc);
    wstring_convert& operator=(const wstring_convert& __wc);
public:

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    wstring_convert() : wstring_convert(new _Codecvt) {}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    explicit wstring_convert(_Codecvt* __pcvt);






    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    wstring_convert(_Codecvt* __pcvt, state_type __state);
    explicit __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) wstring_convert(const byte_string& __byte_err,
                    const wide_string& __wide_err = wide_string());

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    wstring_convert(wstring_convert&& __wc);

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) ~wstring_convert();

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    wide_string from_bytes(char __byte)
        {return from_bytes(&__byte, &__byte+1);}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    wide_string from_bytes(const char* __ptr)
        {return from_bytes(__ptr, __ptr + char_traits<char>::length(__ptr));}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    wide_string from_bytes(const byte_string& __str)
        {return from_bytes(__str.data(), __str.data() + __str.size());}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) wide_string from_bytes(const char* __first, const char* __last);

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    byte_string to_bytes(_Elem __wchar)
        {return to_bytes(&__wchar, &__wchar+1);}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    byte_string to_bytes(const _Elem* __wptr)
        {return to_bytes(__wptr, __wptr + char_traits<_Elem>::length(__wptr));}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    byte_string to_bytes(const wide_string& __wstr)
        {return to_bytes(__wstr.data(), __wstr.data() + __wstr.size());}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) byte_string to_bytes(const _Elem* __first, const _Elem* __last);

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    size_t converted() const noexcept {return __cvtcount_;}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    state_type state() const {return __cvtstate_;}
};

#pragma GCC diagnostic push
# 3658 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/locale" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
# 3658 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/locale" 3
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
template<class _Codecvt, class _Elem, class _WideAlloc, class _ByteAlloc>
inline
wstring_convert<_Codecvt, _Elem, _WideAlloc, _ByteAlloc>::
    wstring_convert(_Codecvt* __pcvt)
        : __cvtptr_(__pcvt), __cvtstate_(), __cvtcount_(0)
{
}
#pragma GCC diagnostic pop

template<class _Codecvt, class _Elem, class _WideAlloc, class _ByteAlloc>
inline
wstring_convert<_Codecvt, _Elem, _WideAlloc, _ByteAlloc>::
    wstring_convert(_Codecvt* __pcvt, state_type __state)
        : __cvtptr_(__pcvt), __cvtstate_(__state), __cvtcount_(0)
{
}

template<class _Codecvt, class _Elem, class _WideAlloc, class _ByteAlloc>
wstring_convert<_Codecvt, _Elem, _WideAlloc, _ByteAlloc>::
    wstring_convert(const byte_string& __byte_err, const wide_string& __wide_err)
        : __byte_err_string_(__byte_err), __wide_err_string_(__wide_err),
          __cvtstate_(), __cvtcount_(0)
{
    __cvtptr_ = new _Codecvt;
}



template<class _Codecvt, class _Elem, class _WideAlloc, class _ByteAlloc>
inline
wstring_convert<_Codecvt, _Elem, _WideAlloc, _ByteAlloc>::
    wstring_convert(wstring_convert&& __wc)
        : __byte_err_string_(std::move(__wc.__byte_err_string_)),
          __wide_err_string_(std::move(__wc.__wide_err_string_)),
          __cvtptr_(__wc.__cvtptr_),
          __cvtstate_(__wc.__cvtstate_), __cvtcount_(__wc.__cvtcount_)
{
    __wc.__cvtptr_ = nullptr;
}



#pragma GCC diagnostic push
# 3701 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/locale" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
# 3701 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/locale" 3
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
template<class _Codecvt, class _Elem, class _WideAlloc, class _ByteAlloc>
wstring_convert<_Codecvt, _Elem, _WideAlloc, _ByteAlloc>::~wstring_convert()
{
    delete __cvtptr_;
}

template<class _Codecvt, class _Elem, class _WideAlloc, class _ByteAlloc>
typename wstring_convert<_Codecvt, _Elem, _WideAlloc, _ByteAlloc>::wide_string
wstring_convert<_Codecvt, _Elem, _WideAlloc, _ByteAlloc>::
    from_bytes(const char* __frm, const char* __frm_end)
{
#pragma GCC diagnostic pop
    __cvtcount_ = 0;
    if (__cvtptr_ != nullptr)
    {
        wide_string __ws(2*(__frm_end - __frm), _Elem());
        if (__frm != __frm_end)
            __ws.resize(__ws.capacity());
        codecvt_base::result __r = codecvt_base::ok;
        state_type __st = __cvtstate_;
        if (__frm != __frm_end)
        {
            _Elem* __to = &__ws[0];
            _Elem* __to_end = __to + __ws.size();
            const char* __frm_nxt;
            do
            {
                _Elem* __to_nxt;
                __r = __cvtptr_->in(__st, __frm, __frm_end, __frm_nxt,
                                          __to, __to_end, __to_nxt);
                __cvtcount_ += __frm_nxt - __frm;
                if (__frm_nxt == __frm)
                {
                    __r = codecvt_base::error;
                }
                else if (__r == codecvt_base::noconv)
                {
                    __ws.resize(__to - &__ws[0]);

                    __ws.append((const _Elem*)__frm, (const _Elem*)__frm_end);
                    __frm = __frm_nxt;
                    __r = codecvt_base::ok;
                }
                else if (__r == codecvt_base::ok)
                {
                    __ws.resize(__to_nxt - &__ws[0]);
                    __frm = __frm_nxt;
                }
                else if (__r == codecvt_base::partial)
                {
                    ptrdiff_t __s = __to_nxt - &__ws[0];
                    __ws.resize(2 * __s);
                    __to = &__ws[0] + __s;
                    __to_end = &__ws[0] + __ws.size();
                    __frm = __frm_nxt;
                }
            } while (__r == codecvt_base::partial && __frm_nxt < __frm_end);
        }
        if (__r == codecvt_base::ok)
            return __ws;
    }

    if (__wide_err_string_.empty())
        __throw_range_error("wstring_convert: from_bytes error");

    return __wide_err_string_;
}

template<class _Codecvt, class _Elem, class _WideAlloc, class _ByteAlloc>
typename wstring_convert<_Codecvt, _Elem, _WideAlloc, _ByteAlloc>::byte_string
wstring_convert<_Codecvt, _Elem, _WideAlloc, _ByteAlloc>::
    to_bytes(const _Elem* __frm, const _Elem* __frm_end)
{
    __cvtcount_ = 0;
    if (__cvtptr_ != nullptr)
    {
        byte_string __bs(2*(__frm_end - __frm), char());
        if (__frm != __frm_end)
            __bs.resize(__bs.capacity());
        codecvt_base::result __r = codecvt_base::ok;
        state_type __st = __cvtstate_;
        if (__frm != __frm_end)
        {
            char* __to = &__bs[0];
            char* __to_end = __to + __bs.size();
            const _Elem* __frm_nxt;
            do
            {
                char* __to_nxt;
                __r = __cvtptr_->out(__st, __frm, __frm_end, __frm_nxt,
                                           __to, __to_end, __to_nxt);
                __cvtcount_ += __frm_nxt - __frm;
                if (__frm_nxt == __frm)
                {
                    __r = codecvt_base::error;
                }
                else if (__r == codecvt_base::noconv)
                {
                    __bs.resize(__to - &__bs[0]);

                    __bs.append((const char*)__frm, (const char*)__frm_end);
                    __frm = __frm_nxt;
                    __r = codecvt_base::ok;
                }
                else if (__r == codecvt_base::ok)
                {
                    __bs.resize(__to_nxt - &__bs[0]);
                    __frm = __frm_nxt;
                }
                else if (__r == codecvt_base::partial)
                {
                    ptrdiff_t __s = __to_nxt - &__bs[0];
                    __bs.resize(2 * __s);
                    __to = &__bs[0] + __s;
                    __to_end = &__bs[0] + __bs.size();
                    __frm = __frm_nxt;
                }
            } while (__r == codecvt_base::partial && __frm_nxt < __frm_end);
        }
        if (__r == codecvt_base::ok)
        {
            size_t __s = __bs.size();
            __bs.resize(__bs.capacity());
            char* __to = &__bs[0] + __s;
            char* __to_end = __to + __bs.size();
            do
            {
                char* __to_nxt;
                __r = __cvtptr_->unshift(__st, __to, __to_end, __to_nxt);
                if (__r == codecvt_base::noconv)
                {
                    __bs.resize(__to - &__bs[0]);
                    __r = codecvt_base::ok;
                }
                else if (__r == codecvt_base::ok)
                {
                    __bs.resize(__to_nxt - &__bs[0]);
                }
                else if (__r == codecvt_base::partial)
                {
                    ptrdiff_t __sp = __to_nxt - &__bs[0];
                    __bs.resize(2 * __sp);
                    __to = &__bs[0] + __sp;
                    __to_end = &__bs[0] + __bs.size();
                }
            } while (__r == codecvt_base::partial);
            if (__r == codecvt_base::ok)
                return __bs;
        }
    }

    if (__byte_err_string_.empty())
        __throw_range_error("wstring_convert: to_bytes error");

    return __byte_err_string_;
}

template <class _Codecvt, class _Elem = wchar_t, class _Tr = char_traits<_Elem> >
class __attribute__((__deprecated__)) wbuffer_convert
    : public basic_streambuf<_Elem, _Tr>
{
public:

    typedef _Elem char_type;
    typedef _Tr traits_type;
    typedef typename traits_type::int_type int_type;
    typedef typename traits_type::pos_type pos_type;
    typedef typename traits_type::off_type off_type;
    typedef typename _Codecvt::state_type state_type;

private:
    char* __extbuf_;
    const char* __extbufnext_;
    const char* __extbufend_;
    char __extbuf_min_[8];
    size_t __ebs_;
    char_type* __intbuf_;
    size_t __ibs_;
    streambuf* __bufptr_;
    _Codecvt* __cv_;
    state_type __st_;
    ios_base::openmode __cm_;
    bool __owns_eb_;
    bool __owns_ib_;
    bool __always_noconv_;

    wbuffer_convert(const wbuffer_convert&);
    wbuffer_convert& operator=(const wbuffer_convert&);

public:

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) wbuffer_convert() : wbuffer_convert(nullptr) {}
    explicit __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) wbuffer_convert(streambuf* __bytebuf,
                             _Codecvt* __pcvt = new _Codecvt,
                             state_type __state = state_type());







    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) ~wbuffer_convert();

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    streambuf* rdbuf() const {return __bufptr_;}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    streambuf* rdbuf(streambuf* __bytebuf)
    {
        streambuf* __r = __bufptr_;
        __bufptr_ = __bytebuf;
        return __r;
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    state_type state() const {return __st_;}

protected:
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) virtual int_type underflow();
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) virtual int_type pbackfail(int_type __c = traits_type::eof());
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) virtual int_type overflow (int_type __c = traits_type::eof());
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) virtual basic_streambuf<char_type, traits_type>* setbuf(char_type* __s,
                                                            streamsize __n);
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) virtual pos_type seekoff(off_type __off, ios_base::seekdir __way,
                             ios_base::openmode __wch = ios_base::in | ios_base::out);
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) virtual pos_type seekpos(pos_type __sp,
                             ios_base::openmode __wch = ios_base::in | ios_base::out);
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) virtual int sync();

private:
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) bool __read_mode();
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) void __write_mode();
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) wbuffer_convert* __close();
};

#pragma GCC diagnostic push
# 3937 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/locale" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
# 3937 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/locale" 3
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
template <class _Codecvt, class _Elem, class _Tr>
wbuffer_convert<_Codecvt, _Elem, _Tr>::
    wbuffer_convert(streambuf* __bytebuf, _Codecvt* __pcvt, state_type __state)
    : __extbuf_(nullptr),
      __extbufnext_(nullptr),
      __extbufend_(nullptr),
      __ebs_(0),
      __intbuf_(0),
      __ibs_(0),
      __bufptr_(__bytebuf),
      __cv_(__pcvt),
      __st_(__state),
      __cm_(0),
      __owns_eb_(false),
      __owns_ib_(false),
      __always_noconv_(__cv_ ? __cv_->always_noconv() : false)
{
    setbuf(0, 4096);
}

template <class _Codecvt, class _Elem, class _Tr>
wbuffer_convert<_Codecvt, _Elem, _Tr>::~wbuffer_convert()
{
    __close();
    delete __cv_;
    if (__owns_eb_)
        delete [] __extbuf_;
    if (__owns_ib_)
        delete [] __intbuf_;
}

template <class _Codecvt, class _Elem, class _Tr>
typename wbuffer_convert<_Codecvt, _Elem, _Tr>::int_type
wbuffer_convert<_Codecvt, _Elem, _Tr>::underflow()
{
#pragma GCC diagnostic pop
    if (__cv_ == 0 || __bufptr_ == 0)
        return traits_type::eof();
    bool __initial = __read_mode();
    char_type __1buf;
    if (this->gptr() == 0)
        this->setg(&__1buf, &__1buf+1, &__1buf+1);
    const size_t __unget_sz = __initial ? 0 : std::min<size_t>((this->egptr() - this->eback()) / 2, 4);
    int_type __c = traits_type::eof();
    if (this->gptr() == this->egptr())
    {
        std::memmove(this->eback(), this->egptr() - __unget_sz, __unget_sz * sizeof(char_type));
        if (__always_noconv_)
        {
            streamsize __nmemb = static_cast<streamsize>(this->egptr() - this->eback() - __unget_sz);
            __nmemb = __bufptr_->sgetn((char*)this->eback() + __unget_sz, __nmemb);
            if (__nmemb != 0)
            {
                this->setg(this->eback(),
                           this->eback() + __unget_sz,
                           this->eback() + __unget_sz + __nmemb);
                __c = *this->gptr();
            }
        }
        else
        {
             if (__extbufend_ != __extbufnext_) {
                ((void)0);
                ((void)0);
                std::memmove(__extbuf_, __extbufnext_, __extbufend_ - __extbufnext_);
             }
            __extbufnext_ = __extbuf_ + (__extbufend_ - __extbufnext_);
            __extbufend_ = __extbuf_ + (__extbuf_ == __extbuf_min_ ? sizeof(__extbuf_min_) : __ebs_);
            streamsize __nmemb = std::min(static_cast<streamsize>(this->egptr() - this->eback() - __unget_sz),
                                 static_cast<streamsize>(__extbufend_ - __extbufnext_));
            codecvt_base::result __r;


            streamsize __nr = __bufptr_->sgetn(const_cast<char*>(__extbufnext_), __nmemb);
            if (__nr != 0)
            {
                __extbufend_ = __extbufnext_ + __nr;
                char_type* __inext;
                __r = __cv_->in(__st_, __extbuf_, __extbufend_, __extbufnext_,
                                       this->eback() + __unget_sz,
                                       this->egptr(), __inext);
                if (__r == codecvt_base::noconv)
                {
                    this->setg((char_type*)__extbuf_, (char_type*)__extbuf_,
                               (char_type*) const_cast<char *>(__extbufend_));
                    __c = *this->gptr();
                }
                else if (__inext != this->eback() + __unget_sz)
                {
                    this->setg(this->eback(), this->eback() + __unget_sz, __inext);
                    __c = *this->gptr();
                }
            }
        }
    }
    else
        __c = *this->gptr();
    if (this->eback() == &__1buf)
        this->setg(0, 0, 0);
    return __c;
}

#pragma GCC diagnostic push
# 4040 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/locale" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
# 4040 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/locale" 3
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
template <class _Codecvt, class _Elem, class _Tr>
typename wbuffer_convert<_Codecvt, _Elem, _Tr>::int_type
wbuffer_convert<_Codecvt, _Elem, _Tr>::pbackfail(int_type __c)
{
#pragma GCC diagnostic pop
    if (__cv_ != 0 && __bufptr_ != 0 && this->eback() < this->gptr())
    {
        if (traits_type::eq_int_type(__c, traits_type::eof()))
        {
            this->gbump(-1);
            return traits_type::not_eof(__c);
        }
        if (traits_type::eq(traits_type::to_char_type(__c), this->gptr()[-1]))
        {
            this->gbump(-1);
            *this->gptr() = traits_type::to_char_type(__c);
            return __c;
        }
    }
    return traits_type::eof();
}

#pragma GCC diagnostic push
# 4063 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/locale" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
# 4063 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/locale" 3
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
template <class _Codecvt, class _Elem, class _Tr>
typename wbuffer_convert<_Codecvt, _Elem, _Tr>::int_type
wbuffer_convert<_Codecvt, _Elem, _Tr>::overflow(int_type __c)
{
#pragma GCC diagnostic pop
    if (__cv_ == 0 || __bufptr_ == 0)
        return traits_type::eof();
    __write_mode();
    char_type __1buf;
    char_type* __pb_save = this->pbase();
    char_type* __epb_save = this->epptr();
    if (!traits_type::eq_int_type(__c, traits_type::eof()))
    {
        if (this->pptr() == 0)
            this->setp(&__1buf, &__1buf+1);
        *this->pptr() = traits_type::to_char_type(__c);
        this->pbump(1);
    }
    if (this->pptr() != this->pbase())
    {
        if (__always_noconv_)
        {
            streamsize __nmemb = static_cast<streamsize>(this->pptr() - this->pbase());
            if (__bufptr_->sputn((const char*)this->pbase(), __nmemb) != __nmemb)
                return traits_type::eof();
        }
        else
        {
            char* __extbe = __extbuf_;
            codecvt_base::result __r;
            do
            {
                const char_type* __e;
                __r = __cv_->out(__st_, this->pbase(), this->pptr(), __e,
                                        __extbuf_, __extbuf_ + __ebs_, __extbe);
                if (__e == this->pbase())
                    return traits_type::eof();
                if (__r == codecvt_base::noconv)
                {
                    streamsize __nmemb = static_cast<size_t>(this->pptr() - this->pbase());
                    if (__bufptr_->sputn((const char*)this->pbase(), __nmemb) != __nmemb)
                        return traits_type::eof();
                }
                else if (__r == codecvt_base::ok || __r == codecvt_base::partial)
                {
                    streamsize __nmemb = static_cast<size_t>(__extbe - __extbuf_);
                    if (__bufptr_->sputn(__extbuf_, __nmemb) != __nmemb)
                        return traits_type::eof();
                    if (__r == codecvt_base::partial)
                    {
                        this->setp(const_cast<char_type *>(__e), this->pptr());
                        this->__pbump(this->epptr() - this->pbase());
                    }
                }
                else
                    return traits_type::eof();
            } while (__r == codecvt_base::partial);
        }
        this->setp(__pb_save, __epb_save);
    }
    return traits_type::not_eof(__c);
}

#pragma GCC diagnostic push
# 4127 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/locale" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
# 4127 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/locale" 3
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
template <class _Codecvt, class _Elem, class _Tr>
basic_streambuf<_Elem, _Tr>*
wbuffer_convert<_Codecvt, _Elem, _Tr>::setbuf(char_type* __s, streamsize __n)
{
#pragma GCC diagnostic pop
    this->setg(0, 0, 0);
    this->setp(0, 0);
    if (__owns_eb_)
        delete [] __extbuf_;
    if (__owns_ib_)
        delete [] __intbuf_;
    __ebs_ = __n;
    if (__ebs_ > sizeof(__extbuf_min_))
    {
        if (__always_noconv_ && __s)
        {
            __extbuf_ = (char*)__s;
            __owns_eb_ = false;
        }
        else
        {
            __extbuf_ = new char[__ebs_];
            __owns_eb_ = true;
        }
    }
    else
    {
        __extbuf_ = __extbuf_min_;
        __ebs_ = sizeof(__extbuf_min_);
        __owns_eb_ = false;
    }
    if (!__always_noconv_)
    {
        __ibs_ = max<streamsize>(__n, sizeof(__extbuf_min_));
        if (__s && __ibs_ >= sizeof(__extbuf_min_))
        {
            __intbuf_ = __s;
            __owns_ib_ = false;
        }
        else
        {
            __intbuf_ = new char_type[__ibs_];
            __owns_ib_ = true;
        }
    }
    else
    {
        __ibs_ = 0;
        __intbuf_ = 0;
        __owns_ib_ = false;
    }
    return this;
}

#pragma GCC diagnostic push
# 4182 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/locale" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
# 4182 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/locale" 3
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
template <class _Codecvt, class _Elem, class _Tr>
typename wbuffer_convert<_Codecvt, _Elem, _Tr>::pos_type
wbuffer_convert<_Codecvt, _Elem, _Tr>::seekoff(off_type __off, ios_base::seekdir __way,
                                        ios_base::openmode __om)
{
    int __width = __cv_->encoding();
    if (__cv_ == 0 || __bufptr_ == 0 || (__width <= 0 && __off != 0) || sync())
        return pos_type(off_type(-1));

    if (__way != ios_base::beg && __way != ios_base::cur && __way != ios_base::end)
        return pos_type(off_type(-1));
    pos_type __r = __bufptr_->pubseekoff(__width * __off, __way, __om);
    __r.state(__st_);
    return __r;
}

template <class _Codecvt, class _Elem, class _Tr>
typename wbuffer_convert<_Codecvt, _Elem, _Tr>::pos_type
wbuffer_convert<_Codecvt, _Elem, _Tr>::seekpos(pos_type __sp, ios_base::openmode __wch)
{
    if (__cv_ == 0 || __bufptr_ == 0 || sync())
        return pos_type(off_type(-1));
    if (__bufptr_->pubseekpos(__sp, __wch) == pos_type(off_type(-1)))
        return pos_type(off_type(-1));
    return __sp;
}

template <class _Codecvt, class _Elem, class _Tr>
int
wbuffer_convert<_Codecvt, _Elem, _Tr>::sync()
{
#pragma GCC diagnostic pop
    if (__cv_ == 0 || __bufptr_ == 0)
        return 0;
    if (__cm_ & ios_base::out)
    {
        if (this->pptr() != this->pbase())
            if (overflow() == traits_type::eof())
                return -1;
        codecvt_base::result __r;
        do
        {
            char* __extbe;
            __r = __cv_->unshift(__st_, __extbuf_, __extbuf_ + __ebs_, __extbe);
            streamsize __nmemb = static_cast<streamsize>(__extbe - __extbuf_);
            if (__bufptr_->sputn(__extbuf_, __nmemb) != __nmemb)
                return -1;
        } while (__r == codecvt_base::partial);
        if (__r == codecvt_base::error)
            return -1;
        if (__bufptr_->pubsync())
            return -1;
    }
    else if (__cm_ & ios_base::in)
    {
        off_type __c;
        if (__always_noconv_)
            __c = this->egptr() - this->gptr();
        else
        {
            int __width = __cv_->encoding();
            __c = __extbufend_ - __extbufnext_;
            if (__width > 0)
                __c += __width * (this->egptr() - this->gptr());
            else
            {
                if (this->gptr() != this->egptr())
                {
                    std::reverse(this->gptr(), this->egptr());
                    codecvt_base::result __r;
                    const char_type* __e = this->gptr();
                    char* __extbe;
                    do
                    {
                        __r = __cv_->out(__st_, __e, this->egptr(), __e,
                                         __extbuf_, __extbuf_ + __ebs_, __extbe);
                        switch (__r)
                        {
                        case codecvt_base::noconv:
                            __c += this->egptr() - this->gptr();
                            break;
                        case codecvt_base::ok:
                        case codecvt_base::partial:
                            __c += __extbe - __extbuf_;
                            break;
                        default:
                            return -1;
                        }
                    } while (__r == codecvt_base::partial);
                }
            }
        }
        if (__bufptr_->pubseekoff(-__c, ios_base::cur, __cm_) == pos_type(off_type(-1)))
            return -1;
        this->setg(0, 0, 0);
        __cm_ = 0;
    }
    return 0;
}

#pragma GCC diagnostic push
# 4283 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/locale" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
# 4283 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/locale" 3
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
template <class _Codecvt, class _Elem, class _Tr>
bool
wbuffer_convert<_Codecvt, _Elem, _Tr>::__read_mode()
{
    if (!(__cm_ & ios_base::in))
    {
        this->setp(0, 0);
        if (__always_noconv_)
            this->setg((char_type*)__extbuf_,
                       (char_type*)__extbuf_ + __ebs_,
                       (char_type*)__extbuf_ + __ebs_);
        else
            this->setg(__intbuf_, __intbuf_ + __ibs_, __intbuf_ + __ibs_);
        __cm_ = ios_base::in;
        return true;
    }
    return false;
}

template <class _Codecvt, class _Elem, class _Tr>
void
wbuffer_convert<_Codecvt, _Elem, _Tr>::__write_mode()
{
    if (!(__cm_ & ios_base::out))
    {
        this->setg(0, 0, 0);
        if (__ebs_ > sizeof(__extbuf_min_))
        {
            if (__always_noconv_)
                this->setp((char_type*)__extbuf_,
                           (char_type*)__extbuf_ + (__ebs_ - 1));
            else
                this->setp(__intbuf_, __intbuf_ + (__ibs_ - 1));
        }
        else
            this->setp(0, 0);
        __cm_ = ios_base::out;
    }
}

template <class _Codecvt, class _Elem, class _Tr>
wbuffer_convert<_Codecvt, _Elem, _Tr>*
wbuffer_convert<_Codecvt, _Elem, _Tr>::__close()
{
    wbuffer_convert* __rt = nullptr;
    if (__cv_ != nullptr && __bufptr_ != nullptr)
    {
        __rt = this;
        if ((__cm_ & ios_base::out) && sync())
            __rt = nullptr;
    }
    return __rt;
}

#pragma GCC diagnostic pop

}}
# 33 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__format/formatter_integral.h" 2 3
# 37 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__format/formatter_integral.h" 3



# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__undef_macros" 1 3
# 41 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__format/formatter_integral.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {



namespace __formatter {





__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) inline char* __insert_sign(char* __buf, bool __negative, __format_spec::__sign __sign) {
  if (__negative)
    *__buf++ = '-';
  else
    switch (__sign) {
    case __format_spec::__sign::__default:
    case __format_spec::__sign::__minus:

      break;
    case __format_spec::__sign::__plus:
      *__buf++ = '+';
      break;
    case __format_spec::__sign::__space:
      *__buf++ = ' ';
      break;
    }

  return __buf;
}
# 87 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__format/formatter_integral.h" 3
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) inline string __determine_grouping(ptrdiff_t __size, const string& __grouping) {
  ((void)0);


  string __r;
  auto __end = __grouping.end() - 1;
  auto __ptr = __grouping.begin();

  while (true) {
    __size -= *__ptr;
    if (__size > 0)
      __r.push_back(*__ptr);
    else {

      __r.push_back(*__ptr + __size);
      return __r;
    }


    if (__ptr != __end) {
      do {
        ++__ptr;

      } while (*__ptr == 0 && __ptr != __end);
    }
  }

  __libcpp_unreachable();
}





template <__fmt_char_type _CharT>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) auto __format_char(
    integral auto __value,
    output_iterator<const _CharT&> auto __out_it,
    __format_spec::__parsed_specifications<_CharT> __specs) -> decltype(__out_it) {
  using _Tp = decltype(__value);
  if constexpr (!same_as<_CharT, _Tp>) {

    if constexpr (signed_integral<_CharT> == signed_integral<_Tp>) {
      if (__value < numeric_limits<_CharT>::min() || __value > numeric_limits<_CharT>::max())
        std::__throw_format_error("Integral value outside the range of the char type");
    } else if constexpr (signed_integral<_CharT>) {

      if (__value > static_cast<make_unsigned_t<_CharT>>(numeric_limits<_CharT>::max()))
        std::__throw_format_error("Integral value outside the range of the char type");
    } else {

      if (__value < 0 || static_cast<make_unsigned_t<_Tp>>(__value) > numeric_limits<_CharT>::max())
        std::__throw_format_error("Integral value outside the range of the char type");
    }
  }

  const auto __c = static_cast<_CharT>(__value);
  return __formatter::__write(std::addressof(__c), std::addressof(__c) + 1, std::move(__out_it), __specs);
}






template <integral _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) char* __to_buffer(char* __first, char* __last, _Tp __value, int __base) {


  to_chars_result __r = std::to_chars(__first, __last, __value, __base);
  ((void)0);
  return __r.ptr;
}







template <unsigned_integral _Tp, size_t _Base>
consteval size_t __buffer_size() noexcept
  requires(_Base == 2)
{
  return numeric_limits<_Tp>::digits
       + 2
       + 1;
}

template <unsigned_integral _Tp, size_t _Base>
consteval size_t __buffer_size() noexcept
  requires(_Base == 8)
{
  return numeric_limits<_Tp>::digits
           / 3
       + 1
       + 1
       + 1;
}

template <unsigned_integral _Tp, size_t _Base>
consteval size_t __buffer_size() noexcept
  requires(_Base == 10)
{
  return numeric_limits<_Tp>::digits10
       + 1
       + 1;
}

template <unsigned_integral _Tp, size_t _Base>
consteval size_t __buffer_size() noexcept
  requires(_Base == 16)
{
  return numeric_limits<_Tp>::digits
           / 4
       + 2
       + 1;
}

template <class _OutIt, class _CharT>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) _OutIt __write_using_decimal_separators(_OutIt __out_it, const char* __begin, const char* __first,
                                                              const char* __last, string&& __grouping, _CharT __sep,
                                                              __format_spec::__parsed_specifications<_CharT> __specs) {
  int __size = (__first - __begin) +
               (__last - __first) +
               (__grouping.size() - 1);

  __padding_size_result __padding = {0, 0};
  if (__specs.__alignment_ == __format_spec::__alignment::__zero_padding) {

    __out_it = __formatter::__copy(__begin, __first, std::move(__out_it));

    if (__specs.__width_ > __size) {

      __padding.__before_ = __specs.__width_ - __size;
      __out_it = __formatter::__fill(std::move(__out_it), __specs.__width_ - __size, _CharT('0'));
    }
  } else {
    if (__specs.__width_ > __size) {

      __padding = __formatter::__padding_size(__size, __specs.__width_, __specs.__alignment_);

      __out_it = __formatter::__fill(std::move(__out_it), __padding.__before_, __specs.__fill_);
    }

    __out_it = __formatter::__copy(__begin, __first, std::move(__out_it));
  }

  auto __r = __grouping.rbegin();
  auto __e = __grouping.rend() - 1;
  ((void)0);
# 250 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__format/formatter_integral.h" 3
  while (true) {
    if (__specs.__std_.__type_ == __format_spec::__type::__hexadecimal_upper_case) {
      __last = __first + *__r;
      __out_it = __formatter::__transform(__first, __last, std::move(__out_it), __hex_to_upper);
      __first = __last;
    } else {
      __out_it = __formatter::__copy(__first, *__r, std::move(__out_it));
      __first += *__r;
    }

    if (__r == __e)
      break;

    ++__r;
    *__out_it++ = __sep;
  }

  return __formatter::__fill(std::move(__out_it), __padding.__after_, __specs.__fill_);
}



template <unsigned_integral _Tp, class _CharT, class _FormatContext>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) typename _FormatContext::iterator __format_integer(
    _Tp __value,
    _FormatContext& __ctx,
    __format_spec::__parsed_specifications<_CharT> __specs,
    bool __negative,
    char* __begin,
    char* __end,
    const char* __prefix,
    int __base) {
  char* __first = __formatter::__insert_sign(__begin, __negative, __specs.__std_.__sign_);
  if (__specs.__std_.__alternate_form_ && __prefix)
    while (*__prefix)
      *__first++ = *__prefix++;

  char* __last = __formatter::__to_buffer(__first, __end, __value, __base);


  if (__specs.__std_.__locale_specific_form_) {
    const auto& __np = std::use_facet<numpunct<_CharT>>(__ctx.locale());
    string __grouping = __np.grouping();
    ptrdiff_t __size = __last - __first;




    if (!__grouping.empty() && __size > __grouping[0])
      return __formatter::__write_using_decimal_separators(
          __ctx.out(),
          __begin,
          __first,
          __last,
          __formatter::__determine_grouping(__size, __grouping),
          __np.thousands_sep(),
          __specs);
  }

  auto __out_it = __ctx.out();
  if (__specs.__alignment_ != __format_spec::__alignment::__zero_padding)
    __first = __begin;
  else {





    __out_it = __formatter::__copy(__begin, __first, std::move(__out_it));
    __specs.__alignment_ = __format_spec::__alignment::__right;
    __specs.__fill_.__data[0] = _CharT('0');
    int32_t __size = __first - __begin;

    __specs.__width_ -= std::min(__size, __specs.__width_);
  }

  if (__specs.__std_.__type_ != __format_spec::__type::__hexadecimal_upper_case) [[likely]]
    return __formatter::__write(__first, __last, __ctx.out(), __specs);

  return __formatter::__write_transformed(__first, __last, __ctx.out(), __specs, __formatter::__hex_to_upper);
}

template <unsigned_integral _Tp, class _CharT, class _FormatContext>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) typename _FormatContext::iterator
__format_integer(_Tp __value,
                 _FormatContext& __ctx,
                 __format_spec::__parsed_specifications<_CharT> __specs,
                 bool __negative = false) {
  switch (__specs.__std_.__type_) {
  case __format_spec::__type::__binary_lower_case: {
    array<char, __formatter::__buffer_size<decltype(__value), 2>()> __array;
    return __formatter::__format_integer(__value, __ctx, __specs, __negative, __array.begin(), __array.end(), "0b", 2);
  }
  case __format_spec::__type::__binary_upper_case: {
    array<char, __formatter::__buffer_size<decltype(__value), 2>()> __array;
    return __formatter::__format_integer(__value, __ctx, __specs, __negative, __array.begin(), __array.end(), "0B", 2);
  }
  case __format_spec::__type::__octal: {

    array<char, __formatter::__buffer_size<decltype(__value), 8>()> __array;
    return __formatter::__format_integer(
        __value, __ctx, __specs, __negative, __array.begin(), __array.end(), __value != 0 ? "0" : nullptr, 8);
  }
  case __format_spec::__type::__default:
  case __format_spec::__type::__decimal: {
    array<char, __formatter::__buffer_size<decltype(__value), 10>()> __array;
    return __formatter::__format_integer(
        __value, __ctx, __specs, __negative, __array.begin(), __array.end(), nullptr, 10);
  }
  case __format_spec::__type::__hexadecimal_lower_case: {
    array<char, __formatter::__buffer_size<decltype(__value), 16>()> __array;
    return __formatter::__format_integer(__value, __ctx, __specs, __negative, __array.begin(), __array.end(), "0x", 16);
  }
  case __format_spec::__type::__hexadecimal_upper_case: {
    array<char, __formatter::__buffer_size<decltype(__value), 16>()> __array;
    return __formatter::__format_integer(__value, __ctx, __specs, __negative, __array.begin(), __array.end(), "0X", 16);
  }
  default:
    ((void)0);
    __libcpp_unreachable();
  }
}

template <signed_integral _Tp, class _CharT, class _FormatContext>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) typename _FormatContext::iterator
__format_integer(_Tp __value, _FormatContext& __ctx, __format_spec::__parsed_specifications<_CharT> __specs) {






  auto __r = std::__to_unsigned_like(__value);
  bool __negative = __value < 0;
  if (__negative)
    __r = std::__complement(__r);

  return __formatter::__format_integer(__r, __ctx, __specs, __negative);
}





template <class _CharT>
struct __bool_strings;

template <>
struct __bool_strings<char> {
  static constexpr string_view __true{"true"};
  static constexpr string_view __false{"false"};
};


template <>
struct __bool_strings<wchar_t> {
  static constexpr wstring_view __true{L"true"};
  static constexpr wstring_view __false{L"false"};
};


template <class _CharT, class _FormatContext>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) typename _FormatContext::iterator
__format_bool(bool __value, _FormatContext& __ctx, __format_spec::__parsed_specifications<_CharT> __specs) {

  if (__specs.__std_.__locale_specific_form_) {
    const auto& __np = std::use_facet<numpunct<_CharT>>(__ctx.locale());
    basic_string<_CharT> __str = __value ? __np.truename() : __np.falsename();
    return __formatter::__write_string_no_precision(basic_string_view<_CharT>{__str}, __ctx.out(), __specs);
  }

  basic_string_view<_CharT> __str =
      __value ? __formatter::__bool_strings<_CharT>::__true : __formatter::__bool_strings<_CharT>::__false;
  return __formatter::__write(__str.begin(), __str.end(), __ctx.out(), __specs);
}

}



}}
# 21 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__format/formatter_bool.h" 2 3
# 30 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__format/formatter_bool.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {



template <__fmt_char_type _CharT>
struct formatter<bool, _CharT> {
public:
  template <class _ParseContext>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr typename _ParseContext::iterator parse(_ParseContext& __ctx) {
    typename _ParseContext::iterator __result = __parser_.__parse(__ctx, __format_spec::__fields_integral);
    __format_spec::__process_parsed_bool(__parser_, "a bool");
    return __result;
  }

  template <class _FormatContext>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) typename _FormatContext::iterator format(bool __value, _FormatContext& __ctx) const {
    switch (__parser_.__type_) {
    case __format_spec::__type::__default:
    case __format_spec::__type::__string:
      return __formatter::__format_bool(__value, __ctx, __parser_.__get_parsed_std_specifications(__ctx));

    case __format_spec::__type::__binary_lower_case:
    case __format_spec::__type::__binary_upper_case:
    case __format_spec::__type::__octal:
    case __format_spec::__type::__decimal:
    case __format_spec::__type::__hexadecimal_lower_case:
    case __format_spec::__type::__hexadecimal_upper_case:


      return __formatter::__format_integer(
          static_cast<unsigned>(__value), __ctx, __parser_.__get_parsed_std_specifications(__ctx));

    default:
      ((void)0);
      __libcpp_unreachable();
    }
  }

  __format_spec::__parser<_CharT> __parser_;
};



}}
# 322 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/vector" 2 3
# 334 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/vector" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__memory/temp_value.h" 1 3
# 20 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__memory/temp_value.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Tp, class _Alloc>
struct __temp_value {
    typedef allocator_traits<_Alloc> _Traits;




    union { _Tp __v; };

    _Alloc &__a;

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr _Tp *__addr() {



        return std::addressof(__v);

    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr _Tp & get() { return *__addr(); }

    template<class... _Args>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) __attribute__((__no_sanitize__("cfi")))
    constexpr __temp_value(_Alloc &__alloc, _Args&& ... __args) : __a(__alloc) {
      _Traits::construct(__a, __addr(), std::forward<_Args>(__args)...);
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr ~__temp_value() { _Traits::destroy(__a, __addr()); }
};

}}
# 335 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/vector" 2 3







# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__split_buffer" 1 3
# 19 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__split_buffer" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__iterator/move_iterator.h" 1 3
# 25 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__iterator/move_iterator.h" 3
# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__iterator/move_sentinel.h" 1 3
# 20 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__iterator/move_sentinel.h" 3



# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__undef_macros" 1 3
# 24 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__iterator/move_sentinel.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {



template <semiregular _Sent>
class move_sentinel
{
public:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
  move_sentinel() = default;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
  explicit move_sentinel(_Sent __s) : __last_(std::move(__s)) {}

  template <class _S2>
    requires convertible_to<const _S2&, _Sent>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
  move_sentinel(const move_sentinel<_S2>& __s) : __last_(__s.base()) {}

  template <class _S2>
    requires assignable_from<_Sent&, const _S2&>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
  move_sentinel& operator=(const move_sentinel<_S2>& __s)
    { __last_ = __s.base(); return *this; }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr _Sent base() const { return __last_; }

private:
    _Sent __last_ = _Sent();
};

template <class... _Tag> [[maybe_unused]] move_sentinel(typename _Tag::__allow_ctad...)->move_sentinel<_Tag...>;



}}
# 26 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__iterator/move_iterator.h" 2 3
# 40 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__iterator/move_iterator.h" 3



# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__undef_macros" 1 3
# 44 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__iterator/move_iterator.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {


template<class _Iter, class = void>
struct __move_iter_category_base {};

template<class _Iter>
  requires requires { typename iterator_traits<_Iter>::iterator_category; }
struct __move_iter_category_base<_Iter> {
    using iterator_category = _If<
        derived_from<typename iterator_traits<_Iter>::iterator_category, random_access_iterator_tag>,
        random_access_iterator_tag,
        typename iterator_traits<_Iter>::iterator_category
    >;
};

template<class _Iter, class _Sent>
concept __move_iter_comparable = requires {
    { std::declval<const _Iter&>() == std::declval<_Sent>() } -> convertible_to<bool>;
};


template <class _Iter>
class move_iterator

    : public __move_iter_category_base<_Iter>

{

private:
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    static constexpr auto __get_iter_concept() {
        if constexpr (random_access_iterator<_Iter>) {
            return random_access_iterator_tag{};
        } else if constexpr (bidirectional_iterator<_Iter>) {
            return bidirectional_iterator_tag{};
        } else if constexpr (forward_iterator<_Iter>) {
            return forward_iterator_tag{};
        } else {
            return input_iterator_tag{};
        }
    }

public:

    using iterator_type = _Iter;
    using iterator_concept = decltype(__get_iter_concept());

    using value_type = iter_value_t<_Iter>;
    using difference_type = iter_difference_t<_Iter>;
    using pointer = _Iter;
    using reference = iter_rvalue_reference_t<_Iter>;
# 116 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__iterator/move_iterator.h" 3
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    explicit move_iterator(_Iter __i) : __current_(std::move(__i)) {}

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    move_iterator& operator++() { ++__current_; return *this; }

    __attribute__((__deprecated__)) __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    pointer operator->() const { return __current_; }


    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    move_iterator() requires is_constructible_v<_Iter> : __current_() {}

    template <class _Up>
        requires (!_IsSame<_Up, _Iter>::value) && convertible_to<const _Up&, _Iter>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    move_iterator(const move_iterator<_Up>& __u) : __current_(__u.base()) {}

    template <class _Up>
        requires (!_IsSame<_Up, _Iter>::value) &&
                 convertible_to<const _Up&, _Iter> &&
                 assignable_from<_Iter&, const _Up&>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    move_iterator& operator=(const move_iterator<_Up>& __u) {
        __current_ = __u.base();
        return *this;
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr const _Iter& base() const & noexcept { return __current_; }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr _Iter base() && { return std::move(__current_); }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    reference operator*() const { return ranges::iter_move(__current_); }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    reference operator[](difference_type __n) const { return ranges::iter_move(__current_ + __n); }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    auto operator++(int)
        requires forward_iterator<_Iter>
    {
        move_iterator __tmp(*this); ++__current_; return __tmp;
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    void operator++(int) { ++__current_; }
# 194 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__iterator/move_iterator.h" 3
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    move_iterator& operator--() { --__current_; return *this; }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    move_iterator operator--(int) { move_iterator __tmp(*this); --__current_; return __tmp; }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    move_iterator operator+(difference_type __n) const { return move_iterator(__current_ + __n); }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    move_iterator& operator+=(difference_type __n) { __current_ += __n; return *this; }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    move_iterator operator-(difference_type __n) const { return move_iterator(__current_ - __n); }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    move_iterator& operator-=(difference_type __n) { __current_ -= __n; return *this; }


    template<sentinel_for<_Iter> _Sent>
    friend __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    bool operator==(const move_iterator& __x, const move_sentinel<_Sent>& __y)
        requires __move_iter_comparable<_Iter, _Sent>
    {
        return __x.base() == __y.base();
    }

    template<sized_sentinel_for<_Iter> _Sent>
    friend __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    iter_difference_t<_Iter> operator-(const move_sentinel<_Sent>& __x, const move_iterator& __y)
    {
        return __x.base() - __y.base();
    }

    template<sized_sentinel_for<_Iter> _Sent>
    friend __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    iter_difference_t<_Iter> operator-(const move_iterator& __x, const move_sentinel<_Sent>& __y)
    {
        return __x.base() - __y.base();
    }

    friend __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    iter_rvalue_reference_t<_Iter> iter_move(const move_iterator& __i)
        noexcept(noexcept(ranges::iter_move(__i.__current_)))
    {
        return ranges::iter_move(__i.__current_);
    }

    template<indirectly_swappable<_Iter> _It2>
    friend __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    void iter_swap(const move_iterator& __x, const move_iterator<_It2>& __y)
        noexcept(noexcept(ranges::iter_swap(__x.__current_, __y.__current_)))
    {
        return ranges::iter_swap(__x.__current_, __y.__current_);
    }


private:
    template<class _It2> friend class move_iterator;

    _Iter __current_;
};
template <class... _Tag> [[maybe_unused]] move_iterator(typename _Tag::__allow_ctad...)->move_iterator<_Tag...>;

template <class _Iter1, class _Iter2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
bool operator==(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)
{
    return __x.base() == __y.base();
}
# 269 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__iterator/move_iterator.h" 3
template <class _Iter1, class _Iter2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
bool operator<(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)
{
    return __x.base() < __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
bool operator>(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)
{
    return __x.base() > __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
bool operator<=(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)
{
    return __x.base() <= __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
bool operator>=(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)
{
    return __x.base() >= __y.base();
}


template <class _Iter1, three_way_comparable_with<_Iter1> _Iter2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
auto operator<=>(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)
    -> compare_three_way_result_t<_Iter1, _Iter2>
{
    return __x.base() <=> __y.base();
}



template <class _Iter1, class _Iter2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
auto operator-(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)
    -> decltype(__x.base() - __y.base())
{
    return __x.base() - __y.base();
}
# 326 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__iterator/move_iterator.h" 3
template <class _Iter>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
move_iterator<_Iter> operator+(iter_difference_t<_Iter> __n, const move_iterator<_Iter>& __x)
    requires requires { { __x.base() + __n } -> same_as<_Iter>; }
{
    return __x + __n;
}
# 343 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__iterator/move_iterator.h" 3
template <class _Iter>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
move_iterator<_Iter>
make_move_iterator(_Iter __i)
{
    return move_iterator<_Iter>(std::move(__i));
}

}}
# 20 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__split_buffer" 2 3
# 41 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__split_buffer" 3



# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__undef_macros" 1 3
# 45 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__split_buffer" 2 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {





template <class _Tp, class _Allocator = allocator<_Tp> >
struct __split_buffer
{
public:
  using value_type = _Tp;
  using allocator_type = _Allocator;
  using __alloc_rr = __libcpp_remove_reference_t<allocator_type>;
  using __alloc_traits = allocator_traits<__alloc_rr>;
  using reference = value_type&;
  using const_reference = const value_type&;
  using size_type = typename __alloc_traits::size_type;
  using difference_type = typename __alloc_traits::difference_type;
  using pointer = typename __alloc_traits::pointer;
  using const_pointer = typename __alloc_traits::const_pointer;
  using iterator = pointer;
  using const_iterator = const_pointer;

  pointer __first_;
  pointer __begin_;
  pointer __end_;
  __compressed_pair<pointer, allocator_type> __end_cap_;

  using __alloc_ref = __add_lvalue_reference_t<allocator_type>;
  using __alloc_const_ref = __add_lvalue_reference_t<allocator_type>;

  __split_buffer(const __split_buffer&) = delete;
  __split_buffer& operator=(const __split_buffer&) = delete;

  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) __split_buffer()
      noexcept(is_nothrow_default_constructible<allocator_type>::value)
      : __first_(nullptr), __begin_(nullptr), __end_(nullptr), __end_cap_(nullptr, __default_init_tag()) {}

  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) explicit __split_buffer(__alloc_rr& __a)
      : __first_(nullptr), __begin_(nullptr), __end_(nullptr), __end_cap_(nullptr, __a) {}

  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) explicit __split_buffer(const __alloc_rr& __a)
      : __first_(nullptr), __begin_(nullptr), __end_(nullptr), __end_cap_(nullptr, __a) {}

  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
  __split_buffer(size_type __cap, size_type __start, __alloc_rr& __a);

  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) __split_buffer(__split_buffer&& __c)
      noexcept(is_nothrow_move_constructible<allocator_type>::value);

  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) __split_buffer(__split_buffer&& __c, const __alloc_rr& __a);

  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) __split_buffer& operator=(__split_buffer&& __c)
      noexcept((__alloc_traits::propagate_on_container_move_assignment::value && is_nothrow_move_assignable<allocator_type>::value) || !__alloc_traits::propagate_on_container_move_assignment::value);



  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) ~__split_buffer();

  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) __alloc_rr& __alloc() noexcept { return __end_cap_.second(); }
  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) const __alloc_rr& __alloc() const noexcept {
    return __end_cap_.second();
  }

  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) pointer& __end_cap() noexcept { return __end_cap_.first(); }
  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) const pointer& __end_cap() const noexcept {
    return __end_cap_.first();
  }

  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) iterator begin() noexcept { return __begin_; }
  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) const_iterator begin() const noexcept { return __begin_; }

  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) iterator end() noexcept { return __end_; }
  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) const_iterator end() const noexcept { return __end_; }

  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) void clear() noexcept { __destruct_at_end(__begin_); }

  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) size_type size() const {
    return static_cast<size_type>(__end_ - __begin_);
  }

  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) bool empty() const { return __end_ == __begin_; }

  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) size_type capacity() const {
    return static_cast<size_type>(__end_cap() - __first_);
  }

  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) size_type __front_spare() const {
    return static_cast<size_type>(__begin_ - __first_);
  }

  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) size_type __back_spare() const {
    return static_cast<size_type>(__end_cap() - __end_);
  }

  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) reference front() { return *__begin_; }
  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) const_reference front() const { return *__begin_; }
  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) reference back() { return *(__end_ - 1); }
  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) const_reference back() const { return *(__end_ - 1); }

  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) void reserve(size_type __n);
  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) void shrink_to_fit() noexcept;
  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) void push_front(const_reference __x);
  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) void push_back(const_reference __x);
  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) void push_front(value_type&& __x);
  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) void push_back(value_type&& __x);

  template <class... _Args>
  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) void emplace_back(_Args&&... __args);

  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) void pop_front() { __destruct_at_begin(__begin_ + 1); }
  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) void pop_back() { __destruct_at_end(__end_ - 1); }

  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) void __construct_at_end(size_type __n);
  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) void __construct_at_end(size_type __n, const_reference __x);

  template <class _InputIter, __enable_if_t<__has_exactly_input_iterator_category<_InputIter>::value, int> = 0>
  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
  void __construct_at_end(_InputIter __first, _InputIter __last);

  template <class _ForwardIterator, __enable_if_t<__has_forward_iterator_category<_ForwardIterator>::value, int> = 0>
  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
  void __construct_at_end(_ForwardIterator __first, _ForwardIterator __last);

  template <class _Iterator, class _Sentinel>
  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
  void __construct_at_end_with_sentinel(_Iterator __first, _Sentinel __last);

  template <class _Iterator>
  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
  void __construct_at_end_with_size(_Iterator __first, size_type __n);

  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) void __destruct_at_begin(pointer __new_begin) {
    __destruct_at_begin(__new_begin, is_trivially_destructible<value_type>());
  }

  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) void __destruct_at_begin(pointer __new_begin, false_type);
  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) void __destruct_at_begin(pointer __new_begin, true_type);

  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) void __destruct_at_end(pointer __new_last) noexcept {
    __destruct_at_end(__new_last, false_type());
  }

  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) void __destruct_at_end(pointer __new_last, false_type) noexcept;
  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) void __destruct_at_end(pointer __new_last, true_type) noexcept;

  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) void swap(__split_buffer& __x)
      noexcept(!__alloc_traits::propagate_on_container_swap::value || __is_nothrow_swappable<__alloc_rr>::value);

  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) bool __invariants() const;

private:
  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) void __move_assign_alloc(__split_buffer& __c, true_type)
      noexcept(is_nothrow_move_assignable<allocator_type>::value) {
    __alloc() = std::move(__c.__alloc());
  }

  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) void __move_assign_alloc(__split_buffer&, false_type) noexcept {}

  struct _ConstructTransaction {
    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) explicit _ConstructTransaction(
        pointer* __p, size_type __n) noexcept
        : __pos_(*__p),
          __end_(*__p + __n),
          __dest_(__p) {}

    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) ~_ConstructTransaction() { *__dest_ = __pos_; }

    pointer __pos_;
    const pointer __end_;

  private:
    pointer* __dest_;
  };
};

template <class _Tp, class _Allocator>
constexpr
bool
__split_buffer<_Tp, _Allocator>::__invariants() const
{
    if (__first_ == nullptr)
    {
        if (__begin_ != nullptr)
            return false;
        if (__end_ != nullptr)
            return false;
        if (__end_cap() != nullptr)
            return false;
    }
    else
    {
        if (__begin_ < __first_)
            return false;
        if (__end_ < __begin_)
            return false;
        if (__end_cap() < __end_)
            return false;
    }
    return true;
}






template <class _Tp, class _Allocator>
constexpr
void
__split_buffer<_Tp, _Allocator>::__construct_at_end(size_type __n)
{
    _ConstructTransaction __tx(&this->__end_, __n);
    for (; __tx.__pos_ != __tx.__end_; ++__tx.__pos_) {
        __alloc_traits::construct(this->__alloc(), std::__to_address(__tx.__pos_));
    }
}







template <class _Tp, class _Allocator>
constexpr
void
__split_buffer<_Tp, _Allocator>::__construct_at_end(size_type __n, const_reference __x)
{
    _ConstructTransaction __tx(&this->__end_, __n);
    for (; __tx.__pos_ != __tx.__end_; ++__tx.__pos_) {
        __alloc_traits::construct(this->__alloc(),
            std::__to_address(__tx.__pos_), __x);
    }
}

template <class _Tp, class _Allocator>
template <class _InputIter, __enable_if_t<__has_exactly_input_iterator_category<_InputIter>::value, int> >
constexpr
void __split_buffer<_Tp, _Allocator>::__construct_at_end(_InputIter __first, _InputIter __last)
{
  __construct_at_end_with_sentinel(__first, __last);
}

template <class _Tp, class _Allocator>
template <class _Iterator, class _Sentinel>
constexpr
void __split_buffer<_Tp, _Allocator>::__construct_at_end_with_sentinel(_Iterator __first, _Sentinel __last) {
    __alloc_rr& __a = this->__alloc();
    for (; __first != __last; ++__first)
    {
        if (__end_ == __end_cap())
        {
            size_type __old_cap = __end_cap() - __first_;
            size_type __new_cap = std::max<size_type>(2 * __old_cap, 8);
            __split_buffer __buf(__new_cap, 0, __a);
            for (pointer __p = __begin_; __p != __end_; ++__p, (void) ++__buf.__end_)
                __alloc_traits::construct(__buf.__alloc(),
                        std::__to_address(__buf.__end_), std::move(*__p));
            swap(__buf);
        }
        __alloc_traits::construct(__a, std::__to_address(this->__end_), *__first);
        ++this->__end_;
    }
}
template <class _Tp, class _Allocator>
template <class _ForwardIterator, __enable_if_t<__has_forward_iterator_category<_ForwardIterator>::value, int> >
constexpr
void __split_buffer<_Tp, _Allocator>::__construct_at_end(_ForwardIterator __first, _ForwardIterator __last)
{
  __construct_at_end_with_size(__first, std::distance(__first, __last));
}

template <class _Tp, class _Allocator>
template <class _ForwardIterator>
constexpr
void __split_buffer<_Tp, _Allocator>::__construct_at_end_with_size(_ForwardIterator __first, size_type __n) {
    _ConstructTransaction __tx(&this->__end_, __n);
    for (; __tx.__pos_ != __tx.__end_; ++__tx.__pos_, (void) ++__first) {
        __alloc_traits::construct(this->__alloc(),
            std::__to_address(__tx.__pos_), *__first);
    }
}

template <class _Tp, class _Allocator>
constexpr
inline
void
__split_buffer<_Tp, _Allocator>::__destruct_at_begin(pointer __new_begin, false_type)
{
    while (__begin_ != __new_begin)
        __alloc_traits::destroy(__alloc(), std::__to_address(__begin_++));
}

template <class _Tp, class _Allocator>
constexpr
inline
void
__split_buffer<_Tp, _Allocator>::__destruct_at_begin(pointer __new_begin, true_type)
{
    __begin_ = __new_begin;
}

template <class _Tp, class _Allocator>
constexpr
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
void
__split_buffer<_Tp, _Allocator>::__destruct_at_end(pointer __new_last, false_type) noexcept
{
    while (__new_last != __end_)
        __alloc_traits::destroy(__alloc(), std::__to_address(--__end_));
}

template <class _Tp, class _Allocator>
constexpr
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
void
__split_buffer<_Tp, _Allocator>::__destruct_at_end(pointer __new_last, true_type) noexcept
{
    __end_ = __new_last;
}

template <class _Tp, class _Allocator>
constexpr
__split_buffer<_Tp, _Allocator>::__split_buffer(size_type __cap, size_type __start, __alloc_rr& __a)
    : __end_cap_(nullptr, __a)
{
    if (__cap == 0) {
        __first_ = nullptr;
    } else {
        auto __allocation = std::__allocate_at_least(__alloc(), __cap);
        __first_ = __allocation.ptr;
        __cap = __allocation.count;
    }
    __begin_ = __end_ = __first_ + __start;
    __end_cap() = __first_ + __cap;
}

template <class _Tp, class _Allocator>
constexpr
__split_buffer<_Tp, _Allocator>::~__split_buffer()
{
    clear();
    if (__first_)
        __alloc_traits::deallocate(__alloc(), __first_, capacity());
}

template <class _Tp, class _Allocator>
constexpr
__split_buffer<_Tp, _Allocator>::__split_buffer(__split_buffer&& __c)
    noexcept(is_nothrow_move_constructible<allocator_type>::value)
    : __first_(std::move(__c.__first_)),
      __begin_(std::move(__c.__begin_)),
      __end_(std::move(__c.__end_)),
      __end_cap_(std::move(__c.__end_cap_))
{
    __c.__first_ = nullptr;
    __c.__begin_ = nullptr;
    __c.__end_ = nullptr;
    __c.__end_cap() = nullptr;
}

template <class _Tp, class _Allocator>
constexpr
__split_buffer<_Tp, _Allocator>::__split_buffer(__split_buffer&& __c, const __alloc_rr& __a)
    : __end_cap_(nullptr, __a)
{
    if (__a == __c.__alloc())
    {
        __first_ = __c.__first_;
        __begin_ = __c.__begin_;
        __end_ = __c.__end_;
        __end_cap() = __c.__end_cap();
        __c.__first_ = nullptr;
        __c.__begin_ = nullptr;
        __c.__end_ = nullptr;
        __c.__end_cap() = nullptr;
    }
    else
    {
        auto __allocation = std::__allocate_at_least(__alloc(), __c.size());
        __first_ = __allocation.ptr;
        __begin_ = __end_ = __first_;
        __end_cap() = __first_ + __allocation.count;
        typedef move_iterator<iterator> _Ip;
        __construct_at_end(_Ip(__c.begin()), _Ip(__c.end()));
    }
}

template <class _Tp, class _Allocator>
constexpr
__split_buffer<_Tp, _Allocator>&
__split_buffer<_Tp, _Allocator>::operator=(__split_buffer&& __c)
    noexcept((__alloc_traits::propagate_on_container_move_assignment::value && is_nothrow_move_assignable<allocator_type>::value) || !__alloc_traits::propagate_on_container_move_assignment::value)


{
    clear();
    shrink_to_fit();
    __first_ = __c.__first_;
    __begin_ = __c.__begin_;
    __end_ = __c.__end_;
    __end_cap() = __c.__end_cap();
    __move_assign_alloc(__c,
        integral_constant<bool,
                          __alloc_traits::propagate_on_container_move_assignment::value>());
    __c.__first_ = __c.__begin_ = __c.__end_ = __c.__end_cap() = nullptr;
    return *this;
}

template <class _Tp, class _Allocator>
constexpr
void
__split_buffer<_Tp, _Allocator>::swap(__split_buffer& __x)
        noexcept(!__alloc_traits::propagate_on_container_swap::value|| __is_nothrow_swappable<__alloc_rr>::value)

{
    std::swap(__first_, __x.__first_);
    std::swap(__begin_, __x.__begin_);
    std::swap(__end_, __x.__end_);
    std::swap(__end_cap(), __x.__end_cap());
    std::__swap_allocator(__alloc(), __x.__alloc());
}

template <class _Tp, class _Allocator>
constexpr
void
__split_buffer<_Tp, _Allocator>::reserve(size_type __n)
{
    if (__n < capacity())
    {
        __split_buffer<value_type, __alloc_rr&> __t(__n, 0, __alloc());
        __t.__construct_at_end(move_iterator<pointer>(__begin_),
                               move_iterator<pointer>(__end_));
        std::swap(__first_, __t.__first_);
        std::swap(__begin_, __t.__begin_);
        std::swap(__end_, __t.__end_);
        std::swap(__end_cap(), __t.__end_cap());
    }
}

template <class _Tp, class _Allocator>
constexpr
void
__split_buffer<_Tp, _Allocator>::shrink_to_fit() noexcept
{
    if (capacity() > size())
    {




            __split_buffer<value_type, __alloc_rr&> __t(size(), 0, __alloc());
            __t.__construct_at_end(move_iterator<pointer>(__begin_),
                                   move_iterator<pointer>(__end_));
            __t.__end_ = __t.__begin_ + (__end_ - __begin_);
            std::swap(__first_, __t.__first_);
            std::swap(__begin_, __t.__begin_);
            std::swap(__end_, __t.__end_);
            std::swap(__end_cap(), __t.__end_cap());






    }
}

template <class _Tp, class _Allocator>
constexpr
void
__split_buffer<_Tp, _Allocator>::push_front(const_reference __x)
{
    if (__begin_ == __first_)
    {
        if (__end_ < __end_cap())
        {
            difference_type __d = __end_cap() - __end_;
            __d = (__d + 1) / 2;
            __begin_ = std::move_backward(__begin_, __end_, __end_ + __d);
            __end_ += __d;
        }
        else
        {
            size_type __c = std::max<size_type>(2 * static_cast<size_t>(__end_cap() - __first_), 1);
            __split_buffer<value_type, __alloc_rr&> __t(__c, (__c + 3) / 4, __alloc());
            __t.__construct_at_end(move_iterator<pointer>(__begin_),
                                   move_iterator<pointer>(__end_));
            std::swap(__first_, __t.__first_);
            std::swap(__begin_, __t.__begin_);
            std::swap(__end_, __t.__end_);
            std::swap(__end_cap(), __t.__end_cap());
        }
    }
    __alloc_traits::construct(__alloc(), std::__to_address(__begin_-1), __x);
    --__begin_;
}

template <class _Tp, class _Allocator>
constexpr
void
__split_buffer<_Tp, _Allocator>::push_front(value_type&& __x)
{
    if (__begin_ == __first_)
    {
        if (__end_ < __end_cap())
        {
            difference_type __d = __end_cap() - __end_;
            __d = (__d + 1) / 2;
            __begin_ = std::move_backward(__begin_, __end_, __end_ + __d);
            __end_ += __d;
        }
        else
        {
            size_type __c = std::max<size_type>(2 * static_cast<size_t>(__end_cap() - __first_), 1);
            __split_buffer<value_type, __alloc_rr&> __t(__c, (__c + 3) / 4, __alloc());
            __t.__construct_at_end(move_iterator<pointer>(__begin_),
                                   move_iterator<pointer>(__end_));
            std::swap(__first_, __t.__first_);
            std::swap(__begin_, __t.__begin_);
            std::swap(__end_, __t.__end_);
            std::swap(__end_cap(), __t.__end_cap());
        }
    }
    __alloc_traits::construct(__alloc(), std::__to_address(__begin_-1),
            std::move(__x));
    --__begin_;
}

template <class _Tp, class _Allocator>
constexpr
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
void
__split_buffer<_Tp, _Allocator>::push_back(const_reference __x)
{
    if (__end_ == __end_cap())
    {
        if (__begin_ > __first_)
        {
            difference_type __d = __begin_ - __first_;
            __d = (__d + 1) / 2;
            __end_ = std::move(__begin_, __end_, __begin_ - __d);
            __begin_ -= __d;
        }
        else
        {
            size_type __c = std::max<size_type>(2 * static_cast<size_t>(__end_cap() - __first_), 1);
            __split_buffer<value_type, __alloc_rr&> __t(__c, __c / 4, __alloc());
            __t.__construct_at_end(move_iterator<pointer>(__begin_),
                                   move_iterator<pointer>(__end_));
            std::swap(__first_, __t.__first_);
            std::swap(__begin_, __t.__begin_);
            std::swap(__end_, __t.__end_);
            std::swap(__end_cap(), __t.__end_cap());
        }
    }
    __alloc_traits::construct(__alloc(), std::__to_address(__end_), __x);
    ++__end_;
}

template <class _Tp, class _Allocator>
constexpr
void
__split_buffer<_Tp, _Allocator>::push_back(value_type&& __x)
{
    if (__end_ == __end_cap())
    {
        if (__begin_ > __first_)
        {
            difference_type __d = __begin_ - __first_;
            __d = (__d + 1) / 2;
            __end_ = std::move(__begin_, __end_, __begin_ - __d);
            __begin_ -= __d;
        }
        else
        {
            size_type __c = std::max<size_type>(2 * static_cast<size_t>(__end_cap() - __first_), 1);
            __split_buffer<value_type, __alloc_rr&> __t(__c, __c / 4, __alloc());
            __t.__construct_at_end(move_iterator<pointer>(__begin_),
                                   move_iterator<pointer>(__end_));
            std::swap(__first_, __t.__first_);
            std::swap(__begin_, __t.__begin_);
            std::swap(__end_, __t.__end_);
            std::swap(__end_cap(), __t.__end_cap());
        }
    }
    __alloc_traits::construct(__alloc(), std::__to_address(__end_),
            std::move(__x));
    ++__end_;
}

template <class _Tp, class _Allocator>
template <class... _Args>
constexpr
void
__split_buffer<_Tp, _Allocator>::emplace_back(_Args&&... __args)
{
    if (__end_ == __end_cap())
    {
        if (__begin_ > __first_)
        {
            difference_type __d = __begin_ - __first_;
            __d = (__d + 1) / 2;
            __end_ = std::move(__begin_, __end_, __begin_ - __d);
            __begin_ -= __d;
        }
        else
        {
            size_type __c = std::max<size_type>(2 * static_cast<size_t>(__end_cap() - __first_), 1);
            __split_buffer<value_type, __alloc_rr&> __t(__c, __c / 4, __alloc());
            __t.__construct_at_end(move_iterator<pointer>(__begin_),
                                   move_iterator<pointer>(__end_));
            std::swap(__first_, __t.__first_);
            std::swap(__begin_, __t.__begin_);
            std::swap(__end_, __t.__end_);
            std::swap(__end_cap(), __t.__end_cap());
        }
    }
    __alloc_traits::construct(__alloc(), std::__to_address(__end_),
                              std::forward<_Args>(__args)...);
    ++__end_;
}

template <class _Tp, class _Allocator>
constexpr
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
void
swap(__split_buffer<_Tp, _Allocator>& __x, __split_buffer<_Tp, _Allocator>& __y)
        noexcept(noexcept(__x.swap(__y)))
{
    __x.swap(__y);
}

}}
# 343 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/vector" 2 3
# 375 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/vector" 3



# 1 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/__undef_macros" 1 3
# 379 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/vector" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Tp, class _Allocator >
class vector
{
private:
    typedef allocator<_Tp> __default_allocator_type;
public:
    typedef vector __self;
    typedef _Tp value_type;
    typedef _Allocator allocator_type;
    typedef allocator_traits<allocator_type> __alloc_traits;
    typedef value_type& reference;
    typedef const value_type& const_reference;
    typedef typename __alloc_traits::size_type size_type;
    typedef typename __alloc_traits::difference_type difference_type;
    typedef typename __alloc_traits::pointer pointer;
    typedef typename __alloc_traits::const_pointer const_pointer;

    typedef __wrap_iter<pointer> iterator;
    typedef __wrap_iter<const_pointer> const_iterator;
    typedef std::reverse_iterator<iterator> reverse_iterator;
    typedef std::reverse_iterator<const_iterator> const_reverse_iterator;

    static_assert((is_same<typename allocator_type::value_type, value_type>::value),
                  "Allocator::value_type must be same type as value_type");

    static_assert(is_same<allocator_type, __rebind_alloc<__alloc_traits, value_type> >::value,
                  "[allocator.requirements] states that rebinding an allocator to the same type should result in the "
                  "original allocator");

    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    vector() noexcept(is_nothrow_default_constructible<allocator_type>::value)
    {
    }
    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) explicit vector(const allocator_type& __a)



        noexcept

        : __end_cap_(nullptr, __a)
    {
    }
    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) explicit vector(size_type __n);

    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) explicit vector(size_type __n, const allocator_type& __a);

    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) vector(size_type __n, const value_type& __x);

    template <class = __enable_if_t<__is_allocator<_Allocator>::value> >
    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    vector(size_type __n, const value_type& __x, const allocator_type& __a)
        : __end_cap_(nullptr, __a)
    {
      if (__n > 0)
      {
          __vallocate(__n);
          __construct_at_end(__n, __x);
      }
    }

  template <class _InputIterator,
            __enable_if_t<__has_exactly_input_iterator_category<_InputIterator>::value &&
                              is_constructible<value_type, typename iterator_traits<_InputIterator>::reference>::value,
                          int> = 0>
  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) vector(_InputIterator __first, _InputIterator __last);
  template <class _InputIterator,
            __enable_if_t<__has_exactly_input_iterator_category<_InputIterator>::value &&
                              is_constructible<value_type, typename iterator_traits<_InputIterator>::reference>::value,
                          int> = 0>
  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
  vector(_InputIterator __first, _InputIterator __last, const allocator_type& __a);

  template <
      class _ForwardIterator,
      __enable_if_t<__has_forward_iterator_category<_ForwardIterator>::value &&
                        is_constructible<value_type, typename iterator_traits<_ForwardIterator>::reference>::value,
                    int> = 0>
  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) vector(_ForwardIterator __first, _ForwardIterator __last);

  template <class _ForwardIterator,
      __enable_if_t<__has_forward_iterator_category<_ForwardIterator>::value &&
                        is_constructible<value_type, typename iterator_traits<_ForwardIterator>::reference>::value,
                    int> = 0>
  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
  vector(_ForwardIterator __first, _ForwardIterator __last, const allocator_type& __a);


  template <_ContainerCompatibleRange<_Tp> _Range>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr vector(from_range_t, _Range&& __range,
      const allocator_type& __alloc = allocator_type()) : __end_cap_(nullptr, __alloc) {
    if constexpr (ranges::forward_range<_Range> || ranges::sized_range<_Range>) {
      auto __n = static_cast<size_type>(ranges::distance(__range));
      __init_with_size(ranges::begin(__range), ranges::end(__range), __n);

    } else {
      __init_with_sentinel(ranges::begin(__range), ranges::end(__range));
    }
  }


private:
  class __destroy_vector {
    public:
      constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) __destroy_vector(vector& __vec) : __vec_(__vec) {}

      constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) void operator()() {
          if (__vec_.__begin_ != nullptr) {
            __vec_.__clear();
            __vec_.__annotate_delete();
            __alloc_traits::deallocate(__vec_.__alloc(), __vec_.__begin_, __vec_.capacity());
          }
      }

    private:
      vector& __vec_;
  };

public:
  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) ~vector() { __destroy_vector(*this)(); }

    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) vector(const vector& __x);
    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) vector(const vector& __x, const __type_identity_t<allocator_type>& __a);
    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    vector& operator=(const vector& __x);


    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    vector(initializer_list<value_type> __il);

    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    vector(initializer_list<value_type> __il, const allocator_type& __a);

    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    vector& operator=(initializer_list<value_type> __il)
        {assign(__il.begin(), __il.end()); return *this;}


    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    vector(vector&& __x)

        noexcept;




    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    vector(vector&& __x, const __type_identity_t<allocator_type>& __a);
    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    vector& operator=(vector&& __x)
        noexcept((__noexcept_move_assign_container<_Allocator, __alloc_traits>::value));

  template <class _InputIterator,
            __enable_if_t<__has_exactly_input_iterator_category<_InputIterator>::value &&
                              is_constructible<value_type, typename iterator_traits<_InputIterator>::reference>::value,
                          int> = 0>
  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) void assign(_InputIterator __first, _InputIterator __last);
  template <
      class _ForwardIterator,
      __enable_if_t<__has_forward_iterator_category<_ForwardIterator>::value &&
                        is_constructible<value_type, typename iterator_traits<_ForwardIterator>::reference>::value,
                    int> = 0>
  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) void assign(_ForwardIterator __first, _ForwardIterator __last);


    template <_ContainerCompatibleRange<_Tp> _Range>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    constexpr void assign_range(_Range&& __range) {
      if constexpr (ranges::forward_range<_Range> || ranges::sized_range<_Range>) {
        auto __n = static_cast<size_type>(ranges::distance(__range));
        __assign_with_size(ranges::begin(__range), ranges::end(__range), __n);

      } else {
        __assign_with_sentinel(ranges::begin(__range), ranges::end(__range));
      }
    }


    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) void assign(size_type __n, const_reference __u);


    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    void assign(initializer_list<value_type> __il)
        {assign(__il.begin(), __il.end());}


    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    allocator_type get_allocator() const noexcept
        {return this->__alloc();}

    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) iterator begin() noexcept;
    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) const_iterator begin() const noexcept;
    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) iterator end() noexcept;
    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) const_iterator end() const noexcept;

    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    reverse_iterator rbegin() noexcept
        {return reverse_iterator(end());}
    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    const_reverse_iterator rbegin() const noexcept
        {return const_reverse_iterator(end());}
    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    reverse_iterator rend() noexcept
        {return reverse_iterator(begin());}
    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    const_reverse_iterator rend() const noexcept
        {return const_reverse_iterator(begin());}

    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    const_iterator cbegin() const noexcept
        {return begin();}
    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    const_iterator cend() const noexcept
        {return end();}
    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    const_reverse_iterator crbegin() const noexcept
        {return rbegin();}
    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    const_reverse_iterator crend() const noexcept
        {return rend();}

    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    size_type size() const noexcept
        {return static_cast<size_type>(this->__end_ - this->__begin_);}
    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    size_type capacity() const noexcept
        {return static_cast<size_type>(__end_cap() - this->__begin_);}
    [[__nodiscard__]] constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    bool empty() const noexcept
        {return this->__begin_ == this->__end_;}
    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) size_type max_size() const noexcept;
    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) void reserve(size_type __n);
    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) void shrink_to_fit() noexcept;

    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) reference operator[](size_type __n) noexcept;
    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) const_reference operator[](size_type __n) const noexcept;
    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) reference at(size_type __n);
    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) const_reference at(size_type __n) const;

    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) reference front() noexcept
    {
        ((void)0);
        return *this->__begin_;
    }
    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) const_reference front() const noexcept
    {
        ((void)0);
        return *this->__begin_;
    }
    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) reference back() noexcept
    {
        ((void)0);
        return *(this->__end_ - 1);
    }
    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) const_reference back() const noexcept
    {
        ((void)0);
        return *(this->__end_ - 1);
    }

    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    value_type* data() noexcept
        {return std::__to_address(this->__begin_);}

    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    const value_type* data() const noexcept
        {return std::__to_address(this->__begin_);}

    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) void push_back(const_reference __x);

    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) void push_back(value_type&& __x);

    template <class... _Args>
    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))

        reference emplace_back(_Args&&... __args);





    template <_ContainerCompatibleRange<_Tp> _Range>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    constexpr void append_range(_Range&& __range) {
      insert_range(end(), std::forward<_Range>(__range));
    }


    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    void pop_back();

    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) iterator insert(const_iterator __position, const_reference __x);

    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) iterator insert(const_iterator __position, value_type&& __x);
    template <class... _Args>
    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) iterator emplace(const_iterator __position, _Args&&... __args);

    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    iterator insert(const_iterator __position, size_type __n, const_reference __x);

  template <class _InputIterator,
            __enable_if_t<__has_exactly_input_iterator_category<_InputIterator>::value &&
                              is_constructible< value_type, typename iterator_traits<_InputIterator>::reference>::value,
                          int> = 0>
  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) iterator
  insert(const_iterator __position, _InputIterator __first, _InputIterator __last);


    template <_ContainerCompatibleRange<_Tp> _Range>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    constexpr iterator insert_range(const_iterator __position, _Range&& __range) {
      if constexpr (ranges::forward_range<_Range> || ranges::sized_range<_Range>) {
        auto __n = static_cast<size_type>(ranges::distance(__range));
        return __insert_with_size(__position, ranges::begin(__range), ranges::end(__range), __n);

      } else {
        return __insert_with_sentinel(__position, ranges::begin(__range), ranges::end(__range));
      }
    }


  template <
      class _ForwardIterator,
      __enable_if_t<__has_forward_iterator_category<_ForwardIterator>::value &&
                        is_constructible< value_type, typename iterator_traits<_ForwardIterator>::reference>::value,
                    int> = 0>
  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) iterator
  insert(const_iterator __position, _ForwardIterator __first, _ForwardIterator __last);


    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    iterator insert(const_iterator __position, initializer_list<value_type> __il)
        {return insert(__position, __il.begin(), __il.end());}


    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) iterator erase(const_iterator __position);
    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) iterator erase(const_iterator __first, const_iterator __last);

    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    void clear() noexcept
    {
        size_type __old_size = size();
        __clear();
        __annotate_shrink(__old_size);
    }

    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) void resize(size_type __sz);
    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) void resize(size_type __sz, const_reference __x);

    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) void swap(vector&)

        noexcept;





    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) bool __invariants() const;

private:
    pointer __begin_ = nullptr;
    pointer __end_ = nullptr;
    __compressed_pair<pointer, allocator_type> __end_cap_ =
        __compressed_pair<pointer, allocator_type>(nullptr, __default_init_tag());
# 753 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/vector" 3
    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) void __vallocate(size_type __n) {
        if (__n > max_size())
            __throw_length_error();
        auto __allocation = std::__allocate_at_least(__alloc(), __n);
        __begin_ = __allocation.ptr;
        __end_ = __allocation.ptr;
        __end_cap() = __begin_ + __allocation.count;
        __annotate_new(0);
    }

    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) void __vdeallocate() noexcept;
    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) size_type __recommend(size_type __new_size) const;
    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) void __construct_at_end(size_type __n);
    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    void __construct_at_end(size_type __n, const_reference __x);

    template <class _InputIterator, class _Sentinel>
    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    void __init_with_size(_InputIterator __first, _Sentinel __last, size_type __n) {
      auto __guard = std::__make_exception_guard(__destroy_vector(*this));

      if (__n > 0) {
        __vallocate(__n);
        __construct_at_end(__first, __last, __n);
      }

      __guard.__complete();
    }

    template <class _InputIterator, class _Sentinel>
    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    void __init_with_sentinel(_InputIterator __first, _Sentinel __last) {
      auto __guard = std::__make_exception_guard(__destroy_vector(*this));

      for (; __first != __last; ++__first)
        emplace_back(*__first);

      __guard.__complete();
    }

    template <class _Iterator, class _Sentinel>
    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    void __assign_with_sentinel(_Iterator __first, _Sentinel __last);

    template <class _ForwardIterator, class _Sentinel>
    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    void __assign_with_size(_ForwardIterator __first, _Sentinel __last, difference_type __n);

    template <class _InputIterator, class _Sentinel>
    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    iterator __insert_with_sentinel(const_iterator __position, _InputIterator __first, _Sentinel __last);

    template <class _Iterator, class _Sentinel>
    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    iterator __insert_with_size(const_iterator __position, _Iterator __first, _Sentinel __last, difference_type __n);

    template <class _InputIterator, class _Sentinel>
    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    void __construct_at_end(_InputIterator __first, _Sentinel __last, size_type __n);

    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) void __append(size_type __n);
    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) void __append(size_type __n, const_reference __x);
    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    iterator __make_iter(pointer __p) noexcept { return iterator(__p); }
    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    const_iterator __make_iter(const_pointer __p) const noexcept { return const_iterator(__p); }
    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) void __swap_out_circular_buffer(__split_buffer<value_type, allocator_type&>& __v);
    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) pointer __swap_out_circular_buffer(__split_buffer<value_type, allocator_type&>& __v, pointer __p);
    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) void __move_range(pointer __from_s, pointer __from_e, pointer __to);
    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) void __move_assign(vector& __c, true_type)
        noexcept(is_nothrow_move_assignable<allocator_type>::value);
    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) void __move_assign(vector& __c, false_type)
        noexcept(__alloc_traits::is_always_equal::value);
    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    void __destruct_at_end(pointer __new_last) noexcept
    {
        size_type __old_size = size();
        __base_destruct_at_end(__new_last);
        __annotate_shrink(__old_size);
    }

    template <class _Up>
    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    inline void __push_back_slow_path(_Up&& __x);

    template <class... _Args>
    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    inline void __emplace_back_slow_path(_Args&&... __args);
# 859 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/vector" 3
    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    void __annotate_contiguous_container(const void*, const void*, const void*,
                                         const void*) const noexcept {}

    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    void __annotate_new(size_type __current_size) const noexcept {
      __annotate_contiguous_container(data(), data() + capacity(),
                                      data() + capacity(), data() + __current_size);
    }

    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    void __annotate_delete() const noexcept {
      __annotate_contiguous_container(data(), data() + capacity(),
                                      data() + size(), data() + capacity());
    }

    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    void __annotate_increase(size_type __n) const noexcept
    {
      __annotate_contiguous_container(data(), data() + capacity(),
                                      data() + size(), data() + size() + __n);
    }

    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    void __annotate_shrink(size_type __old_size) const noexcept
    {
      __annotate_contiguous_container(data(), data() + capacity(),
                                      data() + __old_size, data() + size());
    }

  struct _ConstructTransaction {
    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    explicit _ConstructTransaction(vector &__v, size_type __n)
      : __v_(__v), __pos_(__v.__end_), __new_end_(__v.__end_ + __n) {



    }
    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) ~_ConstructTransaction() {
      __v_.__end_ = __pos_;





    }

    vector &__v_;
    pointer __pos_;
    const_pointer const __new_end_;

  private:
    _ConstructTransaction(_ConstructTransaction const&) = delete;
    _ConstructTransaction& operator=(_ConstructTransaction const&) = delete;
  };

  template <class ..._Args>
  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
  void __construct_one_at_end(_Args&& ...__args) {
    _ConstructTransaction __tx(*this, 1);
    __alloc_traits::construct(this->__alloc(), std::__to_address(__tx.__pos_),
        std::forward<_Args>(__args)...);
    ++__tx.__pos_;
  }

  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
  allocator_type& __alloc() noexcept
      {return this->__end_cap_.second();}
  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
  const allocator_type& __alloc() const noexcept
      {return this->__end_cap_.second();}
  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
  pointer& __end_cap() noexcept
      {return this->__end_cap_.first();}
  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
  const pointer& __end_cap() const noexcept
      {return this->__end_cap_.first();}

  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
  void __clear() noexcept {__base_destruct_at_end(this->__begin_);}

  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
  void __base_destruct_at_end(pointer __new_last) noexcept {
    pointer __soon_to_be_end = this->__end_;
    while (__new_last != __soon_to_be_end)
        __alloc_traits::destroy(__alloc(), std::__to_address(--__soon_to_be_end));
    this->__end_ = __new_last;
  }

  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
  void __copy_assign_alloc(const vector& __c)
      {__copy_assign_alloc(__c, integral_constant<bool,
                    __alloc_traits::propagate_on_container_copy_assignment::value>());}

  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
  void __move_assign_alloc(vector& __c)
      noexcept(!__alloc_traits::propagate_on_container_move_assignment::value || is_nothrow_move_assignable<allocator_type>::value)


      {__move_assign_alloc(__c, integral_constant<bool,
                    __alloc_traits::propagate_on_container_move_assignment::value>());}

  [[noreturn]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
  void __throw_length_error() const {
      std::__throw_length_error("vector");
  }

  [[noreturn]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
  void __throw_out_of_range() const {
      std::__throw_out_of_range("vector");
  }

  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
  void __copy_assign_alloc(const vector& __c, true_type)
  {
    if (__alloc() != __c.__alloc())
    {
      __clear();
      __annotate_delete();
      __alloc_traits::deallocate(__alloc(), this->__begin_, capacity());
      this->__begin_ = this->__end_ = __end_cap() = nullptr;
    }
    __alloc() = __c.__alloc();
  }

  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
  void __copy_assign_alloc(const vector&, false_type)
  {}

  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
  void __move_assign_alloc(vector& __c, true_type)
      noexcept(is_nothrow_move_assignable<allocator_type>::value)
  {
    __alloc() = std::move(__c.__alloc());
  }

  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
  void __move_assign_alloc(vector&, false_type)
      noexcept
  {}
};


template<class _InputIterator,
         class _Alloc = allocator<__iter_value_type<_InputIterator>>,
         class = enable_if_t<__has_input_iterator_category<_InputIterator>::value>,
         class = enable_if_t<__is_allocator<_Alloc>::value>
         >
vector(_InputIterator, _InputIterator)
  -> vector<__iter_value_type<_InputIterator>, _Alloc>;

template<class _InputIterator,
         class _Alloc,
         class = enable_if_t<__has_input_iterator_category<_InputIterator>::value>,
         class = enable_if_t<__is_allocator<_Alloc>::value>
         >
vector(_InputIterator, _InputIterator, _Alloc)
  -> vector<__iter_value_type<_InputIterator>, _Alloc>;



template <ranges::input_range _Range,
          class _Alloc = allocator<ranges::range_value_t<_Range>>,
          class = enable_if_t<__is_allocator<_Alloc>::value>
          >
vector(from_range_t, _Range&&, _Alloc = _Alloc())
  -> vector<ranges::range_value_t<_Range>, _Alloc>;


template <class _Tp, class _Allocator>
constexpr
void
vector<_Tp, _Allocator>::__swap_out_circular_buffer(__split_buffer<value_type, allocator_type&>& __v)
{
    __annotate_delete();
    using _RevIter = std::reverse_iterator<pointer>;
    __v.__begin_ = std::__uninitialized_allocator_move_if_noexcept(
                       __alloc(), _RevIter(__end_), _RevIter(__begin_), _RevIter(__v.__begin_))
                       .base();
    std::swap(this->__begin_, __v.__begin_);
    std::swap(this->__end_, __v.__end_);
    std::swap(this->__end_cap(), __v.__end_cap());
    __v.__first_ = __v.__begin_;
    __annotate_new(size());
}

template <class _Tp, class _Allocator>
constexpr
typename vector<_Tp, _Allocator>::pointer
vector<_Tp, _Allocator>::__swap_out_circular_buffer(__split_buffer<value_type, allocator_type&>& __v, pointer __p)
{
    __annotate_delete();
    pointer __r = __v.__begin_;
    using _RevIter = std::reverse_iterator<pointer>;
    __v.__begin_ = std::__uninitialized_allocator_move_if_noexcept(
                       __alloc(), _RevIter(__p), _RevIter(__begin_), _RevIter(__v.__begin_))
                       .base();
    __v.__end_ = std::__uninitialized_allocator_move_if_noexcept(__alloc(), __p, __end_, __v.__end_);
    std::swap(this->__begin_, __v.__begin_);
    std::swap(this->__end_, __v.__end_);
    std::swap(this->__end_cap(), __v.__end_cap());
    __v.__first_ = __v.__begin_;
    __annotate_new(size());
    return __r;
}

template <class _Tp, class _Allocator>
constexpr
void
vector<_Tp, _Allocator>::__vdeallocate() noexcept
{
    if (this->__begin_ != nullptr)
    {
        clear();
        __annotate_delete();
        __alloc_traits::deallocate(this->__alloc(), this->__begin_, capacity());
        this->__begin_ = this->__end_ = this->__end_cap() = nullptr;
    }
}

template <class _Tp, class _Allocator>
constexpr
typename vector<_Tp, _Allocator>::size_type
vector<_Tp, _Allocator>::max_size() const noexcept
{
    return std::min<size_type>(__alloc_traits::max_size(this->__alloc()),
                                 numeric_limits<difference_type>::max());
}


template <class _Tp, class _Allocator>
constexpr
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
typename vector<_Tp, _Allocator>::size_type
vector<_Tp, _Allocator>::__recommend(size_type __new_size) const
{
    const size_type __ms = max_size();
    if (__new_size > __ms)
        this->__throw_length_error();
    const size_type __cap = capacity();
    if (__cap >= __ms / 2)
        return __ms;
    return std::max<size_type>(2 * __cap, __new_size);
}






template <class _Tp, class _Allocator>
constexpr
void
vector<_Tp, _Allocator>::__construct_at_end(size_type __n)
{
    _ConstructTransaction __tx(*this, __n);
    const_pointer __new_end = __tx.__new_end_;
    for (pointer __pos = __tx.__pos_; __pos != __new_end; __tx.__pos_ = ++__pos) {
        __alloc_traits::construct(this->__alloc(), std::__to_address(__pos));
    }
}







template <class _Tp, class _Allocator>
constexpr
inline
void
vector<_Tp, _Allocator>::__construct_at_end(size_type __n, const_reference __x)
{
    _ConstructTransaction __tx(*this, __n);
    const_pointer __new_end = __tx.__new_end_;
    for (pointer __pos = __tx.__pos_; __pos != __new_end; __tx.__pos_ = ++__pos) {
        __alloc_traits::construct(this->__alloc(), std::__to_address(__pos), __x);
    }
}

template <class _Tp, class _Allocator>
template <class _InputIterator, class _Sentinel>
constexpr void
vector<_Tp, _Allocator>::__construct_at_end(_InputIterator __first, _Sentinel __last, size_type __n) {
  _ConstructTransaction __tx(*this, __n);
  __tx.__pos_ = std::__uninitialized_allocator_copy(__alloc(), __first, __last, __tx.__pos_);
}





template <class _Tp, class _Allocator>
constexpr
void
vector<_Tp, _Allocator>::__append(size_type __n)
{
    if (static_cast<size_type>(this->__end_cap() - this->__end_) >= __n)
        this->__construct_at_end(__n);
    else
    {
        allocator_type& __a = this->__alloc();
        __split_buffer<value_type, allocator_type&> __v(__recommend(size() + __n), size(), __a);
        __v.__construct_at_end(__n);
        __swap_out_circular_buffer(__v);
    }
}





template <class _Tp, class _Allocator>
constexpr
void
vector<_Tp, _Allocator>::__append(size_type __n, const_reference __x)
{
    if (static_cast<size_type>(this->__end_cap() - this->__end_) >= __n)
        this->__construct_at_end(__n, __x);
    else
    {
        allocator_type& __a = this->__alloc();
        __split_buffer<value_type, allocator_type&> __v(__recommend(size() + __n), size(), __a);
        __v.__construct_at_end(__n, __x);
        __swap_out_circular_buffer(__v);
    }
}

template <class _Tp, class _Allocator>
constexpr
vector<_Tp, _Allocator>::vector(size_type __n)
{
    auto __guard = std::__make_exception_guard(__destroy_vector(*this));
    if (__n > 0)
    {
        __vallocate(__n);
        __construct_at_end(__n);
    }
    __guard.__complete();
}


template <class _Tp, class _Allocator>
constexpr
vector<_Tp, _Allocator>::vector(size_type __n, const allocator_type& __a)
    : __end_cap_(nullptr, __a)
{
    auto __guard = std::__make_exception_guard(__destroy_vector(*this));
    if (__n > 0)
    {
        __vallocate(__n);
        __construct_at_end(__n);
    }
    __guard.__complete();
}


template <class _Tp, class _Allocator>
constexpr
vector<_Tp, _Allocator>::vector(size_type __n, const value_type& __x)
{
    auto __guard = std::__make_exception_guard(__destroy_vector(*this));
    if (__n > 0)
    {
        __vallocate(__n);
        __construct_at_end(__n, __x);
    }
    __guard.__complete();
}

template <class _Tp, class _Allocator>
template <class _InputIterator, __enable_if_t<__has_exactly_input_iterator_category<_InputIterator>::value &&
                              is_constructible<_Tp, typename iterator_traits<_InputIterator>::reference>::value,
                          int> >
constexpr
vector<_Tp, _Allocator>::vector(_InputIterator __first, _InputIterator __last)
{
  __init_with_sentinel(__first, __last);
}

template <class _Tp, class _Allocator>
template <class _InputIterator, __enable_if_t<__has_exactly_input_iterator_category<_InputIterator>::value &&
                              is_constructible<_Tp, typename iterator_traits<_InputIterator>::reference>::value,
                          int> >
constexpr
vector<_Tp, _Allocator>::vector(_InputIterator __first, _InputIterator __last, const allocator_type& __a)
    : __end_cap_(nullptr, __a)
{
  __init_with_sentinel(__first, __last);
}

template <class _Tp, class _Allocator>
template <class _ForwardIterator, __enable_if_t<__has_forward_iterator_category<_ForwardIterator>::value &&
                        is_constructible<_Tp, typename iterator_traits<_ForwardIterator>::reference>::value,
                    int> >
constexpr
vector<_Tp, _Allocator>::vector(_ForwardIterator __first, _ForwardIterator __last)
{
  size_type __n = static_cast<size_type>(std::distance(__first, __last));
  __init_with_size(__first, __last, __n);
}

template <class _Tp, class _Allocator>
template <class _ForwardIterator, __enable_if_t<__has_forward_iterator_category<_ForwardIterator>::value &&
                        is_constructible<_Tp, typename iterator_traits<_ForwardIterator>::reference>::value,
                    int> >
constexpr
vector<_Tp, _Allocator>::vector(_ForwardIterator __first, _ForwardIterator __last, const allocator_type& __a)
    : __end_cap_(nullptr, __a)
{
  size_type __n = static_cast<size_type>(std::distance(__first, __last));
  __init_with_size(__first, __last, __n);
}

template <class _Tp, class _Allocator>
constexpr
vector<_Tp, _Allocator>::vector(const vector& __x)
    : __end_cap_(nullptr, __alloc_traits::select_on_container_copy_construction(__x.__alloc()))
{
  __init_with_size(__x.__begin_, __x.__end_, __x.size());
}

template <class _Tp, class _Allocator>
constexpr
vector<_Tp, _Allocator>::vector(const vector& __x, const __type_identity_t<allocator_type>& __a)
    : __end_cap_(nullptr, __a)
{
  __init_with_size(__x.__begin_, __x.__end_, __x.size());
}

template <class _Tp, class _Allocator>
constexpr
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
vector<_Tp, _Allocator>::vector(vector&& __x)

        noexcept



    : __end_cap_(nullptr, std::move(__x.__alloc()))
{
    this->__begin_ = __x.__begin_;
    this->__end_ = __x.__end_;
    this->__end_cap() = __x.__end_cap();
    __x.__begin_ = __x.__end_ = __x.__end_cap() = nullptr;
}

template <class _Tp, class _Allocator>
constexpr
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
vector<_Tp, _Allocator>::vector(vector&& __x, const __type_identity_t<allocator_type>& __a)
    : __end_cap_(nullptr, __a)
{
    if (__a == __x.__alloc())
    {
        this->__begin_ = __x.__begin_;
        this->__end_ = __x.__end_;
        this->__end_cap() = __x.__end_cap();
        __x.__begin_ = __x.__end_ = __x.__end_cap() = nullptr;
    }
    else
    {
        typedef move_iterator<iterator> _Ip;
        auto __guard = std::__make_exception_guard(__destroy_vector(*this));
        assign(_Ip(__x.begin()), _Ip(__x.end()));
        __guard.__complete();
    }
}



template <class _Tp, class _Allocator>
constexpr
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
vector<_Tp, _Allocator>::vector(initializer_list<value_type> __il)
{
    auto __guard = std::__make_exception_guard(__destroy_vector(*this));
    if (__il.size() > 0)
    {
        __vallocate(__il.size());
        __construct_at_end(__il.begin(), __il.end(), __il.size());
    }
    __guard.__complete();
}

template <class _Tp, class _Allocator>
constexpr
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
vector<_Tp, _Allocator>::vector(initializer_list<value_type> __il, const allocator_type& __a)
    : __end_cap_(nullptr, __a)
{
    auto __guard = std::__make_exception_guard(__destroy_vector(*this));
    if (__il.size() > 0)
    {
        __vallocate(__il.size());
        __construct_at_end(__il.begin(), __il.end(), __il.size());
    }
    __guard.__complete();
}



template <class _Tp, class _Allocator>
constexpr
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
vector<_Tp, _Allocator>&
vector<_Tp, _Allocator>::operator=(vector&& __x)
    noexcept((__noexcept_move_assign_container<_Allocator, __alloc_traits>::value))
{
    __move_assign(__x, integral_constant<bool,
          __alloc_traits::propagate_on_container_move_assignment::value>());
    return *this;
}

template <class _Tp, class _Allocator>
constexpr
void
vector<_Tp, _Allocator>::__move_assign(vector& __c, false_type)
    noexcept(__alloc_traits::is_always_equal::value)
{
    if (__alloc() != __c.__alloc())
    {
        typedef move_iterator<iterator> _Ip;
        assign(_Ip(__c.begin()), _Ip(__c.end()));
    }
    else
        __move_assign(__c, true_type());
}

template <class _Tp, class _Allocator>
constexpr
void
vector<_Tp, _Allocator>::__move_assign(vector& __c, true_type)
    noexcept(is_nothrow_move_assignable<allocator_type>::value)
{
    __vdeallocate();
    __move_assign_alloc(__c);
    this->__begin_ = __c.__begin_;
    this->__end_ = __c.__end_;
    this->__end_cap() = __c.__end_cap();
    __c.__begin_ = __c.__end_ = __c.__end_cap() = nullptr;
}

template <class _Tp, class _Allocator>
constexpr
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
vector<_Tp, _Allocator>&
vector<_Tp, _Allocator>::operator=(const vector& __x)
{
    if (this != std::addressof(__x))
    {
        __copy_assign_alloc(__x);
        assign(__x.__begin_, __x.__end_);
    }
    return *this;
}

template <class _Tp, class _Allocator>
template <class _InputIterator, __enable_if_t<__has_exactly_input_iterator_category<_InputIterator>::value &&
                              is_constructible<_Tp, typename iterator_traits<_InputIterator>::reference>::value,
                          int> >
constexpr void
vector<_Tp, _Allocator>::assign(_InputIterator __first, _InputIterator __last)
{
  __assign_with_sentinel(__first, __last);
}

template <class _Tp, class _Allocator>
template <class _Iterator, class _Sentinel>
constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
void vector<_Tp, _Allocator>::__assign_with_sentinel(_Iterator __first, _Sentinel __last) {
    clear();
    for (; __first != __last; ++__first)
        emplace_back(*__first);
}

template <class _Tp, class _Allocator>
template <class _ForwardIterator, __enable_if_t<__has_forward_iterator_category<_ForwardIterator>::value &&
                        is_constructible<_Tp, typename iterator_traits<_ForwardIterator>::reference>::value,
                    int> >
constexpr void
vector<_Tp, _Allocator>::assign(_ForwardIterator __first, _ForwardIterator __last)
{
  __assign_with_size(__first, __last, std::distance(__first, __last));
}

template <class _Tp, class _Allocator>
template <class _ForwardIterator, class _Sentinel>
constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
void vector<_Tp, _Allocator>::__assign_with_size(_ForwardIterator __first, _Sentinel __last, difference_type __n) {
    size_type __new_size = static_cast<size_type>(__n);
    if (__new_size <= capacity())
    {
        if (__new_size > size())
        {
            _ForwardIterator __mid = std::next(__first, size());
            std::copy(__first, __mid, this->__begin_);
            __construct_at_end(__mid, __last, __new_size - size());
        }
        else
        {
            pointer __m = std::__copy<_ClassicAlgPolicy>(__first, __last, this->__begin_).second;
            this->__destruct_at_end(__m);
        }
    }
    else
    {
        __vdeallocate();
        __vallocate(__recommend(__new_size));
        __construct_at_end(__first, __last, __new_size);
    }
}

template <class _Tp, class _Allocator>
constexpr
void
vector<_Tp, _Allocator>::assign(size_type __n, const_reference __u)
{
    if (__n <= capacity())
    {
        size_type __s = size();
        std::fill_n(this->__begin_, std::min(__n, __s), __u);
        if (__n > __s)
            __construct_at_end(__n - __s, __u);
        else
            this->__destruct_at_end(this->__begin_ + __n);
    }
    else
    {
        __vdeallocate();
        __vallocate(__recommend(static_cast<size_type>(__n)));
        __construct_at_end(__n, __u);
    }
}

template <class _Tp, class _Allocator>
constexpr
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
typename vector<_Tp, _Allocator>::iterator
vector<_Tp, _Allocator>::begin() noexcept
{
    return __make_iter(this->__begin_);
}

template <class _Tp, class _Allocator>
constexpr
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
typename vector<_Tp, _Allocator>::const_iterator
vector<_Tp, _Allocator>::begin() const noexcept
{
    return __make_iter(this->__begin_);
}

template <class _Tp, class _Allocator>
constexpr
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
typename vector<_Tp, _Allocator>::iterator
vector<_Tp, _Allocator>::end() noexcept
{
    return __make_iter(this->__end_);
}

template <class _Tp, class _Allocator>
constexpr
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
typename vector<_Tp, _Allocator>::const_iterator
vector<_Tp, _Allocator>::end() const noexcept
{
    return __make_iter(this->__end_);
}

template <class _Tp, class _Allocator>
constexpr
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
typename vector<_Tp, _Allocator>::reference
vector<_Tp, _Allocator>::operator[](size_type __n) noexcept
{
    ((void)0);
    return this->__begin_[__n];
}

template <class _Tp, class _Allocator>
constexpr
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
typename vector<_Tp, _Allocator>::const_reference
vector<_Tp, _Allocator>::operator[](size_type __n) const noexcept
{
    ((void)0);
    return this->__begin_[__n];
}

template <class _Tp, class _Allocator>
constexpr
typename vector<_Tp, _Allocator>::reference
vector<_Tp, _Allocator>::at(size_type __n)
{
    if (__n >= size())
        this->__throw_out_of_range();
    return this->__begin_[__n];
}

template <class _Tp, class _Allocator>
constexpr
typename vector<_Tp, _Allocator>::const_reference
vector<_Tp, _Allocator>::at(size_type __n) const
{
    if (__n >= size())
        this->__throw_out_of_range();
    return this->__begin_[__n];
}

template <class _Tp, class _Allocator>
constexpr
void
vector<_Tp, _Allocator>::reserve(size_type __n)
{
    if (__n > capacity())
    {
        if (__n > max_size())
            this->__throw_length_error();
        allocator_type& __a = this->__alloc();
        __split_buffer<value_type, allocator_type&> __v(__n, size(), __a);
        __swap_out_circular_buffer(__v);
    }
}

template <class _Tp, class _Allocator>
constexpr
void
vector<_Tp, _Allocator>::shrink_to_fit() noexcept
{
    if (capacity() > size())
    {




            allocator_type& __a = this->__alloc();
            __split_buffer<value_type, allocator_type&> __v(size(), size(), __a);
            __swap_out_circular_buffer(__v);






    }
}

template <class _Tp, class _Allocator>
template <class _Up>
constexpr
void
vector<_Tp, _Allocator>::__push_back_slow_path(_Up&& __x)
{
    allocator_type& __a = this->__alloc();
    __split_buffer<value_type, allocator_type&> __v(__recommend(size() + 1), size(), __a);

    __alloc_traits::construct(__a, std::__to_address(__v.__end_), std::forward<_Up>(__x));
    __v.__end_++;
    __swap_out_circular_buffer(__v);
}

template <class _Tp, class _Allocator>
constexpr
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
void
vector<_Tp, _Allocator>::push_back(const_reference __x)
{
    if (this->__end_ != this->__end_cap())
    {
        __construct_one_at_end(__x);
    }
    else
        __push_back_slow_path(__x);
}

template <class _Tp, class _Allocator>
constexpr
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
void
vector<_Tp, _Allocator>::push_back(value_type&& __x)
{
    if (this->__end_ < this->__end_cap())
    {
        __construct_one_at_end(std::move(__x));
    }
    else
        __push_back_slow_path(std::move(__x));
}

template <class _Tp, class _Allocator>
template <class... _Args>
constexpr
void
vector<_Tp, _Allocator>::__emplace_back_slow_path(_Args&&... __args)
{
    allocator_type& __a = this->__alloc();
    __split_buffer<value_type, allocator_type&> __v(__recommend(size() + 1), size(), __a);

    __alloc_traits::construct(__a, std::__to_address(__v.__end_), std::forward<_Args>(__args)...);
    __v.__end_++;
    __swap_out_circular_buffer(__v);
}

template <class _Tp, class _Allocator>
template <class... _Args>
constexpr
inline

typename vector<_Tp, _Allocator>::reference



vector<_Tp, _Allocator>::emplace_back(_Args&&... __args)
{
    if (this->__end_ < this->__end_cap())
    {
        __construct_one_at_end(std::forward<_Args>(__args)...);
    }
    else
        __emplace_back_slow_path(std::forward<_Args>(__args)...);

    return this->back();

}

template <class _Tp, class _Allocator>
constexpr
inline
void
vector<_Tp, _Allocator>::pop_back()
{
    ((void)0);
    this->__destruct_at_end(this->__end_ - 1);
}

template <class _Tp, class _Allocator>
constexpr
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
typename vector<_Tp, _Allocator>::iterator
vector<_Tp, _Allocator>::erase(const_iterator __position)
{
    ((void)0);

    difference_type __ps = __position - cbegin();
    pointer __p = this->__begin_ + __ps;
    this->__destruct_at_end(std::move(__p + 1, this->__end_, __p));
    return __make_iter(__p);
}

template <class _Tp, class _Allocator>
constexpr
typename vector<_Tp, _Allocator>::iterator
vector<_Tp, _Allocator>::erase(const_iterator __first, const_iterator __last)
{
    ((void)0);
    pointer __p = this->__begin_ + (__first - begin());
    if (__first != __last) {
        this->__destruct_at_end(std::move(__p + (__last - __first), this->__end_, __p));
    }
    return __make_iter(__p);
}

template <class _Tp, class _Allocator>
constexpr
void
vector<_Tp, _Allocator>::__move_range(pointer __from_s, pointer __from_e, pointer __to)
{
    pointer __old_last = this->__end_;
    difference_type __n = __old_last - __to;
    {
      pointer __i = __from_s + __n;
      _ConstructTransaction __tx(*this, __from_e - __i);
      for (pointer __pos = __tx.__pos_; __i < __from_e;
           ++__i, (void) ++__pos, __tx.__pos_ = __pos) {
          __alloc_traits::construct(this->__alloc(),
                                    std::__to_address(__pos),
                                    std::move(*__i));
      }
    }
    std::move_backward(__from_s, __from_s + __n, __old_last);
}

template <class _Tp, class _Allocator>
constexpr
typename vector<_Tp, _Allocator>::iterator
vector<_Tp, _Allocator>::insert(const_iterator __position, const_reference __x)
{
    pointer __p = this->__begin_ + (__position - begin());

    if (!__libcpp_is_constant_evaluated() && this->__end_ < this->__end_cap())
    {
        if (__p == this->__end_)
        {
            __construct_one_at_end(__x);
        }
        else
        {
            __move_range(__p, this->__end_, __p + 1);
            const_pointer __xr = pointer_traits<const_pointer>::pointer_to(__x);
            if (__p <= __xr && __xr < this->__end_)
                ++__xr;
            *__p = *__xr;
        }
    }
    else
    {
        allocator_type& __a = this->__alloc();
        __split_buffer<value_type, allocator_type&> __v(__recommend(size() + 1), __p - this->__begin_, __a);
        __v.push_back(__x);
        __p = __swap_out_circular_buffer(__v, __p);
    }
    return __make_iter(__p);
}

template <class _Tp, class _Allocator>
constexpr
typename vector<_Tp, _Allocator>::iterator
vector<_Tp, _Allocator>::insert(const_iterator __position, value_type&& __x)
{
    pointer __p = this->__begin_ + (__position - begin());
    if (this->__end_ < this->__end_cap())
    {
        if (__p == this->__end_)
        {
            __construct_one_at_end(std::move(__x));
        }
        else
        {
            __move_range(__p, this->__end_, __p + 1);
            *__p = std::move(__x);
        }
    }
    else
    {
        allocator_type& __a = this->__alloc();
        __split_buffer<value_type, allocator_type&> __v(__recommend(size() + 1), __p - this->__begin_, __a);
        __v.push_back(std::move(__x));
        __p = __swap_out_circular_buffer(__v, __p);
    }
    return __make_iter(__p);
}

template <class _Tp, class _Allocator>
template <class... _Args>
constexpr
typename vector<_Tp, _Allocator>::iterator
vector<_Tp, _Allocator>::emplace(const_iterator __position, _Args&&... __args)
{
    pointer __p = this->__begin_ + (__position - begin());
    if (this->__end_ < this->__end_cap())
    {
        if (__p == this->__end_)
        {
            __construct_one_at_end(std::forward<_Args>(__args)...);
        }
        else
        {
            __temp_value<value_type, _Allocator> __tmp(this->__alloc(), std::forward<_Args>(__args)...);
            __move_range(__p, this->__end_, __p + 1);
            *__p = std::move(__tmp.get());
        }
    }
    else
    {
        allocator_type& __a = this->__alloc();
        __split_buffer<value_type, allocator_type&> __v(__recommend(size() + 1), __p - this->__begin_, __a);
        __v.emplace_back(std::forward<_Args>(__args)...);
        __p = __swap_out_circular_buffer(__v, __p);
    }
    return __make_iter(__p);
}

template <class _Tp, class _Allocator>
constexpr
typename vector<_Tp, _Allocator>::iterator
vector<_Tp, _Allocator>::insert(const_iterator __position, size_type __n, const_reference __x)
{
    pointer __p = this->__begin_ + (__position - begin());
    if (__n > 0)
    {

        if (!__libcpp_is_constant_evaluated() && __n <= static_cast<size_type>(this->__end_cap() - this->__end_))
        {
            size_type __old_n = __n;
            pointer __old_last = this->__end_;
            if (__n > static_cast<size_type>(this->__end_ - __p))
            {
                size_type __cx = __n - (this->__end_ - __p);
                __construct_at_end(__cx, __x);
                __n -= __cx;
            }
            if (__n > 0)
            {
                __move_range(__p, __old_last, __p + __old_n);
                const_pointer __xr = pointer_traits<const_pointer>::pointer_to(__x);
                if (__p <= __xr && __xr < this->__end_)
                    __xr += __old_n;
                std::fill_n(__p, __n, *__xr);
            }
        }
        else
        {
            allocator_type& __a = this->__alloc();
            __split_buffer<value_type, allocator_type&> __v(__recommend(size() + __n), __p - this->__begin_, __a);
            __v.__construct_at_end(__n, __x);
            __p = __swap_out_circular_buffer(__v, __p);
        }
    }
    return __make_iter(__p);
}
template <class _Tp, class _Allocator>
template <class _InputIterator, __enable_if_t<__has_exactly_input_iterator_category<_InputIterator>::value &&
                              is_constructible<_Tp, typename iterator_traits<_InputIterator>::reference>::value,
                          int> >
constexpr typename vector<_Tp, _Allocator>::iterator
vector<_Tp, _Allocator>::insert(const_iterator __position, _InputIterator __first, _InputIterator __last)
{
  return __insert_with_sentinel(__position, __first, __last);
}

template <class _Tp, class _Allocator>
template <class _InputIterator, class _Sentinel>
constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
typename vector<_Tp, _Allocator>::iterator
vector<_Tp, _Allocator>::__insert_with_sentinel(const_iterator __position, _InputIterator __first, _Sentinel __last) {
    difference_type __off = __position - begin();
    pointer __p = this->__begin_ + __off;
    allocator_type& __a = this->__alloc();
    pointer __old_last = this->__end_;
    for (; this->__end_ != this->__end_cap() && __first != __last; ++__first)
    {
        __construct_one_at_end(*__first);
    }
    __split_buffer<value_type, allocator_type&> __v(__a);
    if (__first != __last)
    {




            __v.__construct_at_end_with_sentinel(std::move(__first), std::move(__last));
            difference_type __old_size = __old_last - this->__begin_;
            difference_type __old_p = __p - this->__begin_;
            reserve(__recommend(size() + __v.size()));
            __p = this->__begin_ + __old_p;
            __old_last = this->__begin_ + __old_size;
# 1916 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/vector" 3
    }
    __p = std::rotate(__p, __old_last, this->__end_);
    insert(__make_iter(__p), std::make_move_iterator(__v.begin()),
                             std::make_move_iterator(__v.end()));
    return begin() + __off;
}

template <class _Tp, class _Allocator>
template <class _ForwardIterator, __enable_if_t<__has_forward_iterator_category<_ForwardIterator>::value &&
                        is_constructible<_Tp, typename iterator_traits<_ForwardIterator>::reference>::value,
                    int> >
constexpr typename vector<_Tp, _Allocator>::iterator
vector<_Tp, _Allocator>::insert(const_iterator __position, _ForwardIterator __first, _ForwardIterator __last)
{
  return __insert_with_size(__position, __first, __last, std::distance(__first, __last));
}

template <class _Tp, class _Allocator>
template <class _Iterator, class _Sentinel>
constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
typename vector<_Tp, _Allocator>::iterator
vector<_Tp, _Allocator>::__insert_with_size(const_iterator __position, _Iterator __first, _Sentinel __last,
                                            difference_type __n) {
    auto __insertion_size = __n;
    pointer __p = this->__begin_ + (__position - begin());
    if (__n > 0)
    {
        if (__n <= this->__end_cap() - this->__end_)
        {
            size_type __old_n = __n;
            pointer __old_last = this->__end_;
            _Iterator __m = std::next(__first, __n);
            difference_type __dx = this->__end_ - __p;
            if (__n > __dx)
            {
                __m = __first;
                difference_type __diff = this->__end_ - __p;
                std::advance(__m, __diff);
                __construct_at_end(__m, __last, __n - __diff);
                __n = __dx;
            }
            if (__n > 0)
            {
                __move_range(__p, __old_last, __p + __old_n);
                std::copy(__first, __m, __p);
            }
        }
        else
        {
            allocator_type& __a = this->__alloc();
            __split_buffer<value_type, allocator_type&> __v(__recommend(size() + __n), __p - this->__begin_, __a);
            __v.__construct_at_end_with_size(__first, __insertion_size);
            __p = __swap_out_circular_buffer(__v, __p);
        }
    }
    return __make_iter(__p);
}

template <class _Tp, class _Allocator>
constexpr
void
vector<_Tp, _Allocator>::resize(size_type __sz)
{
    size_type __cs = size();
    if (__cs < __sz)
        this->__append(__sz - __cs);
    else if (__cs > __sz)
        this->__destruct_at_end(this->__begin_ + __sz);
}

template <class _Tp, class _Allocator>
constexpr
void
vector<_Tp, _Allocator>::resize(size_type __sz, const_reference __x)
{
    size_type __cs = size();
    if (__cs < __sz)
        this->__append(__sz - __cs, __x);
    else if (__cs > __sz)
        this->__destruct_at_end(this->__begin_ + __sz);
}

template <class _Tp, class _Allocator>
constexpr
void
vector<_Tp, _Allocator>::swap(vector& __x)

    noexcept




{
    ((void)0);



    std::swap(this->__begin_, __x.__begin_);
    std::swap(this->__end_, __x.__end_);
    std::swap(this->__end_cap(), __x.__end_cap());
    std::__swap_allocator(this->__alloc(), __x.__alloc(),
        integral_constant<bool,__alloc_traits::propagate_on_container_swap::value>());
}

template <class _Tp, class _Allocator>
constexpr
bool
vector<_Tp, _Allocator>::__invariants() const
{
    if (this->__begin_ == nullptr)
    {
        if (this->__end_ != nullptr || this->__end_cap() != nullptr)
            return false;
    }
    else
    {
        if (this->__begin_ > this->__end_)
            return false;
        if (this->__begin_ == this->__end_cap())
            return false;
        if (this->__end_ > this->__end_cap())
            return false;
    }
    return true;
}



template <class _Allocator> class vector<bool, _Allocator>;

template <class _Allocator> struct hash<vector<bool, _Allocator> >;

template <class _Allocator>
struct __has_storage_type<vector<bool, _Allocator> >
{
    static const bool value = true;
};

template <class _Allocator>
class vector<bool, _Allocator>
{
public:
    typedef vector __self;
    typedef bool value_type;
    typedef _Allocator allocator_type;
    typedef allocator_traits<allocator_type> __alloc_traits;
    typedef typename __alloc_traits::size_type size_type;
    typedef typename __alloc_traits::difference_type difference_type;
    typedef size_type __storage_type;
    typedef __bit_iterator<vector, false> pointer;
    typedef __bit_iterator<vector, true> const_pointer;
    typedef pointer iterator;
    typedef const_pointer const_iterator;
    typedef std::reverse_iterator<iterator> reverse_iterator;
    typedef std::reverse_iterator<const_iterator> const_reverse_iterator;

private:
    typedef __rebind_alloc<__alloc_traits, __storage_type> __storage_allocator;
    typedef allocator_traits<__storage_allocator> __storage_traits;
    typedef typename __storage_traits::pointer __storage_pointer;
    typedef typename __storage_traits::const_pointer __const_storage_pointer;

    __storage_pointer __begin_;
    size_type __size_;
    __compressed_pair<size_type, __storage_allocator> __cap_alloc_;
public:
    typedef __bit_reference<vector> reference;



    typedef __bit_const_reference<vector> const_reference;

private:
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    size_type& __cap() noexcept
        {return __cap_alloc_.first();}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    const size_type& __cap() const noexcept
        {return __cap_alloc_.first();}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    __storage_allocator& __alloc() noexcept
        {return __cap_alloc_.second();}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    const __storage_allocator& __alloc() const noexcept
        {return __cap_alloc_.second();}

    static const unsigned __bits_per_word = static_cast<unsigned>(sizeof(__storage_type) * 8);

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    static size_type __internal_cap_to_external(size_type __n) noexcept
        {return __n * __bits_per_word;}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    static size_type __external_cap_to_internal(size_type __n) noexcept
        {return (__n - 1) / __bits_per_word + 1;}

public:
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    vector() noexcept(is_nothrow_default_constructible<allocator_type>::value);

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr explicit vector(const allocator_type& __a)



        noexcept;


private:
  class __destroy_vector {
    public:
      constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) __destroy_vector(vector& __vec) : __vec_(__vec) {}

      constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) void operator()() {
        if (__vec_.__begin_ != nullptr)
            __storage_traits::deallocate(__vec_.__alloc(), __vec_.__begin_, __vec_.__cap());
      }

    private:
      vector& __vec_;
  };

public:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr ~vector() { __destroy_vector(*this)(); }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr explicit vector(size_type __n);

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr explicit vector(size_type __n, const allocator_type& __a);

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr vector(size_type __n, const value_type& __v);
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr vector(size_type __n, const value_type& __v, const allocator_type& __a);
    template <class _InputIterator, __enable_if_t<__has_exactly_input_iterator_category<_InputIterator>::value, int> = 0>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr vector(_InputIterator __first, _InputIterator __last);
    template <class _InputIterator, __enable_if_t<__has_exactly_input_iterator_category<_InputIterator>::value, int> = 0>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr vector(_InputIterator __first, _InputIterator __last, const allocator_type& __a);
    template <class _ForwardIterator, __enable_if_t<__has_forward_iterator_category<_ForwardIterator>::value, int> = 0>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr vector(_ForwardIterator __first, _ForwardIterator __last);
    template <class _ForwardIterator, __enable_if_t<__has_forward_iterator_category<_ForwardIterator>::value, int> = 0>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr vector(_ForwardIterator __first, _ForwardIterator __last, const allocator_type& __a);


    template <_ContainerCompatibleRange<bool> _Range>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    vector(from_range_t, _Range&& __range, const allocator_type& __a = allocator_type())
    : __begin_(nullptr),
      __size_(0),
      __cap_alloc_(0, static_cast<__storage_allocator>(__a)) {
      if constexpr (ranges::forward_range<_Range> || ranges::sized_range<_Range>) {
        auto __n = static_cast<size_type>(ranges::distance(__range));
        __init_with_size(ranges::begin(__range), ranges::end(__range), __n);

      } else {
        __init_with_sentinel(ranges::begin(__range), ranges::end(__range));
      }
    }


    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr vector(const vector& __v);
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr vector(const vector& __v, const allocator_type& __a);
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr vector& operator=(const vector& __v);


    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr vector(initializer_list<value_type> __il);
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr vector(initializer_list<value_type> __il, const allocator_type& __a);

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    vector& operator=(initializer_list<value_type> __il)
        {assign(__il.begin(), __il.end()); return *this;}



    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    vector(vector&& __v)

        noexcept;



    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr vector(vector&& __v, const __type_identity_t<allocator_type>& __a);
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    vector& operator=(vector&& __v)
        noexcept((__noexcept_move_assign_container<_Allocator, __alloc_traits>::value));

    template <class _InputIterator, __enable_if_t<__has_exactly_input_iterator_category<_InputIterator>::value, int> = 0>
    void
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr assign(_InputIterator __first, _InputIterator __last);
    template <class _ForwardIterator, __enable_if_t<__has_forward_iterator_category<_ForwardIterator>::value, int> = 0>
    void
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr assign(_ForwardIterator __first, _ForwardIterator __last);


    template <_ContainerCompatibleRange<bool> _Range>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    constexpr void assign_range(_Range&& __range) {
      if constexpr (ranges::forward_range<_Range> || ranges::sized_range<_Range>) {
        auto __n = static_cast<size_type>(ranges::distance(__range));
        __assign_with_size(ranges::begin(__range), ranges::end(__range), __n);

      } else {
        __assign_with_sentinel(ranges::begin(__range), ranges::end(__range));
      }
    }


    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr void assign(size_type __n, const value_type& __x);


    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    void assign(initializer_list<value_type> __il)
        {assign(__il.begin(), __il.end());}


    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr allocator_type get_allocator() const noexcept
        {return allocator_type(this->__alloc());}

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr size_type max_size() const noexcept;
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    size_type capacity() const noexcept
        {return __internal_cap_to_external(__cap());}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    size_type size() const noexcept
        {return __size_;}
    [[__nodiscard__]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    bool empty() const noexcept
        {return __size_ == 0;}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr void reserve(size_type __n);
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr void shrink_to_fit() noexcept;

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    iterator begin() noexcept
        {return __make_iter(0);}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    const_iterator begin() const noexcept
        {return __make_iter(0);}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    iterator end() noexcept
        {return __make_iter(__size_);}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    const_iterator end() const noexcept
        {return __make_iter(__size_);}

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    reverse_iterator rbegin() noexcept
        {return reverse_iterator(end());}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    const_reverse_iterator rbegin() const noexcept
        {return const_reverse_iterator(end());}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    reverse_iterator rend() noexcept
        {return reverse_iterator(begin());}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    const_reverse_iterator rend() const noexcept
        {return const_reverse_iterator(begin());}

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    const_iterator cbegin() const noexcept
        {return __make_iter(0);}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    const_iterator cend() const noexcept
        {return __make_iter(__size_);}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    const_reverse_iterator crbegin() const noexcept
        {return rbegin();}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    const_reverse_iterator crend() const noexcept
        {return rend();}

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr reference operator[](size_type __n) {return __make_ref(__n);}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr const_reference operator[](size_type __n) const {return __make_ref(__n);}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) reference at(size_type __n);
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) const_reference at(size_type __n) const;

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr reference front() {return __make_ref(0);}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr const_reference front() const {return __make_ref(0);}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr reference back() {return __make_ref(__size_ - 1);}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr const_reference back() const {return __make_ref(__size_ - 1);}

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr void push_back(const value_type& __x);

    template <class... _Args>

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr reference emplace_back(_Args&&... __args)



    {
        push_back ( value_type ( std::forward<_Args>(__args)... ));

        return this->back();

    }



    template <_ContainerCompatibleRange<bool> _Range>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    constexpr void append_range(_Range&& __range) {
      insert_range(end(), std::forward<_Range>(__range));
    }


    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr void pop_back() {--__size_;}


    template <class... _Args>
   __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr iterator emplace(const_iterator __position, _Args&&... __args)
        { return insert ( __position, value_type ( std::forward<_Args>(__args)... )); }


    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr iterator insert(const_iterator __position, const value_type& __x);
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr iterator insert(const_iterator __position, size_type __n, const value_type& __x);
    template <class _InputIterator, __enable_if_t<__has_exactly_input_iterator_category<_InputIterator>::value, int> = 0>
        iterator
        __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr insert(const_iterator __position, _InputIterator __first, _InputIterator __last);
    template <class _ForwardIterator, __enable_if_t<__has_forward_iterator_category<_ForwardIterator>::value, int> = 0>
        iterator
        __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr insert(const_iterator __position, _ForwardIterator __first, _ForwardIterator __last);


    template <_ContainerCompatibleRange<bool> _Range>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    constexpr iterator insert_range(const_iterator __position, _Range&& __range) {
      if constexpr (ranges::forward_range<_Range> || ranges::sized_range<_Range>) {
        auto __n = static_cast<size_type>(ranges::distance(__range));
        return __insert_with_size(__position, ranges::begin(__range), ranges::end(__range), __n);

      } else {
        return __insert_with_sentinel(__position, ranges::begin(__range), ranges::end(__range));
      }
    }



    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    iterator insert(const_iterator __position, initializer_list<value_type> __il)
        {return insert(__position, __il.begin(), __il.end());}


    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr iterator erase(const_iterator __position);
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr iterator erase(const_iterator __first, const_iterator __last);

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    void clear() noexcept {__size_ = 0;}

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr void swap(vector&)

        noexcept;




    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr static void swap(reference __x, reference __y) noexcept { std::swap(__x, __y); }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr void resize(size_type __sz, value_type __x = false);
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr void flip() noexcept;

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr bool __invariants() const;

private:
    [[noreturn]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    void __throw_length_error() const {
        std::__throw_length_error("vector");
    }

    [[noreturn]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
    void __throw_out_of_range() const {
        std::__throw_out_of_range("vector");
    }

    template <class _InputIterator, class _Sentinel>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    void __init_with_size(_InputIterator __first, _Sentinel __last, size_type __n) {
      auto __guard = std::__make_exception_guard(__destroy_vector(*this));

      if (__n > 0) {
        __vallocate(__n);
        __construct_at_end(std::move(__first), std::move(__last), __n);
      }

      __guard.__complete();
    }

    template <class _InputIterator, class _Sentinel>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    void __init_with_sentinel(_InputIterator __first, _Sentinel __last) {



        for (; __first != __last; ++__first)
            push_back(*__first);







    }

  template <class _Iterator, class _Sentinel>
  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
  void __assign_with_sentinel(_Iterator __first, _Sentinel __last);

  template <class _ForwardIterator, class _Sentinel>
  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
  void __assign_with_size(_ForwardIterator __first, _Sentinel __last, difference_type __ns);

  template <class _InputIterator, class _Sentinel>
  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
  iterator __insert_with_sentinel(const_iterator __position, _InputIterator __first, _Sentinel __last);

  template <class _Iterator, class _Sentinel>
  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
  iterator __insert_with_size(const_iterator __position, _Iterator __first, _Sentinel __last, difference_type __n);
# 2436 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/vector" 3
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr void __vallocate(size_type __n) {
        if (__n > max_size())
            __throw_length_error();
        auto __allocation = std::__allocate_at_least(__alloc(), __external_cap_to_internal(__n));
        __begin_ = __allocation.ptr;
        __size_ = 0;
        __cap() = __allocation.count;
        if (__libcpp_is_constant_evaluated()) {
            for (size_type __i = 0; __i != __cap(); ++__i)
                std::__construct_at(std::__to_address(__begin_) + __i);
        }
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr void __vdeallocate() noexcept;
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    static size_type __align_it(size_type __new_size) noexcept
        {return (__new_size + (__bits_per_word-1)) & ~((size_type)__bits_per_word-1);}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr size_type __recommend(size_type __new_size) const;
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr void __construct_at_end(size_type __n, bool __x);
    template <class _InputIterator, class _Sentinel>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    void __construct_at_end(_InputIterator __first, _Sentinel __last, size_type __n);
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr void __append(size_type __n, const_reference __x);
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    reference __make_ref(size_type __pos) noexcept
        {return reference(__begin_ + __pos / __bits_per_word, __storage_type(1) << __pos % __bits_per_word);}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    const_reference __make_ref(size_type __pos) const noexcept {
        return __bit_const_reference<vector>(__begin_ + __pos / __bits_per_word,
                                             __storage_type(1) << __pos % __bits_per_word);
    }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    iterator __make_iter(size_type __pos) noexcept
        {return iterator(__begin_ + __pos / __bits_per_word, static_cast<unsigned>(__pos % __bits_per_word));}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    const_iterator __make_iter(size_type __pos) const noexcept
        {return const_iterator(__begin_ + __pos / __bits_per_word, static_cast<unsigned>(__pos % __bits_per_word));}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    iterator __const_iterator_cast(const_iterator __p) noexcept
        {return begin() + (__p - cbegin());}

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    void __copy_assign_alloc(const vector& __v)
        {__copy_assign_alloc(__v, integral_constant<bool,
                      __storage_traits::propagate_on_container_copy_assignment::value>());}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    void __copy_assign_alloc(const vector& __c, true_type)
        {
            if (__alloc() != __c.__alloc())
                __vdeallocate();
            __alloc() = __c.__alloc();
        }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    void __copy_assign_alloc(const vector&, false_type)
        {}

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr void __move_assign(vector& __c, false_type);
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr void __move_assign(vector& __c, true_type)
        noexcept(is_nothrow_move_assignable<allocator_type>::value);
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    void __move_assign_alloc(vector& __c)
        noexcept(!__storage_traits::propagate_on_container_move_assignment::value || is_nothrow_move_assignable<allocator_type>::value)


        {__move_assign_alloc(__c, integral_constant<bool,
                      __storage_traits::propagate_on_container_move_assignment::value>());}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    void __move_assign_alloc(vector& __c, true_type)
        noexcept(is_nothrow_move_assignable<allocator_type>::value)
        {
            __alloc() = std::move(__c.__alloc());
        }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    void __move_assign_alloc(vector&, false_type)
        noexcept
        {}

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr size_t __hash_code() const noexcept;

    friend class __bit_reference<vector>;
    friend class __bit_const_reference<vector>;
    friend class __bit_iterator<vector, false>;
    friend class __bit_iterator<vector, true>;
    friend struct __bit_array<vector>;
    friend struct hash<vector>;
};

template <class _Allocator>
constexpr void
vector<bool, _Allocator>::__vdeallocate() noexcept
{
    if (this->__begin_ != nullptr)
    {
        __storage_traits::deallocate(this->__alloc(), this->__begin_, __cap());
        this->__begin_ = nullptr;
        this->__size_ = this->__cap() = 0;
    }
}

template <class _Allocator>
constexpr
typename vector<bool, _Allocator>::size_type
vector<bool, _Allocator>::max_size() const noexcept
{
    size_type __amax = __storage_traits::max_size(__alloc());
    size_type __nmax = numeric_limits<size_type>::max() / 2;
    if (__nmax / __bits_per_word <= __amax)
        return __nmax;
    return __internal_cap_to_external(__amax);
}


template <class _Allocator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
typename vector<bool, _Allocator>::size_type
vector<bool, _Allocator>::__recommend(size_type __new_size) const
{
    const size_type __ms = max_size();
    if (__new_size > __ms)
        this->__throw_length_error();
    const size_type __cap = capacity();
    if (__cap >= __ms / 2)
        return __ms;
    return std::max(2 * __cap, __align_it(__new_size));
}





template <class _Allocator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
void
vector<bool, _Allocator>::__construct_at_end(size_type __n, bool __x)
{
    size_type __old_size = this->__size_;
    this->__size_ += __n;
    if (__old_size == 0 || ((__old_size - 1) / __bits_per_word) != ((this->__size_ - 1) / __bits_per_word))
    {
        if (this->__size_ <= __bits_per_word)
            this->__begin_[0] = __storage_type(0);
        else
            this->__begin_[(this->__size_ - 1) / __bits_per_word] = __storage_type(0);
    }
    std::fill_n(__make_iter(__old_size), __n, __x);
}

template <class _Allocator>
template <class _InputIterator, class _Sentinel>
constexpr
void vector<bool, _Allocator>::__construct_at_end(_InputIterator __first, _Sentinel __last, size_type __n) {
    size_type __old_size = this->__size_;
    this->__size_ += __n;
    if (__old_size == 0 || ((__old_size - 1) / __bits_per_word) != ((this->__size_ - 1) / __bits_per_word))
    {
        if (this->__size_ <= __bits_per_word)
            this->__begin_[0] = __storage_type(0);
        else
            this->__begin_[(this->__size_ - 1) / __bits_per_word] = __storage_type(0);
    }
    std::__copy<_ClassicAlgPolicy>(__first, __last, __make_iter(__old_size));
}

template <class _Allocator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
vector<bool, _Allocator>::vector()
    noexcept(is_nothrow_default_constructible<allocator_type>::value)
    : __begin_(nullptr),
      __size_(0),
      __cap_alloc_(0, __default_init_tag())
{
}

template <class _Allocator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
vector<bool, _Allocator>::vector(const allocator_type& __a)



        noexcept

    : __begin_(nullptr),
      __size_(0),
      __cap_alloc_(0, static_cast<__storage_allocator>(__a))
{
}

template <class _Allocator>
constexpr
vector<bool, _Allocator>::vector(size_type __n)
    : __begin_(nullptr),
      __size_(0),
      __cap_alloc_(0, __default_init_tag())
{
    if (__n > 0)
    {
        __vallocate(__n);
        __construct_at_end(__n, false);
    }
}


template <class _Allocator>
constexpr
vector<bool, _Allocator>::vector(size_type __n, const allocator_type& __a)
    : __begin_(nullptr),
      __size_(0),
      __cap_alloc_(0, static_cast<__storage_allocator>(__a))
{
    if (__n > 0)
    {
        __vallocate(__n);
        __construct_at_end(__n, false);
    }
}


template <class _Allocator>
constexpr
vector<bool, _Allocator>::vector(size_type __n, const value_type& __x)
    : __begin_(nullptr),
      __size_(0),
      __cap_alloc_(0, __default_init_tag())
{
    if (__n > 0)
    {
        __vallocate(__n);
        __construct_at_end(__n, __x);
    }
}

template <class _Allocator>
constexpr
vector<bool, _Allocator>::vector(size_type __n, const value_type& __x, const allocator_type& __a)
    : __begin_(nullptr),
      __size_(0),
      __cap_alloc_(0, static_cast<__storage_allocator>(__a))
{
    if (__n > 0)
    {
        __vallocate(__n);
        __construct_at_end(__n, __x);
    }
}

template <class _Allocator>
template <class _InputIterator, __enable_if_t<__has_exactly_input_iterator_category<_InputIterator>::value, int> >
constexpr
vector<bool, _Allocator>::vector(_InputIterator __first, _InputIterator __last)
    : __begin_(nullptr),
      __size_(0),
      __cap_alloc_(0, __default_init_tag())
{
  __init_with_sentinel(__first, __last);
}

template <class _Allocator>
template <class _InputIterator, __enable_if_t<__has_exactly_input_iterator_category<_InputIterator>::value, int> >
constexpr
vector<bool, _Allocator>::vector(_InputIterator __first, _InputIterator __last, const allocator_type& __a)
    : __begin_(nullptr),
      __size_(0),
      __cap_alloc_(0, static_cast<__storage_allocator>(__a))
{
  __init_with_sentinel(__first, __last);
}

template <class _Allocator>
template <class _ForwardIterator, __enable_if_t<__has_forward_iterator_category<_ForwardIterator>::value, int> >
constexpr
vector<bool, _Allocator>::vector(_ForwardIterator __first, _ForwardIterator __last)
    : __begin_(nullptr),
      __size_(0),
      __cap_alloc_(0, __default_init_tag())
{
  auto __n = static_cast<size_type>(std::distance(__first, __last));
  __init_with_size(__first, __last, __n);
}

template <class _Allocator>
template <class _ForwardIterator, __enable_if_t<__has_forward_iterator_category<_ForwardIterator>::value, int> >
constexpr
vector<bool, _Allocator>::vector(_ForwardIterator __first, _ForwardIterator __last, const allocator_type& __a)
    : __begin_(nullptr),
      __size_(0),
      __cap_alloc_(0, static_cast<__storage_allocator>(__a))
{
  auto __n = static_cast<size_type>(std::distance(__first, __last));
  __init_with_size(__first, __last, __n);
}



template <class _Allocator>
constexpr
vector<bool, _Allocator>::vector(initializer_list<value_type> __il)
    : __begin_(nullptr),
      __size_(0),
      __cap_alloc_(0, __default_init_tag())
{
    size_type __n = static_cast<size_type>(__il.size());
    if (__n > 0)
    {
        __vallocate(__n);
        __construct_at_end(__il.begin(), __il.end(), __n);
    }
}

template <class _Allocator>
constexpr
vector<bool, _Allocator>::vector(initializer_list<value_type> __il, const allocator_type& __a)
    : __begin_(nullptr),
      __size_(0),
      __cap_alloc_(0, static_cast<__storage_allocator>(__a))
{
    size_type __n = static_cast<size_type>(__il.size());
    if (__n > 0)
    {
        __vallocate(__n);
        __construct_at_end(__il.begin(), __il.end(), __n);
    }
}



template <class _Allocator>
constexpr
vector<bool, _Allocator>::vector(const vector& __v)
    : __begin_(nullptr),
      __size_(0),
      __cap_alloc_(0, __storage_traits::select_on_container_copy_construction(__v.__alloc()))
{
    if (__v.size() > 0)
    {
        __vallocate(__v.size());
        __construct_at_end(__v.begin(), __v.end(), __v.size());
    }
}

template <class _Allocator>
constexpr
vector<bool, _Allocator>::vector(const vector& __v, const allocator_type& __a)
    : __begin_(nullptr),
      __size_(0),
      __cap_alloc_(0, __a)
{
    if (__v.size() > 0)
    {
        __vallocate(__v.size());
        __construct_at_end(__v.begin(), __v.end(), __v.size());
    }
}

template <class _Allocator>
constexpr
vector<bool, _Allocator>&
vector<bool, _Allocator>::operator=(const vector& __v)
{
    if (this != std::addressof(__v))
    {
        __copy_assign_alloc(__v);
        if (__v.__size_)
        {
            if (__v.__size_ > capacity())
            {
                __vdeallocate();
                __vallocate(__v.__size_);
            }
            std::copy(__v.__begin_, __v.__begin_ + __external_cap_to_internal(__v.__size_), __begin_);
        }
        __size_ = __v.__size_;
    }
    return *this;
}

template <class _Allocator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr vector<bool, _Allocator>::vector(vector&& __v)

    noexcept



    : __begin_(__v.__begin_),
      __size_(__v.__size_),
      __cap_alloc_(std::move(__v.__cap_alloc_)) {
    __v.__begin_ = nullptr;
    __v.__size_ = 0;
    __v.__cap() = 0;
}

template <class _Allocator>
constexpr
vector<bool, _Allocator>::vector(vector&& __v, const __type_identity_t<allocator_type>& __a)
    : __begin_(nullptr),
      __size_(0),
      __cap_alloc_(0, __a)
{
    if (__a == allocator_type(__v.__alloc()))
    {
        this->__begin_ = __v.__begin_;
        this->__size_ = __v.__size_;
        this->__cap() = __v.__cap();
        __v.__begin_ = nullptr;
        __v.__cap() = __v.__size_ = 0;
    }
    else if (__v.size() > 0)
    {
        __vallocate(__v.size());
        __construct_at_end(__v.begin(), __v.end(), __v.size());
    }
}

template <class _Allocator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
vector<bool, _Allocator>&
vector<bool, _Allocator>::operator=(vector&& __v)
    noexcept((__noexcept_move_assign_container<_Allocator, __alloc_traits>::value))
{
    __move_assign(__v, integral_constant<bool,
          __storage_traits::propagate_on_container_move_assignment::value>());
    return *this;
}

template <class _Allocator>
constexpr void
vector<bool, _Allocator>::__move_assign(vector& __c, false_type)
{
    if (__alloc() != __c.__alloc())
        assign(__c.begin(), __c.end());
    else
        __move_assign(__c, true_type());
}

template <class _Allocator>
constexpr void
vector<bool, _Allocator>::__move_assign(vector& __c, true_type)
    noexcept(is_nothrow_move_assignable<allocator_type>::value)
{
    __vdeallocate();
    __move_assign_alloc(__c);
    this->__begin_ = __c.__begin_;
    this->__size_ = __c.__size_;
    this->__cap() = __c.__cap();
    __c.__begin_ = nullptr;
    __c.__cap() = __c.__size_ = 0;
}

template <class _Allocator>
constexpr void
vector<bool, _Allocator>::assign(size_type __n, const value_type& __x)
{
    __size_ = 0;
    if (__n > 0)
    {
        size_type __c = capacity();
        if (__n <= __c)
            __size_ = __n;
        else
        {
            vector __v(get_allocator());
            __v.reserve(__recommend(__n));
            __v.__size_ = __n;
            swap(__v);
        }
        std::fill_n(begin(), __n, __x);
    }
}

template <class _Allocator>
template <class _InputIterator, __enable_if_t<__has_exactly_input_iterator_category<_InputIterator>::value, int> >
constexpr
void
vector<bool, _Allocator>::assign(_InputIterator __first, _InputIterator __last)
{
  __assign_with_sentinel(__first, __last);
}

template <class _Allocator>
template <class _Iterator, class _Sentinel>
constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
void vector<bool, _Allocator>::__assign_with_sentinel(_Iterator __first, _Sentinel __last) {
    clear();
    for (; __first != __last; ++__first)
        push_back(*__first);
}

template <class _Allocator>
template <class _ForwardIterator, __enable_if_t<__has_forward_iterator_category<_ForwardIterator>::value, int> >
constexpr
void
vector<bool, _Allocator>::assign(_ForwardIterator __first, _ForwardIterator __last)
{
  __assign_with_size(__first, __last, std::distance(__first, __last));
}

template <class _Allocator>
template <class _ForwardIterator, class _Sentinel>
constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
void vector<bool, _Allocator>::__assign_with_size(_ForwardIterator __first, _Sentinel __last, difference_type __ns) {
    ((void)0);

    clear();

    const size_t __n = static_cast<size_type>(__ns);
    if (__n)
    {
        if (__n > capacity())
        {
            __vdeallocate();
            __vallocate(__n);
        }
        __construct_at_end(__first, __last, __n);
    }
}

template <class _Allocator>
constexpr void
vector<bool, _Allocator>::reserve(size_type __n)
{
    if (__n > capacity())
    {
        if (__n > max_size())
            this->__throw_length_error();
        vector __v(this->get_allocator());
        __v.__vallocate(__n);
        __v.__construct_at_end(this->begin(), this->end(), this->size());
        swap(__v);
    }
}

template <class _Allocator>
constexpr void
vector<bool, _Allocator>::shrink_to_fit() noexcept
{
    if (__external_cap_to_internal(size()) > __cap())
    {




            vector(*this, allocator_type(__alloc())).swap(*this);






    }
}

template <class _Allocator>
typename vector<bool, _Allocator>::reference
vector<bool, _Allocator>::at(size_type __n)
{
    if (__n >= size())
        this->__throw_out_of_range();
    return (*this)[__n];
}

template <class _Allocator>
typename vector<bool, _Allocator>::const_reference
vector<bool, _Allocator>::at(size_type __n) const
{
    if (__n >= size())
        this->__throw_out_of_range();
    return (*this)[__n];
}

template <class _Allocator>
constexpr void
vector<bool, _Allocator>::push_back(const value_type& __x)
{
    if (this->__size_ == this->capacity())
        reserve(__recommend(this->__size_ + 1));
    ++this->__size_;
    back() = __x;
}

template <class _Allocator>
constexpr typename vector<bool, _Allocator>::iterator
vector<bool, _Allocator>::insert(const_iterator __position, const value_type& __x)
{
    iterator __r;
    if (size() < capacity())
    {
        const_iterator __old_end = end();
        ++__size_;
        std::copy_backward(__position, __old_end, end());
        __r = __const_iterator_cast(__position);
    }
    else
    {
        vector __v(get_allocator());
        __v.reserve(__recommend(__size_ + 1));
        __v.__size_ = __size_ + 1;
        __r = std::copy(cbegin(), __position, __v.begin());
        std::copy_backward(__position, cend(), __v.end());
        swap(__v);
    }
    *__r = __x;
    return __r;
}

template <class _Allocator>
constexpr typename vector<bool, _Allocator>::iterator
vector<bool, _Allocator>::insert(const_iterator __position, size_type __n, const value_type& __x)
{
    iterator __r;
    size_type __c = capacity();
    if (__n <= __c && size() <= __c - __n)
    {
        const_iterator __old_end = end();
        __size_ += __n;
        std::copy_backward(__position, __old_end, end());
        __r = __const_iterator_cast(__position);
    }
    else
    {
        vector __v(get_allocator());
        __v.reserve(__recommend(__size_ + __n));
        __v.__size_ = __size_ + __n;
        __r = std::copy(cbegin(), __position, __v.begin());
        std::copy_backward(__position, cend(), __v.end());
        swap(__v);
    }
    std::fill_n(__r, __n, __x);
    return __r;
}

template <class _Allocator>
template <class _InputIterator, __enable_if_t<__has_exactly_input_iterator_category<_InputIterator>::value, int> >
constexpr
typename vector<bool, _Allocator>::iterator
vector<bool, _Allocator>::insert(const_iterator __position, _InputIterator __first, _InputIterator __last)
{
  return __insert_with_sentinel(__position, __first, __last);
}

template <class _Allocator>
template <class _InputIterator, class _Sentinel>
constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
typename vector<bool, _Allocator>::iterator
vector<bool, _Allocator>::__insert_with_sentinel(const_iterator __position, _InputIterator __first, _Sentinel __last) {
    difference_type __off = __position - begin();
    iterator __p = __const_iterator_cast(__position);
    iterator __old_end = end();
    for (; size() != capacity() && __first != __last; ++__first)
    {
        ++this->__size_;
        back() = *__first;
    }
    vector __v(get_allocator());
    if (__first != __last)
    {




            __v.__assign_with_sentinel(std::move(__first), std::move(__last));
            difference_type __old_size = static_cast<difference_type>(__old_end - begin());
            difference_type __old_p = __p - begin();
            reserve(__recommend(size() + __v.size()));
            __p = begin() + __old_p;
            __old_end = begin() + __old_size;
# 3110 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/vector" 3
    }
    __p = std::rotate(__p, __old_end, end());
    insert(__p, __v.begin(), __v.end());
    return begin() + __off;
}

template <class _Allocator>
template <class _ForwardIterator, __enable_if_t<__has_forward_iterator_category<_ForwardIterator>::value, int> >
constexpr
typename vector<bool, _Allocator>::iterator
vector<bool, _Allocator>::insert(const_iterator __position, _ForwardIterator __first, _ForwardIterator __last)
{
  return __insert_with_size(__position, __first, __last, std::distance(__first, __last));
}

template <class _Allocator>
template <class _ForwardIterator, class _Sentinel>
constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
typename vector<bool, _Allocator>::iterator
vector<bool, _Allocator>::__insert_with_size(const_iterator __position, _ForwardIterator __first, _Sentinel __last,
                                             difference_type __n_signed) {
    ((void)0);
    const size_type __n = static_cast<size_type>(__n_signed);
    iterator __r;
    size_type __c = capacity();
    if (__n <= __c && size() <= __c - __n)
    {
        const_iterator __old_end = end();
        __size_ += __n;
        std::copy_backward(__position, __old_end, end());
        __r = __const_iterator_cast(__position);
    }
    else
    {
        vector __v(get_allocator());
        __v.reserve(__recommend(__size_ + __n));
        __v.__size_ = __size_ + __n;
        __r = std::copy(cbegin(), __position, __v.begin());
        std::copy_backward(__position, cend(), __v.end());
        swap(__v);
    }
    std::__copy<_ClassicAlgPolicy>(__first, __last, __r);
    return __r;
}

template <class _Allocator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
typename vector<bool, _Allocator>::iterator
vector<bool, _Allocator>::erase(const_iterator __position)
{
    iterator __r = __const_iterator_cast(__position);
    std::copy(__position + 1, this->cend(), __r);
    --__size_;
    return __r;
}

template <class _Allocator>
constexpr
typename vector<bool, _Allocator>::iterator
vector<bool, _Allocator>::erase(const_iterator __first, const_iterator __last)
{
    iterator __r = __const_iterator_cast(__first);
    difference_type __d = __last - __first;
    std::copy(__last, this->cend(), __r);
    __size_ -= __d;
    return __r;
}

template <class _Allocator>
constexpr void
vector<bool, _Allocator>::swap(vector& __x)

    noexcept




{
    std::swap(this->__begin_, __x.__begin_);
    std::swap(this->__size_, __x.__size_);
    std::swap(this->__cap(), __x.__cap());
    std::__swap_allocator(this->__alloc(), __x.__alloc(),
        integral_constant<bool, __alloc_traits::propagate_on_container_swap::value>());
}

template <class _Allocator>
constexpr void
vector<bool, _Allocator>::resize(size_type __sz, value_type __x)
{
    size_type __cs = size();
    if (__cs < __sz)
    {
        iterator __r;
        size_type __c = capacity();
        size_type __n = __sz - __cs;
        if (__n <= __c && __cs <= __c - __n)
        {
            __r = end();
            __size_ += __n;
        }
        else
        {
            vector __v(get_allocator());
            __v.reserve(__recommend(__size_ + __n));
            __v.__size_ = __size_ + __n;
            __r = std::copy(cbegin(), cend(), __v.begin());
            swap(__v);
        }
        std::fill_n(__r, __n, __x);
    }
    else
        __size_ = __sz;
}

template <class _Allocator>
constexpr void
vector<bool, _Allocator>::flip() noexcept
{

    size_type __n = __size_;
    __storage_pointer __p = __begin_;
    for (; __n >= __bits_per_word; ++__p, __n -= __bits_per_word)
        *__p = ~*__p;

    if (__n > 0)
    {
        __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
        __storage_type __b = *__p & __m;
        *__p &= ~__m;
        *__p |= ~__b & __m;
    }
}

template <class _Allocator>
constexpr bool
vector<bool, _Allocator>::__invariants() const
{
    if (this->__begin_ == nullptr)
    {
        if (this->__size_ != 0 || this->__cap() != 0)
            return false;
    }
    else
    {
        if (this->__cap() == 0)
            return false;
        if (this->__size_ > this->capacity())
            return false;
    }
    return true;
}

template <class _Allocator>
constexpr size_t
vector<bool, _Allocator>::__hash_code() const noexcept
{
    size_t __h = 0;

    size_type __n = __size_;
    __storage_pointer __p = __begin_;
    for (; __n >= __bits_per_word; ++__p, __n -= __bits_per_word)
        __h ^= *__p;

    if (__n > 0)
    {
        const __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
        __h ^= *__p & __m;
    }
    return __h;
}

template <class _Allocator>
struct hash<vector<bool, _Allocator> >
    : public __unary_function<vector<bool, _Allocator>, size_t>
{
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr
    size_t operator()(const vector<bool, _Allocator>& __vec) const noexcept
        {return __vec.__hash_code();}
};

template <class _Tp, class _Allocator>
constexpr
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
bool
operator==(const vector<_Tp, _Allocator>& __x, const vector<_Tp, _Allocator>& __y)
{
    const typename vector<_Tp, _Allocator>::size_type __sz = __x.size();
    return __sz == __y.size() && std::equal(__x.begin(), __x.end(), __y.begin());
}
# 3344 "/dev/shm/rydahl1/LLVM/install/bin/../include/c++/v1/vector" 3
template <class _Tp, class _Allocator>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr __synth_three_way_result<_Tp>
operator<=>(const vector<_Tp, _Allocator>& __x, const vector<_Tp, _Allocator>& __y) {
    return std::lexicographical_compare_three_way(
        __x.begin(), __x.end(), __y.begin(), __y.end(), std::__synth_three_way<_Tp, _Tp>);
}



template <class _Tp, class _Allocator>
constexpr
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000")))
void
swap(vector<_Tp, _Allocator>& __x, vector<_Tp, _Allocator>& __y)
    noexcept(noexcept(__x.swap(__y)))
{
    __x.swap(__y);
}


template <class _Tp, class _Allocator, class _Up>
constexpr
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) typename vector<_Tp, _Allocator>::size_type
erase(vector<_Tp, _Allocator>& __c, const _Up& __v) {
  auto __old_size = __c.size();
  __c.erase(std::remove(__c.begin(), __c.end(), __v), __c.end());
  return __old_size - __c.size();
}

template <class _Tp, class _Allocator, class _Predicate>
constexpr
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) typename vector<_Tp, _Allocator>::size_type
erase_if(vector<_Tp, _Allocator>& __c, _Predicate __pred) {
  auto __old_size = __c.size();
  __c.erase(std::remove_if(__c.begin(), __c.end(), __pred), __c.end());
  return __old_size - __c.size();
}

template <>
inline constexpr bool __format::__enable_insertable<vector<char>> = true;

template <>
inline constexpr bool __format::__enable_insertable<vector<wchar_t>> = true;





template <class _Tp, class _CharT>

  requires same_as<typename _Tp::__container, vector<bool, typename _Tp::__container::allocator_type>>
struct formatter<_Tp, _CharT> {
private:
  formatter<bool, _CharT> __underlying_;

public:
  template <class _ParseContext>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) constexpr typename _ParseContext::iterator parse(_ParseContext& __ctx) {
        return __underlying_.parse(__ctx);
  }

  template <class _FormatContext>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v180000"))) typename _FormatContext::iterator format(const _Tp& __ref, _FormatContext& __ctx) const {
        return __underlying_.format(__ref, __ctx);
  }
};


}}


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
namespace pmr {
template <class _ValueT>
using vector = std::vector<_ValueT, polymorphic_allocator<_ValueT>>;
}
}}
# 5 "src/transform_reduce/std_vector.cpp" 2
# 1 "include/definitions.h" 1
# 6 "src/transform_reduce/std_vector.cpp" 2

int main()
{
  std::vector<int> v(35791394);
  std::vector<int> w(35791394);
  std::for_each(std::execution::par_unseq,w.begin(),w.end(),[&](int & n){n=0;});
  for (int i=0; i < 100; i++) {

#pragma omp target enter data map(always,to:i)
    std::for_each(std::execution::par_unseq,v.begin(),v.end(),[&](int & n){n=i;});
    std::transform(std::execution::par_unseq,v.begin(),v.end(),w.begin(),[](int n ){return n*n;});
    (static_cast <bool> (w[0] == i*i) ? void (0) : __assert_fail ("w[0] == i*i", "src/transform_reduce/std_vector.cpp", 17, __extension__ __PRETTY_FUNCTION__));
    (static_cast <bool> (w[35791394 -1] == i*i) ? void (0) : __assert_fail ("w[LEN-1] == i*i", "src/transform_reduce/std_vector.cpp", 18, __extension__ __PRETTY_FUNCTION__));
  }
  return 0;
}
